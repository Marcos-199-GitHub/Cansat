CCS PCH C Compiler, Version 5.112, 29001               06-may.-23 21:28

               Filename:   I:\CanSat\Nueva carpeta\RFM69\Receptor\New\RFM69.lst

               ROM used:   2742 bytes (8%)
                           Largest free fragment is 30022
               RAM used:   108 (5%) at main() level
                           138 (7%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   09B6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   00EE
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18F4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
*
00FE:  BCF    F9E.0
0100:  GOTO   0060
.................... #device PIC18F4550
*
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 01,04
00C0:  DATA 02,00
00C2:  DATA 03,02
00C4:  DATA 04,40
00C6:  DATA 05,03
00C8:  DATA 06,33
00CA:  DATA 07,E4
00CC:  DATA 08,C0
00CE:  DATA 09,00
00D0:  DATA 19,42
00D2:  DATA 25,40
00D4:  DATA 26,07
00D6:  DATA 28,10
00D8:  DATA 29,DC
00DA:  DATA 2D,03
00DC:  DATA 2E,88
00DE:  DATA 2F,2D
00E0:  DATA 30,01
00E2:  DATA 37,90
00E4:  DATA 38,42
00E6:  DATA 3C,8F
00E8:  DATA 3D,12
00EA:  DATA 6F,30
00EC:  DATA FF,00
00EE:  MOVLW  01
00F0:  ADDWF  20,F
00F2:  BTFSC  FD8.0
00F4:  INCF   21,F
00F6:  BTFSC  FD8.2
00F8:  INCF   22,F
00FA:  BTFSC  FD8.2
00FC:  INCF   23,F
*
0104:  DATA 73,69
0106:  DATA 6E,63
0108:  DATA 72,6F
010A:  DATA 6E,69
010C:  DATA 7A,61
010E:  DATA 6E,64
0110:  DATA 6F,00
0112:  DATA 49,6E
0114:  DATA 63,6F
0116:  DATA 72,72
0118:  DATA 65,63
011A:  DATA 74,20
011C:  DATA 52,46
011E:  DATA 4D,20
0120:  DATA 64,65
0122:  DATA 76,69
0124:  DATA 63,65
0126:  DATA 0A,00
0128:  DATA 73,69
012A:  DATA 6E,63
012C:  DATA 72,6F
012E:  DATA 6E,69
0130:  DATA 7A,61
0132:  DATA 64,6F
0134:  DATA 31,00
0136:  DATA 73,69
0138:  DATA 6E,63
013A:  DATA 72,6F
013C:  DATA 6E,69
013E:  DATA 7A,61
0140:  DATA 64,6F
0142:  DATA 32,00
0144:  DATA 74,69
0146:  DATA 6D,65
0148:  DATA 6F,75
014A:  DATA 74,00
014C:  DATA 63,6F
014E:  DATA 6E,66
0150:  DATA 69,67
0152:  DATA 75,72
0154:  DATA 61,64
0156:  DATA 6F,00
0158:  DATA 6D,6F
015A:  DATA 64,65
015C:  DATA 20,73
015E:  DATA 65,74
0160:  DATA 0A,00
0162:  DATA 48,69
0164:  DATA 67,68
0166:  DATA 50,6F
0168:  DATA 77,65
016A:  DATA 72,00
016C:  DATA 41,64
016E:  DATA 64,72
0170:  DATA 65,73
0172:  DATA 73,20
0174:  DATA 2D,20
0176:  DATA 48,45
0178:  DATA 58,20
017A:  DATA 2D,20
017C:  DATA 42,49
017E:  DATA 4E,20
0180:  DATA 0A,00
0182:  DATA 20,2D
0184:  DATA 20,00
0186:  DATA 20,2D
0188:  DATA 20,00
018A:  DATA 41,42
018C:  DATA 43,44
018E:  DATA 45,46
0190:  DATA 47,48
0192:  DATA 49,4A
0194:  DATA 4B,4C
0196:  DATA 4D,4E
0198:  DATA 4F,50
019A:  DATA 51,52
019C:  DATA 53,54
019E:  DATA 55,56
01A0:  DATA 57,58
01A2:  DATA 59,5A
01A4:  DATA 00,00
*
01CE:  TBLRD*+
01D0:  MOVF   FF5,F
01D2:  BZ    01EE
01D4:  MOVFF  FF6,81
01D8:  MOVFF  FF7,82
01DC:  MOVF   FF5,W
01DE:  BTFSS  F9E.4
01E0:  BRA    01DE
01E2:  MOVWF  FAD
01E4:  MOVFF  81,FF6
01E8:  MOVFF  82,FF7
01EC:  BRA    01CE
01EE:  RETURN 0
*
0696:  BTFSC  x6F.7
0698:  BRA    06BA
069A:  MOVLW  0F
069C:  MOVWF  00
069E:  SWAPF  x6E,W
06A0:  ANDWF  00,F
06A2:  MOVLW  0A
06A4:  SUBWF  00,W
06A6:  BC    06AE
06A8:  MOVLW  30
06AA:  ADDWF  00,F
06AC:  BRA    06B2
06AE:  MOVF   x6F,W
06B0:  ADDWF  00,F
06B2:  MOVF   00,W
06B4:  BTFSS  F9E.4
06B6:  BRA    06B4
06B8:  MOVWF  FAD
06BA:  MOVLW  0F
06BC:  ANDWF  x6E,F
06BE:  MOVLW  0A
06C0:  SUBWF  x6E,W
06C2:  BC    06C8
06C4:  MOVLW  30
06C6:  BRA    06CC
06C8:  BCF    x6F.7
06CA:  MOVF   x6F,W
06CC:  ADDWF  x6E,F
06CE:  MOVF   x6E,W
06D0:  BTFSS  F9E.4
06D2:  BRA    06D0
06D4:  MOVWF  FAD
06D6:  RETURN 0
*
0772:  MOVFF  2D,FEA
0776:  MOVFF  2C,FE9
077A:  MOVFF  6D,FEF
077E:  INCF   FE9,F
0780:  BTFSC  FD8.2
0782:  INCF   FEA,F
0784:  CLRF   FEF
0786:  INCF   2C,F
0788:  BTFSC  FD8.2
078A:  INCF   2D,F
078C:  GOTO   07A4 (RETURN)
0790:  TBLRD*+
0792:  MOVF   FF5,F
0794:  BZ    07AE
0796:  MOVFF  FF6,6B
079A:  MOVFF  FF7,6C
079E:  MOVFF  FF5,6D
07A2:  BRA    0772
07A4:  MOVFF  6B,FF6
07A8:  MOVFF  6C,FF7
07AC:  BRA    0790
07AE:  GOTO   0A94 (RETURN)
*
098E:  MOVF   FEF,F
0990:  BZ    09B2
0992:  MOVFF  FEA,6C
0996:  MOVFF  FE9,6B
099A:  MOVF   FEF,W
099C:  BTFSS  F9E.4
099E:  BRA    099C
09A0:  MOVWF  FAD
09A2:  MOVFF  6C,FEA
09A6:  MOVFF  6B,FE9
09AA:  INCF   FE9,F
09AC:  BTFSC  FD8.2
09AE:  INCF   FEA,F
09B0:  BRA    098E
09B2:  GOTO   0AAE (RETURN)
.................... 
.................... #list
.................... 
.................... //#device ADC=10
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
....................    goto StrtoulGO;
.................... 
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(; sd!=0; )
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtoulGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
....................    }
....................    if (endptr)
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #Fuses HS, nowdt, nolvp, vregen, noprotect, /*nomclr,*/ PUT, nobrownout
.................... 
.................... //#use delay(clock=24MHz,crystal=16MHz,USB_LOW)
.................... 
.................... #use delay(clock=16MHz,crystal=16MHz)
*
01A6:  CLRF   FEA
01A8:  MOVLW  89
01AA:  MOVWF  FE9
01AC:  MOVF   FEF,W
01AE:  BZ    01CC
01B0:  MOVLW  05
01B2:  MOVWF  01
01B4:  CLRF   00
01B6:  DECFSZ 00,F
01B8:  BRA    01B6
01BA:  DECFSZ 01,F
01BC:  BRA    01B4
01BE:  MOVLW  2E
01C0:  MOVWF  00
01C2:  DECFSZ 00,F
01C4:  BRA    01C2
01C6:  BRA    01C8
01C8:  DECFSZ FEF,F
01CA:  BRA    01B0
01CC:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=GPS,errors)
.................... #USE TIMER(TIMER=1,TICK=1ms,BITS=32,ISR)
*
01F0:  MOVFF  20,01
01F4:  MOVF   FCE,W
01F6:  MOVFF  FCF,03
01FA:  BCF    F9D.0
01FC:  MOVWF  02
01FE:  MOVF   20,W
0200:  SUBWF  01,W
0202:  BZ    020C
0204:  MOVF   FCE,W
0206:  MOVFF  FCF,03
020A:  BRA    020E
020C:  MOVF   02,W
020E:  MOVFF  03,00
0212:  MOVFF  20,01
0216:  MOVFF  21,02
021A:  MOVFF  22,03
021E:  MOVF   23,W
0220:  RRCF   FE8,F
0222:  RRCF   03,F
0224:  RRCF   02,F
0226:  RRCF   01,F
0228:  RRCF   00,F
022A:  BSF    F9D.0
022C:  GOTO   0232 (RETURN)
.................... 
.................... 
.................... #define _slaveSelectPin Pin_D7
.................... #define SCK             Pin_D6
.................... #define SerOut          Pin_D5
.................... #define SerIn           Pin_D4
.................... #define _interruptPin   Pin_B0
.................... 
.................... 
.................... 
.................... // ----------------------------------------
.................... #include "RFM69.h"
.................... #include <RFM69registers.h>
.................... // **********************************************************************************
.................... // Registers used in driver definition for HopeRF RFM69W/RFM69HW, Semtech SX1231/1231H
.................... // **********************************************************************************
.................... // Copyright Felix Rusu (2015), felix@lowpowerlab.com
.................... // http://lowpowerlab.com/
.................... // **********************************************************************************
.................... // License
.................... // **********************************************************************************
.................... // This program is free software; you can redistribute it 
.................... // and/or modify it under the terms of the GNU General    
.................... // Public License as published by the Free Software       
.................... // Foundation; either version 2 of the License, or        
.................... // (at your option) any later version.                    
.................... //                                                        
.................... // This program is distributed in the hope that it will   
.................... // be useful, but WITHOUT ANY WARRANTY; without even the  
.................... // implied warranty of MERCHANTABILITY or FITNESS FOR A   
.................... // PARTICULAR PURPOSE.  See the GNU General Public        
.................... // License for more details.                              
.................... //                                                        
.................... // You should have received a copy of the GNU General    
.................... // Public License along with this program; if not, write 
.................... // to the Free Software Foundation, Inc.,                
.................... // 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
.................... //                                                        
.................... // Licence can be viewed at                               
.................... // http://www.fsf.org/licenses/gpl.txt                    
.................... //
.................... // Please maintain this license information along with authorship
.................... // and copyright notices in any redistribution of this code
.................... // **********************************************************************************
.................... // RFM69/SX1231 Internal registers addresses
.................... //**************************************************
.................... #define REG_FIFO          0x00
.................... #define REG_OPMODE        0x01
.................... #define REG_DATAMODUL     0x02
.................... #define REG_BITRATEMSB    0x03
.................... #define REG_BITRATELSB    0x04
.................... #define REG_FDEVMSB       0x05
.................... #define REG_FDEVLSB       0x06
.................... #define REG_FRFMSB        0x07
.................... #define REG_FRFMID        0x08
.................... #define REG_FRFLSB        0x09
.................... #define REG_OSC1          0x0A
.................... #define REG_AFCCTRL       0x0B
.................... #define REG_LOWBAT        0x0C
.................... #define REG_LISTEN1       0x0D
.................... #define REG_LISTEN2       0x0E
.................... #define REG_LISTEN3       0x0F
.................... #define REG_VERSION       0x10
.................... #define REG_PALEVEL       0x11
.................... #define REG_PARAMP        0x12
.................... #define REG_OCP           0x13
.................... #define REG_AGCREF        0x14  // not present on RFM69/SX1231
.................... #define REG_AGCTHRESH1    0x15  // not present on RFM69/SX1231
.................... #define REG_AGCTHRESH2    0x16  // not present on RFM69/SX1231
.................... #define REG_AGCTHRESH3    0x17  // not present on RFM69/SX1231
.................... #define REG_LNA           0x18
.................... #define REG_RXBW          0x19
.................... #define REG_AFCBW         0x1A
.................... #define REG_OOKPEAK       0x1B
.................... #define REG_OOKAVG        0x1C
.................... #define REG_OOKFIX        0x1D
.................... #define REG_AFCFEI        0x1E
.................... #define REG_AFCMSB        0x1F
.................... #define REG_AFCLSB        0x20
.................... #define REG_FEIMSB        0x21
.................... #define REG_FEILSB        0x22
.................... #define REG_RSSICONFIG    0x23
.................... #define REG_RSSIVALUE     0x24
.................... #define REG_DIOMAPPING1   0x25
.................... #define REG_DIOMAPPING2   0x26
.................... #define REG_IRQFLAGS1     0x27
.................... #define REG_IRQFLAGS2     0x28
.................... #define REG_RSSITHRESH    0x29
.................... #define REG_RXTIMEOUT1    0x2A
.................... #define REG_RXTIMEOUT2    0x2B
.................... #define REG_PREAMBLEMSB   0x2C
.................... #define REG_PREAMBLELSB   0x2D
.................... #define REG_SYNCCONFIG    0x2E
.................... #define REG_SYNCVALUE1    0x2F
.................... #define REG_SYNCVALUE2    0x30
.................... #define REG_SYNCVALUE3    0x31
.................... #define REG_SYNCVALUE4    0x32
.................... #define REG_SYNCVALUE5    0x33
.................... #define REG_SYNCVALUE6    0x34
.................... #define REG_SYNCVALUE7    0x35
.................... #define REG_SYNCVALUE8    0x36
.................... #define REG_PACKETCONFIG1 0x37
.................... #define REG_PAYLOADLENGTH 0x38
.................... #define REG_NODEADRS      0x39
.................... #define REG_BROADCASTADRS 0x3A
.................... #define REG_AUTOMODES     0x3B
.................... #define REG_FIFOTHRESH    0x3C
.................... #define REG_PACKETCONFIG2 0x3D
.................... #define REG_AESKEY1       0x3E
.................... #define REG_AESKEY2       0x3F
.................... #define REG_AESKEY3       0x40
.................... #define REG_AESKEY4       0x41
.................... #define REG_AESKEY5       0x42
.................... #define REG_AESKEY6       0x43
.................... #define REG_AESKEY7       0x44
.................... #define REG_AESKEY8       0x45
.................... #define REG_AESKEY9       0x46
.................... #define REG_AESKEY10      0x47
.................... #define REG_AESKEY11      0x48
.................... #define REG_AESKEY12      0x49
.................... #define REG_AESKEY13      0x4A
.................... #define REG_AESKEY14      0x4B
.................... #define REG_AESKEY15      0x4C
.................... #define REG_AESKEY16      0x4D
.................... #define REG_TEMP1         0x4E
.................... #define REG_TEMP2         0x4F
.................... #define REG_TESTLNA       0x58
.................... #define REG_TESTPA1       0x5A  // only present on RFM69HW/SX1231H
.................... #define REG_TESTPA2       0x5C  // only present on RFM69HW/SX1231H
.................... #define REG_TESTDAGC      0x6F
.................... 
.................... //******************************************************
.................... // RF69/SX1231 bit control definition
.................... //******************************************************
.................... 
.................... // RegOpMode
.................... #define RF_OPMODE_SEQUENCER_OFF       0x80
.................... #define RF_OPMODE_SEQUENCER_ON        0x00  // Default
.................... 
.................... #define RF_OPMODE_LISTEN_ON           0x40
.................... #define RF_OPMODE_LISTEN_OFF          0x00  // Default
.................... 
.................... #define RF_OPMODE_LISTENABORT         0x20
.................... 
.................... #define RF_OPMODE_SLEEP               0x00
.................... #define RF_OPMODE_STANDBY             0x04  // Default
.................... #define RF_OPMODE_SYNTHESIZER         0x08
.................... #define RF_OPMODE_TRANSMITTER         0x0C
.................... #define RF_OPMODE_RECEIVER            0x10
.................... 
.................... 
.................... // RegDataModul
.................... #define RF_DATAMODUL_DATAMODE_PACKET            0x00  // Default
.................... #define RF_DATAMODUL_DATAMODE_CONTINUOUS        0x40
.................... #define RF_DATAMODUL_DATAMODE_CONTINUOUSNOBSYNC 0x60
.................... 
.................... #define RF_DATAMODUL_MODULATIONTYPE_FSK         0x00  // Default
.................... #define RF_DATAMODUL_MODULATIONTYPE_OOK         0x08
.................... 
.................... #define RF_DATAMODUL_MODULATIONSHAPING_00       0x00  // Default
.................... #define RF_DATAMODUL_MODULATIONSHAPING_01       0x01
.................... #define RF_DATAMODUL_MODULATIONSHAPING_10       0x02
.................... #define RF_DATAMODUL_MODULATIONSHAPING_11       0x03
.................... 
.................... 
.................... // RegBitRate (bits/sec) example bit rates
.................... #define RF_BITRATEMSB_1200            0x68
.................... #define RF_BITRATELSB_1200            0x2B
.................... #define RF_BITRATEMSB_2400            0x34
.................... #define RF_BITRATELSB_2400            0x15
.................... #define RF_BITRATEMSB_4800            0x1A  // Default
.................... #define RF_BITRATELSB_4800            0x0B  // Default
.................... #define RF_BITRATEMSB_9600            0x0D
.................... #define RF_BITRATELSB_9600            0x05
.................... #define RF_BITRATEMSB_19200           0x06
.................... #define RF_BITRATELSB_19200           0x83
.................... #define RF_BITRATEMSB_38400           0x03
.................... #define RF_BITRATELSB_38400           0x41
.................... 
.................... #define RF_BITRATEMSB_38323           0x03
.................... #define RF_BITRATELSB_38323           0x43
.................... 
.................... #define RF_BITRATEMSB_34482           0x03
.................... #define RF_BITRATELSB_34482           0xA0
.................... 
.................... #define RF_BITRATEMSB_76800           0x01
.................... #define RF_BITRATELSB_76800           0xA1
.................... #define RF_BITRATEMSB_153600          0x00
.................... #define RF_BITRATELSB_153600          0xD0
.................... #define RF_BITRATEMSB_57600           0x02
.................... #define RF_BITRATELSB_57600           0x2C
.................... #define RF_BITRATEMSB_115200          0x01
.................... #define RF_BITRATELSB_115200          0x16
.................... #define RF_BITRATEMSB_12500           0x0A
.................... #define RF_BITRATELSB_12500           0x00
.................... #define RF_BITRATEMSB_25000           0x05
.................... #define RF_BITRATELSB_25000           0x00
.................... #define RF_BITRATEMSB_50000           0x02
.................... #define RF_BITRATELSB_50000           0x80
.................... #define RF_BITRATEMSB_100000          0x01
.................... #define RF_BITRATELSB_100000          0x40
.................... #define RF_BITRATEMSB_150000          0x00
.................... #define RF_BITRATELSB_150000          0xD5
.................... #define RF_BITRATEMSB_200000          0x00
.................... #define RF_BITRATELSB_200000          0xA0
.................... #define RF_BITRATEMSB_250000          0x00
.................... #define RF_BITRATELSB_250000          0x80
.................... #define RF_BITRATEMSB_300000          0x00
.................... #define RF_BITRATELSB_300000          0x6B
.................... #define RF_BITRATEMSB_32768           0x03
.................... #define RF_BITRATELSB_32768           0xD1
.................... // custom bit rates
.................... #define RF_BITRATEMSB_55555           0x02
.................... #define RF_BITRATELSB_55555           0x40
.................... #define RF_BITRATEMSB_200KBPS         0x00
.................... #define RF_BITRATELSB_200KBPS         0xa0
.................... 
.................... 
.................... // RegFdev - frequency deviation (Hz)
.................... #define RF_FDEVMSB_2000             0x00
.................... #define RF_FDEVLSB_2000             0x21
.................... #define RF_FDEVMSB_5000             0x00  // Default
.................... #define RF_FDEVLSB_5000             0x52  // Default
.................... #define RF_FDEVMSB_7500             0x00
.................... #define RF_FDEVLSB_7500             0x7B
.................... #define RF_FDEVMSB_10000            0x00
.................... #define RF_FDEVLSB_10000            0xA4
.................... #define RF_FDEVMSB_15000            0x00
.................... #define RF_FDEVLSB_15000            0xF6
.................... #define RF_FDEVMSB_20000            0x01
.................... #define RF_FDEVLSB_20000            0x48
.................... #define RF_FDEVMSB_25000            0x01
.................... #define RF_FDEVLSB_25000            0x9A
.................... #define RF_FDEVMSB_30000            0x01
.................... #define RF_FDEVLSB_30000            0xEC
.................... #define RF_FDEVMSB_35000            0x02
.................... #define RF_FDEVLSB_35000            0x3D
.................... #define RF_FDEVMSB_40000            0x02
.................... #define RF_FDEVLSB_40000            0x8F
.................... #define RF_FDEVMSB_45000            0x02
.................... #define RF_FDEVLSB_45000            0xE1
.................... #define RF_FDEVMSB_50000            0x03
.................... #define RF_FDEVLSB_50000            0x33
.................... #define RF_FDEVMSB_55000            0x03
.................... #define RF_FDEVLSB_55000            0x85
.................... #define RF_FDEVMSB_60000            0x03
.................... #define RF_FDEVLSB_60000            0xD7
.................... #define RF_FDEVMSB_65000            0x04
.................... #define RF_FDEVLSB_65000            0x29
.................... #define RF_FDEVMSB_70000            0x04
.................... #define RF_FDEVLSB_70000            0x7B
.................... #define RF_FDEVMSB_75000            0x04
.................... #define RF_FDEVLSB_75000            0xCD
.................... #define RF_FDEVMSB_80000            0x05
.................... #define RF_FDEVLSB_80000            0x1F
.................... #define RF_FDEVMSB_85000            0x05
.................... #define RF_FDEVLSB_85000            0x71
.................... #define RF_FDEVMSB_90000            0x05
.................... #define RF_FDEVLSB_90000            0xC3
.................... #define RF_FDEVMSB_95000            0x06
.................... #define RF_FDEVLSB_95000            0x14
.................... #define RF_FDEVMSB_100000           0x06
.................... #define RF_FDEVLSB_100000           0x66
.................... #define RF_FDEVMSB_110000           0x07
.................... #define RF_FDEVLSB_110000           0x0A
.................... #define RF_FDEVMSB_120000           0x07
.................... #define RF_FDEVLSB_120000           0xAE
.................... #define RF_FDEVMSB_130000           0x08
.................... #define RF_FDEVLSB_130000           0x52
.................... #define RF_FDEVMSB_140000           0x08
.................... #define RF_FDEVLSB_140000           0xF6
.................... #define RF_FDEVMSB_150000           0x09
.................... #define RF_FDEVLSB_150000           0x9A
.................... #define RF_FDEVMSB_160000           0x0A
.................... #define RF_FDEVLSB_160000           0x3D
.................... #define RF_FDEVMSB_170000           0x0A
.................... #define RF_FDEVLSB_170000           0xE1
.................... #define RF_FDEVMSB_180000           0x0B
.................... #define RF_FDEVLSB_180000           0x85
.................... #define RF_FDEVMSB_190000           0x0C
.................... #define RF_FDEVLSB_190000           0x29
.................... #define RF_FDEVMSB_200000           0x0C
.................... #define RF_FDEVLSB_200000           0xCD
.................... #define RF_FDEVMSB_210000           0x0D
.................... #define RF_FDEVLSB_210000           0x71
.................... #define RF_FDEVMSB_220000           0x0E
.................... #define RF_FDEVLSB_220000           0x14
.................... #define RF_FDEVMSB_230000           0x0E
.................... #define RF_FDEVLSB_230000           0xB8
.................... #define RF_FDEVMSB_240000           0x0F
.................... #define RF_FDEVLSB_240000           0x5C
.................... #define RF_FDEVMSB_250000           0x10
.................... #define RF_FDEVLSB_250000           0x00
.................... #define RF_FDEVMSB_260000           0x10
.................... #define RF_FDEVLSB_260000           0xA4
.................... #define RF_FDEVMSB_270000           0x11
.................... #define RF_FDEVLSB_270000           0x48
.................... #define RF_FDEVMSB_280000           0x11
.................... #define RF_FDEVLSB_280000           0xEC
.................... #define RF_FDEVMSB_290000           0x12
.................... #define RF_FDEVLSB_290000           0x8F
.................... #define RF_FDEVMSB_300000           0x13
.................... #define RF_FDEVLSB_300000           0x33
.................... 
.................... 
.................... // RegFrf (MHz) - carrier frequency
.................... // 315Mhz band
.................... #define RF_FRFMSB_314             0x4E
.................... #define RF_FRFMID_314             0x80
.................... #define RF_FRFLSB_314             0x00
.................... #define RF_FRFMSB_315             0x4E
.................... #define RF_FRFMID_315             0xC0
.................... #define RF_FRFLSB_315             0x00
.................... #define RF_FRFMSB_316             0x4F
.................... #define RF_FRFMID_316             0x00
.................... #define RF_FRFLSB_316             0x00
.................... // 433mhz band
.................... #define RF_FRFMSB_433             0x6C
.................... #define RF_FRFMID_433             0x40
.................... #define RF_FRFLSB_433             0x00
.................... #define RF_FRFMSB_434             0x6C
.................... #define RF_FRFMID_434             0x80
.................... #define RF_FRFLSB_434             0x00
.................... #define RF_FRFMSB_435             0x6C
.................... #define RF_FRFMID_435             0xC0
.................... #define RF_FRFLSB_435             0x00
.................... // 868Mhz band
.................... #define RF_FRFMSB_863             0xD7
.................... #define RF_FRFMID_863             0xC0
.................... #define RF_FRFLSB_863             0x00
.................... #define RF_FRFMSB_864             0xD8
.................... #define RF_FRFMID_864             0x00
.................... #define RF_FRFLSB_864             0x00
.................... #define RF_FRFMSB_865             0xD8
.................... #define RF_FRFMID_865             0x40
.................... #define RF_FRFLSB_865             0x00
.................... #define RF_FRFMSB_866             0xD8
.................... #define RF_FRFMID_866             0x80
.................... #define RF_FRFLSB_866             0x00
.................... #define RF_FRFMSB_867             0xD8
.................... #define RF_FRFMID_867             0xC0
.................... #define RF_FRFLSB_867             0x00
.................... #define RF_FRFMSB_868             0xD9
.................... #define RF_FRFMID_868             0x00
.................... #define RF_FRFLSB_868             0x00
.................... #define RF_FRFMSB_869             0xD9
.................... #define RF_FRFMID_869             0x40
.................... #define RF_FRFLSB_869             0x00
.................... #define RF_FRFMSB_870             0xD9
.................... #define RF_FRFMID_870             0x80
.................... #define RF_FRFLSB_870             0x00
.................... // 915Mhz band
.................... #define RF_FRFMSB_902             0xE1
.................... #define RF_FRFMID_902             0x80
.................... #define RF_FRFLSB_902             0x00
.................... #define RF_FRFMSB_903             0xE1
.................... #define RF_FRFMID_903             0xC0
.................... #define RF_FRFLSB_903             0x00
.................... #define RF_FRFMSB_904             0xE2
.................... #define RF_FRFMID_904             0x00
.................... #define RF_FRFLSB_904             0x00
.................... #define RF_FRFMSB_905             0xE2
.................... #define RF_FRFMID_905             0x40
.................... #define RF_FRFLSB_905             0x00
.................... #define RF_FRFMSB_906             0xE2
.................... #define RF_FRFMID_906             0x80
.................... #define RF_FRFLSB_906             0x00
.................... #define RF_FRFMSB_907             0xE2
.................... #define RF_FRFMID_907             0xC0
.................... #define RF_FRFLSB_907             0x00
.................... #define RF_FRFMSB_908             0xE3
.................... #define RF_FRFMID_908             0x00
.................... #define RF_FRFLSB_908             0x00
.................... #define RF_FRFMSB_909             0xE3
.................... #define RF_FRFMID_909             0x40
.................... #define RF_FRFLSB_909             0x00
.................... #define RF_FRFMSB_910             0xE3
.................... #define RF_FRFMID_910             0x80
.................... #define RF_FRFLSB_910             0x00
.................... #define RF_FRFMSB_911             0xE3
.................... #define RF_FRFMID_911             0xC0
.................... #define RF_FRFLSB_911             0x00
.................... #define RF_FRFMSB_912             0xE4
.................... #define RF_FRFMID_912             0x00
.................... #define RF_FRFLSB_912             0x00
.................... #define RF_FRFMSB_913             0xE4
.................... #define RF_FRFMID_913             0x40
.................... #define RF_FRFLSB_913             0x00
.................... #define RF_FRFMSB_914             0xE4
.................... #define RF_FRFMID_914             0x80
.................... #define RF_FRFLSB_914             0x00
.................... #define RF_FRFMSB_915             0xE4  // Default
.................... #define RF_FRFMID_915             0xC0  // Default
.................... #define RF_FRFLSB_915             0x00  // Default
.................... #define RF_FRFMSB_916             0xE5
.................... #define RF_FRFMID_916             0x00
.................... #define RF_FRFLSB_916             0x00
.................... #define RF_FRFMSB_917             0xE5
.................... #define RF_FRFMID_917             0x40
.................... #define RF_FRFLSB_917             0x00
.................... #define RF_FRFMSB_918             0xE5
.................... #define RF_FRFMID_918             0x80
.................... #define RF_FRFLSB_918             0x00
.................... #define RF_FRFMSB_919             0xE5
.................... #define RF_FRFMID_919             0xC0
.................... #define RF_FRFLSB_919             0x00
.................... #define RF_FRFMSB_920             0xE6
.................... #define RF_FRFMID_920             0x00
.................... #define RF_FRFLSB_920             0x00
.................... #define RF_FRFMSB_921             0xE6
.................... #define RF_FRFMID_921             0x40
.................... #define RF_FRFLSB_921             0x00
.................... #define RF_FRFMSB_922             0xE6
.................... #define RF_FRFMID_922             0x80
.................... #define RF_FRFLSB_922             0x00
.................... #define RF_FRFMSB_923             0xE6
.................... #define RF_FRFMID_923             0xC0
.................... #define RF_FRFLSB_923             0x00
.................... #define RF_FRFMSB_924             0xE7
.................... #define RF_FRFMID_924             0x00
.................... #define RF_FRFLSB_924             0x00
.................... #define RF_FRFMSB_925             0xE7
.................... #define RF_FRFMID_925             0x40
.................... #define RF_FRFLSB_925             0x00
.................... #define RF_FRFMSB_926             0xE7
.................... #define RF_FRFMID_926             0x80
.................... #define RF_FRFLSB_926             0x00
.................... #define RF_FRFMSB_927             0xE7
.................... #define RF_FRFMID_927             0xC0
.................... #define RF_FRFLSB_927             0x00
.................... #define RF_FRFMSB_928             0xE8
.................... #define RF_FRFMID_928             0x00
.................... #define RF_FRFLSB_928             0x00
.................... 
.................... 
.................... // RegOsc1
.................... #define RF_OSC1_RCCAL_START       0x80
.................... #define RF_OSC1_RCCAL_DONE        0x40
.................... 
.................... 
.................... // RegAfcCtrl
.................... #define RF_AFCCTRL_LOWBETA_OFF    0x00  // Default
.................... #define RF_AFCCTRL_LOWBETA_ON     0x20
.................... 
.................... 
.................... // RegLowBat
.................... #define RF_LOWBAT_MONITOR         0x10
.................... #define RF_LOWBAT_ON              0x08
.................... #define RF_LOWBAT_OFF             0x00  // Default
.................... 
.................... #define RF_LOWBAT_TRIM_1695       0x00
.................... #define RF_LOWBAT_TRIM_1764       0x01
.................... #define RF_LOWBAT_TRIM_1835       0x02  // Default
.................... #define RF_LOWBAT_TRIM_1905       0x03
.................... #define RF_LOWBAT_TRIM_1976       0x04
.................... #define RF_LOWBAT_TRIM_2045       0x05
.................... #define RF_LOWBAT_TRIM_2116       0x06
.................... #define RF_LOWBAT_TRIM_2185       0x07
.................... 
.................... 
.................... // RegListen1
.................... #define RF_LISTEN1_RESOL_64       0x50
.................... #define RF_LISTEN1_RESOL_4100     0xA0  // Default
.................... #define RF_LISTEN1_RESOL_262000   0xF0
.................... 
.................... #define RF_LISTEN1_RESOL_IDLE_64     0x40
.................... #define RF_LISTEN1_RESOL_IDLE_4100   0x80  // Default
.................... #define RF_LISTEN1_RESOL_IDLE_262000 0xC0
.................... 
.................... #define RF_LISTEN1_RESOL_RX_64       0x10
.................... #define RF_LISTEN1_RESOL_RX_4100     0x20  // Default
.................... #define RF_LISTEN1_RESOL_RX_262000   0x30
.................... 
.................... #define RF_LISTEN1_CRITERIA_RSSI          0x00  // Default
.................... #define RF_LISTEN1_CRITERIA_RSSIANDSYNC   0x08
.................... 
.................... #define RF_LISTEN1_END_00                 0x00
.................... #define RF_LISTEN1_END_01                 0x02  // Default
.................... #define RF_LISTEN1_END_10                 0x04
.................... 
.................... 
.................... // RegListen2
.................... #define RF_LISTEN2_COEFIDLE_VALUE         0xF5 // Default
.................... 
.................... 
.................... // RegListen3
.................... #define RF_LISTEN3_COEFRX_VALUE           0x20 // Default
.................... 
.................... 
.................... // RegVersion
.................... #define RF_VERSION_VER        0x24  // Default
.................... 
.................... 
.................... // RegPaLevel
.................... #define RF_PALEVEL_PA0_ON     0x80  // Default
.................... #define RF_PALEVEL_PA0_OFF    0x00
.................... #define RF_PALEVEL_PA1_ON     0x40
.................... #define RF_PALEVEL_PA1_OFF    0x00  // Default
.................... #define RF_PALEVEL_PA2_ON     0x20
.................... #define RF_PALEVEL_PA2_OFF    0x00  // Default
.................... 
.................... #define RF_PALEVEL_OUTPUTPOWER_00000      0x00
.................... #define RF_PALEVEL_OUTPUTPOWER_00001      0x01
.................... #define RF_PALEVEL_OUTPUTPOWER_00010      0x02
.................... #define RF_PALEVEL_OUTPUTPOWER_00011      0x03
.................... #define RF_PALEVEL_OUTPUTPOWER_00100      0x04
.................... #define RF_PALEVEL_OUTPUTPOWER_00101      0x05
.................... #define RF_PALEVEL_OUTPUTPOWER_00110      0x06
.................... #define RF_PALEVEL_OUTPUTPOWER_00111      0x07
.................... #define RF_PALEVEL_OUTPUTPOWER_01000      0x08
.................... #define RF_PALEVEL_OUTPUTPOWER_01001      0x09
.................... #define RF_PALEVEL_OUTPUTPOWER_01010      0x0A
.................... #define RF_PALEVEL_OUTPUTPOWER_01011      0x0B
.................... #define RF_PALEVEL_OUTPUTPOWER_01100      0x0C
.................... #define RF_PALEVEL_OUTPUTPOWER_01101      0x0D
.................... #define RF_PALEVEL_OUTPUTPOWER_01110      0x0E
.................... #define RF_PALEVEL_OUTPUTPOWER_01111      0x0F
.................... #define RF_PALEVEL_OUTPUTPOWER_10000      0x10
.................... #define RF_PALEVEL_OUTPUTPOWER_10001      0x11
.................... #define RF_PALEVEL_OUTPUTPOWER_10010      0x12
.................... #define RF_PALEVEL_OUTPUTPOWER_10011      0x13
.................... #define RF_PALEVEL_OUTPUTPOWER_10100      0x14
.................... #define RF_PALEVEL_OUTPUTPOWER_10101      0x15
.................... #define RF_PALEVEL_OUTPUTPOWER_10110      0x16
.................... #define RF_PALEVEL_OUTPUTPOWER_10111      0x17
.................... #define RF_PALEVEL_OUTPUTPOWER_11000      0x18
.................... #define RF_PALEVEL_OUTPUTPOWER_11001      0x19
.................... #define RF_PALEVEL_OUTPUTPOWER_11010      0x1A
.................... #define RF_PALEVEL_OUTPUTPOWER_11011      0x1B
.................... #define RF_PALEVEL_OUTPUTPOWER_11100      0x1C
.................... #define RF_PALEVEL_OUTPUTPOWER_11101      0x1D
.................... #define RF_PALEVEL_OUTPUTPOWER_11110      0x1E
.................... #define RF_PALEVEL_OUTPUTPOWER_11111      0x1F  // Default
.................... 
.................... 
.................... // RegPaRamp
.................... #define RF_PARAMP_3400            0x00
.................... #define RF_PARAMP_2000            0x01
.................... #define RF_PARAMP_1000            0x02
.................... #define RF_PARAMP_500             0x03
.................... #define RF_PARAMP_250             0x04
.................... #define RF_PARAMP_125             0x05
.................... #define RF_PARAMP_100             0x06
.................... #define RF_PARAMP_62              0x07
.................... #define RF_PARAMP_50              0x08
.................... #define RF_PARAMP_40              0x09  // Default
.................... #define RF_PARAMP_31              0x0A
.................... #define RF_PARAMP_25              0x0B
.................... #define RF_PARAMP_20              0x0C
.................... #define RF_PARAMP_15              0x0D
.................... #define RF_PARAMP_12              0x0E
.................... #define RF_PARAMP_10              0x0F
.................... 
.................... 
.................... // RegOcp
.................... #define RF_OCP_OFF                0x0F
.................... #define RF_OCP_ON                 0x1A  // Default
.................... 
.................... #define RF_OCP_TRIM_45            0x00
.................... #define RF_OCP_TRIM_50            0x01
.................... #define RF_OCP_TRIM_55            0x02
.................... #define RF_OCP_TRIM_60            0x03
.................... #define RF_OCP_TRIM_65            0x04
.................... #define RF_OCP_TRIM_70            0x05
.................... #define RF_OCP_TRIM_75            0x06
.................... #define RF_OCP_TRIM_80            0x07
.................... #define RF_OCP_TRIM_85            0x08
.................... #define RF_OCP_TRIM_90            0x09
.................... #define RF_OCP_TRIM_95            0x0A  // Default
.................... #define RF_OCP_TRIM_100           0x0B
.................... #define RF_OCP_TRIM_105           0x0C
.................... #define RF_OCP_TRIM_110           0x0D
.................... #define RF_OCP_TRIM_115           0x0E
.................... #define RF_OCP_TRIM_120           0x0F
.................... 
.................... 
.................... // RegAgcRef - not present on RFM69/SX1231
.................... #define RF_AGCREF_AUTO_ON         0x40  // Default
.................... #define RF_AGCREF_AUTO_OFF        0x00
.................... 
.................... #define RF_AGCREF_LEVEL_MINUS80   0x00  // Default
.................... #define RF_AGCREF_LEVEL_MINUS81   0x01
.................... #define RF_AGCREF_LEVEL_MINUS82   0x02
.................... #define RF_AGCREF_LEVEL_MINUS83   0x03
.................... #define RF_AGCREF_LEVEL_MINUS84   0x04
.................... #define RF_AGCREF_LEVEL_MINUS85   0x05
.................... #define RF_AGCREF_LEVEL_MINUS86   0x06
.................... #define RF_AGCREF_LEVEL_MINUS87   0x07
.................... #define RF_AGCREF_LEVEL_MINUS88   0x08
.................... #define RF_AGCREF_LEVEL_MINUS89   0x09
.................... #define RF_AGCREF_LEVEL_MINUS90   0x0A
.................... #define RF_AGCREF_LEVEL_MINUS91   0x0B
.................... #define RF_AGCREF_LEVEL_MINUS92   0x0C
.................... #define RF_AGCREF_LEVEL_MINUS93   0x0D
.................... #define RF_AGCREF_LEVEL_MINUS94   0x0E
.................... #define RF_AGCREF_LEVEL_MINUS95   0x0F
.................... #define RF_AGCREF_LEVEL_MINUS96   0x10
.................... #define RF_AGCREF_LEVEL_MINUS97   0x11
.................... #define RF_AGCREF_LEVEL_MINUS98   0x12
.................... #define RF_AGCREF_LEVEL_MINUS99   0x13
.................... #define RF_AGCREF_LEVEL_MINUS100  0x14
.................... #define RF_AGCREF_LEVEL_MINUS101  0x15
.................... #define RF_AGCREF_LEVEL_MINUS102  0x16
.................... #define RF_AGCREF_LEVEL_MINUS103  0x17
.................... #define RF_AGCREF_LEVEL_MINUS104  0x18
.................... #define RF_AGCREF_LEVEL_MINUS105  0x19
.................... #define RF_AGCREF_LEVEL_MINUS106  0x1A
.................... #define RF_AGCREF_LEVEL_MINUS107  0x1B
.................... #define RF_AGCREF_LEVEL_MINUS108  0x1C
.................... #define RF_AGCREF_LEVEL_MINUS109  0x1D
.................... #define RF_AGCREF_LEVEL_MINUS110  0x1E
.................... #define RF_AGCREF_LEVEL_MINUS111  0x1F
.................... #define RF_AGCREF_LEVEL_MINUS112  0x20
.................... #define RF_AGCREF_LEVEL_MINUS113  0x21
.................... #define RF_AGCREF_LEVEL_MINUS114  0x22
.................... #define RF_AGCREF_LEVEL_MINUS115  0x23
.................... #define RF_AGCREF_LEVEL_MINUS116  0x24
.................... #define RF_AGCREF_LEVEL_MINUS117  0x25
.................... #define RF_AGCREF_LEVEL_MINUS118  0x26
.................... #define RF_AGCREF_LEVEL_MINUS119  0x27
.................... #define RF_AGCREF_LEVEL_MINUS120  0x28
.................... #define RF_AGCREF_LEVEL_MINUS121  0x29
.................... #define RF_AGCREF_LEVEL_MINUS122  0x2A
.................... #define RF_AGCREF_LEVEL_MINUS123  0x2B
.................... #define RF_AGCREF_LEVEL_MINUS124  0x2C
.................... #define RF_AGCREF_LEVEL_MINUS125  0x2D
.................... #define RF_AGCREF_LEVEL_MINUS126  0x2E
.................... #define RF_AGCREF_LEVEL_MINUS127  0x2F
.................... #define RF_AGCREF_LEVEL_MINUS128  0x30
.................... #define RF_AGCREF_LEVEL_MINUS129  0x31
.................... #define RF_AGCREF_LEVEL_MINUS130  0x32
.................... #define RF_AGCREF_LEVEL_MINUS131  0x33
.................... #define RF_AGCREF_LEVEL_MINUS132  0x34
.................... #define RF_AGCREF_LEVEL_MINUS133  0x35
.................... #define RF_AGCREF_LEVEL_MINUS134  0x36
.................... #define RF_AGCREF_LEVEL_MINUS135  0x37
.................... #define RF_AGCREF_LEVEL_MINUS136  0x38
.................... #define RF_AGCREF_LEVEL_MINUS137  0x39
.................... #define RF_AGCREF_LEVEL_MINUS138  0x3A
.................... #define RF_AGCREF_LEVEL_MINUS139  0x3B
.................... #define RF_AGCREF_LEVEL_MINUS140  0x3C
.................... #define RF_AGCREF_LEVEL_MINUS141  0x3D
.................... #define RF_AGCREF_LEVEL_MINUS142  0x3E
.................... #define RF_AGCREF_LEVEL_MINUS143  0x3F
.................... 
.................... 
.................... // RegAgcThresh1 - not present on RFM69/SX1231
.................... #define RF_AGCTHRESH1_SNRMARGIN_000   0x00
.................... #define RF_AGCTHRESH1_SNRMARGIN_001   0x20
.................... #define RF_AGCTHRESH1_SNRMARGIN_010   0x40
.................... #define RF_AGCTHRESH1_SNRMARGIN_011   0x60
.................... #define RF_AGCTHRESH1_SNRMARGIN_100   0x80
.................... #define RF_AGCTHRESH1_SNRMARGIN_101   0xA0  // Default
.................... #define RF_AGCTHRESH1_SNRMARGIN_110   0xC0
.................... #define RF_AGCTHRESH1_SNRMARGIN_111   0xE0
.................... 
.................... #define RF_AGCTHRESH1_STEP1_0         0x00
.................... #define RF_AGCTHRESH1_STEP1_1         0x01
.................... #define RF_AGCTHRESH1_STEP1_2         0x02
.................... #define RF_AGCTHRESH1_STEP1_3         0x03
.................... #define RF_AGCTHRESH1_STEP1_4         0x04
.................... #define RF_AGCTHRESH1_STEP1_5         0x05
.................... #define RF_AGCTHRESH1_STEP1_6         0x06
.................... #define RF_AGCTHRESH1_STEP1_7         0x07
.................... #define RF_AGCTHRESH1_STEP1_8         0x08
.................... #define RF_AGCTHRESH1_STEP1_9         0x09
.................... #define RF_AGCTHRESH1_STEP1_10        0x0A
.................... #define RF_AGCTHRESH1_STEP1_11        0x0B
.................... #define RF_AGCTHRESH1_STEP1_12        0x0C
.................... #define RF_AGCTHRESH1_STEP1_13        0x0D
.................... #define RF_AGCTHRESH1_STEP1_14        0x0E
.................... #define RF_AGCTHRESH1_STEP1_15        0x0F
.................... #define RF_AGCTHRESH1_STEP1_16        0x10  // Default
.................... #define RF_AGCTHRESH1_STEP1_17        0x11
.................... #define RF_AGCTHRESH1_STEP1_18        0x12
.................... #define RF_AGCTHRESH1_STEP1_19        0x13
.................... #define RF_AGCTHRESH1_STEP1_20        0x14
.................... #define RF_AGCTHRESH1_STEP1_21        0x15
.................... #define RF_AGCTHRESH1_STEP1_22        0x16
.................... #define RF_AGCTHRESH1_STEP1_23        0x17
.................... #define RF_AGCTHRESH1_STEP1_24        0x18
.................... #define RF_AGCTHRESH1_STEP1_25        0x19
.................... #define RF_AGCTHRESH1_STEP1_26        0x1A
.................... #define RF_AGCTHRESH1_STEP1_27        0x1B
.................... #define RF_AGCTHRESH1_STEP1_28        0x1C
.................... #define RF_AGCTHRESH1_STEP1_29        0x1D
.................... #define RF_AGCTHRESH1_STEP1_30        0x1E
.................... #define RF_AGCTHRESH1_STEP1_31        0x1F
.................... 
.................... 
.................... // RegAgcThresh2 - not present on RFM69/SX1231
.................... #define RF_AGCTHRESH2_STEP2_0         0x00
.................... #define RF_AGCTHRESH2_STEP2_1         0x10
.................... #define RF_AGCTHRESH2_STEP2_2         0x20
.................... #define RF_AGCTHRESH2_STEP2_3         0x30  // XXX wrong -- Default
.................... #define RF_AGCTHRESH2_STEP2_4         0x40
.................... #define RF_AGCTHRESH2_STEP2_5         0x50
.................... #define RF_AGCTHRESH2_STEP2_6         0x60
.................... #define RF_AGCTHRESH2_STEP2_7         0x70  // default
.................... #define RF_AGCTHRESH2_STEP2_8         0x80
.................... #define RF_AGCTHRESH2_STEP2_9         0x90
.................... #define RF_AGCTHRESH2_STEP2_10        0xA0
.................... #define RF_AGCTHRESH2_STEP2_11        0xB0
.................... #define RF_AGCTHRESH2_STEP2_12        0xC0
.................... #define RF_AGCTHRESH2_STEP2_13        0xD0
.................... #define RF_AGCTHRESH2_STEP2_14        0xE0
.................... #define RF_AGCTHRESH2_STEP2_15        0xF0
.................... 
.................... #define RF_AGCTHRESH2_STEP3_0         0x00
.................... #define RF_AGCTHRESH2_STEP3_1         0x01
.................... #define RF_AGCTHRESH2_STEP3_2         0x02
.................... #define RF_AGCTHRESH2_STEP3_3         0x03
.................... #define RF_AGCTHRESH2_STEP3_4         0x04
.................... #define RF_AGCTHRESH2_STEP3_5         0x05
.................... #define RF_AGCTHRESH2_STEP3_6         0x06
.................... #define RF_AGCTHRESH2_STEP3_7         0x07
.................... #define RF_AGCTHRESH2_STEP3_8         0x08
.................... #define RF_AGCTHRESH2_STEP3_9         0x09
.................... #define RF_AGCTHRESH2_STEP3_10        0x0A
.................... #define RF_AGCTHRESH2_STEP3_11        0x0B  // Default
.................... #define RF_AGCTHRESH2_STEP3_12        0x0C
.................... #define RF_AGCTHRESH2_STEP3_13        0x0D
.................... #define RF_AGCTHRESH2_STEP3_14        0x0E
.................... #define RF_AGCTHRESH2_STEP3_15        0x0F
.................... 
.................... 
.................... // RegAgcThresh3 - not present on RFM69/SX1231
.................... #define RF_AGCTHRESH3_STEP4_0         0x00
.................... #define RF_AGCTHRESH3_STEP4_1         0x10
.................... #define RF_AGCTHRESH3_STEP4_2         0x20
.................... #define RF_AGCTHRESH3_STEP4_3         0x30
.................... #define RF_AGCTHRESH3_STEP4_4         0x40
.................... #define RF_AGCTHRESH3_STEP4_5         0x50
.................... #define RF_AGCTHRESH3_STEP4_6         0x60
.................... #define RF_AGCTHRESH3_STEP4_7         0x70
.................... #define RF_AGCTHRESH3_STEP4_8         0x80
.................... #define RF_AGCTHRESH3_STEP4_9         0x90  // Default
.................... #define RF_AGCTHRESH3_STEP4_10        0xA0
.................... #define RF_AGCTHRESH3_STEP4_11        0xB0
.................... #define RF_AGCTHRESH3_STEP4_12        0xC0
.................... #define RF_AGCTHRESH3_STEP4_13        0xD0
.................... #define RF_AGCTHRESH3_STEP4_14        0xE0
.................... #define RF_AGCTHRESH3_STEP4_15        0xF0
.................... 
.................... #define RF_AGCTHRESH3_STEP5_0         0x00
.................... #define RF_AGCTHRESH3_STEP5_1         0x01
.................... #define RF_AGCTHRESH3_STEP5_2         0x02
.................... #define RF_AGCTHRESH3_STEP5_3         0x03
.................... #define RF_AGCTHRESH3_STEP5_4         0x04
.................... #define RF_AGCTHRESH3_STEP5_5         0x05
.................... #define RF_AGCTHRESH3_STEP5_6         0x06
.................... #define RF_AGCTHRESH3_STEP5_7         0x07
.................... #define RF_AGCTHRES33_STEP5_8         0x08
.................... #define RF_AGCTHRESH3_STEP5_9         0x09
.................... #define RF_AGCTHRESH3_STEP5_10        0x0A
.................... #define RF_AGCTHRESH3_STEP5_11        0x0B  // Default
.................... #define RF_AGCTHRESH3_STEP5_12        0x0C
.................... #define RF_AGCTHRESH3_STEP5_13        0x0D
.................... #define RF_AGCTHRESH3_STEP5_14        0x0E
.................... #define RF_AGCTHRESH3_STEP5_15        0x0F
.................... 
.................... 
.................... // RegLna
.................... #define RF_LNA_ZIN_50                 0x00  // Reset value
.................... #define RF_LNA_ZIN_200                0x80  // Recommended default
.................... 
.................... #define RF_LNA_LOWPOWER_OFF           0x00  // Default
.................... #define RF_LNA_LOWPOWER_ON            0x40
.................... 
.................... #define RF_LNA_CURRENTGAIN            0x08
.................... 
.................... #define RF_LNA_GAINSELECT_AUTO        0x00  // Default
.................... #define RF_LNA_GAINSELECT_MAX         0x01
.................... #define RF_LNA_GAINSELECT_MAXMINUS6   0x02
.................... #define RF_LNA_GAINSELECT_MAXMINUS12  0x03
.................... #define RF_LNA_GAINSELECT_MAXMINUS24  0x04
.................... #define RF_LNA_GAINSELECT_MAXMINUS36  0x05
.................... #define RF_LNA_GAINSELECT_MAXMINUS48  0x06
.................... 
.................... 
.................... // RegRxBw
.................... #define RF_RXBW_DCCFREQ_000           0x00
.................... #define RF_RXBW_DCCFREQ_001           0x20
.................... #define RF_RXBW_DCCFREQ_010           0x40  // Recommended default
.................... #define RF_RXBW_DCCFREQ_011           0x60
.................... #define RF_RXBW_DCCFREQ_100           0x80  // Reset value
.................... #define RF_RXBW_DCCFREQ_101           0xA0
.................... #define RF_RXBW_DCCFREQ_110           0xC0
.................... #define RF_RXBW_DCCFREQ_111           0xE0
.................... 
.................... #define RF_RXBW_MANT_16               0x00  // Reset value
.................... #define RF_RXBW_MANT_20               0x08
.................... #define RF_RXBW_MANT_24               0x10  // Recommended default
.................... 
.................... #define RF_RXBW_EXP_0                 0x00
.................... #define RF_RXBW_EXP_1                 0x01
.................... #define RF_RXBW_EXP_2                 0x02
.................... #define RF_RXBW_EXP_3                 0x03
.................... #define RF_RXBW_EXP_4                 0x04
.................... #define RF_RXBW_EXP_5                 0x05  // Recommended default
.................... #define RF_RXBW_EXP_6                 0x06  // Reset value
.................... #define RF_RXBW_EXP_7                 0x07
.................... 
.................... 
.................... // RegAfcBw
.................... #define RF_AFCBW_DCCFREQAFC_000       0x00
.................... #define RF_AFCBW_DCCFREQAFC_001       0x20
.................... #define RF_AFCBW_DCCFREQAFC_010       0x40
.................... #define RF_AFCBW_DCCFREQAFC_011       0x60
.................... #define RF_AFCBW_DCCFREQAFC_100       0x80  // Default
.................... #define RF_AFCBW_DCCFREQAFC_101       0xA0
.................... #define RF_AFCBW_DCCFREQAFC_110       0xC0
.................... #define RF_AFCBW_DCCFREQAFC_111       0xE0
.................... 
.................... #define RF_AFCBW_MANTAFC_16           0x00
.................... #define RF_AFCBW_MANTAFC_20           0x08  // Default
.................... #define RF_AFCBW_MANTAFC_24           0x10
.................... 
.................... #define RF_AFCBW_EXPAFC_0             0x00
.................... #define RF_AFCBW_EXPAFC_1             0x01
.................... #define RF_AFCBW_EXPAFC_2             0x02  // Reset value
.................... #define RF_AFCBW_EXPAFC_3             0x03  // Recommended default
.................... #define RF_AFCBW_EXPAFC_4             0x04
.................... #define RF_AFCBW_EXPAFC_5             0x05
.................... #define RF_AFCBW_EXPAFC_6             0x06
.................... #define RF_AFCBW_EXPAFC_7             0x07
.................... 
.................... 
.................... // RegOokPeak
.................... #define RF_OOKPEAK_THRESHTYPE_FIXED       0x00
.................... #define RF_OOKPEAK_THRESHTYPE_PEAK        0x40  // Default
.................... #define RF_OOKPEAK_THRESHTYPE_AVERAGE     0x80
.................... 
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_000     0x00  // Default
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_001     0x08
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_010     0x10
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_011     0x18
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_100     0x20
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_101     0x28
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_110     0x30
.................... #define RF_OOKPEAK_PEAKTHRESHSTEP_111     0x38
.................... 
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_000      0x00  // Default
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_001      0x01
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_010      0x02
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_011      0x03
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_100      0x04
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_101      0x05
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_110      0x06
.................... #define RF_OOKPEAK_PEAKTHRESHDEC_111      0x07
.................... 
.................... 
.................... // RegOokAvg
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_00    0x00
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_01    0x40
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_10    0x80  // Default
.................... #define RF_OOKAVG_AVERAGETHRESHFILT_11    0xC0
.................... 
.................... 
.................... // RegOokFix
.................... #define RF_OOKFIX_FIXEDTHRESH_VALUE       0x06  // Default
.................... 
.................... 
.................... // RegAfcFei
.................... #define RF_AFCFEI_FEI_DONE                0x40
.................... #define RF_AFCFEI_FEI_START               0x20
.................... #define RF_AFCFEI_AFC_DONE                0x10
.................... #define RF_AFCFEI_AFCAUTOCLEAR_ON         0x08
.................... #define RF_AFCFEI_AFCAUTOCLEAR_OFF        0x00  // Default
.................... 
.................... #define RF_AFCFEI_AFCAUTO_ON              0x04
.................... #define RF_AFCFEI_AFCAUTO_OFF             0x00  // Default
.................... 
.................... #define RF_AFCFEI_AFC_CLEAR               0x02
.................... #define RF_AFCFEI_AFC_START               0x01
.................... 
.................... 
.................... // RegRssiConfig
.................... #define RF_RSSI_FASTRX_ON                 0x08  // not present on RFM69/SX1231
.................... #define RF_RSSI_FASTRX_OFF                0x00  // Default
.................... 
.................... #define RF_RSSI_DONE                      0x02
.................... #define RF_RSSI_START                     0x01
.................... 
.................... 
.................... // RegDioMapping1
.................... #define RF_DIOMAPPING1_DIO0_00            0x00  // Default
.................... #define RF_DIOMAPPING1_DIO0_01            0x40
.................... #define RF_DIOMAPPING1_DIO0_10            0x80
.................... #define RF_DIOMAPPING1_DIO0_11            0xC0
.................... 
.................... #define RF_DIOMAPPING1_DIO1_00            0x00  // Default
.................... #define RF_DIOMAPPING1_DIO1_01            0x10
.................... #define RF_DIOMAPPING1_DIO1_10            0x20
.................... #define RF_DIOMAPPING1_DIO1_11            0x30
.................... 
.................... #define RF_DIOMAPPING1_DIO2_00            0x00  // Default
.................... #define RF_DIOMAPPING1_DIO2_01            0x04
.................... #define RF_DIOMAPPING1_DIO2_10            0x08
.................... #define RF_DIOMAPPING1_DIO2_11            0x0C
.................... 
.................... #define RF_DIOMAPPING1_DIO3_00            0x00  // Default
.................... #define RF_DIOMAPPING1_DIO3_01            0x01
.................... #define RF_DIOMAPPING1_DIO3_10            0x02
.................... #define RF_DIOMAPPING1_DIO3_11            0x03
.................... 
.................... 
.................... // RegDioMapping2
.................... #define RF_DIOMAPPING2_DIO4_00            0x00  // Default
.................... #define RF_DIOMAPPING2_DIO4_01            0x40
.................... #define RF_DIOMAPPING2_DIO4_10            0x80
.................... #define RF_DIOMAPPING2_DIO4_11            0xC0
.................... 
.................... #define RF_DIOMAPPING2_DIO5_00            0x00  // Default
.................... #define RF_DIOMAPPING2_DIO5_01            0x10
.................... #define RF_DIOMAPPING2_DIO5_10            0x20
.................... #define RF_DIOMAPPING2_DIO5_11            0x30
.................... 
.................... #define RF_DIOMAPPING2_CLKOUT_32MHZ       0x00
.................... #define RF_DIOMAPPING2_CLKOUT_16MHZ       0x01
.................... #define RF_DIOMAPPING2_CLKOUT_8MHZ        0x02
.................... #define RF_DIOMAPPING2_CLKOUT_4MHZ        0x03
.................... #define RF_DIOMAPPING2_CLKOUT_2MHZ        0x04
.................... #define RF_DIOMAPPING2_CLKOUT_1MHZ        0x05  // Reset value
.................... #define RF_DIOMAPPING2_CLKOUT_RC          0x06
.................... #define RF_DIOMAPPING2_CLKOUT_OFF         0x07  // Recommended default
.................... 
.................... 
.................... // RegIrqFlags1
.................... #define RF_IRQFLAGS1_MODEREADY            0x80
.................... #define RF_IRQFLAGS1_RXREADY              0x40
.................... #define RF_IRQFLAGS1_TXREADY              0x20
.................... #define RF_IRQFLAGS1_PLLLOCK              0x10
.................... #define RF_IRQFLAGS1_RSSI                 0x08
.................... #define RF_IRQFLAGS1_TIMEOUT              0x04
.................... #define RF_IRQFLAGS1_AUTOMODE             0x02
.................... #define RF_IRQFLAGS1_SYNCADDRESSMATCH     0x01
.................... 
.................... 
.................... // RegIrqFlags2
.................... #define RF_IRQFLAGS2_FIFOFULL             0x80
.................... #define RF_IRQFLAGS2_FIFONOTEMPTY         0x40
.................... #define RF_IRQFLAGS2_FIFOLEVEL            0x20
.................... #define RF_IRQFLAGS2_FIFOOVERRUN          0x10
.................... #define RF_IRQFLAGS2_PACKETSENT           0x08
.................... #define RF_IRQFLAGS2_PAYLOADREADY         0x04
.................... #define RF_IRQFLAGS2_CRCOK                0x02
.................... #define RF_IRQFLAGS2_LOWBAT               0x01  // not present on RFM69/SX1231
.................... 
.................... 
.................... // RegRssiThresh
.................... #define RF_RSSITHRESH_VALUE               0xE4  // Default
.................... 
.................... 
.................... // RegRxTimeout1
.................... #define RF_RXTIMEOUT1_RXSTART_VALUE       0x00  // Default
.................... 
.................... 
.................... // RegRxTimeout2
.................... #define RF_RXTIMEOUT2_RSSITHRESH_VALUE    0x00  // Default
.................... 
.................... 
.................... // RegPreamble
.................... #define RF_PREAMBLESIZE_MSB_VALUE         0x00  // Default
.................... #define RF_PREAMBLESIZE_LSB_VALUE         0x03  // Default
.................... 
.................... 
.................... // RegSyncConfig
.................... #define RF_SYNC_ON                0x80  // Default
.................... #define RF_SYNC_OFF               0x00
.................... 
.................... #define RF_SYNC_FIFOFILL_AUTO     0x00  // Default -- when sync interrupt occurs
.................... #define RF_SYNC_FIFOFILL_MANUAL   0x40
.................... 
.................... #define RF_SYNC_SIZE_1            0x00
.................... #define RF_SYNC_SIZE_2            0x08
.................... #define RF_SYNC_SIZE_3            0x10
.................... #define RF_SYNC_SIZE_4            0x18  // Default
.................... #define RF_SYNC_SIZE_5            0x20
.................... #define RF_SYNC_SIZE_6            0x28
.................... #define RF_SYNC_SIZE_7            0x30
.................... #define RF_SYNC_SIZE_8            0x38
.................... 
.................... #define RF_SYNC_TOL_0             0x00  // Default
.................... #define RF_SYNC_TOL_1             0x01
.................... #define RF_SYNC_TOL_2             0x02
.................... #define RF_SYNC_TOL_3             0x03
.................... #define RF_SYNC_TOL_4             0x04
.................... #define RF_SYNC_TOL_5             0x05
.................... #define RF_SYNC_TOL_6             0x06
.................... #define RF_SYNC_TOL_7             0x07
.................... 
.................... 
.................... // RegSyncValue1-8
.................... #define RF_SYNC_BYTE1_VALUE       0x00  // Default
.................... #define RF_SYNC_BYTE2_VALUE       0x00  // Default
.................... #define RF_SYNC_BYTE3_VALUE       0x00  // Default
.................... #define RF_SYNC_BYTE4_VALUE       0x00  // Default
.................... #define RF_SYNC_BYTE5_VALUE       0x00  // Default
.................... #define RF_SYNC_BYTE6_VALUE       0x00  // Default
.................... #define RF_SYNC_BYTE7_VALUE       0x00  // Default
.................... #define RF_SYNC_BYTE8_VALUE       0x00  // Default
.................... 
.................... 
.................... // RegPacketConfig1
.................... #define RF_PACKET1_FORMAT_FIXED       0x00  // Default
.................... #define RF_PACKET1_FORMAT_VARIABLE    0x80
.................... 
.................... #define RF_PACKET1_DCFREE_OFF         0x00  // Default
.................... #define RF_PACKET1_DCFREE_MANCHESTER  0x20
.................... #define RF_PACKET1_DCFREE_WHITENING   0x40
.................... 
.................... #define RF_PACKET1_CRC_ON             0x10  // Default
.................... #define RF_PACKET1_CRC_OFF            0x00
.................... 
.................... #define RF_PACKET1_CRCAUTOCLEAR_ON    0x00  // Default
.................... #define RF_PACKET1_CRCAUTOCLEAR_OFF   0x08
.................... 
.................... #define RF_PACKET1_ADRSFILTERING_OFF            0x00  // Default
.................... #define RF_PACKET1_ADRSFILTERING_NODE           0x02
.................... #define RF_PACKET1_ADRSFILTERING_NODEBROADCAST  0x04
.................... 
.................... 
.................... // RegPayloadLength
.................... #define RF_PAYLOADLENGTH_VALUE          0x40  // Default
.................... 
.................... 
.................... // RegBroadcastAdrs
.................... #define RF_BROADCASTADDRESS_VALUE       0x00
.................... 
.................... 
.................... // RegAutoModes
.................... #define RF_AUTOMODES_ENTER_OFF                0x00  // Default
.................... #define RF_AUTOMODES_ENTER_FIFONOTEMPTY       0x20
.................... #define RF_AUTOMODES_ENTER_FIFOLEVEL          0x40
.................... #define RF_AUTOMODES_ENTER_CRCOK              0x60
.................... #define RF_AUTOMODES_ENTER_PAYLOADREADY       0x80
.................... #define RF_AUTOMODES_ENTER_SYNCADRSMATCH      0xA0
.................... #define RF_AUTOMODES_ENTER_PACKETSENT         0xC0
.................... #define RF_AUTOMODES_ENTER_FIFOEMPTY          0xE0
.................... 
.................... #define RF_AUTOMODES_EXIT_OFF                 0x00  // Default
.................... #define RF_AUTOMODES_EXIT_FIFOEMPTY           0x04
.................... #define RF_AUTOMODES_EXIT_FIFOLEVEL           0x08
.................... #define RF_AUTOMODES_EXIT_CRCOK               0x0C
.................... #define RF_AUTOMODES_EXIT_PAYLOADREADY        0x10
.................... #define RF_AUTOMODES_EXIT_SYNCADRSMATCH       0x14
.................... #define RF_AUTOMODES_EXIT_PACKETSENT          0x18
.................... #define RF_AUTOMODES_EXIT_RXTIMEOUT           0x1C
.................... 
.................... #define RF_AUTOMODES_INTERMEDIATE_SLEEP       0x00  // Default
.................... #define RF_AUTOMODES_INTERMEDIATE_STANDBY     0x01
.................... #define RF_AUTOMODES_INTERMEDIATE_RECEIVER    0x02
.................... #define RF_AUTOMODES_INTERMEDIATE_TRANSMITTER 0x03
.................... 
.................... 
.................... // RegFifoThresh
.................... #define RF_FIFOTHRESH_TXSTART_FIFOTHRESH      0x00  // Reset value
.................... #define RF_FIFOTHRESH_TXSTART_FIFONOTEMPTY    0x80  // Recommended default
.................... 
.................... #define RF_FIFOTHRESH_VALUE                   0x0F  // Default
.................... 
.................... 
.................... // RegPacketConfig2
.................... #define RF_PACKET2_RXRESTARTDELAY_1BIT        0x00  // Default
.................... #define RF_PACKET2_RXRESTARTDELAY_2BITS       0x10
.................... #define RF_PACKET2_RXRESTARTDELAY_4BITS       0x20
.................... #define RF_PACKET2_RXRESTARTDELAY_8BITS       0x30
.................... #define RF_PACKET2_RXRESTARTDELAY_16BITS      0x40
.................... #define RF_PACKET2_RXRESTARTDELAY_32BITS      0x50
.................... #define RF_PACKET2_RXRESTARTDELAY_64BITS      0x60
.................... #define RF_PACKET2_RXRESTARTDELAY_128BITS     0x70
.................... #define RF_PACKET2_RXRESTARTDELAY_256BITS     0x80
.................... #define RF_PACKET2_RXRESTARTDELAY_512BITS     0x90
.................... #define RF_PACKET2_RXRESTARTDELAY_1024BITS    0xA0
.................... #define RF_PACKET2_RXRESTARTDELAY_2048BITS    0xB0
.................... #define RF_PACKET2_RXRESTARTDELAY_NONE        0xC0
.................... #define RF_PACKET2_RXRESTART                  0x04
.................... 
.................... #define RF_PACKET2_AUTORXRESTART_ON           0x02  // Default
.................... #define RF_PACKET2_AUTORXRESTART_OFF          0x00
.................... 
.................... #define RF_PACKET2_AES_ON                     0x01
.................... #define RF_PACKET2_AES_OFF                    0x00  // Default
.................... 
.................... 
.................... // RegAesKey1-16
.................... #define RF_AESKEY1_VALUE            0x00  // Default
.................... #define RF_AESKEY2_VALUE            0x00  // Default
.................... #define RF_AESKEY3_VALUE            0x00  // Default
.................... #define RF_AESKEY4_VALUE            0x00  // Default
.................... #define RF_AESKEY5_VALUE            0x00  // Default
.................... #define RF_AESKEY6_VALUE            0x00  // Default
.................... #define RF_AESKEY7_VALUE            0x00  // Default
.................... #define RF_AESKEY8_VALUE            0x00  // Default
.................... #define RF_AESKEY9_VALUE            0x00  // Default
.................... #define RF_AESKEY10_VALUE           0x00  // Default
.................... #define RF_AESKEY11_VALUE           0x00  // Default
.................... #define RF_AESKEY12_VALUE           0x00  // Default
.................... #define RF_AESKEY13_VALUE           0x00  // Default
.................... #define RF_AESKEY14_VALUE           0x00  // Default
.................... #define RF_AESKEY15_VALUE           0x00  // Default
.................... #define RF_AESKEY16_VALUE           0x00  // Default
.................... 
.................... 
.................... // RegTemp1
.................... #define RF_TEMP1_MEAS_START         0x08
.................... #define RF_TEMP1_MEAS_RUNNING       0x04
.................... // not present on RFM69/SX1231
.................... #define RF_TEMP1_ADCLOWPOWER_ON     0x01  // Default
.................... #define RF_TEMP1_ADCLOWPOWER_OFF    0x00
.................... 
.................... 
.................... // RegTestLna
.................... #define RF_TESTLNA_NORMAL           0x1B
.................... #define RF_TESTLNA_HIGH_SENSITIVITY 0x2D
.................... 
.................... 
.................... // RegTestDagc
.................... #define RF_DAGC_NORMAL              0x00  // Reset value
.................... #define RF_DAGC_IMPROVED_LOWBETA1   0x20
.................... #define RF_DAGC_IMPROVED_LOWBETA0   0x30  // Recommended default
.................... 
.................... 
.................... #define RF69_MAX_DATA_LEN       61 
.................... int CSMA_LIMIT = -90; // upper RX signal sensitivity threshold in dBm for carrier sense access
.................... #define RF69_MODE_SLEEP         0 // XTAL OFF
.................... #define RF69_MODE_STANDBY       1 // XTAL ON
.................... #define RF69_MODE_SYNTH         2 // PLL ON
.................... #define RF69_MODE_RX            3 // RX MODE
.................... #define RF69_MODE_TX            4 // TX MODE
.................... 
.................... // available frequency bands
.................... #define RF69_315MHZ            31 // non trivial values to avoid misconfiguration
.................... #define RF69_433MHZ            43
.................... #define RF69_868MHZ            86
.................... #define RF69_915MHZ            91
.................... 
.................... #define COURSE_TEMP_COEF    -90 // puts the temperature reading in the ballpark, user can fine tune the returned value
.................... #define RF69_BROADCAST_ADDR 255
.................... #define RF69_CSMA_LIMIT_MS 1000
.................... #define RF69_TX_LIMIT_MS   1000
.................... #define RF69_FSTEP  61.03515625 // == FXOSC / 2^19 = 32MHz / 2^19 (p13 in datasheet)
.................... 
.................... // TWS: define CTLbyte bits
.................... #define RFM69_CTL_SENDACK   0x80
.................... #define RFM69_CTL_REQACK    0x40
.................... 
.................... 
....................    // static volatile int DATA[RF69_MAX_DATA_LEN]; // recv/xmit buf, including header & crc bytes
....................     //static volatile int DATALEN;
....................     //static volatile int SENDERID;
....................     //static volatile int TARGETID; // should match _address
....................     static volatile int PAYLOADLEN;
....................     //static volatile int ACK_REQUESTED;
....................     //static volatile int ACK_RECEIVED; // should be polled immediately after sending a packet with ACK request
....................     static volatile int16 RSSI; // most accurate RSSI during reception (closest to the reception)
....................     static volatile int _mode, _address;// should be protected?
....................     short  _isRFM69HW=1;
....................     //short  _promiscuousMode = 0;
....................     int    _powerLevel = 31;
.................... 
....................     byte SPIRead8bit(void);
....................     byte SPItransfer(byte WrPara);
....................     int32 millis();
....................     short initialize(int8 ID);
....................     short canSend();
....................     void send(int toAddress,byte* buffer, int bufferSize, short requestACK=false);
....................     short sendWithRetry(int toAddress, byte* buffer, int bufferSize, int retries=2, int retryWaitTime=40); // 40ms roundtrip req for 61byte packets
....................     short receiveDone();
....................     short ACKReceived(int fromNodeID);
....................     short ACKRequested();
....................     void sendACK(byte* buffer , int bufferSize);
.................... 
....................     // allow hacking registers by making these public
....................     int readReg(int addr);
....................     void writeReg(int8 addr, int8 val);
....................     void readAllRegs();
....................     
....................     //static volatile short _inISR;
....................     void sendFrame(int8 toAddress, byte *buffer, int size, short requestACK=false,short sendACK=false);
.................... 
....................     void setMode(int mode);
....................     void select();
....................     void unselect();
....................     int16 readRSSI(short forceTrigger);
....................     void setHighPower(short onOff);
....................     void setHighPowerRegs(short onOff);
.................... 
.................... short initialize( int nodeID)
.................... {
....................    const int networkID = 1;
.................... 
....................   const int8 CONFIG[][2] =
....................   {
....................     /* 0x01 */ { REG_OPMODE, RF_OPMODE_SEQUENCER_ON | RF_OPMODE_LISTEN_OFF | RF_OPMODE_STANDBY },
....................     /* 0x02 */ { REG_DATAMODUL, RF_DATAMODUL_DATAMODE_PACKET | RF_DATAMODUL_MODULATIONTYPE_FSK | RF_DATAMODUL_MODULATIONSHAPING_00 }, // no shaping
....................     /* 0x03 */ { REG_BITRATEMSB, RF_BITRATEMSB_55555}, // default: 4.8 KBPS
....................     /* 0x04 */ { REG_BITRATELSB, RF_BITRATELSB_55555},
....................     /* 0x05 */ { REG_FDEVMSB, RF_FDEVMSB_50000}, // default: 5KHz, (FDEV + BitRate / 2 <= 500KHz)
....................     /* 0x06 */ { REG_FDEVLSB, RF_FDEVLSB_50000},
.................... 
....................     /* 0x07 */ { REG_FRFMSB, RF_FRFMSB_915 },
....................     /* 0x08 */ { REG_FRFMID, RF_FRFMID_915 },
....................     /* 0x09 */ { REG_FRFLSB, RF_FRFLSB_915 },
.................... 
....................     // looks like PA1 and PA2 are not implemented on RFM69W, hence the max output power is 13dBm
....................     // +17dBm and +20dBm are possible on RFM69HW
....................     // +13dBm formula: Pout = -18 + OutputPower (with PA0 or PA1**)
....................     // +17dBm formula: Pout = -14 + OutputPower (with PA1 and PA2)**
....................     // +20dBm formula: Pout = -11 + OutputPower (with PA1 and PA2)** and high power PA settings (section 3.3.7 in datasheet)
....................     ///* 0x11 */ { REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | RF_PALEVEL_OUTPUTPOWER_11111},
....................     ///* 0x13 */ { REG_OCP, RF_OCP_ON | RF_OCP_TRIM_95 }, // over current protection (default is 95mA)
.................... 
....................     // RXBW defaults are { REG_RXBW, RF_RXBW_DCCFREQ_010 | RF_RXBW_MANT_24 | RF_RXBW_EXP_5} (RxBw: 10.4KHz)
....................     /* 0x19 */ { REG_RXBW, RF_RXBW_DCCFREQ_010 | RF_RXBW_MANT_16 | RF_RXBW_EXP_2 }, // (BitRate < 2 * RxBw)
....................     //for BR-19200: /* 0x19 */ { REG_RXBW, RF_RXBW_DCCFREQ_010 | RF_RXBW_MANT_24 | RF_RXBW_EXP_3 },
....................     /* 0x25 */ { REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_01 }, // DIO0 is the only IRQ we're using
....................     /* 0x26 */ { REG_DIOMAPPING2, RF_DIOMAPPING2_CLKOUT_OFF }, // DIO5 ClkOut disable for power saving
....................     /* 0x28 */ { REG_IRQFLAGS2, RF_IRQFLAGS2_FIFOOVERRUN }, // writing to this bit ensures that the FIFO & status flags are reset
....................     /* 0x29 */ { REG_RSSITHRESH, 220 }, // must be set to dBm = (-Sensitivity / 2), default is 0xE4 = 228 so -114dBm
....................     /* 0x2D */ { REG_PREAMBLELSB, RF_PREAMBLESIZE_LSB_VALUE }, // default 3 preamble bytes 0xAAAAAA
....................     /* 0x2E */ { REG_SYNCCONFIG, RF_SYNC_ON | RF_SYNC_FIFOFILL_AUTO | RF_SYNC_SIZE_2 | RF_SYNC_TOL_0 },
....................     /* 0x2F */ { REG_SYNCVALUE1, 0x2D },      // attempt to make this compatible with sync1 byte of RFM12B lib
....................     /* 0x30 */ { REG_SYNCVALUE2, networkID}, // NETWORK ID
....................     /* 0x37 */ { REG_PACKETCONFIG1, RF_PACKET1_FORMAT_VARIABLE | RF_PACKET1_DCFREE_OFF | RF_PACKET1_CRC_ON | RF_PACKET1_CRCAUTOCLEAR_ON | RF_PACKET1_ADRSFILTERING_OFF },
....................     /* 0x38 */ { REG_PAYLOADLENGTH, 66 }, // in variable length mode: the max frame size, not used in TX
....................     ///* 0x39 */ { REG_NODEADRS, nodeID }, // turned off because we're not using address filtering
....................     /* 0x3C */ { REG_FIFOTHRESH, RF_FIFOTHRESH_TXSTART_FIFONOTEMPTY | RF_FIFOTHRESH_VALUE }, // TX on FIFO not empty
....................     /* 0x3D */ { REG_PACKETCONFIG2, RF_PACKET2_RXRESTARTDELAY_2BITS | RF_PACKET2_AUTORXRESTART_ON | RF_PACKET2_AES_OFF }, // RXRESTARTDELAY must match transmitter PA ramp-down time (bitrate dependent)
....................     //for BR-19200: /* 0x3D */ { REG_PACKETCONFIG2, RF_PACKET2_RXRESTARTDELAY_NONE | RF_PACKET2_AUTORXRESTART_ON | RF_PACKET2_AES_OFF }, // RXRESTARTDELAY must match transmitter PA ramp-down time (bitrate dependent)
....................     /* 0x6F */ { REG_TESTDAGC, RF_DAGC_IMPROVED_LOWBETA0 }, // run DAGC continuously in RX mode for Fading Margin Improvement, recommended default for AfcLowBetaOn=0
....................     {255, 0}
....................   };
....................    
....................    printf("sincronizando");
*
044E:  MOVLW  04
0450:  MOVWF  FF6
0452:  MOVLW  01
0454:  MOVWF  FF7
0456:  RCALL  01CE
....................   output_high(_slaveSelectPin);
0458:  BCF    F95.7
045A:  BSF    F8C.7
....................   int32 start = millis();
....................   int timeout = 50;
....................   int version_match = 0;
....................   int v = 0;
045C:  RCALL  0230
045E:  MOVFF  03,6F
0462:  MOVFF  02,6E
0466:  MOVFF  01,6D
046A:  MOVFF  00,6C
046E:  MOVLW  32
0470:  MOVWF  x70
0472:  CLRF   x71
0474:  CLRF   x72
....................   while(!version_match){
0476:  MOVF   x71,F
0478:  BNZ   04E0
....................   v=readReg(REG_VERSION);
047A:  MOVLW  10
047C:  MOVWF  x81
047E:  RCALL  02C4
0480:  MOVFF  01,72
....................   printf("Incorrect RFM device\n");
0484:  MOVLW  12
0486:  MOVWF  FF6
0488:  MOVLW  01
048A:  MOVWF  FF7
048C:  RCALL  01CE
....................   for (byte i = 8; i!=0 ; i--)
048E:  MOVLW  08
0490:  MOVWF  x73
0492:  MOVF   x73,F
0494:  BZ    04C8
....................       {
....................       if(bit_test(v, (i-1))) 
0496:  MOVLW  01
0498:  SUBWF  x73,W
049A:  MOVWF  x75
049C:  MOVFF  72,00
04A0:  MOVF   x75,W
04A2:  MOVWF  01
04A4:  BZ    04AE
04A6:  BCF    FD8.0
04A8:  RRCF   00,F
04AA:  DECFSZ 01,F
04AC:  BRA    04A6
04AE:  BTFSS  00.0
04B0:  BRA    04BC
....................          printf("1"); 
04B2:  MOVLW  31
04B4:  BTFSS  F9E.4
04B6:  BRA    04B4
04B8:  MOVWF  FAD
04BA:  BRA    04C4
....................       else 
....................          printf("0"); 
04BC:  MOVLW  30
04BE:  BTFSS  F9E.4
04C0:  BRA    04BE
04C2:  MOVWF  FAD
04C4:  DECF   x73,F
04C6:  BRA    0492
....................       }
....................      printf("\n");
04C8:  MOVLW  0A
04CA:  BTFSS  F9E.4
04CC:  BRA    04CA
04CE:  MOVWF  FAD
....................   version_match = v==0x24;}
04D0:  MOVF   x72,W
04D2:  SUBLW  24
04D4:  BZ    04DA
04D6:  MOVLW  00
04D8:  BRA    04DC
04DA:  MOVLW  01
04DC:  MOVWF  x71
04DE:  BRA    0476
....................   
....................   do writeReg(REG_SYNCVALUE1, 0xAA); while (readReg(REG_SYNCVALUE1) != 0xaa && millis()-start < timeout);
04E0:  MOVLW  2F
04E2:  MOVWF  x83
04E4:  MOVLW  AA
04E6:  MOVWF  x84
04E8:  RCALL  02DE
04EA:  MOVLW  2F
04EC:  MOVWF  x81
04EE:  RCALL  02C4
04F0:  MOVF   01,W
04F2:  SUBLW  AA
04F4:  BZ    0528
04F6:  RCALL  0230
04F8:  MOVFF  03,78
04FC:  MOVFF  02,77
0500:  MOVFF  01,76
0504:  MOVFF  00,75
0508:  MOVF   x6C,W
050A:  SUBWF  x75,F
050C:  MOVF   x6D,W
050E:  SUBWFB x76,F
0510:  MOVF   x6E,W
0512:  SUBWFB x77,F
0514:  MOVF   x6F,W
0516:  SUBWFB x78,F
0518:  BNZ   0528
051A:  MOVF   x77,F
051C:  BNZ   0528
051E:  MOVF   x76,F
0520:  BNZ   0528
0522:  MOVF   x70,W
0524:  SUBWF  x75,W
0526:  BNC   04E0
....................   printf("sincronizado1");
0528:  MOVLW  28
052A:  MOVWF  FF6
052C:  MOVLW  01
052E:  MOVWF  FF7
0530:  RCALL  01CE
....................   start = millis();
0532:  RCALL  0230
0534:  MOVFF  03,6F
0538:  MOVFF  02,6E
053C:  MOVFF  01,6D
0540:  MOVFF  00,6C
....................   do writeReg(REG_SYNCVALUE1, 0x55); while (readReg(REG_SYNCVALUE1) != 0x55 && millis()-start < timeout);
0544:  MOVLW  2F
0546:  MOVWF  x83
0548:  MOVLW  55
054A:  MOVWF  x84
054C:  RCALL  02DE
054E:  MOVLW  2F
0550:  MOVWF  x81
0552:  RCALL  02C4
0554:  MOVF   01,W
0556:  SUBLW  55
0558:  BZ    058C
055A:  RCALL  0230
055C:  MOVFF  03,78
0560:  MOVFF  02,77
0564:  MOVFF  01,76
0568:  MOVFF  00,75
056C:  MOVF   x6C,W
056E:  SUBWF  x75,F
0570:  MOVF   x6D,W
0572:  SUBWFB x76,F
0574:  MOVF   x6E,W
0576:  SUBWFB x77,F
0578:  MOVF   x6F,W
057A:  SUBWFB x78,F
057C:  BNZ   058C
057E:  MOVF   x77,F
0580:  BNZ   058C
0582:  MOVF   x76,F
0584:  BNZ   058C
0586:  MOVF   x70,W
0588:  SUBWF  x75,W
058A:  BNC   0544
....................    printf("sincronizado2");
058C:  MOVLW  36
058E:  MOVWF  FF6
0590:  MOVLW  01
0592:  MOVWF  FF7
0594:  RCALL  01CE
....................   
....................   for (int i = 0; CONFIG[i][0] != 255; i++)
0596:  CLRF   x74
0598:  BCF    FD8.0
059A:  RLCF   x74,W
059C:  MOVWF  x75
059E:  CLRF   03
05A0:  MOVF   x75,W
05A2:  RCALL  00AE
05A4:  SUBLW  FF
05A6:  BZ    05DC
....................     writeReg(CONFIG[i][0], CONFIG[i][1]);
05A8:  BCF    FD8.0
05AA:  RLCF   x74,W
05AC:  MOVWF  x75
05AE:  CLRF   03
05B0:  MOVF   x75,W
05B2:  RCALL  00AE
05B4:  MOVWF  x77
05B6:  BCF    FD8.0
05B8:  RLCF   x74,W
05BA:  CLRF   x79
05BC:  MOVWF  x78
05BE:  MOVLW  01
05C0:  ADDWF  x78,W
05C2:  MOVWF  01
05C4:  MOVLW  00
05C6:  ADDWFC x79,W
05C8:  MOVWF  03
05CA:  MOVF   01,W
05CC:  RCALL  00AE
05CE:  MOVWF  x78
05D0:  MOVFF  77,83
05D4:  MOVWF  x84
05D6:  RCALL  02DE
05D8:  INCF   x74,F
05DA:  BRA    0598
.................... 
....................    
....................   // Encryption is persistent between resets and can trip you up during debugging.
....................   // Disable it during initialization so we always start from a known state.
....................   
....................   setHighPower(_isRFM69HW); // called regardless if it's a RFM69W or RFM69HW
05DC:  MOVLW  00
05DE:  BTFSC  2A.0
05E0:  MOVLW  01
05E2:  MOVWF  x75
05E4:  MOVWF  x76
05E6:  RCALL  02F4
....................   setMode(RF69_MODE_STANDBY);
05E8:  MOVLW  01
05EA:  MOVWF  x80
05EC:  RCALL  037A
....................   start = millis();
05EE:  RCALL  0230
05F0:  MOVFF  03,6F
05F4:  MOVFF  02,6E
05F8:  MOVFF  01,6D
05FC:  MOVFF  00,6C
....................   while (((readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00) && millis()-start < timeout); // wait for ModeReady
0600:  MOVLW  27
0602:  MOVWF  x81
0604:  RCALL  02C4
0606:  MOVF   01,W
0608:  ANDLW  80
060A:  BNZ   063E
060C:  RCALL  0230
060E:  MOVFF  03,78
0612:  MOVFF  02,77
0616:  MOVFF  01,76
061A:  MOVFF  00,75
061E:  MOVF   x6C,W
0620:  SUBWF  x75,F
0622:  MOVF   x6D,W
0624:  SUBWFB x76,F
0626:  MOVF   x6E,W
0628:  SUBWFB x77,F
062A:  MOVF   x6F,W
062C:  SUBWFB x78,F
062E:  BNZ   063E
0630:  MOVF   x77,F
0632:  BNZ   063E
0634:  MOVF   x76,F
0636:  BNZ   063E
0638:  MOVF   x70,W
063A:  SUBWF  x75,W
063C:  BNC   0600
....................   if (millis()-start >= timeout){
063E:  RCALL  0230
0640:  MOVFF  03,78
0644:  MOVFF  02,77
0648:  MOVFF  01,76
064C:  MOVFF  00,75
0650:  MOVF   x6C,W
0652:  SUBWF  x75,F
0654:  MOVF   x6D,W
0656:  SUBWFB x76,F
0658:  MOVF   x6E,W
065A:  SUBWFB x77,F
065C:  MOVF   x6F,W
065E:  SUBWFB x78,F
0660:  BNZ   0670
0662:  MOVF   x77,F
0664:  BNZ   0670
0666:  MOVF   x76,F
0668:  BNZ   0670
066A:  MOVF   x70,W
066C:  SUBWF  x75,W
066E:  BNC   0680
....................       printf("timeout");
0670:  MOVLW  44
0672:  MOVWF  FF6
0674:  MOVLW  01
0676:  MOVWF  FF7
0678:  RCALL  01CE
....................     return false;
067A:  MOVLW  00
067C:  MOVWF  01
067E:  BRA    0692
....................     
....................     }
....................   
....................   //_inISR = false;
....................     //ext_int_edge(L_TO_H);
....................    //Enable_interrupts(INT_EXT);
.................... 
....................  printf("configurado");
0680:  MOVLW  4C
0682:  MOVWF  FF6
0684:  MOVLW  01
0686:  MOVWF  FF7
0688:  RCALL  01CE
....................   _address = nodeID;
068A:  MOVFF  6B,29
....................   return true;
068E:  MOVLW  01
0690:  MOVWF  01
0692:  GOTO   0A68 (RETURN)
.................... }
.................... 
.................... 
.................... void setMode(int newMode)
.................... {
....................   
....................    if (newMode == _mode)
*
037A:  MOVF   28,W
037C:  SUBWF  x80,W
037E:  BNZ   0382
....................     return;
0380:  BRA    044C
.................... 
....................   switch (newMode) {
0382:  MOVF   x80,W
0384:  XORLW  04
0386:  BZ    039A
0388:  XORLW  07
038A:  BZ    03BE
038C:  XORLW  01
038E:  BZ    03E0
0390:  XORLW  03
0392:  BZ    03FA
0394:  XORLW  01
0396:  BZ    0414
0398:  BRA    042C
....................     case RF69_MODE_TX:
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_TRANSMITTER);
039A:  MOVLW  01
039C:  MOVWF  x81
039E:  RCALL  02C4
03A0:  MOVF   01,W
03A2:  ANDLW  E3
03A4:  IORLW  0C
03A6:  MOVWF  x81
03A8:  MOVLW  01
03AA:  MOVWF  x83
03AC:  MOVFF  81,84
03B0:  RCALL  02DE
....................       if (_isRFM69HW) setHighPowerRegs(true);
03B2:  BTFSS  2A.0
03B4:  BRA    03BC
03B6:  MOVLW  01
03B8:  MOVWF  x81
03BA:  RCALL  034C
....................       break;
03BC:  BRA    042E
....................     case RF69_MODE_RX:
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_RECEIVER);
03BE:  MOVLW  01
03C0:  MOVWF  x81
03C2:  RCALL  02C4
03C4:  MOVF   01,W
03C6:  ANDLW  E3
03C8:  IORLW  10
03CA:  MOVWF  x81
03CC:  MOVLW  01
03CE:  MOVWF  x83
03D0:  MOVFF  81,84
03D4:  RCALL  02DE
....................       if (_isRFM69HW) setHighPowerRegs(false);
03D6:  BTFSS  2A.0
03D8:  BRA    03DE
03DA:  CLRF   x81
03DC:  RCALL  034C
....................       break;
03DE:  BRA    042E
....................     case RF69_MODE_SYNTH:
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_SYNTHESIZER);
03E0:  MOVLW  01
03E2:  MOVWF  x81
03E4:  RCALL  02C4
03E6:  MOVF   01,W
03E8:  ANDLW  E3
03EA:  IORLW  08
03EC:  MOVWF  x81
03EE:  MOVLW  01
03F0:  MOVWF  x83
03F2:  MOVFF  81,84
03F6:  RCALL  02DE
....................       break;
03F8:  BRA    042E
....................     case RF69_MODE_STANDBY:
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_STANDBY);
03FA:  MOVLW  01
03FC:  MOVWF  x81
03FE:  RCALL  02C4
0400:  MOVF   01,W
0402:  ANDLW  E3
0404:  IORLW  04
0406:  MOVWF  x81
0408:  MOVLW  01
040A:  MOVWF  x83
040C:  MOVFF  81,84
0410:  RCALL  02DE
....................       break;
0412:  BRA    042E
....................     case RF69_MODE_SLEEP:
....................       writeReg(REG_OPMODE, (readReg(REG_OPMODE) & 0xE3) | RF_OPMODE_SLEEP);
0414:  MOVLW  01
0416:  MOVWF  x81
0418:  RCALL  02C4
041A:  MOVF   01,W
041C:  ANDLW  E3
041E:  MOVWF  x81
0420:  MOVLW  01
0422:  MOVWF  x83
0424:  MOVFF  81,84
0428:  RCALL  02DE
....................       break;
042A:  BRA    042E
....................     default:
....................       return;
042C:  BRA    044C
....................   }
.................... 
....................   // we are using packet mode, so this check is not really needed
....................   // but waiting for mode ready is necessary when going from sleep because the FIFO may not be immediately available from previous mode
....................   
....................   while (_mode == RF69_MODE_SLEEP && (readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // wait for ModeReady
042E:  MOVF   28,F
0430:  BNZ   043E
0432:  MOVLW  27
0434:  MOVWF  x81
0436:  RCALL  02C4
0438:  MOVF   01,W
043A:  ANDLW  80
043C:  BZ    042E
.................... 
....................   _mode = newMode;
043E:  MOVFF  80,28
....................   printf("mode set\n");
0442:  MOVLW  58
0444:  MOVWF  FF6
0446:  MOVLW  01
0448:  MOVWF  FF7
044A:  RCALL  01CE
044C:  RETURN 0
.................... }
.................... 
.................... short canSend()
.................... {
.................... if ((_mode == RF69_MODE_RX) && (PAYLOADLEN == 0) && (readRSSI(1) < CSMA_LIMIT)) // if signal stronger than -100dBm is detected assume channel activity
*
07F2:  MOVF   28,W
07F4:  SUBLW  03
07F6:  BNZ   0820
07F8:  MOVF   25,F
07FA:  BNZ   0820
07FC:  MOVLW  01
07FE:  MOVWF  x74
0800:  BRA    07B2
0802:  MOVFF  02,75
0806:  MOVFF  01,74
080A:  MOVF   x75,F
080C:  BNZ   0820
080E:  MOVF   24,W
0810:  SUBWF  x74,W
0812:  BC    0820
....................   {
....................     setMode(RF69_MODE_STANDBY);
0814:  MOVLW  01
0816:  MOVWF  x80
0818:  RCALL  037A
....................     return true;
081A:  MOVLW  01
081C:  MOVWF  01
081E:  BRA    0824
....................   }
....................   return false;
0820:  MOVLW  00
0822:  MOVWF  01
0824:  GOTO   0938 (RETURN)
.................... }
.................... 
.................... void send(int toAddress, byte * buffer, int bufferSize, short requestACK)
.................... {
....................   writeReg(REG_PACKETCONFIG2, (readReg(REG_PACKETCONFIG2) & 0xFB) | RF_PACKET2_RXRESTART); // avoid RX deadlocks
*
090C:  MOVLW  3D
090E:  MOVWF  x81
0910:  RCALL  02C4
0912:  MOVF   01,W
0914:  ANDLW  FB
0916:  IORLW  04
0918:  MOVWF  x74
091A:  MOVLW  3D
091C:  MOVWF  x83
091E:  MOVFF  74,84
0922:  RCALL  02DE
....................   int32 now = millis();
0924:  RCALL  0230
0926:  MOVFF  03,73
092A:  MOVFF  02,72
092E:  MOVFF  01,71
0932:  MOVFF  00,70
....................   while (!canSend() && millis() - now < RF69_CSMA_LIMIT_MS);
0936:  BRA    07F2
0938:  MOVF   01,F
093A:  BNZ   0972
093C:  RCALL  0230
093E:  MOVFF  03,77
0942:  MOVFF  02,76
0946:  MOVFF  01,75
094A:  MOVFF  00,74
094E:  MOVF   x70,W
0950:  SUBWF  x74,F
0952:  MOVF   x71,W
0954:  SUBWFB x75,F
0956:  MOVF   x72,W
0958:  SUBWFB x76,F
095A:  MOVF   x73,W
095C:  SUBWFB x77,F
095E:  BNZ   0972
0960:  MOVF   x76,F
0962:  BNZ   0972
0964:  MOVF   x75,W
0966:  SUBLW  03
0968:  BNC   0972
096A:  BNZ   0936
096C:  MOVF   x74,W
096E:  SUBLW  E7
0970:  BC    0936
....................   sendFrame(toAddress, buffer, bufferSize, requestACK, false);
0972:  MOVFF  6B,74
0976:  MOVFF  6D,76
097A:  MOVFF  6C,75
097E:  MOVFF  6E,77
0982:  MOVFF  6F,78
0986:  CLRF   x79
0988:  BRA    0828
098A:  GOTO   0AA6 (RETURN)
.................... }
.................... 
.................... // to increase the chance of getting a packet across, call this function instead of send
.................... // and it handles all the ACK requesting/retrying for you :)
.................... // The only twist is that you have to manually listen to ACK requests on the other side and send back the ACKs
.................... // The reason for the semi-automaton is that the lib is interrupt driven and
.................... // requires user action to read the received data and decide what to do with it
.................... // replies usually take only 5..8ms at 50kbps@915MHz
.................... short sendWithRetry(int toAddress, byte *buffer, int bufferSize, int retries, int retryWaitTime) {
....................   int32 sentTime;
....................   for (int i = 0; i <= retries; i++)
....................   {
....................     send(toAddress, buffer, bufferSize, true);
....................     sentTime = millis();
....................     while (millis() - sentTime < retryWaitTime);
....................    
....................   }
....................   return false;
.................... }
.................... 
.................... 
.................... // internal function
.................... void sendFrame(int toAddress, byte *buffer, int bufferSize, short requestACK, short sendACK)
.................... {
....................   setMode(RF69_MODE_STANDBY); // turn off receiver to prevent reception while filling fifo
*
0828:  MOVLW  01
082A:  MOVWF  x80
082C:  RCALL  037A
....................   while ((readReg(REG_IRQFLAGS1) & RF_IRQFLAGS1_MODEREADY) == 0x00); // wait for ModeReady
082E:  MOVLW  27
0830:  MOVWF  x81
0832:  RCALL  02C4
0834:  MOVF   01,W
0836:  ANDLW  80
0838:  BZ    082E
....................   writeReg(REG_DIOMAPPING1, RF_DIOMAPPING1_DIO0_00); // DIO0 is "Packet Sent"
083A:  MOVLW  25
083C:  MOVWF  x83
083E:  CLRF   x84
0840:  RCALL  02DE
....................   if (bufferSize > RF69_MAX_DATA_LEN) bufferSize = RF69_MAX_DATA_LEN;
0842:  MOVF   x77,W
0844:  SUBLW  3D
0846:  BC    084C
0848:  MOVLW  3D
084A:  MOVWF  x77
.................... 
....................   // control byte
....................   byte CTLbyte = 0x00;
084C:  CLRF   x7A
....................   if (sendACK)
084E:  MOVF   x79,F
0850:  BZ    0858
....................     CTLbyte = RFM69_CTL_SENDACK;
0852:  MOVLW  80
0854:  MOVWF  x7A
0856:  BRA    0860
....................   else if (requestACK)
0858:  MOVF   x78,F
085A:  BZ    0860
....................     CTLbyte = RFM69_CTL_REQACK;
085C:  MOVLW  40
085E:  MOVWF  x7A
.................... 
....................   // write to FIFO
....................   select();
0860:  RCALL  0234
....................   SPItransfer(REG_FIFO | 0x80);
0862:  MOVLW  80
0864:  MOVWF  x86
0866:  RCALL  023A
....................   SPItransfer(bufferSize + 3);
0868:  MOVLW  03
086A:  ADDWF  x77,W
086C:  MOVWF  x80
086E:  MOVWF  x86
0870:  RCALL  023A
....................   SPItransfer(toAddress);
0872:  MOVFF  74,86
0876:  RCALL  023A
....................   SPItransfer(_address);
0878:  MOVFF  29,86
087C:  RCALL  023A
....................   SPItransfer(CTLbyte);
087E:  MOVFF  7A,86
0882:  RCALL  023A
.................... 
....................   for (int i = 0; i < bufferSize; i++)
0884:  CLRF   x7B
0886:  MOVF   x77,W
0888:  SUBWF  x7B,W
088A:  BC    08A2
....................     SPItransfer(((byte *) buffer)[i]);
088C:  MOVF   x7B,W
088E:  ADDWF  x75,W
0890:  MOVWF  FE9
0892:  MOVLW  00
0894:  ADDWFC x76,W
0896:  MOVWF  FEA
0898:  MOVFF  FEF,86
089C:  RCALL  023A
089E:  INCF   x7B,F
08A0:  BRA    0886
....................   unselect();
08A2:  RCALL  02BE
.................... 
....................   // no need to wait for transmit mode to be ready since its handled by the radio
....................   setMode(RF69_MODE_TX);
08A4:  MOVLW  04
08A6:  MOVWF  x80
08A8:  RCALL  037A
....................   int32 txStart = millis();
08AA:  RCALL  0230
08AC:  MOVFF  03,7F
08B0:  MOVFF  02,7E
08B4:  MOVFF  01,7D
08B8:  MOVFF  00,7C
....................   while ( input(_interruptPin) == 0 && millis() - txStart < RF69_TX_LIMIT_MS); // wait for DIO0 to turn HIGH signalling transmission finish
08BC:  BSF    F93.0
08BE:  BTFSC  F81.0
08C0:  BRA    08F8
08C2:  RCALL  0230
08C4:  MOVFF  03,84
08C8:  MOVFF  02,83
08CC:  MOVFF  01,82
08D0:  MOVFF  00,81
08D4:  MOVF   x7C,W
08D6:  SUBWF  x81,F
08D8:  MOVF   x7D,W
08DA:  SUBWFB x82,F
08DC:  MOVF   x7E,W
08DE:  SUBWFB x83,F
08E0:  MOVF   x7F,W
08E2:  SUBWFB x84,F
08E4:  BNZ   08F8
08E6:  MOVF   x83,F
08E8:  BNZ   08F8
08EA:  MOVF   x82,W
08EC:  SUBLW  03
08EE:  BNC   08F8
08F0:  BNZ   08BC
08F2:  MOVF   x81,W
08F4:  SUBLW  E7
08F6:  BC    08BC
....................   while (readReg(REG_IRQFLAGS2) & (RF_IRQFLAGS2_PACKETSENT == 0x00)); // wait for ModeReady
08F8:  MOVLW  28
08FA:  MOVWF  x81
08FC:  RCALL  02C4
08FE:  ANDLW  00
0900:  BNZ   08F8
....................   setMode(RF69_MODE_STANDBY);
0902:  MOVLW  01
0904:  MOVWF  x80
0906:  RCALL  037A
0908:  GOTO   098A (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... 
.................... int32 millis()
.................... {
....................    return get_ticks();
*
0230:  BRA    01F0
0232:  RETURN 0
.................... }
.................... 
.................... int readReg(int addr)
.................... {
....................   select();
*
02C4:  RCALL  0234
....................   SPItransfer(addr & 0x7F);
02C6:  MOVF   x81,W
02C8:  ANDLW  7F
02CA:  MOVWF  x83
02CC:  MOVWF  x86
02CE:  RCALL  023A
....................   int regval = SPIRead8bit();
02D0:  RCALL  0284
02D2:  MOVFF  01,82
....................   unselect();
02D6:  RCALL  02BE
....................   return regval;
02D8:  MOVFF  82,01
02DC:  RETURN 0
.................... }
.................... 
.................... void writeReg(int addr, int value)
.................... {
....................   select();
02DE:  RCALL  0234
....................   SPItransfer(addr | 0x80);
02E0:  MOVF   x83,W
02E2:  IORLW  80
02E4:  MOVWF  x85
02E6:  MOVWF  x86
02E8:  RCALL  023A
....................   SPItransfer(value);
02EA:  MOVFF  84,86
02EE:  RCALL  023A
....................   unselect();
02F0:  RCALL  02BE
02F2:  RETURN 0
.................... }
.................... 
.................... void select() {
....................   output_low(_slaveSelectPin);
*
0234:  BCF    F95.7
0236:  BCF    F8C.7
0238:  RETURN 0
.................... }
.................... 
.................... // unselect the RFM69 transceiver (set CS high, restore SPI settings)
.................... void unselect() {
....................   output_high(_slaveSelectPin);
*
02BE:  BCF    F95.7
02C0:  BSF    F8C.7
02C2:  RETURN 0
.................... }
.................... 
.................... 
.................... // for RFM69HW only: you must call setHighPower(true) after initialize() or else transmission won't work
.................... void setHighPower(short onOff) {
....................   _isRFM69HW = onOff;
*
02F4:  BCF    2A.0
02F6:  BTFSC  x76.0
02F8:  BSF    2A.0
....................   writeReg(REG_OCP, _isRFM69HW ? RF_OCP_OFF : RF_OCP_ON);
02FA:  BTFSS  2A.0
02FC:  BRA    0302
02FE:  MOVLW  0F
0300:  BRA    0304
0302:  MOVLW  1A
0304:  MOVWF  x77
0306:  MOVLW  13
0308:  MOVWF  x83
030A:  MOVFF  77,84
030E:  RCALL  02DE
....................   if (_isRFM69HW) // turning ON
0310:  BTFSS  2A.0
0312:  BRA    0330
....................     writeReg(REG_PALEVEL, (readReg(REG_PALEVEL) & 0x1F) | RF_PALEVEL_PA1_ON | RF_PALEVEL_PA2_ON); // enable P1 & P2 amplifier stages
0314:  MOVLW  11
0316:  MOVWF  x81
0318:  RCALL  02C4
031A:  MOVF   01,W
031C:  ANDLW  1F
031E:  IORLW  40
0320:  IORLW  20
0322:  MOVWF  x77
0324:  MOVLW  11
0326:  MOVWF  x83
0328:  MOVFF  77,84
032C:  RCALL  02DE
032E:  BRA    0340
....................   else
....................     writeReg(REG_PALEVEL, RF_PALEVEL_PA0_ON | RF_PALEVEL_PA1_OFF | RF_PALEVEL_PA2_OFF | _powerLevel); // enable P0 only
0330:  MOVF   2B,W
0332:  IORLW  80
0334:  MOVWF  x77
0336:  MOVLW  11
0338:  MOVWF  x83
033A:  MOVFF  77,84
033E:  RCALL  02DE
....................    printf("HighPower");
0340:  MOVLW  62
0342:  MOVWF  FF6
0344:  MOVLW  01
0346:  MOVWF  FF7
0348:  RCALL  01CE
034A:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... void readAllRegs()
.................... {
....................   int regVal;
....................  
....................   //... State Variables for intelligent decoding
....................   
....................   printf("Address - HEX - BIN \n");
*
06D8:  MOVLW  6C
06DA:  MOVWF  FF6
06DC:  MOVLW  01
06DE:  MOVWF  FF7
06E0:  RCALL  01CE
....................   for (int regAddr = 1; regAddr <= 0x4F; regAddr++)
06E2:  MOVLW  01
06E4:  MOVWF  x6C
06E6:  MOVF   x6C,W
06E8:  SUBLW  4F
06EA:  BNC   076E
....................   {
....................     select();
06EC:  RCALL  0234
....................     SPItransfer(regAddr & 0x7F); // send address + r/w bit
06EE:  MOVF   x6C,W
06F0:  ANDLW  7F
06F2:  MOVWF  x6E
06F4:  MOVWF  x86
06F6:  RCALL  023A
....................     regVal = SPIRead8bit();
06F8:  RCALL  0284
06FA:  MOVFF  01,6B
....................     unselect();
06FE:  RCALL  02BE
.................... 
....................     printf("%X", regAddr);
0700:  MOVFF  6C,6E
0704:  MOVLW  37
0706:  MOVWF  x6F
0708:  RCALL  0696
....................     printf(" - ");
070A:  MOVLW  82
070C:  MOVWF  FF6
070E:  MOVLW  01
0710:  MOVWF  FF7
0712:  RCALL  01CE
....................     printf("%X", regVal);
0714:  MOVFF  6B,6E
0718:  MOVLW  37
071A:  MOVWF  x6F
071C:  RCALL  0696
....................     printf(" - ");
071E:  MOVLW  86
0720:  MOVWF  FF6
0722:  MOVLW  01
0724:  MOVWF  FF7
0726:  RCALL  01CE
....................     for (byte i = 8; i!=0 ; i--)
0728:  MOVLW  08
072A:  MOVWF  x6D
072C:  MOVF   x6D,F
072E:  BZ    0762
....................       {
....................       if(bit_test(regVal, (i-1))) 
0730:  MOVLW  01
0732:  SUBWF  x6D,W
0734:  MOVWF  x6E
0736:  MOVFF  6B,00
073A:  MOVF   x6E,W
073C:  MOVWF  01
073E:  BZ    0748
0740:  BCF    FD8.0
0742:  RRCF   00,F
0744:  DECFSZ 01,F
0746:  BRA    0740
0748:  BTFSS  00.0
074A:  BRA    0756
....................          printf("1"); 
074C:  MOVLW  31
074E:  BTFSS  F9E.4
0750:  BRA    074E
0752:  MOVWF  FAD
0754:  BRA    075E
....................       else 
....................          printf("0"); 
0756:  MOVLW  30
0758:  BTFSS  F9E.4
075A:  BRA    0758
075C:  MOVWF  FAD
075E:  DECF   x6D,F
0760:  BRA    072C
....................       }
....................      printf("\n");
0762:  MOVLW  0A
0764:  BTFSS  F9E.4
0766:  BRA    0764
0768:  MOVWF  FAD
076A:  INCF   x6C,F
076C:  BRA    06E6
....................     }
....................  
....................   unselect();
076E:  RCALL  02BE
0770:  RETURN 0
.................... }
.................... 
.................... byte SPItransfer(byte WrPara)
*
023A:  CLRF   x87
.................... {
.................... byte Data_In = 0;
.................... byte bitcnt;   
.................... 
.................... Output_Low(SCK);
023C:  BCF    F95.6
023E:  BCF    F8C.6
....................  for(bitcnt=8; bitcnt!=0; bitcnt--)
0240:  MOVLW  08
0242:  MOVWF  x88
0244:  MOVF   x88,F
0246:  BZ    0276
....................     {
....................     delay_ms(10);
0248:  MOVLW  0A
024A:  MOVWF  x89
024C:  RCALL  01A6
....................     Output_Low(SCK);
024E:  BCF    F95.6
0250:  BCF    F8C.6
....................     if(WrPara&0x80)
0252:  BTFSS  x86.7
0254:  BRA    025C
....................        Output_High(SerOut);   // RFM69 SDI 
0256:  BCF    F95.5
0258:  BSF    F8C.5
025A:  BRA    0260
....................     else
....................        Output_Low(SerOut);   
025C:  BCF    F95.5
025E:  BCF    F8C.5
....................     Output_High(SCK);
0260:  BCF    F95.6
0262:  BSF    F8C.6
....................     if (Input(SerIn))
0264:  BSF    F95.4
0266:  BTFSS  F83.4
0268:  BRA    026C
....................       Data_In |= 1;
026A:  BSF    x87.0
....................     WrPara <<= 1;
026C:  BCF    FD8.0
026E:  RLCF   x86,F
....................     delay_cycles(1);
0270:  NOP   
0272:  DECF   x88,F
0274:  BRA    0244
....................     }
.................... Output_Low(SCK);
0276:  BCF    F95.6
0278:  BCF    F8C.6
.................... Output_High(SerOut);
027A:  BCF    F95.5
027C:  BSF    F8C.5
.................... return(Data_In);
027E:  MOVFF  87,01
0282:  RETURN 0
.................... }
.................... 
.................... 
.................... byte SPIRead8bit(void)
0284:  CLRF   x83
.................... {
.................... byte RdPara = 0;
.................... byte bitcnt;
.................... Output_High(SerOut);   // RFM69 SDI                                                                          //Read one byte data from FIFO, MOSI hold to High 
0286:  BCF    F95.5
0288:  BSF    F8C.5
....................  for(bitcnt=8; bitcnt!=0; bitcnt--)
028A:  MOVLW  08
028C:  MOVWF  x84
028E:  MOVF   x84,F
0290:  BZ    02B4
....................     {
....................     delay_ms(10);
0292:  MOVLW  0A
0294:  MOVWF  x89
0296:  RCALL  01A6
....................     Output_Low(SCK);
0298:  BCF    F95.6
029A:  BCF    F8C.6
....................     RdPara <<= 1;
029C:  BCF    FD8.0
029E:  RLCF   x83,F
....................     Output_High(SCK);
02A0:  BCF    F95.6
02A2:  BSF    F8C.6
....................     if(Input(SerIn))
02A4:  BSF    F95.4
02A6:  BTFSS  F83.4
02A8:  BRA    02AE
....................        RdPara |= 0x01;
02AA:  BSF    x83.0
02AC:  BRA    02B0
....................     else
....................        delay_cycles(1); 
02AE:  NOP   
02B0:  DECF   x84,F
02B2:  BRA    028E
....................     }
....................  Output_Low(SCK);   
02B4:  BCF    F95.6
02B6:  BCF    F8C.6
....................  return(RdPara);
02B8:  MOVFF  83,01
02BC:  RETURN 0
.................... }
.................... 
.................... int16 readRSSI(short forceTrigger)
*
07B2:  CLRF   x76
07B4:  CLRF   x75
.................... {
....................   int16 rssi = 0;
....................   if (forceTrigger)
07B6:  MOVF   x74,F
07B8:  BZ    07D0
....................   {
....................     // RSSI trigger not needed if DAGC is in continuous mode
....................     writeReg(REG_RSSICONFIG, RF_RSSI_START);
07BA:  MOVLW  23
07BC:  MOVWF  x83
07BE:  MOVLW  01
07C0:  MOVWF  x84
07C2:  RCALL  02DE
....................     while ((readReg(REG_RSSICONFIG) & RF_RSSI_DONE) == 0x00); // wait for RSSI_Ready
07C4:  MOVLW  23
07C6:  MOVWF  x81
07C8:  RCALL  02C4
07CA:  MOVF   01,W
07CC:  ANDLW  02
07CE:  BZ    07C4
....................   }
....................   rssi = -readReg(REG_RSSIVALUE);
07D0:  MOVLW  24
07D2:  MOVWF  x81
07D4:  RCALL  02C4
07D6:  COMF   01,W
07D8:  MOVWF  x75
07DA:  INCF   x75,F
07DC:  BTFSC  FD8.2
07DE:  INCF   x76,F
....................   rssi >>= 1;
07E0:  BCF    FD8.0
07E2:  RRCF   x76,F
07E4:  RRCF   x75,F
....................   return rssi;
07E6:  MOVFF  75,01
07EA:  MOVFF  76,02
07EE:  GOTO   0802 (RETURN)
.................... }
.................... 
.................... // internal function
.................... void setHighPowerRegs(short onOff) {
....................   writeReg(REG_TESTPA1, onOff ? 0x5D : 0x55);
*
034C:  MOVF   x81,F
034E:  BZ    0354
0350:  MOVLW  5D
0352:  BRA    0356
0354:  MOVLW  55
0356:  MOVWF  x82
0358:  MOVLW  5A
035A:  MOVWF  x83
035C:  MOVFF  82,84
0360:  RCALL  02DE
....................   writeReg(REG_TESTPA2, onOff ? 0x7C : 0x70);
0362:  MOVF   x81,F
0364:  BZ    036A
0366:  MOVLW  7C
0368:  BRA    036C
036A:  MOVLW  70
036C:  MOVWF  x82
036E:  MOVLW  5C
0370:  MOVWF  x83
0372:  MOVFF  82,84
0376:  RCALL  02DE
0378:  RETURN 0
.................... }
.................... 
.................... // ----------------------------------------
.................... 
.................... byte TX_DATA[61];
.................... 
.................... void main(void)
*
09B6:  CLRF   FF8
09B8:  BCF    FD0.7
09BA:  BSF    07.7
09BC:  MOVLW  FE
09BE:  MOVWF  00
09C0:  MOVLW  08
09C2:  MOVWF  01
09C4:  MOVLW  02
09C6:  MOVWF  FE9
09C8:  MOVLW  00
09CA:  MOVWF  FEA
09CC:  CLRF   FEE
09CE:  DECFSZ 00,F
09D0:  BRA    09CC
09D2:  DECFSZ 01,F
09D4:  BRA    09CC
09D6:  CLRF   1F
09D8:  BSF    FB8.3
09DA:  MOVLW  A0
09DC:  MOVWF  FAF
09DE:  MOVLW  01
09E0:  MOVWF  FB0
09E2:  MOVLW  A6
09E4:  MOVWF  FAC
09E6:  MOVLW  90
09E8:  MOVWF  FAB
09EA:  CLRF   23
09EC:  CLRF   22
09EE:  CLRF   21
09F0:  CLRF   20
09F2:  BCF    FCD.0
09F4:  MOVLW  B5
09F6:  MOVWF  FCD
09F8:  CLRF   FCF
09FA:  CLRF   FCE
09FC:  NOP   
09FE:  BCF    F9E.0
0A00:  BSF    F9D.0
0A02:  MOVLW  A6
0A04:  MOVWF  24
0A06:  BSF    2A.0
0A08:  MOVLW  1F
0A0A:  MOVWF  2B
0A0C:  CLRF   2D
0A0E:  CLRF   2C
0A10:  MOVF   FC1,W
0A12:  ANDLW  C0
0A14:  IORLW  0F
0A16:  MOVWF  FC1
0A18:  MOVLW  07
0A1A:  MOVWF  FB4
0A1C:  CLRF   19
0A1E:  CLRF   1A
0A20:  CLRF   25
0A22:  CLRF   26
0A24:  CLRF   27
0A26:  CLRF   28
0A28:  CLRF   29
.................... { 
.................... #zero_ram
.................... 
.................... set_tris_C(0b00010001);     // ser in 0
0A2A:  MOVLW  11
0A2C:  MOVWF  F94
.................... set_tris_D(0b00010000);
0A2E:  MOVLW  10
0A30:  MOVWF  F95
.................... 
.................... output_low(Pin_B7);
0A32:  BCF    F93.7
0A34:  BCF    F8A.7
.................... delay_ms(500);
0A36:  MOVLW  02
0A38:  MOVWF  x6B
0A3A:  MOVLW  FA
0A3C:  MOVWF  x89
0A3E:  CALL   01A6
0A42:  DECFSZ x6B,F
0A44:  BRA    0A3A
.................... output_high(Pin_B7);
0A46:  BCF    F93.7
0A48:  BSF    F8A.7
.................... 
.................... Output_High(_slaveSelectPin);
0A4A:  BCF    F95.7
0A4C:  BSF    F8C.7
.................... Output_Low(SCK);
0A4E:  BCF    F95.6
0A50:  BCF    F8C.6
.................... delay_ms(500);
0A52:  MOVLW  02
0A54:  MOVWF  x6B
0A56:  MOVLW  FA
0A58:  MOVWF  x89
0A5A:  CALL   01A6
0A5E:  DECFSZ x6B,F
0A60:  BRA    0A56
.................... //LCD_init();
.................... 
.................... 
.................... initialize(2);
0A62:  MOVLW  02
0A64:  MOVWF  x6B
0A66:  BRA    044E
.................... 
.................... delay_ms(500);
0A68:  MOVLW  02
0A6A:  MOVWF  x6B
0A6C:  MOVLW  FA
0A6E:  MOVWF  x89
0A70:  CALL   01A6
0A74:  DECFSZ x6B,F
0A76:  BRA    0A6C
.................... 
.................... setHighPower(1);
0A78:  MOVLW  01
0A7A:  MOVWF  x76
0A7C:  RCALL  02F4
.................... 
.................... //putc("Antes que nada buenos dias");
.................... 
.................... readAllRegs();
0A7E:  RCALL  06D8
.................... 
.................... 
.................... 
.................... // --------------------------------------------------------------
.................... while(true)
....................    {
....................       readAllRegs();
0A80:  RCALL  06D8
....................       continue;
0A82:  BRA    0A80
....................       
....................       sprintf(TX_DATA, "%s", "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
0A84:  CLRF   2D
0A86:  MOVLW  2E
0A88:  MOVWF  2C
0A8A:  MOVLW  8A
0A8C:  MOVWF  FF6
0A8E:  MOVLW  01
0A90:  MOVWF  FF7
0A92:  BRA    0790
....................       send(0x01, TX_DATA, 63, 0);
0A94:  MOVLW  01
0A96:  MOVWF  x6B
0A98:  CLRF   x6D
0A9A:  MOVLW  2E
0A9C:  MOVWF  x6C
0A9E:  MOVLW  3F
0AA0:  MOVWF  x6E
0AA2:  CLRF   x6F
0AA4:  BRA    090C
....................       printf("%s", TX_DATA);
0AA6:  CLRF   FEA
0AA8:  MOVLW  2E
0AAA:  MOVWF  FE9
0AAC:  BRA    098E
....................       
....................       delay_ms(100);
0AAE:  MOVLW  64
0AB0:  MOVWF  x89
0AB2:  CALL   01A6
0AB6:  BRA    0A80
....................    }
....................    // End While Loop
.................... }         // End Main 
.................... 
0AB8:  SLEEP 
.................... 
.................... /*****************************************************************************/
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 

Configuration Fuses:
   Word  1: CC03   PLL4 CPUDIV1 NOUSBDIV HS FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
