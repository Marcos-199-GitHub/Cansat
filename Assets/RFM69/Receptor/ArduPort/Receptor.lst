CCS PCH C Compiler, Version 5.112, 29001               11-ago.-23 12:07

               Filename:   I:\CanSat\Cansat\Assets\RFM69\Receptor\ArduPort\Receptor.lst

               ROM used:   17760 bytes (54%)
                           Largest free fragment is 15008
               RAM used:   735 (36%) at main() level
                           973 (48%) worst case
               Stack used: 24 locations (13 in main + 11 for interrupts)
               Stack size: 31

*
0000:  GOTO   3EC6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF0.4
0056:  GOTO   0060
005A:  BTFSC  FF0.1
005C:  GOTO   1834
0060:  BTFSS  FA0.5
0062:  GOTO   006C
0066:  BTFSC  FA1.5
0068:  GOTO   142C
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #define HEX 16
.................... #define BIN 2
.................... #define DEC 10
.................... #define UDEC 11
.................... #define SSPin PIN_A5
.................... #define TIMER_START 114
.................... #define TIMER_STEP_MS 3
.................... #define FREQ_433
.................... 
.................... #include <Receptor.h>
.................... #include <18LF4550.h>
.................... //////////// Standard Header file for the PIC18LF4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18LF4550
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 00,03
00CC:  DATA 02,FF
00CE:  DATA FF,FF
00D0:  DATA FF,FF
00D2:  DATA FF,FF
00D4:  DATA FF,FF
00D6:  DATA FF,FF
00D8:  DATA FF,FF
00DA:  CLRF   FF7
00DC:  ADDLW  EA
00DE:  MOVWF  FF6
00E0:  MOVLW  00
00E2:  ADDWFC FF7,F
00E4:  TBLRD*+
00E6:  MOVF   FF5,W
00E8:  RETURN 0
00EA:  DATA 00,FF
00EC:  DATA 02,FF
00EE:  DATA FF,FF
00F0:  DATA FF,FF
00F2:  DATA FF,FF
00F4:  DATA FF,FF
00F6:  DATA FF,FF
00F8:  DATA FF,FF
00FA:  CLRF   FF7
00FC:  ADDLW  0A
00FE:  MOVWF  FF6
0100:  MOVLW  01
0102:  ADDWFC FF7,F
0104:  TBLRD*+
0106:  MOVF   FF5,W
0108:  RETURN 0
010A:  DATA 40,00
010C:  DATA 0B,00
010E:  DATA 40,00
0110:  DATA 00,00
0112:  DATA 00,00
0114:  DATA 00,00
0116:  DATA 00,00
0118:  DATA 00,00
011A:  DATA 00,00
011C:  DATA 00,00
011E:  DATA 00,00
0120:  DATA 00,00
0122:  DATA 00,00
0124:  DATA 00,00
0126:  DATA 00,00
0128:  DATA 00,00
012A:  CLRF   FF7
012C:  ADDLW  3A
012E:  MOVWF  FF6
0130:  MOVLW  01
0132:  ADDWFC FF7,F
0134:  TBLRD*+
0136:  MOVF   FF5,W
0138:  RETURN 0
013A:  DATA 40,00
013C:  DATA 00,00
013E:  DATA 40,00
0140:  DATA 00,00
0142:  DATA 00,00
0144:  DATA 00,00
0146:  DATA 00,00
0148:  DATA 00,00
014A:  DATA 00,00
014C:  DATA 00,00
014E:  DATA 00,00
0150:  DATA 00,00
0152:  DATA 00,00
0154:  DATA 00,00
0156:  DATA 00,00
0158:  DATA 00,00
015A:  CLRF   FF7
015C:  ADDLW  6A
015E:  MOVWF  FF6
0160:  MOVLW  01
0162:  ADDWFC FF7,F
0164:  TBLRD*+
0166:  MOVF   FF5,W
0168:  RETURN 0
016A:  DATA 09,02
016C:  DATA 43,00
016E:  DATA 02,01
0170:  DATA 00,80
0172:  DATA FA,09
0174:  DATA 04,00
0176:  DATA 00,01
0178:  DATA 02,02
017A:  DATA 01,00
017C:  DATA 05,24
017E:  DATA 00,10
0180:  DATA 01,04
0182:  DATA 24,02
0184:  DATA 02,05
0186:  DATA 24,06
0188:  DATA 00,01
018A:  DATA 05,24
018C:  DATA 01,00
018E:  DATA 01,07
0190:  DATA 05,81
0192:  DATA 03,0B
0194:  DATA 00,FA
0196:  DATA 09,04
0198:  DATA 01,00
019A:  DATA 02,0A
019C:  DATA 00,00
019E:  DATA 00,07
01A0:  DATA 05,02
01A2:  DATA 02,40
01A4:  DATA 00,01
01A6:  DATA 07,05
01A8:  DATA 82,02
01AA:  DATA 40,00
01AC:  DATA 01,00
01AE:  CLRF   FF7
01B0:  ADDLW  BE
01B2:  MOVWF  FF6
01B4:  MOVLW  01
01B6:  ADDWFC FF7,F
01B8:  TBLRD*+
01BA:  MOVF   FF5,W
01BC:  RETURN 0
01BE:  DATA 02,00
01C0:  CLRF   FF7
01C2:  ADDLW  D0
01C4:  MOVWF  FF6
01C6:  MOVLW  01
01C8:  ADDWFC FF7,F
01CA:  TBLRD*+
01CC:  MOVF   FF5,W
01CE:  RETURN 0
01D0:  DATA 12,17
01D2:  DATA 1B,20
01D4:  DATA FF,FF
01D6:  DATA FF,FF
01D8:  CLRF   FF7
01DA:  ADDLW  E8
01DC:  MOVWF  FF6
01DE:  MOVLW  01
01E0:  ADDWFC FF7,F
01E2:  TBLRD*+
01E4:  MOVF   FF5,W
01E6:  RETURN 0
01E8:  DATA 12,01
01EA:  DATA 10,01
01EC:  DATA 02,00
01EE:  DATA 00,40
01F0:  DATA 05,24
01F2:  DATA 0B,00
01F4:  DATA 00,01
01F6:  DATA 01,02
01F8:  DATA 00,01
01FA:  CLRF   FF7
01FC:  ADDLW  0A
01FE:  MOVWF  FF6
0200:  MOVLW  02
0202:  ADDWFC FF7,F
0204:  TBLRD*+
0206:  MOVF   FF5,W
0208:  RETURN 0
020A:  DATA 04,03
020C:  DATA 09,04
020E:  DATA 08,03
0210:  DATA 43,00
0212:  DATA 43,00
0214:  DATA 53,00
0216:  DATA 20,03
0218:  DATA 43,00
021A:  DATA 43,00
021C:  DATA 53,00
021E:  DATA 20,00
0220:  DATA 55,00
0222:  DATA 53,00
0224:  DATA 42,00
0226:  DATA 20,00
0228:  DATA 74,00
022A:  DATA 6F,00
022C:  DATA 20,00
022E:  DATA 55,00
0230:  DATA 41,00
0232:  DATA 52,00
0234:  DATA 54,00
0236:  CLRF   FF7
0238:  ADDLW  46
023A:  MOVWF  FF6
023C:  MOVLW  02
023E:  ADDWFC FF7,F
0240:  TBLRD*+
0242:  MOVF   FF5,W
0244:  RETURN 0
0246:  DATA 49,6E
0248:  DATA 69,74
024A:  DATA 69,61
024C:  DATA 6C,20
024E:  DATA 63,6F
0250:  DATA 6E,66
0252:  DATA 20,73
0254:  DATA 74,61
0256:  DATA 72,74
0258:  DATA 73,00
025A:  CLRF   FF7
025C:  ADDLW  6A
025E:  MOVWF  FF6
0260:  MOVLW  02
0262:  ADDWFC FF7,F
0264:  TBLRD*+
0266:  MOVF   FF5,W
0268:  RETURN 0
026A:  DATA 45,72
026C:  DATA 72,6F
026E:  DATA 72,3A
0270:  DATA 20,49
0272:  DATA 44,20
0274:  DATA 64,65
0276:  DATA 6C,20
0278:  DATA 52,46
027A:  DATA 4D,20
027C:  DATA 69,6E
027E:  DATA 63,6F
0280:  DATA 72,72
0282:  DATA 65,63
0284:  DATA 74,61
0286:  DATA 00,00
0288:  CLRF   FF7
028A:  ADDLW  98
028C:  MOVWF  FF6
028E:  MOVLW  02
0290:  ADDWFC FF7,F
0292:  TBLRD*+
0294:  MOVF   FF5,W
0296:  RETURN 0
0298:  DATA 49,44
029A:  DATA 20,4C
029C:  DATA 6F,6F
029E:  DATA 70,00
02A0:  CLRF   FF7
02A2:  ADDLW  B0
02A4:  MOVWF  FF6
02A6:  MOVLW  02
02A8:  ADDWFC FF7,F
02AA:  TBLRD*+
02AC:  MOVF   FF5,W
02AE:  RETURN 0
02B0:  DATA 49,6E
02B2:  DATA 69,74
02B4:  DATA 69,61
02B6:  DATA 6C,20
02B8:  DATA 63,6F
02BA:  DATA 6E,66
02BC:  DATA 69,67
02BE:  DATA 75,72
02C0:  DATA 61,74
02C2:  DATA 69,6F
02C4:  DATA 6E,20
02C6:  DATA 65,6E
02C8:  DATA 64,0A
02CA:  DATA 00,00
02CC:  CLRF   FF7
02CE:  ADDLW  DC
02D0:  MOVWF  FF6
02D2:  MOVLW  02
02D4:  ADDWFC FF7,F
02D6:  TBLRD*+
02D8:  MOVF   FF5,W
02DA:  RETURN 0
02DC:  DATA 4F,50
02DE:  DATA 20,4C
02E0:  DATA 6F,6F
02E2:  DATA 70,20
02E4:  DATA 31,00
02E6:  CLRF   FF7
02E8:  ADDLW  F6
02EA:  MOVWF  FF6
02EC:  MOVLW  02
02EE:  ADDWFC FF7,F
02F0:  TBLRD*+
02F2:  MOVF   FF5,W
02F4:  RETURN 0
02F6:  DATA 4F,70
02F8:  DATA 65,72
02FA:  DATA 61,74
02FC:  DATA 69,6F
02FE:  DATA 6E,20
0300:  DATA 4D,6F
0302:  DATA 64,65
0304:  DATA 20,63
0306:  DATA 6F,75
0308:  DATA 6C,64
030A:  DATA 6E,74
030C:  DATA 20,62
030E:  DATA 65,20
0310:  DATA 73,65
0312:  DATA 74,0A
0314:  DATA 00,00
0316:  CLRF   FF7
0318:  ADDLW  26
031A:  MOVWF  FF6
031C:  MOVLW  03
031E:  ADDWFC FF7,F
0320:  TBLRD*+
0322:  MOVF   FF5,W
0324:  RETURN 0
0326:  DATA 4F,50
0328:  DATA 20,4C
032A:  DATA 6F,6F
032C:  DATA 70,20
032E:  DATA 32,00
0330:  CLRF   FF7
0332:  ADDLW  40
0334:  MOVWF  FF6
0336:  MOVLW  03
0338:  ADDWFC FF7,F
033A:  TBLRD*+
033C:  MOVF   FF5,W
033E:  RETURN 0
0340:  DATA 54,69
0342:  DATA 6D,65
0344:  DATA 6F,75
0346:  DATA 74,20
0348:  DATA 6F,6E
034A:  DATA 20,4F
034C:  DATA 70,65
034E:  DATA 72,61
0350:  DATA 74,69
0352:  DATA 6F,6E
0354:  DATA 20,4D
0356:  DATA 6F,64
0358:  DATA 65,20
035A:  DATA 53,65
035C:  DATA 74,0A
035E:  DATA 00,00
0360:  CLRF   FF7
0362:  ADDLW  70
0364:  MOVWF  FF6
0366:  MOVLW  03
0368:  ADDWFC FF7,F
036A:  TBLRD*+
036C:  MOVF   FF5,W
036E:  RETURN 0
0370:  DATA 50,61
0372:  DATA 79,6C
0374:  DATA 6F,61
0376:  DATA 64,3A
0378:  DATA 20,00
037A:  CLRF   FF7
037C:  ADDLW  8A
037E:  MOVWF  FF6
0380:  MOVLW  03
0382:  ADDWFC FF7,F
0384:  TBLRD*+
0386:  MOVF   FF5,W
0388:  RETURN 0
038A:  DATA 54,69
038C:  DATA 6D,65
038E:  DATA 64,20
0390:  DATA 6F,75
0392:  DATA 74,00
0394:  CLRF   FF7
0396:  ADDLW  A4
0398:  MOVWF  FF6
039A:  MOVLW  03
039C:  ADDWFC FF7,F
039E:  TBLRD*+
03A0:  MOVF   FF5,W
03A2:  RETURN 0
03A4:  DATA 0A,53
03A6:  DATA 69,67
03A8:  DATA 6E,61
03AA:  DATA 6C,20
03AC:  DATA 53,74
03AE:  DATA 72,65
03B0:  DATA 6E,67
03B2:  DATA 74,68
03B4:  DATA 3A,20
03B6:  DATA 00,00
03B8:  CLRF   FF7
03BA:  ADDLW  C8
03BC:  MOVWF  FF6
03BE:  MOVLW  03
03C0:  ADDWFC FF7,F
03C2:  TBLRD*+
03C4:  MOVF   FF5,W
03C6:  RETURN 0
03C8:  DATA 46,49
03CA:  DATA 46,4F
03CC:  DATA 20,4C
03CE:  DATA 45,4E
03D0:  DATA 3A,20
03D2:  DATA 00,00
03D4:  CLRF   FF7
03D6:  ADDLW  E4
03D8:  MOVWF  FF6
03DA:  MOVLW  03
03DC:  ADDWFC FF7,F
03DE:  TBLRD*+
03E0:  MOVF   FF5,W
03E2:  RETURN 0
03E4:  DATA 49,64
03E6:  DATA 20,69
03E8:  DATA 6E,63
03EA:  DATA 6F,72
03EC:  DATA 72,65
03EE:  DATA 63,74
03F0:  DATA 6F,00
03F2:  CLRF   FF7
03F4:  ADDLW  02
03F6:  MOVWF  FF6
03F8:  MOVLW  04
03FA:  ADDWFC FF7,F
03FC:  TBLRD*+
03FE:  MOVF   FF5,W
0400:  RETURN 0
0402:  DATA 49,4E
0404:  DATA 49,54
0406:  DATA 20,44
0408:  DATA 4F,4E
040A:  DATA 45,00
040C:  CLRF   FF7
040E:  ADDLW  1C
0410:  MOVWF  FF6
0412:  MOVLW  04
0414:  ADDWFC FF7,F
0416:  TBLRD*+
0418:  MOVF   FF5,W
041A:  RETURN 0
041C:  DATA 50,61
041E:  DATA 63,6B
0420:  DATA 65,74
0422:  DATA 00,00
0424:  CLRF   FF7
0426:  ADDLW  34
0428:  MOVWF  FF6
042A:  MOVLW  04
042C:  ADDWFC FF7,F
042E:  TBLRD*+
0430:  MOVF   FF5,W
0432:  RETURN 0
0434:  DATA 45,73
0436:  DATA 70,65
0438:  DATA 72,61
043A:  DATA 6E,64
043C:  DATA 6F,00
*
04DE:  MOVLB  2
04E0:  MOVF   xA5,W
04E2:  MULWF  xA7
04E4:  MOVFF  FF3,01
04E8:  MOVFF  FF4,00
04EC:  MULWF  xA8
04EE:  MOVF   FF3,W
04F0:  ADDWF  00,F
04F2:  MOVF   xA6,W
04F4:  MULWF  xA7
04F6:  MOVF   FF3,W
04F8:  ADDWFC 00,W
04FA:  MOVWF  02
04FC:  MOVLB  0
04FE:  RETURN 0
*
14B4:  MOVLB  2
14B6:  MOVF   x93,W
14B8:  ANDLW  07
14BA:  MOVWF  00
14BC:  RRCF   x93,W
14BE:  MOVWF  01
14C0:  RRCF   01,F
14C2:  RRCF   01,F
14C4:  MOVLW  1F
14C6:  ANDWF  01,F
14C8:  MOVF   01,W
14CA:  ADDWF  x95,W
14CC:  MOVWF  FE9
14CE:  MOVLW  00
14D0:  ADDWFC x96,W
14D2:  MOVWF  FEA
14D4:  CLRF   01
14D6:  INCF   01,F
14D8:  INCF   00,F
14DA:  BRA    14DE
14DC:  RLCF   01,F
14DE:  DECFSZ 00,F
14E0:  BRA    14DC
14E2:  MOVF   x94,F
14E4:  BZ    14EC
14E6:  MOVF   01,W
14E8:  IORWF  FEF,F
14EA:  BRA    14F2
14EC:  COMF   01,F
14EE:  MOVF   01,W
14F0:  ANDWF  FEF,F
14F2:  MOVLB  0
14F4:  RETURN 0
14F6:  MOVLB  2
14F8:  MOVF   x8A,W
14FA:  ANDLW  07
14FC:  MOVWF  00
14FE:  RRCF   x8A,W
1500:  MOVWF  01
1502:  RRCF   01,F
1504:  RRCF   01,F
1506:  MOVLW  1F
1508:  ANDWF  01,F
150A:  MOVF   01,W
150C:  ADDWF  x8B,W
150E:  MOVWF  FE9
1510:  MOVLW  00
1512:  ADDWFC x8C,W
1514:  MOVWF  FEA
1516:  MOVFF  FEF,01
151A:  INCF   00,F
151C:  BRA    1520
151E:  RRCF   01,F
1520:  DECFSZ 00,F
1522:  BRA    151E
1524:  MOVLW  01
1526:  ANDWF  01,F
1528:  MOVLB  0
152A:  GOTO   1556 (RETURN)
*
1952:  MOVFF  DD,FEA
1956:  MOVFF  DC,FE9
195A:  MOVFF  273,FEF
195E:  INCF   FE9,F
1960:  BTFSC  FD8.2
1962:  INCF   FEA,F
1964:  CLRF   FEF
1966:  MOVLB  0
1968:  INCF   xDC,F
196A:  BTFSC  FD8.2
196C:  INCF   xDD,F
196E:  RETURN 0
1970:  MOVLB  2
1972:  BTFSC  x6B.7
1974:  BRA    1998
1976:  MOVLW  0F
1978:  MOVWF  00
197A:  SWAPF  x6A,W
197C:  ANDWF  00,F
197E:  MOVLW  0A
1980:  SUBWF  00,W
1982:  BC    198A
1984:  MOVLW  30
1986:  ADDWF  00,F
1988:  BRA    198E
198A:  MOVF   x6B,W
198C:  ADDWF  00,F
198E:  MOVFF  00,273
1992:  MOVLB  0
1994:  RCALL  1952
1996:  MOVLB  2
1998:  MOVLW  0F
199A:  ANDWF  x6A,F
199C:  MOVLW  0A
199E:  SUBWF  x6A,W
19A0:  BC    19A6
19A2:  MOVLW  30
19A4:  BRA    19AA
19A6:  BCF    x6B.7
19A8:  MOVF   x6B,W
19AA:  ADDWF  x6A,F
19AC:  MOVFF  26A,273
19B0:  MOVLB  0
19B2:  RCALL  1952
19B4:  GOTO   1CAC (RETURN)
19B8:  MOVFF  FEA,272
19BC:  MOVFF  FE9,271
19C0:  MOVLB  2
19C2:  BTFSS  x6B.7
19C4:  BRA    19D6
19C6:  BSF    x71.7
19C8:  BTFSS  x71.4
19CA:  INCF   x71,F
19CC:  COMF   x6A,F
19CE:  COMF   x6B,F
19D0:  INCF   x6A,F
19D2:  BTFSC  FD8.2
19D4:  INCF   x6B,F
19D6:  SWAPF  x6B,W
19D8:  IORLW  F0
19DA:  MOVWF  x6D
19DC:  ADDWF  x6D,F
19DE:  ADDLW  E2
19E0:  MOVWF  x6E
19E2:  ADDLW  32
19E4:  MOVWF  x70
19E6:  MOVF   x6B,W
19E8:  ANDLW  0F
19EA:  ADDWF  x6E,F
19EC:  ADDWF  x6E,F
19EE:  ADDWF  x70,F
19F0:  ADDLW  E9
19F2:  MOVWF  x6F
19F4:  ADDWF  x6F,F
19F6:  ADDWF  x6F,F
19F8:  SWAPF  x6A,W
19FA:  ANDLW  0F
19FC:  ADDWF  x6F,F
19FE:  ADDWF  x70,F
1A00:  RLCF   x6F,F
1A02:  RLCF   x70,F
1A04:  COMF   x70,F
1A06:  RLCF   x70,F
1A08:  MOVF   x6A,W
1A0A:  ANDLW  0F
1A0C:  ADDWF  x70,F
1A0E:  RLCF   x6D,F
1A10:  MOVLW  07
1A12:  MOVWF  x6C
1A14:  MOVLW  0A
1A16:  DECF   x6F,F
1A18:  ADDWF  x70,F
1A1A:  BNC   1A16
1A1C:  DECF   x6E,F
1A1E:  ADDWF  x6F,F
1A20:  BNC   1A1C
1A22:  DECF   x6D,F
1A24:  ADDWF  x6E,F
1A26:  BNC   1A22
1A28:  DECF   x6C,F
1A2A:  ADDWF  x6D,F
1A2C:  BNC   1A28
1A2E:  MOVLW  02
1A30:  MOVWF  FEA
1A32:  MOVLW  6C
1A34:  MOVWF  FE9
1A36:  MOVLW  07
1A38:  ANDWF  x71,W
1A3A:  BCF    x71.6
1A3C:  MOVF   FED,F
1A3E:  ANDWF  x71,W
1A40:  BNZ   1A50
1A42:  BTFSC  x71.4
1A44:  MOVF   FEE,F
1A46:  BTFSC  x71.4
1A48:  BRA    1A50
1A4A:  MOVLW  20
1A4C:  MOVWF  00
1A4E:  BRA    1A92
1A50:  ADDWF  FE9,F
1A52:  MOVLW  00
1A54:  ADDWFC FEA,F
1A56:  MOVF   FE9,W
1A58:  SUBLW  70
1A5A:  BNZ   1A64
1A5C:  MOVF   FEA,W
1A5E:  SUBLW  02
1A60:  BNZ   1A64
1A62:  BSF    x71.6
1A64:  MOVF   FEF,W
1A66:  MOVWF  00
1A68:  BNZ   1A7A
1A6A:  BTFSC  x71.6
1A6C:  BRA    1A7A
1A6E:  BTFSC  x71.4
1A70:  BRA    1AAC
1A72:  BTFSC  x71.3
1A74:  BRA    1A7A
1A76:  MOVLW  20
1A78:  BRA    1A90
1A7A:  BTFSS  x71.7
1A7C:  BRA    1A8A
1A7E:  MOVLW  2D
1A80:  MOVWF  00
1A82:  MOVF   FED,W
1A84:  BCF    x71.6
1A86:  BCF    x71.7
1A88:  BRA    1A92
1A8A:  BSF    x71.3
1A8C:  BCF    x71.4
1A8E:  MOVLW  30
1A90:  ADDWF  00,F
1A92:  MOVFF  FEA,26B
1A96:  MOVFF  FE9,26A
1A9A:  MOVFF  00,273
1A9E:  MOVLB  0
1AA0:  RCALL  1952
1AA2:  MOVFF  26B,FEA
1AA6:  MOVFF  26A,FE9
1AAA:  MOVLB  2
1AAC:  MOVF   FEE,W
1AAE:  BTFSS  x71.6
1AB0:  BRA    1A56
1AB2:  MOVLB  0
1AB4:  GOTO   1C8A (RETURN)
1AB8:  MOVFF  FEA,272
1ABC:  MOVFF  FE9,271
1AC0:  MOVLB  2
1AC2:  SWAPF  x6B,W
1AC4:  IORLW  F0
1AC6:  MOVWF  x6D
1AC8:  ADDWF  x6D,F
1ACA:  ADDLW  E2
1ACC:  MOVWF  x6E
1ACE:  ADDLW  32
1AD0:  MOVWF  x70
1AD2:  MOVF   x6B,W
1AD4:  ANDLW  0F
1AD6:  ADDWF  x6E,F
1AD8:  ADDWF  x6E,F
1ADA:  ADDWF  x70,F
1ADC:  ADDLW  E9
1ADE:  MOVWF  x6F
1AE0:  ADDWF  x6F,F
1AE2:  ADDWF  x6F,F
1AE4:  SWAPF  x6A,W
1AE6:  ANDLW  0F
1AE8:  ADDWF  x6F,F
1AEA:  ADDWF  x70,F
1AEC:  RLCF   x6F,F
1AEE:  RLCF   x70,F
1AF0:  COMF   x70,F
1AF2:  RLCF   x70,F
1AF4:  MOVF   x6A,W
1AF6:  ANDLW  0F
1AF8:  ADDWF  x70,F
1AFA:  RLCF   x6D,F
1AFC:  MOVLW  07
1AFE:  MOVWF  x6C
1B00:  MOVLW  0A
1B02:  DECF   x6F,F
1B04:  ADDWF  x70,F
1B06:  BNC   1B02
1B08:  DECF   x6E,F
1B0A:  ADDWF  x6F,F
1B0C:  BNC   1B08
1B0E:  DECF   x6D,F
1B10:  ADDWF  x6E,F
1B12:  BNC   1B0E
1B14:  DECF   x6C,F
1B16:  ADDWF  x6D,F
1B18:  BNC   1B14
1B1A:  MOVLW  02
1B1C:  MOVWF  FEA
1B1E:  MOVLW  6C
1B20:  MOVWF  FE9
1B22:  MOVLW  07
1B24:  ANDWF  x71,W
1B26:  BCF    x71.6
1B28:  ADDWF  FE9,F
1B2A:  MOVLW  00
1B2C:  ADDWFC FEA,F
1B2E:  MOVF   FE9,W
1B30:  SUBLW  70
1B32:  BNZ   1B3C
1B34:  MOVF   FEA,W
1B36:  SUBLW  02
1B38:  BNZ   1B3C
1B3A:  BSF    x71.6
1B3C:  MOVF   FEF,W
1B3E:  MOVWF  00
1B40:  BNZ   1B52
1B42:  BTFSC  x71.6
1B44:  BRA    1B52
1B46:  BTFSC  x71.4
1B48:  BRA    1B74
1B4A:  BTFSC  x71.3
1B4C:  BRA    1B52
1B4E:  MOVLW  20
1B50:  BRA    1B58
1B52:  BSF    x71.3
1B54:  BCF    x71.4
1B56:  MOVLW  30
1B58:  ADDWF  00,F
1B5A:  MOVFF  FEA,26B
1B5E:  MOVFF  FE9,26A
1B62:  MOVFF  00,273
1B66:  MOVLB  0
1B68:  RCALL  1952
1B6A:  MOVFF  26B,FEA
1B6E:  MOVFF  26A,FE9
1B72:  MOVLB  2
1B74:  MOVF   FEE,W
1B76:  BTFSS  x71.6
1B78:  BRA    1B2E
1B7A:  MOVLB  0
1B7C:  RETURN 0
1B7E:  MOVF   FEF,F
1B80:  BZ    1BAC
1B82:  MOVFF  FEA,270
1B86:  MOVFF  FE9,26F
1B8A:  CLRF   19
1B8C:  BTFSC  FF2.7
1B8E:  BSF    19.7
1B90:  BCF    FF2.7
1B92:  MOVFF  FEF,292
1B96:  RCALL  15F6
1B98:  BTFSC  19.7
1B9A:  BSF    FF2.7
1B9C:  MOVFF  270,FEA
1BA0:  MOVFF  26F,FE9
1BA4:  INCF   FE9,F
1BA6:  BTFSC  FD8.2
1BA8:  INCF   FEA,F
1BAA:  BRA    1B7E
1BAC:  GOTO   1BD8 (RETURN)
*
21F6:  MOVLB  1
21F8:  MOVF   xEE,W
21FA:  BTFSC  FD8.2
21FC:  BRA    2348
21FE:  MOVWF  xFA
2200:  MOVF   xF2,W
2202:  BTFSC  FD8.2
2204:  BRA    2348
2206:  SUBWF  xFA,F
2208:  BNC   2214
220A:  MOVLW  7F
220C:  ADDWF  xFA,F
220E:  BTFSC  FD8.0
2210:  BRA    2348
2212:  BRA    2220
2214:  MOVLW  81
2216:  SUBWF  xFA,F
2218:  BTFSS  FD8.0
221A:  BRA    2348
221C:  BTFSC  FD8.2
221E:  BRA    2348
2220:  MOVFF  1FA,00
2224:  CLRF   01
2226:  CLRF   02
2228:  CLRF   03
222A:  CLRF   xF9
222C:  MOVFF  1EF,1F8
2230:  BSF    xF8.7
2232:  MOVFF  1F0,1F7
2236:  MOVFF  1F1,1F6
223A:  MOVLW  19
223C:  MOVWF  xFA
223E:  MOVF   xF5,W
2240:  SUBWF  xF6,F
2242:  BC    225E
2244:  MOVLW  01
2246:  SUBWF  xF7,F
2248:  BC    225E
224A:  SUBWF  xF8,F
224C:  BC    225E
224E:  SUBWF  xF9,F
2250:  BC    225E
2252:  INCF   xF9,F
2254:  INCF   xF8,F
2256:  INCF   xF7,F
2258:  MOVF   xF5,W
225A:  ADDWF  xF6,F
225C:  BRA    22AE
225E:  MOVF   xF4,W
2260:  SUBWF  xF7,F
2262:  BC    2288
2264:  MOVLW  01
2266:  SUBWF  xF8,F
2268:  BC    2288
226A:  SUBWF  xF9,F
226C:  BC    2288
226E:  INCF   xF9,F
2270:  INCF   xF8,F
2272:  MOVF   xF4,W
2274:  ADDWF  xF7,F
2276:  MOVF   xF5,W
2278:  ADDWF  xF6,F
227A:  BNC   22AE
227C:  INCF   xF7,F
227E:  BNZ   22AE
2280:  INCF   xF8,F
2282:  BNZ   22AE
2284:  INCF   xF9,F
2286:  BRA    22AE
2288:  MOVF   xF3,W
228A:  IORLW  80
228C:  SUBWF  xF8,F
228E:  BC    22AC
2290:  MOVLW  01
2292:  SUBWF  xF9,F
2294:  BC    22AC
2296:  INCF   xF9,F
2298:  MOVF   xF3,W
229A:  IORLW  80
229C:  ADDWF  xF8,F
229E:  MOVF   xF4,W
22A0:  ADDWF  xF7,F
22A2:  BNC   2276
22A4:  INCF   xF8,F
22A6:  BNZ   2276
22A8:  INCF   xF9,F
22AA:  BRA    2276
22AC:  BSF    03.0
22AE:  DECFSZ xFA,F
22B0:  BRA    22B4
22B2:  BRA    22CA
22B4:  BCF    FD8.0
22B6:  RLCF   xF6,F
22B8:  RLCF   xF7,F
22BA:  RLCF   xF8,F
22BC:  RLCF   xF9,F
22BE:  BCF    FD8.0
22C0:  RLCF   03,F
22C2:  RLCF   02,F
22C4:  RLCF   01,F
22C6:  RLCF   xFB,F
22C8:  BRA    223E
22CA:  BTFSS  xFB.0
22CC:  BRA    22DA
22CE:  BCF    FD8.0
22D0:  RRCF   01,F
22D2:  RRCF   02,F
22D4:  RRCF   03,F
22D6:  RRCF   xFB,F
22D8:  BRA    22DE
22DA:  DECF   00,F
22DC:  BZ    2348
22DE:  BTFSC  xFB.7
22E0:  BRA    231E
22E2:  BCF    FD8.0
22E4:  RLCF   xF6,F
22E6:  RLCF   xF7,F
22E8:  RLCF   xF8,F
22EA:  RLCF   xF9,F
22EC:  MOVF   xF5,W
22EE:  SUBWF  xF6,F
22F0:  BC    2300
22F2:  MOVLW  01
22F4:  SUBWF  xF7,F
22F6:  BC    2300
22F8:  SUBWF  xF8,F
22FA:  BC    2300
22FC:  SUBWF  xF9,F
22FE:  BNC   2334
2300:  MOVF   xF4,W
2302:  SUBWF  xF7,F
2304:  BC    2310
2306:  MOVLW  01
2308:  SUBWF  xF8,F
230A:  BC    2310
230C:  SUBWF  xF9,F
230E:  BNC   2334
2310:  MOVF   xF3,W
2312:  IORLW  80
2314:  SUBWF  xF8,F
2316:  BC    231E
2318:  MOVLW  01
231A:  SUBWF  xF9,F
231C:  BNC   2334
231E:  INCF   03,F
2320:  BNZ   2334
2322:  INCF   02,F
2324:  BNZ   2334
2326:  INCF   01,F
2328:  BNZ   2334
232A:  INCF   00,F
232C:  BZ    2348
232E:  RRCF   01,F
2330:  RRCF   02,F
2332:  RRCF   03,F
2334:  MOVFF  1EF,1FA
2338:  MOVF   xF3,W
233A:  XORWF  xFA,F
233C:  BTFSS  xFA.7
233E:  BRA    2344
2340:  BSF    01.7
2342:  BRA    2350
2344:  BCF    01.7
2346:  BRA    2350
2348:  CLRF   00
234A:  CLRF   01
234C:  CLRF   02
234E:  CLRF   03
2350:  MOVLB  0
2352:  RETURN 0
2354:  MOVLW  80
2356:  BTFSS  FD8.1
2358:  BRA    235E
235A:  MOVLB  2
235C:  XORWF  x1B,F
235E:  MOVLB  2
2360:  CLRF   x20
2362:  CLRF   x21
2364:  MOVFF  217,21F
2368:  MOVF   x1B,W
236A:  XORWF  x1F,F
236C:  MOVF   x16,W
236E:  BTFSC  FD8.2
2370:  BRA    2530
2372:  MOVWF  x1E
2374:  MOVWF  00
2376:  MOVF   x1A,W
2378:  BTFSC  FD8.2
237A:  BRA    2542
237C:  SUBWF  x1E,F
237E:  BTFSC  FD8.2
2380:  BRA    2488
2382:  BNC   2400
2384:  MOVFF  21B,224
2388:  BSF    x24.7
238A:  MOVFF  21C,223
238E:  MOVFF  21D,222
2392:  CLRF   x21
2394:  BCF    FD8.0
2396:  RRCF   x24,F
2398:  RRCF   x23,F
239A:  RRCF   x22,F
239C:  RRCF   x21,F
239E:  DECFSZ x1E,F
23A0:  BRA    2392
23A2:  BTFSS  x1F.7
23A4:  BRA    23AC
23A6:  BSF    x20.0
23A8:  BRA    256A
23AA:  BCF    x20.0
23AC:  BCF    x1E.0
23AE:  BSF    x20.4
23B0:  MOVLW  02
23B2:  MOVWF  FEA
23B4:  MOVLW  19
23B6:  MOVWF  FE9
23B8:  BRA    2590
23BA:  BCF    x20.4
23BC:  BTFSC  x1F.7
23BE:  BRA    23D4
23C0:  BTFSS  x1E.0
23C2:  BRA    23EA
23C4:  RRCF   x24,F
23C6:  RRCF   x23,F
23C8:  RRCF   x22,F
23CA:  RRCF   x21,F
23CC:  INCF   00,F
23CE:  BTFSC  FD8.2
23D0:  BRA    2560
23D2:  BRA    23EA
23D4:  BTFSC  x24.7
23D6:  BRA    23F0
23D8:  BCF    FD8.0
23DA:  RLCF   x21,F
23DC:  RLCF   x22,F
23DE:  RLCF   x23,F
23E0:  RLCF   x24,F
23E2:  DECF   00,F
23E4:  BTFSC  FD8.2
23E6:  BRA    2560
23E8:  BRA    23D4
23EA:  BSF    x20.6
23EC:  BRA    24C8
23EE:  BCF    x20.6
23F0:  MOVFF  217,21F
23F4:  BTFSS  x17.7
23F6:  BRA    23FC
23F8:  BSF    x24.7
23FA:  BRA    2552
23FC:  BCF    x24.7
23FE:  BRA    2552
2400:  MOVFF  21A,21E
2404:  MOVFF  21A,00
2408:  MOVF   x16,W
240A:  SUBWF  x1E,F
240C:  MOVFF  217,224
2410:  BSF    x24.7
2412:  MOVFF  218,223
2416:  MOVFF  219,222
241A:  CLRF   x21
241C:  BCF    FD8.0
241E:  RRCF   x24,F
2420:  RRCF   x23,F
2422:  RRCF   x22,F
2424:  RRCF   x21,F
2426:  DECFSZ x1E,F
2428:  BRA    241A
242A:  BTFSS  x1F.7
242C:  BRA    2434
242E:  BSF    x20.1
2430:  BRA    256A
2432:  BCF    x20.1
2434:  BCF    x1E.0
2436:  BSF    x20.5
2438:  MOVLW  02
243A:  MOVWF  FEA
243C:  MOVLW  1D
243E:  MOVWF  FE9
2440:  BRA    2590
2442:  BCF    x20.5
2444:  BTFSC  x1F.7
2446:  BRA    245C
2448:  BTFSS  x1E.0
244A:  BRA    2472
244C:  RRCF   x24,F
244E:  RRCF   x23,F
2450:  RRCF   x22,F
2452:  RRCF   x21,F
2454:  INCF   00,F
2456:  BTFSC  FD8.2
2458:  BRA    2560
245A:  BRA    2472
245C:  BTFSC  x24.7
245E:  BRA    2478
2460:  BCF    FD8.0
2462:  RLCF   x21,F
2464:  RLCF   x22,F
2466:  RLCF   x23,F
2468:  RLCF   x24,F
246A:  DECF   00,F
246C:  BTFSC  FD8.2
246E:  BRA    2560
2470:  BRA    245C
2472:  BSF    x20.7
2474:  BRA    24C8
2476:  BCF    x20.7
2478:  MOVFF  21B,21F
247C:  BTFSS  x1B.7
247E:  BRA    2484
2480:  BSF    x24.7
2482:  BRA    2552
2484:  BCF    x24.7
2486:  BRA    2552
2488:  MOVFF  21B,224
248C:  BSF    x24.7
248E:  MOVFF  21C,223
2492:  MOVFF  21D,222
2496:  BTFSS  x1F.7
2498:  BRA    24A2
249A:  BCF    x24.7
249C:  BSF    x20.2
249E:  BRA    256A
24A0:  BCF    x20.2
24A2:  CLRF   x21
24A4:  BCF    x1E.0
24A6:  MOVLW  02
24A8:  MOVWF  FEA
24AA:  MOVLW  19
24AC:  MOVWF  FE9
24AE:  BRA    2590
24B0:  BTFSC  x1F.7
24B2:  BRA    24EC
24B4:  MOVFF  217,21F
24B8:  BTFSS  x1E.0
24BA:  BRA    24C8
24BC:  RRCF   x24,F
24BE:  RRCF   x23,F
24C0:  RRCF   x22,F
24C2:  RRCF   x21,F
24C4:  INCF   00,F
24C6:  BZ    2560
24C8:  BTFSS  x21.7
24CA:  BRA    24E2
24CC:  INCF   x22,F
24CE:  BNZ   24E2
24D0:  INCF   x23,F
24D2:  BNZ   24E2
24D4:  INCF   x24,F
24D6:  BNZ   24E2
24D8:  RRCF   x24,F
24DA:  RRCF   x23,F
24DC:  RRCF   x22,F
24DE:  INCF   00,F
24E0:  BZ    2560
24E2:  BTFSC  x20.6
24E4:  BRA    23EE
24E6:  BTFSC  x20.7
24E8:  BRA    2476
24EA:  BRA    2524
24EC:  MOVLW  80
24EE:  XORWF  x24,F
24F0:  BTFSS  x24.7
24F2:  BRA    24FC
24F4:  BRA    256A
24F6:  MOVFF  21B,21F
24FA:  BRA    2510
24FC:  MOVFF  217,21F
2500:  MOVF   x24,F
2502:  BNZ   2510
2504:  MOVF   x23,F
2506:  BNZ   2510
2508:  MOVF   x22,F
250A:  BNZ   2510
250C:  CLRF   00
250E:  BRA    2552
2510:  BTFSC  x24.7
2512:  BRA    2524
2514:  BCF    FD8.0
2516:  RLCF   x21,F
2518:  RLCF   x22,F
251A:  RLCF   x23,F
251C:  RLCF   x24,F
251E:  DECFSZ 00,F
2520:  BRA    2510
2522:  BRA    2560
2524:  BTFSS  x1F.7
2526:  BRA    252C
2528:  BSF    x24.7
252A:  BRA    2552
252C:  BCF    x24.7
252E:  BRA    2552
2530:  MOVFF  21A,00
2534:  MOVFF  21B,224
2538:  MOVFF  21C,223
253C:  MOVFF  21D,222
2540:  BRA    2552
2542:  MOVFF  216,00
2546:  MOVFF  217,224
254A:  MOVFF  218,223
254E:  MOVFF  219,222
2552:  MOVFF  224,01
2556:  MOVFF  223,02
255A:  MOVFF  222,03
255E:  BRA    25C8
2560:  CLRF   00
2562:  CLRF   01
2564:  CLRF   02
2566:  CLRF   03
2568:  BRA    25C8
256A:  CLRF   x21
256C:  COMF   x22,F
256E:  COMF   x23,F
2570:  COMF   x24,F
2572:  COMF   x21,F
2574:  INCF   x21,F
2576:  BNZ   2582
2578:  INCF   x22,F
257A:  BNZ   2582
257C:  INCF   x23,F
257E:  BNZ   2582
2580:  INCF   x24,F
2582:  BTFSC  x20.0
2584:  BRA    23AA
2586:  BTFSC  x20.1
2588:  BRA    2432
258A:  BTFSC  x20.2
258C:  BRA    24A0
258E:  BRA    24F6
2590:  MOVF   FEF,W
2592:  ADDWF  x22,F
2594:  BNC   25A0
2596:  INCF   x23,F
2598:  BNZ   25A0
259A:  INCF   x24,F
259C:  BTFSC  FD8.2
259E:  BSF    x1E.0
25A0:  MOVF   FED,F
25A2:  MOVF   FEF,W
25A4:  ADDWF  x23,F
25A6:  BNC   25AE
25A8:  INCF   x24,F
25AA:  BTFSC  FD8.2
25AC:  BSF    x1E.0
25AE:  MOVF   FED,F
25B0:  MOVF   FEF,W
25B2:  BTFSC  FEF.7
25B4:  BRA    25B8
25B6:  XORLW  80
25B8:  ADDWF  x24,F
25BA:  BTFSC  FD8.0
25BC:  BSF    x1E.0
25BE:  BTFSC  x20.4
25C0:  BRA    23BA
25C2:  BTFSC  x20.5
25C4:  BRA    2442
25C6:  BRA    24B0
25C8:  MOVLB  0
25CA:  RETURN 0
25CC:  MOVLW  8E
25CE:  MOVWF  00
25D0:  MOVLB  1
25D2:  MOVF   xEA,W
25D4:  SUBWF  00,F
25D6:  MOVFF  1EB,02
25DA:  MOVFF  1EC,01
25DE:  BSF    02.7
25E0:  MOVF   00,F
25E2:  BZ    25F6
25E4:  BCF    FD8.0
25E6:  MOVF   02,F
25E8:  BNZ   25EE
25EA:  MOVF   01,F
25EC:  BZ    25F6
25EE:  RRCF   02,F
25F0:  RRCF   01,F
25F2:  DECFSZ 00,F
25F4:  BRA    25E4
25F6:  BTFSS  xEB.7
25F8:  BRA    2604
25FA:  COMF   01,F
25FC:  COMF   02,F
25FE:  INCF   01,F
2600:  BTFSC  FD8.2
2602:  INCF   02,F
2604:  MOVLB  0
2606:  RETURN 0
*
2C12:  MOVFF  217,21E
2C16:  MOVLB  2
2C18:  MOVF   x1B,W
2C1A:  XORWF  x1E,F
2C1C:  BTFSS  x1E.7
2C1E:  BRA    2C2A
2C20:  BCF    FD8.2
2C22:  BCF    FD8.0
2C24:  BTFSC  x17.7
2C26:  BSF    FD8.0
2C28:  BRA    2C88
2C2A:  MOVFF  217,21E
2C2E:  MOVFF  21A,21F
2C32:  MOVF   x16,W
2C34:  SUBWF  x1F,F
2C36:  BZ    2C44
2C38:  BTFSS  x1E.7
2C3A:  BRA    2C88
2C3C:  MOVF   FD8,W
2C3E:  XORLW  01
2C40:  MOVWF  FD8
2C42:  BRA    2C88
2C44:  MOVFF  21B,21F
2C48:  MOVF   x17,W
2C4A:  SUBWF  x1F,F
2C4C:  BZ    2C5A
2C4E:  BTFSS  x1E.7
2C50:  BRA    2C88
2C52:  MOVF   FD8,W
2C54:  XORLW  01
2C56:  MOVWF  FD8
2C58:  BRA    2C88
2C5A:  MOVFF  21C,21F
2C5E:  MOVF   x18,W
2C60:  SUBWF  x1F,F
2C62:  BZ    2C70
2C64:  BTFSS  x1E.7
2C66:  BRA    2C88
2C68:  MOVF   FD8,W
2C6A:  XORLW  01
2C6C:  MOVWF  FD8
2C6E:  BRA    2C88
2C70:  MOVFF  21D,21F
2C74:  MOVF   x19,W
2C76:  SUBWF  x1F,F
2C78:  BZ    2C86
2C7A:  BTFSS  x1E.7
2C7C:  BRA    2C88
2C7E:  MOVF   FD8,W
2C80:  XORLW  01
2C82:  MOVWF  FD8
2C84:  BRA    2C88
2C86:  BCF    FD8.0
2C88:  MOVLB  0
2C8A:  RETURN 0
*
2CBE:  MOVLW  8E
2CC0:  MOVWF  00
2CC2:  MOVFF  215,01
2CC6:  MOVFF  214,02
2CCA:  CLRF   03
2CCC:  MOVF   01,F
2CCE:  BNZ   2CE2
2CD0:  MOVFF  02,01
2CD4:  CLRF   02
2CD6:  MOVLW  08
2CD8:  SUBWF  00,F
2CDA:  MOVF   01,F
2CDC:  BNZ   2CE2
2CDE:  CLRF   00
2CE0:  BRA    2CF2
2CE2:  BCF    FD8.0
2CE4:  BTFSC  01.7
2CE6:  BRA    2CF0
2CE8:  RLCF   02,F
2CEA:  RLCF   01,F
2CEC:  DECF   00,F
2CEE:  BRA    2CE2
2CF0:  BCF    01.7
2CF2:  RETURN 0
2CF4:  MOVLB  2
2CF6:  MOVF   x18,W
2CF8:  BTFSC  FD8.2
2CFA:  BRA    2DDE
2CFC:  MOVWF  00
2CFE:  MOVF   x1C,W
2D00:  BTFSC  FD8.2
2D02:  BRA    2DDE
2D04:  ADDWF  00,F
2D06:  BNC   2D10
2D08:  MOVLW  81
2D0A:  ADDWF  00,F
2D0C:  BC    2DDE
2D0E:  BRA    2D18
2D10:  MOVLW  7F
2D12:  SUBWF  00,F
2D14:  BNC   2DDE
2D16:  BZ    2DDE
2D18:  MOVFF  219,220
2D1C:  MOVF   x1D,W
2D1E:  XORWF  x20,F
2D20:  BSF    x19.7
2D22:  BSF    x1D.7
2D24:  MOVF   x1B,W
2D26:  MULWF  x1F
2D28:  MOVFF  FF4,222
2D2C:  MOVF   x1A,W
2D2E:  MULWF  x1E
2D30:  MOVFF  FF4,03
2D34:  MOVFF  FF3,221
2D38:  MULWF  x1F
2D3A:  MOVF   FF3,W
2D3C:  ADDWF  x22,F
2D3E:  MOVF   FF4,W
2D40:  ADDWFC x21,F
2D42:  MOVLW  00
2D44:  ADDWFC 03,F
2D46:  MOVF   x1B,W
2D48:  MULWF  x1E
2D4A:  MOVF   FF3,W
2D4C:  ADDWF  x22,F
2D4E:  MOVF   FF4,W
2D50:  ADDWFC x21,F
2D52:  MOVLW  00
2D54:  CLRF   02
2D56:  ADDWFC 03,F
2D58:  ADDWFC 02,F
2D5A:  MOVF   x19,W
2D5C:  MULWF  x1F
2D5E:  MOVF   FF3,W
2D60:  ADDWF  x21,F
2D62:  MOVF   FF4,W
2D64:  ADDWFC 03,F
2D66:  MOVLW  00
2D68:  ADDWFC 02,F
2D6A:  MOVF   x19,W
2D6C:  MULWF  x1E
2D6E:  MOVF   FF3,W
2D70:  ADDWF  03,F
2D72:  MOVF   FF4,W
2D74:  ADDWFC 02,F
2D76:  MOVLW  00
2D78:  CLRF   01
2D7A:  ADDWFC 01,F
2D7C:  MOVF   x1B,W
2D7E:  MULWF  x1D
2D80:  MOVF   FF3,W
2D82:  ADDWF  x21,F
2D84:  MOVF   FF4,W
2D86:  ADDWFC 03,F
2D88:  MOVLW  00
2D8A:  ADDWFC 02,F
2D8C:  ADDWFC 01,F
2D8E:  MOVF   x1A,W
2D90:  MULWF  x1D
2D92:  MOVF   FF3,W
2D94:  ADDWF  03,F
2D96:  MOVF   FF4,W
2D98:  ADDWFC 02,F
2D9A:  MOVLW  00
2D9C:  ADDWFC 01,F
2D9E:  MOVF   x19,W
2DA0:  MULWF  x1D
2DA2:  MOVF   FF3,W
2DA4:  ADDWF  02,F
2DA6:  MOVF   FF4,W
2DA8:  ADDWFC 01,F
2DAA:  INCF   00,F
2DAC:  BTFSC  01.7
2DAE:  BRA    2DBA
2DB0:  RLCF   x21,F
2DB2:  RLCF   03,F
2DB4:  RLCF   02,F
2DB6:  RLCF   01,F
2DB8:  DECF   00,F
2DBA:  MOVLW  00
2DBC:  BTFSS  x21.7
2DBE:  BRA    2DD4
2DC0:  INCF   03,F
2DC2:  ADDWFC 02,F
2DC4:  ADDWFC 01,F
2DC6:  MOVF   01,W
2DC8:  BNZ   2DD4
2DCA:  MOVF   02,W
2DCC:  BNZ   2DD4
2DCE:  MOVF   03,W
2DD0:  BNZ   2DD4
2DD2:  INCF   00,F
2DD4:  BTFSC  x20.7
2DD6:  BSF    01.7
2DD8:  BTFSS  x20.7
2DDA:  BCF    01.7
2DDC:  BRA    2DE6
2DDE:  CLRF   00
2DE0:  CLRF   01
2DE2:  CLRF   02
2DE4:  CLRF   03
2DE6:  MOVLB  0
2DE8:  RETURN 0
*
2F8A:  MOVLB  1
2F8C:  MOVF   xF7,W
2F8E:  SUBLW  B6
2F90:  MOVWF  xF7
2F92:  CLRF   03
2F94:  MOVFF  1F8,1FB
2F98:  BSF    xF8.7
2F9A:  BCF    FD8.0
2F9C:  RRCF   xF8,F
2F9E:  RRCF   xF9,F
2FA0:  RRCF   xFA,F
2FA2:  RRCF   03,F
2FA4:  RRCF   02,F
2FA6:  RRCF   01,F
2FA8:  RRCF   00,F
2FAA:  DECFSZ xF7,F
2FAC:  BRA    2F9A
2FAE:  BTFSS  xFB.7
2FB0:  BRA    2FC8
2FB2:  COMF   00,F
2FB4:  COMF   01,F
2FB6:  COMF   02,F
2FB8:  COMF   03,F
2FBA:  INCF   00,F
2FBC:  BTFSC  FD8.2
2FBE:  INCF   01,F
2FC0:  BTFSC  FD8.2
2FC2:  INCF   02,F
2FC4:  BTFSC  FD8.2
2FC6:  INCF   03,F
2FC8:  MOVLB  0
2FCA:  GOTO   30F0 (RETURN)
2FCE:  BTFSC  FD8.1
2FD0:  BRA    2FD8
2FD2:  MOVLW  01
2FD4:  MOVWF  FEA
2FD6:  SETF   FE9
2FD8:  CLRF   00
2FDA:  CLRF   01
2FDC:  CLRF   02
2FDE:  CLRF   03
2FE0:  MOVLB  1
2FE2:  CLRF   xFF
2FE4:  MOVLB  2
2FE6:  CLRF   x00
2FE8:  CLRF   x01
2FEA:  CLRF   x02
2FEC:  MOVLB  1
2FEE:  MOVF   xFE,W
2FF0:  IORWF  xFD,W
2FF2:  IORWF  xFC,W
2FF4:  IORWF  xFB,W
2FF6:  BZ    3084
2FF8:  MOVLW  20
2FFA:  MOVLB  2
2FFC:  MOVWF  x03
2FFE:  BCF    FD8.0
3000:  MOVLB  1
3002:  RLCF   xF7,F
3004:  RLCF   xF8,F
3006:  RLCF   xF9,F
3008:  RLCF   xFA,F
300A:  RLCF   xFF,F
300C:  MOVLB  2
300E:  RLCF   x00,F
3010:  RLCF   x01,F
3012:  RLCF   x02,F
3014:  MOVLB  1
3016:  MOVF   xFE,W
3018:  MOVLB  2
301A:  SUBWF  x02,W
301C:  BNZ   303A
301E:  MOVLB  1
3020:  MOVF   xFD,W
3022:  MOVLB  2
3024:  SUBWF  x01,W
3026:  BNZ   303A
3028:  MOVLB  1
302A:  MOVF   xFC,W
302C:  MOVLB  2
302E:  SUBWF  x00,W
3030:  BNZ   303A
3032:  MOVLB  1
3034:  MOVF   xFB,W
3036:  SUBWF  xFF,W
3038:  MOVLB  2
303A:  BNC   3076
303C:  MOVLB  1
303E:  MOVF   xFB,W
3040:  SUBWF  xFF,F
3042:  MOVF   xFC,W
3044:  BTFSS  FD8.0
3046:  INCFSZ xFC,W
3048:  BRA    304C
304A:  BRA    3052
304C:  MOVLB  2
304E:  SUBWF  x00,F
3050:  MOVLB  1
3052:  MOVF   xFD,W
3054:  BTFSS  FD8.0
3056:  INCFSZ xFD,W
3058:  BRA    305C
305A:  BRA    3062
305C:  MOVLB  2
305E:  SUBWF  x01,F
3060:  MOVLB  1
3062:  MOVF   xFE,W
3064:  BTFSS  FD8.0
3066:  INCFSZ xFE,W
3068:  BRA    306C
306A:  BRA    3072
306C:  MOVLB  2
306E:  SUBWF  x02,F
3070:  MOVLB  1
3072:  BSF    FD8.0
3074:  MOVLB  2
3076:  RLCF   00,F
3078:  RLCF   01,F
307A:  RLCF   02,F
307C:  RLCF   03,F
307E:  DECFSZ x03,F
3080:  BRA    2FFE
3082:  MOVLB  1
3084:  MOVFF  1FF,FEF
3088:  MOVFF  200,FEC
308C:  MOVFF  201,FEC
3090:  MOVFF  202,FEC
3094:  MOVLB  0
3096:  RETURN 0
3098:  MOVF   FE9,W
309A:  MOVLB  1
309C:  MOVWF  xEF
309E:  MOVF   xEE,W
30A0:  MOVWF  xF1
30A2:  BZ    30DC
30A4:  MOVFF  1ED,21B
30A8:  MOVFF  1EC,21A
30AC:  MOVFF  1EB,219
30B0:  MOVFF  1EA,218
30B4:  MOVLB  2
30B6:  CLRF   x1F
30B8:  CLRF   x1E
30BA:  MOVLW  20
30BC:  MOVWF  x1D
30BE:  MOVLW  82
30C0:  MOVWF  x1C
30C2:  MOVLB  0
30C4:  RCALL  2CF4
30C6:  MOVFF  03,1ED
30CA:  MOVFF  02,1EC
30CE:  MOVFF  01,1EB
30D2:  MOVFF  00,1EA
30D6:  MOVLB  1
30D8:  DECFSZ xF1,F
30DA:  BRA    30A4
30DC:  MOVFF  1ED,1FA
30E0:  MOVFF  1EC,1F9
30E4:  MOVFF  1EB,1F8
30E8:  MOVFF  1EA,1F7
30EC:  MOVLB  0
30EE:  BRA    2F8A
30F0:  MOVFF  03,1ED
30F4:  MOVFF  02,1EC
30F8:  MOVFF  01,1EB
30FC:  MOVFF  00,1EA
3100:  MOVLB  1
3102:  BTFSS  xED.7
3104:  BRA    3120
3106:  DECF   xEF,F
3108:  BSF    xEF.5
310A:  COMF   xEA,F
310C:  COMF   xEB,F
310E:  COMF   xEC,F
3110:  COMF   xED,F
3112:  INCF   xEA,F
3114:  BTFSC  FD8.2
3116:  INCF   xEB,F
3118:  BTFSC  FD8.2
311A:  INCF   xEC,F
311C:  BTFSC  FD8.2
311E:  INCF   xED,F
3120:  MOVLW  3B
3122:  MOVWF  xF6
3124:  MOVLW  9A
3126:  MOVWF  xF5
3128:  MOVLW  CA
312A:  MOVWF  xF4
312C:  CLRF   xF3
312E:  MOVLW  0A
3130:  MOVWF  xF1
3132:  MOVF   xEE,W
3134:  BTFSC  FD8.2
3136:  INCF   xEF,F
3138:  BSF    FD8.1
313A:  MOVLW  01
313C:  MOVWF  FEA
313E:  MOVLW  EA
3140:  MOVWF  FE9
3142:  MOVFF  1ED,1FA
3146:  MOVFF  1EC,1F9
314A:  MOVFF  1EB,1F8
314E:  MOVFF  1EA,1F7
3152:  MOVFF  1F6,1FE
3156:  MOVFF  1F5,1FD
315A:  MOVFF  1F4,1FC
315E:  MOVFF  1F3,1FB
3162:  MOVLB  0
3164:  RCALL  2FCE
3166:  MOVF   01,W
3168:  MOVF   00,F
316A:  BNZ   3192
316C:  MOVLB  1
316E:  INCF   xEE,W
3170:  SUBWF  xF1,W
3172:  BTFSS  FD8.2
3174:  BRA    317A
3176:  MOVLB  0
3178:  BRA    3192
317A:  MOVF   xEF,W
317C:  BZ    3198
317E:  ANDLW  0F
3180:  SUBWF  xF1,W
3182:  BZ    3186
3184:  BC    3214
3186:  BTFSC  xEF.7
3188:  BRA    3214
318A:  BTFSC  xEF.6
318C:  BRA    3198
318E:  MOVLW  20
3190:  BRA    3206
3192:  MOVLW  20
3194:  MOVLB  1
3196:  ANDWF  xEF,F
3198:  BTFSS  xEF.5
319A:  BRA    31BC
319C:  BCF    xEF.5
319E:  MOVF   xEE,W
31A0:  BTFSS  FD8.2
31A2:  DECF   xEF,F
31A4:  MOVF   00,W
31A6:  MOVWF  xEF
31A8:  MOVLW  2D
31AA:  MOVLB  2
31AC:  MOVWF  x73
31AE:  MOVLB  0
31B0:  CALL   1952
31B4:  MOVLB  1
31B6:  MOVF   xEF,W
31B8:  MOVWF  00
31BA:  CLRF   xEF
31BC:  MOVF   xEE,W
31BE:  SUBWF  xF1,W
31C0:  BNZ   31DE
31C2:  MOVF   00,W
31C4:  MOVWF  xEF
31C6:  MOVLW  2E
31C8:  MOVLB  2
31CA:  MOVWF  x73
31CC:  MOVLB  0
31CE:  CALL   1952
31D2:  MOVLB  1
31D4:  MOVF   xEF,W
31D6:  MOVWF  00
31D8:  MOVLW  20
31DA:  ANDWF  xEF,F
31DC:  MOVLW  00
31DE:  MOVLW  30
31E0:  BTFSS  xEF.5
31E2:  BRA    3206
31E4:  BCF    xEF.5
31E6:  MOVF   xEE,W
31E8:  BTFSS  FD8.2
31EA:  DECF   xEF,F
31EC:  MOVF   00,W
31EE:  MOVWF  xEF
31F0:  MOVLW  2D
31F2:  MOVLB  2
31F4:  MOVWF  x73
31F6:  MOVLB  0
31F8:  CALL   1952
31FC:  MOVLB  1
31FE:  MOVF   xEF,W
3200:  MOVWF  00
3202:  CLRF   xEF
3204:  MOVLW  30
3206:  ADDWF  00,F
3208:  MOVFF  00,273
320C:  MOVLB  0
320E:  CALL   1952
3212:  MOVLB  1
3214:  BCF    FD8.1
3216:  MOVFF  1F6,1FA
321A:  MOVFF  1F5,1F9
321E:  MOVFF  1F4,1F8
3222:  MOVFF  1F3,1F7
3226:  CLRF   xFE
3228:  CLRF   xFD
322A:  CLRF   xFC
322C:  MOVLW  0A
322E:  MOVWF  xFB
3230:  MOVLB  0
3232:  RCALL  2FCE
3234:  MOVFF  03,1F6
3238:  MOVFF  02,1F5
323C:  MOVFF  01,1F4
3240:  MOVFF  00,1F3
3244:  MOVLB  1
3246:  DECFSZ xF1,F
3248:  BRA    3138
324A:  MOVLB  0
324C:  GOTO   3B5A (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... //IMPORTANTE: el fuse PLL5 es un predivisor del reloj, que tiene valores 1,2,3,4,5,6,10,12
.................... //Dependiendo del cristal, se debe elegir el PLL para que al dividirlo
.................... //de una frecuencia de 4MHz
.................... #fuses HSPLL, NOWDT, NOPROTECT, NODEBUG, USBDIV, PLL5, CPUDIV1, VREGEN
.................... 
.................... #use delay(clock=48MHz,crystal=20MHz,USB_FULL)
*
1694:  MOVLW  01
1696:  MOVLB  2
1698:  SUBWF  x91,F
169A:  BNC   16B6
169C:  MOVLW  02
169E:  MOVWF  FEA
16A0:  MOVLW  91
16A2:  MOVWF  FE9
16A4:  MOVF   FEF,W
16A6:  BZ    16B6
16A8:  MOVLW  02
16AA:  MOVWF  00
16AC:  DECFSZ 00,F
16AE:  BRA    16AC
16B0:  BRA    16B2
16B2:  DECFSZ FEF,F
16B4:  BRA    16A8
16B6:  MOVLB  0
16B8:  RETURN 0
*
18FA:  MOVLW  02
18FC:  MOVWF  FEA
18FE:  MOVLW  51
1900:  MOVWF  FE9
1902:  MOVF   FEF,W
1904:  BZ    1922
1906:  MOVLW  0F
1908:  MOVWF  01
190A:  CLRF   00
190C:  DECFSZ 00,F
190E:  BRA    190C
1910:  DECFSZ 01,F
1912:  BRA    190A
1914:  MOVLW  8F
1916:  MOVWF  00
1918:  DECFSZ 00,F
191A:  BRA    1918
191C:  NOP   
191E:  DECFSZ FEF,F
1920:  BRA    1906
1922:  RETURN 0
.................... #use FIXED_IO( E_outputs=PIN_E0 )
.................... //#use FIXED_IO( A_outputs=PIN_A4 )
.................... //#use FIXED_IO( B_inputs=PIN_B2 )
.................... 
.................... #define RF_RESET   PIN_E0
.................... #define DIO_0 PIN_B3
.................... #define DIO_2 PIN_B4
.................... #define DIO_1 PIN_A4
.................... #define BUTTON_3 PIN_D4
.................... 
.................... 
.................... //#define USB_CABLE_IS_ATTACHED()  input(PIN_B2)
.................... #define USB_CONFIG_VID 0x2405
.................... #define USB_CONFIG_PID 0x000B
.................... #define USB_CONFIG_BUS_POWER 500
.................... 
.................... // if USB_CDC_ISR is defined, then this function will be called
.................... // by the USB ISR when there incoming CDC (virtual com port) data.
.................... // this is useful if you want to port old RS232 code that was use
.................... // #int_rda to CDC.
.................... #define USB_CDC_ISR() RDA_isr()
.................... 
.................... // in order for handle_incoming_usb() to be able to transmit the entire
.................... // USB message in one pass, we need to increase the CDC buffer size from
.................... // the normal size and use the USB_CDC_DELAYED_FLUSH option.
.................... // failure to do this would cause some loss of data.
.................... #define USB_CDC_DELAYED_FLUSH
.................... #define USB_CDC_DATA_LOCAL_SIZE  128
.................... 
.................... 
.................... 
.................... static void RDA_isr(void);
.................... 
.................... #include <usb_cdc.h>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////                            usb_cdc.h                            ////
.................... ////                                                                 ////
.................... //// Library for adding a virtual COM port on your PC over USB using ////
.................... //// the standard Communication Device Class (CDC) specification.    ////
.................... //// Including this file in your code will add all USB code,         ////
.................... //// interrupts, descriptors and handlers required.  No other        ////
.................... //// modifications need to be made.                                  ////
.................... ////                                                                 ////
.................... //// This library creates a virtual RS232 link between the PC and    ////
.................... //// the PIC, therefore the library provided will be familiar to     ////
.................... //// anyone with standard UART stream I/O:                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          ////
.................... ////      character received and waiting in the receive buffer.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  ////
.................... ////      there is no data in the receive buffer it will wait until  ////
.................... ////      there is data in the receive buffer.  If you do not want   ////
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   ////
.................... ////      check if there is data before calling usb_cdc_getc().      ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       ////
.................... ////      buffer.  If the transmit buffer is full it will wait until ////
.................... ////      the transmit buffer is not full before putting the char    ////
.................... ////      into the transmit buffer.  The transmit buffer is read by  ////
.................... ////      the PC very quickly, and therefore the buffer should only  ////
.................... ////      be full for a few milli-seconds.  If you are concerned     ////
.................... ////      and don't want to be stuck in a long or infinite loop,     ////
.................... ////      use usb_cdc_putready() to see if there is space in the     ////
.................... ////      transmit buffer before putting data into the transmit      ////
.................... ////      buffer.                                                    ////
.................... ////                                                                 ////
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    ////
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'ptr' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    ////
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'len' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putready() - Returns the number of bytes available      ////
.................... ////     in the TX buffer for storing characters.  If this returns   ////
.................... ////     0 then the buffer is full and waiting for the host (PC)     ////
.................... ////     to read the buffer.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   ////
.................... ////     empty and fully flushed/transmitted to host (PC).           ////
.................... ////                                                                 ////
.................... //// usb_cdc_connected() - Returns TRUE if we received a             ////
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   ////
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        ////
.................... ////      message when the program starts and it opens the virtual   ////
.................... ////      COM port.  This is a simple way to determine if the PC     ////
.................... ////      is ready to display data on a serial terminal program,     ////
.................... ////      but is not garaunteed to work all the time or on other     ////
.................... ////      terminal programs.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   ////
.................... ////      if the transmit buffer is full it will skip the char.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  ////
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   ////
.................... ////                                                                 ////
.................... //// usb_cdc_break - If the PC has sent a break command, this will   ////
.................... ////       hold the break time (in milli-seconds).  If the PC sends  ////
.................... ////       a value of 0xFFFF the device is supposed to hold the      ////
.................... ////       break until it sends a value of 0                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. ////
.................... ////       Of most relevance is the field dte_present, which is the  ////
.................... ////       DTR setting.                                              ////
.................... ////                                                                 ////
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          ////
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   ////
.................... ////       ring, break and more.  See the documentation above        ////
.................... ////       usb_cdc_serial_state() for more information, including    ////
.................... ////       format of state structure.                                ////
.................... ////                                                                 ////
.................... //// The following functions are also provided, and are ports of the ////
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   ////
.................... //// documentation:                                                  ////
.................... ////   get_float_usb() - Read a float number from the user           ////
.................... ////   get_long_usb() - Read a long number from the user             ////
.................... ////   get_int_usb() - Read an integer number from the user          ////
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. ////
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             ////
.................... ////   gethex1_usb() - Read a HEX character                          ////
.................... ////                                                                 ////
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  ////
.................... //// be called when there is incoming CDC (virtual com port) data.   ////
.................... //// This is useful if you want to update legacy RS232 code that     ////
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    ////
.................... //// However, see the INTERRUPT LIMITATIONS section below.           ////
.................... ////                                                                 ////
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    ////
.................... ////  to flush the data as soon as possible.  However at times       ////
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   ////
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         ////
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     ////
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       ////
.................... ////  also attempt to flush the packet on each call to usb_task().   ////
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     ////
.................... ////  if you have a main loop that periodically calls usb_task().    ////
.................... ////                                                                 ////
.................... //// This driver will load all the rest of the USB code, and a set   ////
.................... //// of descriptors that will properly describe a CDC device for a   ////
.................... //// virtual COM port (usb_desc_cdc.h)                               ////
.................... ////                                                                 ////
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      ////
.................... //// standard CDC drivers for a virtual COM port in Windows          ////
.................... //// NT/2000/XP and above.                                           ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// Encapsuated Messages: (USB_CDC_USE_ENCAPSULATED)                ////
.................... //// -------------------------------------------------------------   ////
.................... ////                                                                 ////
.................... //// If USB_CDC_USE_ENCAPSULATED is defined, then the user must      ////
.................... //// provide the following callbacks in their application to provide ////
.................... //// encapsuated message support (SendEncapsulatedCommand and        ////
.................... ////  GetEncapsulatedResponse):                                      ////
.................... ////                                                                 ////
.................... //// usb_cdc_SendEncapsulatedCommand(byte *ptr, unsigned int16 num)  ////
.................... ////     PIC receives encapsulated command from host (PC), 'num'     ////
.................... ////     bytes of message stored in 'ptr'.                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_GetEncapsulatedResponse(byte *ptr, unsigned int16 num)  ////
.................... ////     Host (PC) is asking for 'num' bytes response from the PIC,  ////
.................... ////     PIC should store up to 'num' bytes to 'ptr' as the          ////
.................... ////     response.                                                   ////
.................... ////                                                                 ////
.................... //// Due to the design of the USB stack, all encapsulated messages   ////
.................... //// must be smaller than one endpoint 0 packet.  They cannot be     ////
.................... //// equal in size or larger than the endpoint 0 size.  See          ////
.................... //// USB_MAX_EP0_PACKET_LENGTH.                                      ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// BUFFER SIZES                                                    ////
.................... //// -------------------------------------------------------------   ////
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     ////
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        ////
.................... ////  Full speed devices limit this value to be 64.  To increase     ////
.................... ////  the size of the local PIC buffer you can also define           ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        ////
.................... ////  defined then the total PIC->PC buffer size would be            ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  ////
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      ////
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      ////
.................... ////  then this option isn't used.                                   ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// INTERRUPT LIMITATIONS                                           ////
.................... //// -------------------------------------------------------------   ////
.................... //// This section is only relevant if you are using USB interrupts   ////
.................... ////  and not the USB_ISR_POLLING option.                            ////
.................... ////                                                                 ////
.................... //// USB handling is complex, often requiring several packet         ////
.................... ////  transmissions to accomplish transfer of one block of data.     ////
.................... ////  Most of this processing is done in the USB ISR.  Because       ////
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the ////
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   ////
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  ////
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  ////
.................... ////  overflow the TX buffer than data will be lost.                 ////
.................... ////                                                                 ////
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB ////
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      ////
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           ////
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    ////
.................... ////                                                                 ////
.................... //// ex_usb_serial3.c shows an example of working around these       ////
.................... ////  ISR limitations.  Failure to follow these limitations can      ////
.................... ////  cause the PIC to lockup.  These limtations only need to be     ////
.................... ////  followed in the conditions listed above (writing code in the   ////
.................... ////  ISR or interrupts are disabled).                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// VERSION HISTORY                                                 ////
.................... ////                                                                 ////
.................... //// Nov 20th, 2014:                                                 ////
.................... ////  While usb_cdc_putc() waits for local buffer to be free, also   ////
.................... ////     check the endpoint buffer in case there was a situation     ////
.................... ////     that the ISR for this event was missed.                     ////
.................... ////                                                                 ////
.................... //// Dec 16th, 2013:                                                 ////
.................... ////  Added encapsulated message support.  See                       ////
.................... ////     USB_CDC_USE_ENCAPSULATED above for documentation.           ////
.................... ////                                                                 ////
.................... //// May 31st, 2013:                                                 ////
.................... ////  usb_cdc_putready() now returns the number of bytes available.  ////
.................... ////                                                                 ////
.................... //// May 23rd, 2013:                                                 ////
.................... ////  Added usb_cdc_putd().                                          ////
.................... ////                                                                 ////
.................... //// February 18th, 2013:                                            ////
.................... ////  Enhanced PIC16 support added.                                  ////
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 ////
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    ////
.................... ////                                                                 ////
.................... //// September 13th, 2012:                                           ////
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     ////
.................... ////     (PIC24, dsPIC33).                                           ////
.................... ////  Added usb_cdc_putempty().                                      ////
.................... ////                                                                 ////
.................... //// December 16th, 2011:                                            ////
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will ////
.................... ////     only include the get string helper functions.  This is      ////
.................... ////     a rarely used option, used only if you already wrote your   ////
.................... ////     own getc() and putc() routines.                             ////
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  ////
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      ////
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  ////
.................... ////                                                                 ////
.................... //// Oct 27th, 2011:                                                 ////
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    ////
.................... ////     documentation.  In order for this to work,                  ////
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   ////
.................... ////                                                                 ////
.................... //// Jan 28, 2010:                                                   ////
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    ////
.................... ////     one packet.                                                 ////
.................... ////                                                                 ////
.................... //// Jan 25, 2010:                                                   ////
.................... ////  Ignore incoming 0 length packets.                              ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// April 7th, 2009:                                                ////
.................... ////   Vista 'code 10' issues resolved.                              ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 26th, 2007:                                                 ////
.................... ////              usb_cdc_put_buffer_free() should be more stable.   ////
.................... ////              Fixed a hang-up that would happen if you sent      ////
.................... ////                 exactly 64 bytes.                               ////
.................... ////                                                                 ////
.................... //// Nov 6th, 2007:                                                  ////
.................... ////              Compatabible with latest pic18_usb.h, which        ////
.................... ////                 reduces RAM footprint of USB driver.            ////
.................... ////              This driver now fits on 18F4450/2450 PICs.         ////
.................... ////                                                                 ////
.................... //// October 27th, 2005: Changed the way incoming packets are        ////
.................... ////               handled in that CDC driver will not flush         ////
.................... ////               endpoint until user has handled all data.  This   ////
.................... ////               will prevent overflows as the USB will NAK        ////
.................... ////               incoming packets until it is ready to receive     ////
.................... ////               more.                                             ////
.................... ////            When using 18F4550 family, the RX buffer is          ////
.................... ////               mapped directly to the endpoint buffer - this     ////
.................... ////               saves a chunk of RAM.                             ////
.................... ////            When using the 18F4550 family, you can increase      ////
.................... ////               the TX and RX size over 64 bytes.                 ////
.................... ////            No longer send 0len packets in the TBE interrupt.    ////
.................... ////            Hopefully fixed bugs that caused random crashes      ////
.................... ////               if you tried sending more than 64 bytes.          ////
.................... ////                                                                 ////
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   ////
.................... ////                   buffer.                                       ////
.................... ////                                                                 ////
.................... //// July 1st, 2005: Initial Release.                                ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... //input.c ported to use CDC:
.................... float get_float_usb();
.................... signed long get_long_usb();
.................... signed int get_int_usb();
.................... void get_string_usb(char* s, unsigned int max);
.................... char gethex_usb();
.................... char gethex1_usb();
.................... 
.................... #if !defined(__USB_CDC_HELPERS_ONLY__)
.................... 
.................... //api for the user:
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got)
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free())
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin)
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding)
.................... void usb_cdc_putc_fast(char c);
.................... char usb_cdc_getc(void);
.................... void usb_cdc_putc(char c);
.................... void usb_cdc_get_discard(void);
.................... 
.................... //functions automatically called by USB handler code
.................... void usb_isr_tkn_cdc(void);
.................... void usb_cdc_init(void);
.................... void usb_isr_tok_out_cdc_control_dne(void);
.................... void usb_isr_tok_in_cdc_data_dne(void);
.................... void usb_isr_tok_out_cdc_data_dne(void);
.................... 
.................... void usb_cdc_flush_tx_buffer(void);
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //
.................... // Include the CCS USB Libraries.  See the comments at the top of these
.................... // files for more information
.................... //
.................... /////////////////////////////////////////////////////////////////////////////
.................... #ifndef __USB_PIC_PERIF__
.................... #define __USB_PIC_PERIF__   1
.................... #endif
.................... 
.................... #if __USB_PIC_PERIF__
....................    #if defined(__PCM__)
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c
....................    #elif defined(__PCH__)
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.h                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  This hardware layer      ////
.................... //// supports the USB peripheral on the PIC18 family chips.  Current ////
.................... //// supported families are:                                         ////
.................... ////     PIC18F2455/2550/4455/4550                                   ////
.................... ////     PIC18F2450/4450                                             ////
.................... ////     PIC18F2458/2553/4458/4553                                   ////
.................... ////     PIC18F13K50/14K50                                           ////
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     ////
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       ////
.................... ////     PIC18FxxK50                                                 ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      ////
.................... //// that are specific to only this HW peripheral that you may       ////
.................... //// find useful to use in your application.                         ////
.................... ////                                                                 ////
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    ////
.................... ////  Due to the limited USB RAM of this family, a limitation of     ////
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   ////
.................... ////  The HW actually supports more endpoints, but to simplify       ////
.................... ////  driver development this driver will only support the first 3   ////
.................... ////  so there is an easier memory block to work with.               ////
.................... ////                                                                 ////
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     ////
.................... ////  of USB speed, to save RAM.                                     ////
.................... ////                                                                 ////
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    ////
.................... ////  If you are not using internal pullups, you will need to put    ////
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    ////
.................... ////  want to use slow speed or full speed.  This code configures    ////
.................... ////  the device to use internal pullups, see usb_init() if you      ////
.................... ////  want to change that.                                           ////
.................... ////                                                                 ////
.................... ////  You need approximately 470nF cap on Vusb, even if you are      ////
.................... ////  using the internal 3.3V USB regulator.                         ////
.................... ////                                                                 ////
.................... ////  To run at full speed, you must use the oscillator              ////
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   ////
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     ////
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      ////
.................... ////  96MHz clock.  See the datasheet for details.                   ////
.................... ////                                                                 ////
.................... ////  To run at slow speed you must configure your MCU to run at     ////
.................... ////  24Mhz.  See the datasheet for details.                         ////
.................... ////                                                                 ////
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   ////
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the ////
.................... //// PIC when an event has happened on the USB Bus.  Therfore        ////
.................... //// this code enables interrupts.  A user modification can be made  ////
.................... //// to poll the USB interrupt flag instead of relying on an         ////
.................... //// interrupt.                                                      ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_H__
.................... #DEFINE __PIC18_USB_H__
.................... 
.................... #DEFINE __USB_HARDWARE__
.................... 
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral
.................... #DEFINE __PIC__   1
.................... 
.................... #ifndef USB_USE_FULL_SPEED
....................  #define USB_USE_FULL_SPEED   1
.................... #endif
.................... 
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................    //due to limited ram, force max packet length to 8 for this chip
....................    #define USB_MAX_EP0_PACKET_LENGTH   8
.................... #else
....................    #if USB_USE_FULL_SPEED==0
....................       //slow speed requires 8byte max packet size for endpoint 0
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8
....................    #else
....................       //for full speed you can still use 8bytes, but 64 will be faster
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64
....................    #endif
.................... #endif
.................... #endif
.................... 
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8))
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8
....................  #error Max Endpoint 0 length can't be less than 8!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64
....................  #error Max Endpoint 0 length can't be greater than 64!
.................... #endif
.................... 
.................... #include <usb_hw_layer.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_hw_layer.h                            ////
.................... ////                                                                   ////
.................... //// HW Layer for the USB Stack.                                       ////
.................... ////                                                                   ////
.................... //// HW drivers for the USB stack must support this API.               ////
.................... ////                                                                   ////
.................... //// The HW driver must also have a token handler that will call       ////
.................... //// usb_token_reset() when the device is init/reset, will call        ////
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          ////
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    ////
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     ////
.................... //// See usb.h for documentation of these functions.                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __USB_HW_LAYER_H__
.................... #define __USB_HW_LAYER_H__
.................... 
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0,
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4};
.................... 
.................... 
.................... // USER LEVEL FUNCTIONS:
.................... 
.................... /*****************************************************************************
.................... /* usb_init()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_init_cs()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_cs(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_task()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_task(void);
.................... 
.................... /******************************************************************************
.................... /* usb_attach()
.................... /*
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral.
.................... /*
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt.
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_attach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_detach()
.................... /*
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB.
.................... /*
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* If the user does call this function while USB is connected, the USB 
.................... /* peripheral will be disabled only momentarily because usb_task() will
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB
.................... /* reset of the device.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_detach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_put_packet()
.................... /*
.................... /* Input: endpoint - endpoint to send packet to (0..15).
.................... /*        ptr - points to data to send.
.................... /*        len - amount of data to send.
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, 
.................... /*                 or toggle from the last DATAx pid.
.................... /*
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only 
.................... /*         reason it will return FALSE is if because the TX buffer is still full 
.................... /*         from the last time it tried to send a packet.
.................... /*
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a 
.................... /*          difference between a packet and a message.  If you wanted to send a 
.................... /*          512 byte message on an endpoint that only supported 64 byte packets,
.................... /*          this would be accomplished this by sending 8 64-byte packets, 
.................... /*          followed by a 0 length packet.  If the last (or only packet) being 
.................... /*          sent is less than the max packet size defined in your descriptor 
.................... /*          then you do not need to send a 0 length packet to identify
.................... /*          an end of message.
.................... /*
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message 
.................... /*          correctly and know if a 0 lenght packet needs to be sent.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl);
.................... 
.................... /*******************************************************************************
.................... /* usb_get_packet(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer and saved to ptr.
.................... /*
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS!
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()!
.................... /*
.................... /* Summary: Gets a packet of data from the USB endpoint buffer.
.................... /*          Until this is called, if there is data in the receive buffer the
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be
.................... /*          allowed to send a new packet.  Only receives one packet, if you need 
.................... /*          to receive multiple packets or handle 0-length terminator packets,
.................... /*          then use usb_gets().
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /********************************************************************************/
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max);
.................... 
.................... /****************************************************************************
.................... /* usb_kbhit(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check (0..15)
.................... /*
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not.
.................... /*
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers.
.................... /*          See API section of USB.H for more information.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_kbhit(unsigned int8 en);
.................... 
.................... /******************************************************************************
.................... /* usb_tbe(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last
.................... /*         transmit or if this endpoint is invalid.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_tbe(unsigned int8 en);
.................... 
.................... //////////////// END USER LEVEL FUNCTIONS /////////////////////////////////////
.................... 
.................... 
.................... ///
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by
.................... ///            the USB stack, and are not meant to be called by the 
.................... ///            user/application.
.................... ///
.................... 
.................... /*****************************************************************************
.................... /* usb_stall_ep()
.................... /*
.................... /* Input: endpoint - endpoint to stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will
.................... /*          send STALL packet if the host tries to access this endpoint's 
.................... /*          buffer.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_stall_ep(unsigned int8 endpoint);
.................... 
.................... 
.................... /*****************************************************************************
.................... /* usb_unstall_ep(endpoint, direction)
.................... /*
.................... /* Input: endpoint - endpoint to un-stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Un-stalls endpoint.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_unstall_ep(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_endpoint_stalled()
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not.
.................... /*
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to
.................... /*          see if endpoint has been issued a STALL, just whether or not it is
.................... /*          configured to STALL on the next packet.  See Set_Feature and 
.................... /*          Clear_Feature Chapter 9 requests.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_set_address(address)
.................... /*
.................... /* Input: address - address the host specified that we use
.................... /*
.................... /* Summary: Configures the USB Peripheral for the specified device address.  
.................... /*          The host will now talk to use with the following address.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_address(unsigned int8 address);
.................... 
.................... /******************************************************************************
.................... /* usb_set_configured()
.................... /*
.................... /* Input: config - Configuration to use.  0 to uncofigure device.
.................... /*
.................... /* Summary: Configures or unconfigures device.  If configuring device it will
.................... /*          enable all the endpoints the user specified for this configuration.
.................... /*          If un-configuring device it will disable all endpoints.
.................... /*
.................... /*          NOTE: CCS only provides code to handle 1 configuration.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_configured(unsigned int8 config);
.................... 
.................... /******************************************************************************
.................... /* usb_disable_endpoints()
.................... /*
.................... /* Summary: Disables endpoints (all endpoints but 0)
.................... /*
.................... /*****************************************************************************/
.................... void usb_disable_endpoints(void);
.................... 
.................... 
.................... /*******************************************************************************
.................... /* usb_disable_endpoint()
.................... /*
.................... /* Input: Endpoint to disable (0..15)
.................... /*
.................... /* Summary: Disables specified endpoint
.................... /*
.................... /********************************************************************************/
.................... void usb_disable_endpoint(unsigned int8 en);
.................... 
.................... /**************************************************************
.................... /* usb_request_send_response(len)
.................... /* usb_request_get_data()
.................... /* usb_request_stall()
.................... /*
.................... /* Input: len - size of packet to send
.................... /*
.................... /* Summary: One of these 3 functions will be called by the USB stack after
.................... /*          handling a SETUP packet.
.................... /*          
.................... /*          After we process a SETUP request, we have 1 of three responses:
.................... /*            1.) send a response IN packet
.................... /*            2.) wait for followup OUT packet(s) with data
.................... /*            3.) stall because we don't support that SETUP request
.................... /*
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold
.................... /*          the response and the USB Request handler code will call
.................... /*          usb_request_send_response() to let us know how big the packet is.
.................... /*
.................... /*          If we are waiting for more data, usb_request_get_data() will
.................... /*          be called by the USB request handler code to configure the EP0 OUT
.................... /*          endpoint to be ready for more data
.................... /*
.................... /*          If we don't support a request, usb_request_stall() will be called
.................... /*          by the USB request handler code to stall the endpoint 0.
.................... /*
.................... /*          The operation of these functions depends on how SETUP packets
.................... /*          are handled in the hardware layer.
.................... /*
.................... /***************************************************************/
.................... void usb_request_send_response(unsigned int8 len);
.................... void usb_request_get_data(void);
.................... void usb_request_stall(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... //////////////////////// EXTRA USER FUNCTIONS /////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_flush_in()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for transfer
.................... /*        len - length of data that is being tramsferred
.................... /*        tgl - Data toggle synchronization for this packet
.................... /*
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint)
.................... /*
.................... /* Summary: Marks the endpoint ready for transmission.  You must
.................... /*          have already loaded the endpoint buffer with data.
.................... /*          (IN is PIC -> PC).
.................... /*          This routine is useful if you want to setup an endpoint by
.................... /*          writing to the buffer directly.
.................... /*          This routine is not necessary if you use usb_put_packet().
.................... /***************************************************************/
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_flush_out()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for release
.................... /*        tgl - Data toggle synchronization to expect in the next packet
.................... /*
.................... /* Output: NONE
.................... /*
.................... /* Summary: Clears the previously received packet, and then marks this
.................... /*          endpoint's receive buffer as ready for more data.
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not
.................... /*          want to use usb_get_packet(), instead you want to handle with
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size().
.................... /*          This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_rx_packet_size()
.................... /*
.................... /* Input: endpoint - which endpoint to mark to check
.................... /*
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer.
.................... /*
.................... /* Summary: Read the number of data stored in the receive buffer.  When you
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint.
.................... /*    This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... int16 usb_rx_packet_size(int8 endpoint);
.................... 
.................... #ENDIF
.................... 
....................    #else
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
....................    #endif
.................... #else
....................    #include <usbn960x.h>
.................... #endif
.................... #ifndef __USB_DESCRIPTORS__
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_desc_cdc.h                            ////
.................... ////                                                                   ////
.................... //// An example set of device / configuration descriptors for use with ////
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// Oct 27th, 2011:                                                   ////
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     ////
.................... ////     send SERIAL_STATE messages in one packet.                     ////
.................... ////                                                                   ////
.................... //// April 7th, 2009:                                                  ////
.................... ////   Vista 'code 10' issues resolved.                                ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// 10/28/05:                                                         ////
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        ////
.................... ////    packets.                                                       ////
.................... ////    Changed device to USB 1.10                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
.................... #DEFINE __USB_DESCRIPTORS__
.................... 
.................... ///////// config options, although it's best to leave alone for this demo /////
.................... #ifndef  USB_CONFIG_PID
....................    #define  USB_CONFIG_PID       0x000b
.................... #endif
.................... #ifndef  USB_CONFIG_VID
....................    #define  USB_CONFIG_VID       0x2405
.................... #endif
.................... #ifndef  USB_CONFIG_BUS_POWER
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500)
.................... #endif
.................... #ifndef  USB_CONFIG_VERSION
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99
.................... #endif
.................... //////// end config ///////////////////////////////////////////////////////////
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #DEFINE USB_HID_DEVICE  false
.................... #DEFINE USB_CDC_DEVICE  true
.................... 
.................... #define USB_CDC_COMM_IN_ENDPOINT       1
.................... #ifndef USB_CDC_COMM_IN_SIZE
.................... #define USB_CDC_COMM_IN_SIZE           11
.................... #endif
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE
.................... 
.................... //pic to pc endpoint config
.................... #define USB_CDC_DATA_IN_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_IN_SIZE
.................... #define USB_CDC_DATA_IN_SIZE           64
.................... #endif
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE
.................... 
.................... //pc to pic endpoint config
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_OUT_SIZE
.................... #define USB_CDC_DATA_OUT_SIZE           64
.................... #endif
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start config descriptor
.................... ///   right now we only support one configuration descriptor.
.................... ///   the config, interface, class, and endpoint goes into this array.
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints)
.................... 
....................    const char USB_CONFIG_DESC[] = {
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE:
....................       //    config(s)
....................       //    interface(s)
....................       //    class(es)
....................       //    endpoint(s)
.................... 
....................    //config_descriptor for config index 1
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3
....................          2, //number of interfaces this device supports       ==4
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5
....................          0x00, //index of string descriptor for this configuration      ==6
....................         #if USB_CONFIG_BUS_POWER
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #else
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #endif
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8
.................... 
.................... 
....................    //interface descriptor 0 (comm class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11
....................          0x00, //alternate setting     ==12
....................          1, //number of endpoints   ==13
....................          0x02, //class code, 02 = Comm Interface Class     ==14
....................          0x02, //subclass code, 2 = Abstract     ==15
....................          0x01, //protocol code, 1 = v.25ter      ==16
....................          0x00, //index of string descriptor for interface      ==17
.................... 
....................    //class descriptor [functional header]
....................          5, //length of descriptor    ==18
....................          0x24, //dscriptor type (0x24 == )      ==19
....................          0, //sub type (0=functional header) ==20
....................          0x10,0x01, //      ==21,22 //cdc version
.................... 
....................    //class descriptor [acm header]
....................          4, //length of descriptor    ==23
....................          0x24, //dscriptor type (0x24 == )      ==24
....................          2, //sub type (2=ACM)   ==25
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State.
.................... 
....................    //class descriptor [union header]
....................          5, //length of descriptor    ==27
....................          0x24, //dscriptor type (0x24 == )      ==28
....................          6, //sub type (6=union)    ==29
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union.
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. *
.................... 
....................    //class descriptor [call mgmt header]
....................          5, //length of descriptor    ==32
....................          0x24, //dscriptor type (0x24 == )      ==33
....................          1, //sub type (1=call mgmt)   ==34
....................          0, //capabilities          ==35  //device does not handle call management itself
....................          1, //data interface        ==36  //interface number of data class interface
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43
.................... 
....................    //interface descriptor 1 (data class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46
....................          0x00, //alternate setting     ==47
....................          2, //number of endpoints   ==48
....................          0x0A, //class code, 0A = Data Interface Class     ==49
....................          0x00, //subclass code      ==50
....................          0x00, //protocol code      ==51
....................          0x00, //index of string descriptor for interface      ==52
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55
....................          0x02, //transfer type supported (0x02 is bulk)         ==56
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58
....................          1,  //polling interval, in ms.   ==59
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62
....................          0x02, //transfer type supported (0x02 is bulk)         ==63
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67
....................          1  //polling interval, in ms.   ==68
....................    };
.................... 
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ********
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find
....................    //  a specific descriptor in the above table.
.................... 
....................    //the maximum number of interfaces seen on any config
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2
....................    #define USB_MAX_NUM_INTERFACES   2
.................... 
....................    //define how many interfaces there are per config.  [0] is the first config, etc.
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2};
.................... 
....................    //define where to find class descriptors
....................    //first dimension is the config number
....................    //second dimension specifies which interface
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface
....................    //if a class descriptor is not valid, set the value to 0xFFFF
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]=
....................    {
....................    //config 1
....................       //interface 0
....................          //class 1-4
....................          18,23,27,32,
....................       //interface 1
....................          //no classes for this interface
....................          0xFF,0xFF,0xFF,0xFF
....................    };
.................... 
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN)
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly
....................    #endif
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start device descriptors
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={
....................       //starts of with device configuration. only one possible
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1
....................          0x10,0x01, //usb version in bcd  ==2,3
....................          0x02, //class code. 0x02=Communication Device Class ==4
....................          0x00, //subclass code ==5
....................          0x00, //protocol code ==6
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14
....................          0x02, //index of string descriptor of the product  ==15
....................          0x00, //index of string descriptor of serial number  ==16
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17
....................    };
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start string descriptors
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone.
.................... ///
.................... ///   You must define the length else get_next_string_character() will not see the string
.................... ///   Current code only supports 10 strings (0 thru 9)
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
.................... #if !defined(USB_STRINGS_OVERWRITTEN)
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored.
.................... // Strings are saved as unicode.
.................... // These strings are mostly only displayed during the add hardware wizard.
.................... // Once the operating system drivers have been installed it will usually display
.................... // the name from the drivers .INF.
.................... char const USB_STRING_DESC[]={
....................    //string 0
....................          4, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          0x09,0x04,   //Microsoft Defined for US-English
....................    //string 1  - manufacturer
....................          8, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................    //string 2 - product
....................          32, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................          ' ',0,
....................          'U',0,
....................          'S',0,
....................          'B',0,
....................          ' ',0,
....................          't',0,
....................          'o',0,
....................          ' ',0,
....................          'U',0,
....................          'A',0,
....................          'R',0,
....................          'T',0
.................... };
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN)
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... struct {
....................    int1 got;
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100
....................    unsigned int16 len;
....................    unsigned int16 index;
....................   #else
....................    unsigned int8 len;
....................    unsigned int8 index;
....................   #endif
.................... } usb_cdc_get_buffer_status;
.................... 
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             usb.c                                 ////
.................... ////                                                                   ////
.................... //// Standard USB request and token handler code.                      ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... //// The majority of this code is called and used by the interrupt     ////
.................... //// generated by the hardware level, and therefore it is not meant    ////
.................... //// to be called by the user.  The functions that are meant to be     ////
.................... //// called by the user (init, put packet, get packet, etc) are        ////
.................... //// documented in USB.H.                                              ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////    This code will not create a multiple configuration device.     ////
.................... ////    If you wish to create a multiple configuration device then you ////
.................... ////    will have to modify these drivers.                             ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    ////
.................... ////   requests.  These requests are optional.  If you want to support ////
.................... ////   these requests you must provide the code yourself.  See         ////
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      ////
.................... ////   support.                                                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// If you wish to provide your own USB peripheral hardware layer, it ////
.................... //// must must provide the API as described in usb_hw_layer.h.         ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 20, 2015                                                    ////
.................... ////     USB_STRING_DESC_OFFSET no longer used.                        ////
.................... ////                                                                   ////
.................... //// Feb 6th, 2015                                                     ////
.................... ////     Fixed 'len' not being intiailized in usb_gets()               ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// June 8th, 2011:                                                   ////
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  ////
.................... ////     (for no timeout) resolved.                                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// November 13th, 2009:                                              ////
.................... ////  usb_endpoint_is_valid() has an extra check.                      ////
.................... ////                                                                   ////
.................... //// June 9th, 2009:                                                   ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// Dec 14, 2007:                                                     ////
.................... ////  usb_kbhit() moved to device driver.                              ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    ////
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release.                                         ////
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     ////
.................... ////    layer.                                                         ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////  TODO: alot of indexing and length handling for descriptors is    ////
.................... ////   only 8bit, so make sure all descriptor tables are less than     ////
.................... ////   256 bytes long.                                                 ////
.................... ////                                                                   ////
.................... //// Apr 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     ////
.................... ////   usb_ep_tx_size[] defined in usb.h                               ////
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             ////
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  ////
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     ////
.................... ////   the endpoint buffer until you usb_get_packet(), which will      ////
.................... ////   then free the endpoint buffer for more data.  This affects      ////
.................... ////   routines such as usb_gets() and usb_kbhit().                    ////
.................... ////  usb_gets() no longer reads buffered data (see above note),       ////
.................... ////   now it reads multiple packets in the same way usb_puts()        ////
.................... ////   writes multiple packets                                         ////
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  ////
.................... ////   layer.                                                          ////
.................... ////                                                                   ////
.................... //// Nov 11th, 2004:                                                   ////
.................... ////  No longer includes wrong descriptor header.                      ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   ////
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    ////
.................... ////                     although it didn't cause any serious problems ////
.................... ////                                                                   ////
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  ////
.................... ////                     problems with multiple packet messages        ////
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   ////
.................... ////                     descriptors that require a 0 len packet to    ////
.................... ////                     end message.                                  ////
.................... ////                                                                   ////
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DRIVER__
.................... #DEFINE __USB_DRIVER__
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #else
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) 
....................    {
....................       while(len--)
....................       {
....................          debug_usb_packet(debug_putc, "%02X", *ptr++);
....................       }
....................    }
.................... #endif
.................... 
.................... // legacy
.................... #ifndef debug_usb
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l)
.................... #endif
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if defined(__PIC16F_USB_H__)
....................  #include <pic16f_usb.c>
.................... #endif
.................... 
.................... #if defined(__PIC18_USB_H__)
....................  #include <pic18_usb.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.c                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     ////
.................... //// documentation about the PIC18 hardware layer.                   ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Dec 12, 2016:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Mar 20, 2015:                                                   ////
.................... ////  When TXing a packet, set UOWN bit as a different instruction   ////
.................... ////     as the rest of the BDSTAT flags.  Doing it this way         ////
.................... ////     prevents PIC18F45K50 family USB from locking up.            ////
.................... ////                                                                 ////
.................... //// Mar 1, 2015:                                                    ////
.................... ////  Added __STALL_ON_UEP_ERRATA__ and __UIDLE_JAM_ERRATA__ from    ////
.................... ////     PIC24 USB library, in case those erratas found              ////
.................... ////     their way on the PIC18 USB parts.                           ////
.................... ////                                                                 ////
.................... //// Dec 17, 2013:                                                   ////
.................... ////  Added 18FxxJ9x family support.                                 ////
.................... ////                                                                 ////
.................... //// Dec 11, 2013:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// July 9th, 2012:                                                 ////
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     ////
.................... ////     for non-setup packets on endpoint 0 or all other            ////
.................... ////     endpoints.  This really only affects people using           ////
.................... ////     usb_put_packet() or usb_get_packet() inside of other        ////
.................... ////     interrupts.                                                 ////
.................... ////                                                                 ////
.................... //// Sep 22, 2011:                                                   ////
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   ////
.................... ////     primarily developed for users developing code where         ////
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Added initial 18F47J53 family support.                         ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work.                          ////
.................... ////                                                                 ////
.................... //// Nov 13th, 2009:                                                 ////
.................... ////  usb_disable_endpoint() won't touch BD status registers for     ////
.................... ////     endpoints that aren't allocated.                            ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_C__
.................... #DEFINE __PIC18_USB_C__
.................... 
.................... // i got these from PIC24 library, but maybe these bugs made their way
.................... // into PIC18 usb peripherals.
.................... // __STALL_ON_UEP_ERRATA__ looked wrong on the PIC24 library.
.................... #define __STALL_ON_UEP_ERRATA__
.................... #define __UIDLE_JAM_ERRATA__
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #endif
.................... 
.................... #bit USBIE=getenv("BIT:USBIE")
.................... 
.................... //if you are worried that the PIC is not receiving packets because a bug in the
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on
.................... //receiving.
.................... #ifndef USB_IGNORE_RX_DTS
....................  #define USB_IGNORE_RX_DTS false
.................... #endif
.................... 
.................... #ifndef USB_IGNORE_TX_DTS
....................  #define USB_IGNORE_TX_DTS false
.................... #endif
.................... 
.................... // if only USB_BDT_START is defined, then BDT has a fixed location in RAM
.................... //    but endpoint memory can be anywhere on the PIC.
.................... // if only USB_RAM_START is defined, then both BDT and endpoint have a fixed
.................... //    location in RAM (BDT first, endpoint second).
.................... // if USB_BDT_START and USB_RAM_START are both defined, then BDT has a fixed
.................... //    location in RAM and the endpoint buffers have a different location
.................... //    in RAM.
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50"))
....................  #define __USB_87J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \
....................        (getenv("DEVICE")=="PIC18F24K50") || \
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF24K50"))
....................  #define __USB_45K50__
....................  #define USB_TOTAL_RAM_SPACE  1024
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50"))
....................  #define __USB_46J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || \
....................        (getenv("DEVICE")=="PIC18LF2450") || (getenv("DEVICE")=="PIC18LF4450"))
....................  #define __USB_4450__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................  #define __USB_K50__ //backwards compatability
....................  #define __USB_14K50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x200
....................  #define USB_NUM_UEP 8
....................  //technically this device supports 8 endpoints, but for RAM reasons you should
....................  //attempt to only use the first 3 endpoints.
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") || \
....................        (getenv("DEVICE")=="PIC18LF2455") || (getenv("DEVICE")=="PIC18LF2550") || \
....................        (getenv("DEVICE")=="PIC18LF4455") || (getenv("DEVICE")=="PIC18LF4550") || \
....................        (getenv("DEVICE")=="PIC18LF2458") || (getenv("DEVICE")=="PIC18LF2553") || \
....................        (getenv("DEVICE")=="PIC18LF4458") || (getenv("DEVICE")=="PIC18LF4553") \
....................        )
....................  #define __USB_4550__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") || \
....................        (getenv("DEVICE")=="PIC18LF26J53") || (getenv("DEVICE")=="PIC18LF27J53") || \ 
....................        (getenv("DEVICE")=="PIC18LF46J53") || (getenv("DEVICE")=="PIC18LF47J53") \       
....................        )
....................  #define __USB_18FJ53__
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use
....................  #define USB_BDT_START  0xD00
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F97J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F87J94") ||  \
....................        (getenv("DEVICE")=="PIC18F67J94") ||  \
....................        (getenv("DEVICE")=="PIC18F96J99") ||  \
....................        (getenv("DEVICE")=="PIC18F86J99") ||  \
....................        (getenv("DEVICE")=="PIC18F66J99") ||  \
....................        (getenv("DEVICE")=="PIC18F96J94") ||  \
....................        (getenv("DEVICE")=="PIC18F86J94") ||  \
....................        (getenv("DEVICE")=="PIC18F66J94") ||  \
....................        (getenv("DEVICE")=="PIC18F95J94") ||  \
....................        (getenv("DEVICE")=="PIC18F85J94") ||  \
....................        (getenv("DEVICE")=="PIC18F65J94"))
....................  #define __USB_18FJ94__
....................  #define USB_BDT_START  0x100
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library.
.................... #endif
.................... 
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  15
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  14
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  13
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  12
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  11
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  10
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  9
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  8
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  7
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  6
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  5
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  4
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  3
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  2
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  1
.................... #else
....................  #define USB_LAST_DEFINED_ENDPOINT  0
.................... #endif
.................... 
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8)
.................... 
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)
.................... 
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT)
....................  #error You are trying to use an invalid endpoint for this hardware!
.................... #endif
.................... 
.................... typedef struct
.................... {
....................    unsigned int8 stat;
....................    unsigned int8 cnt;
....................    unsigned int16 addr;
.................... } STRUCT_BD;
.................... 
.................... #if defined(USB_RAM_START) && !defined(USB_BDT_START)
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       struct
....................       {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................       } bd[USB_LAST_DEFINED_ENDPOINT+1];
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM.buffer)
....................    
....................    #locate g_USBRAM=USB_RAM_START
....................    
....................    #define g_USBBDT g_USBRAM.bd
.................... #else
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #if defined(USB_RAM_START)
....................       #locate g_USBRAM=USB_RAM_START
....................    #endif
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM)
....................    
....................    struct
....................    {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................    } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1];
....................    
....................    #locate g_USBBDT=USB_BDT_START
.................... #endif
.................... 
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer
.................... 
.................... //these buffer definitions needed for CDC library
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer
.................... 
.................... //if you enable this it will keep a counter of the 6 possible errors the
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time.
.................... #if !defined(USB_USE_ERROR_COUNTER)
....................    #define USB_USE_ERROR_COUNTER false
.................... #endif
.................... 
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints
.................... 
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS!
.................... #if !defined(USB_PING_PONG_MODE)
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF
.................... #endif
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................    unsigned int ERROR_COUNTER[6];
.................... #endif
.................... 
.................... //---pic18fxx5x memory locations
.................... #if defined(__USB_4550__) || defined(__USB_4450__)
....................    #byte UFRML   =  0xF66
....................    #byte UFRMH   =  0xF67
....................    #byte UIR     =  0xF68
....................    #byte UIE     =  0xF69
....................    #byte UEIR    =  0xF6A
....................    #byte UEIE    =  0xF6B
....................    #byte U1STAT   =  0xF6C
....................    #byte UCON    =  0xF6D
....................    #byte UADDR   =  0xF6E
....................    #byte UCFG    =  0xF6F
....................    #define  UEP0_LOC 0xF70
.................... #elif defined(__USB_46J50__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #elif defined(__USB_14K50__)
....................    #byte UFRML   =  0xF5D
....................    #byte UFRMH   =  0xF5E
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF60
....................    #byte UEIR    =  0xF5F
....................    #byte UEIE    =  0xF5B
....................    #byte U1STAT   =  0xF63
....................    #byte UCON    =  0xF64
....................    #byte UADDR   =  0xF5C
....................    #byte UCFG    =  0xF61
....................    #define  UEP0_LOC 0xF53
.................... #elif defined(__USB_18FJ53__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #else
....................    #byte UFRML = getenv("SFR:UFRML")
....................    #byte UFRMH = getenv("SFR:UFRMH")
....................    #byte UIR = getenv("SFR:UIR")
....................    #byte UIE = getenv("SFR:UIE")
....................    #byte UEIR = getenv("SFR:UEIR")
....................    #byte UEIE = getenv("SFR:UEIE")
....................    #byte U1STAT = getenv("SFR:USTAT")
....................    #byte UCON = getenv("SFR:UCON")
....................    #byte UADDR = getenv("SFR:UADDR")
....................    #byte UCFG = getenv("SFR:UCFG")
.................... #endif
.................... 
.................... unsigned int8 USTATCopy;
.................... 
.................... unsigned int8 g_UEP[USB_NUM_UEP];
.................... #if defined(UEP0_LOC)
.................... #locate g_UEP=UEP0_LOC
.................... #else
.................... #locate g_UEP=getenv("SFR:UEP0")
.................... #endif
.................... #define UEP(x) g_UEP[x]
.................... 
.................... #define BIT_SOF   6
.................... #define BIT_STALL 5
.................... #define BIT_IDLE  4
.................... #define BIT_TRN   3
.................... #define BIT_ACTV  2
.................... #define BIT_UERR  1
.................... #define BIT_URST  0
.................... 
.................... #BIT UIR_SOF = UIR.BIT_SOF
.................... #BIT UIR_STALL = UIR.BIT_STALL
.................... #BIT UIR_IDLE = UIR.BIT_IDLE
.................... #BIT UIR_TRN = UIR.BIT_TRN
.................... #BIT UIR_ACTV = UIR.BIT_ACTV
.................... #BIT UIR_UERR = UIR.BIT_UERR
.................... #BIT UIR_URST = UIR.BIT_URST
.................... 
.................... #BIT UIE_SOF = UIE.BIT_SOF
.................... #BIT UIE_STALL = UIE.BIT_STALL
.................... #BIT UIE_IDLE = UIE.BIT_IDLE
.................... #BIT UIE_TRN = UIE.BIT_TRN
.................... #BIT UIE_ACTV = UIE.BIT_ACTV
.................... #BIT UIE_UERR = UIE.BIT_UERR
.................... #BIT UIE_URST = UIE.BIT_URST
.................... 
.................... #if getenv("BIT_VALID:PPBRST")
....................    #bit UCON_PPBRST = getenv("BIT:PPBRST")
.................... #endif
.................... #bit UCON_SE0=UCON.5
.................... #bit UCON_PKTDIS=UCON.4
.................... #bit UCON_USBEN=UCON.3
.................... #bit UCON_RESUME=UCON.2
.................... #bit UCON_SUSPND=UCON.1
.................... 
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF)
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr
.................... #else
.................... #error Right now this driver only supports no ping pong
.................... #endif
.................... 
.................... //See UEPn (0xF70-0xF7F)
.................... #define ENDPT_DISABLED   0x00   //endpoint not used
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions
.................... 
.................... //Define the states that the USB interface can be in
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3,
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state;
.................... 
.................... //--BDendST has their PIDs upshifed 2
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction
.................... 
.................... #define USTAT_IN_E0        4
.................... #define USTAT_OUT_SETUP_E0 0
.................... 
.................... #define __USB_UIF_RESET    0x01
.................... #define __USB_UIF_ERROR    0x02
.................... #define __USB_UIF_ACTIVE   0x04
.................... #define __USB_UIF_TOKEN    0x08
.................... #define __USB_UIF_IDLE     0x10
.................... #define __USB_UIF_STALL    0x20
.................... #define __USB_UIF_SOF      0x40
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET
.................... #else
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET
.................... #endif
.................... 
.................... #define __USB_UCFG_UTEYE   0x80
.................... #if defined(__USB_4550__)
....................  #define __USB_UCFG_UOEMON  0x40
.................... #endif
.................... #define __USB_UCFG_UPUEN   0x10
.................... #if !defined(__USB_14K50__)
....................  #define __USB_UCFG_UTRDIS  0x08
.................... #endif
.................... #define __USB_UCFG_FSEN    0x04
.................... 
.................... #if defined(USB_EXTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  0
.................... #endif
.................... 
.................... #if defined(USB_INTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if !defined(__USB_UCFG_MY_UPUEN)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if USB_USE_FULL_SPEED
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE)
.................... #else
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE);
.................... #endif
.................... 
.................... #if defined(__USB_UCFG_UTRDIS)
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS
.................... #else
....................  #define __UCFG_VAL_DISABLED__   0
.................... #endif
.................... 
.................... 
.................... unsigned int8 __setup_0_tx_size;
.................... 
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only
.................... void usb_handle_interrupt();
.................... void usb_isr_rst();
.................... void usb_isr_uerr();
.................... void usb_isr_sof(void);
.................... void usb_isr_activity();
.................... void usb_isr_uidle();
.................... void usb_isr_tok_dne();
.................... void usb_isr_stall(void);
.................... void usb_init_ep0_setup(void);
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... void usb_isr(void);
.................... #endif
.................... 
.................... //// BEGIN User Functions:
.................... 
.................... // see usb_hw_layer.h for more documentation
.................... int1 usb_kbhit(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7)));
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_tbe(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7)));
*
0E6E:  CLRF   03
0E70:  MOVLB  2
0E72:  MOVF   xA4,W
0E74:  ADDLW  70
0E76:  MOVWF  FE9
0E78:  MOVLW  0F
0E7A:  ADDWFC 03,W
0E7C:  MOVWF  FEA
0E7E:  MOVF   FEF,F
0E80:  BZ    0EB8
0E82:  CLRF   xA6
0E84:  MOVFF  2A4,2A5
0E88:  CLRF   xA8
0E8A:  MOVLW  08
0E8C:  MOVWF  xA7
0E8E:  MOVLB  0
0E90:  CALL   04DE
0E94:  MOVFF  02,2A6
0E98:  MOVFF  01,2A5
0E9C:  MOVLW  04
0E9E:  MOVLB  2
0EA0:  ADDWF  xA5,F
0EA2:  MOVLW  00
0EA4:  ADDWFC xA6,F
0EA6:  MOVFF  2A5,FE9
0EAA:  MOVLW  04
0EAC:  ADDWF  xA6,W
0EAE:  MOVWF  FEA
0EB0:  MOVFF  FEF,2A7
0EB4:  BTFSS  xA7.7
0EB6:  BRA    0EBC
0EB8:  MOVLW  00
0EBA:  BRA    0EBE
0EBC:  MOVLW  01
0EBE:  MOVWF  01
0EC0:  MOVLB  0
0EC2:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_detach(void)
.................... {
....................    UCON_SUSPND = 0;
*
18B0:  BCF    F6D.1
....................    UCON = 0;  //disable USB hardware
18B2:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts
18B4:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__;
18B6:  MOVLW  08
18B8:  MOVWF  F6F
.................... 
....................    // set D+/D- to inputs
....................   #if defined(__USB_87J50__)
....................    set_tris_f(get_tris_f() | 0x18);
....................   #elif defined(__USB_14K50__)
....................    set_tris_a(get_tris_a() | 0x3);
....................   #elif defined(__USB_18FJ94__)
....................    output_float(PIN_F4);
....................    output_float(PIN_F3);
....................   #elif !defined(USB_PIC_NO_USB_GPIO)
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5
18BA:  MOVF   F94,W
18BC:  IORLW  30
18BE:  MOVLB  1
18C0:  MOVWF  F94
....................   #endif
....................   
....................    usb_state = USB_STATE_DETACHED;
18C2:  CLRF   22
18C4:  CLRF   19
18C6:  BTFSC  FF2.7
18C8:  BSF    19.7
18CA:  BCF    FF2.7
....................    
....................    usb_token_reset();              //clear the chapter9 stack
18CC:  MOVLB  0
18CE:  CALL   05CE
18D2:  BTFSC  19.7
18D4:  BSF    FF2.7
18D6:  GOTO   18DC (RETURN)
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_attach(void) 
.................... {
....................    usb_token_reset();
*
1566:  CALL   05CE
....................    UCON_SUSPND = 0;
156A:  BCF    F6D.1
....................    UCON = 0;
156C:  CLRF   F6D
....................   #if getenv("BIT_VALID:PPBRST")
....................    UCON_PPBRST = 1;
156E:  BSF    F6D.6
....................    delay_cycles(5);
1570:  BRA    1572
1572:  BRA    1574
1574:  NOP   
....................    UCON_PPBRST = 0;
1576:  BCF    F6D.6
....................   #endif
....................    UCFG = __UCFG_VAL_ENABLED__;
1578:  MOVLW  14
157A:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts
157C:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus
157E:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h
1580:  MOVLW  01
1582:  MOVWF  22
1584:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init_cs(void)
.................... {
....................    usb_detach();
*
18DA:  BRA    18B0
18DC:  GOTO   18E2 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_task(void) 
.................... {
....................   #if defined(USB_ISR_POLLING)
....................    if (interrupt_active(INT_USB))
....................    {
....................       usb_isr();
....................    }
....................   #endif
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_enumerated())
*
1586:  RCALL  1560
1588:  MOVF   01,F
158A:  BZ    158E
....................    {
....................       usb_cdc_flush_tx_buffer();
158C:  RCALL  1286
....................    }
....................   #endif
.................... 
....................    if (usb_attached()) 
....................    {
....................       if (UCON_USBEN==0) 
158E:  BTFSC  F6D.3
1590:  BRA    1594
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: ATTACH");
....................          usb_attach();
1592:  RCALL  1566
....................       }
....................    }
....................    else 
....................    {
....................       if (UCON_USBEN==1)  
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: DE-ATTACH");
....................          usb_detach();
....................       }
....................    }
.................... 
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) 
1594:  DECFSZ 22,W
1596:  BRA    15AE
1598:  BTFSC  F6D.5
159A:  BRA    15AE
....................    {
....................       UIR = 0;
159C:  CLRF   F68
....................       UIE = 0;
159E:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING)
....................       enable_interrupts(INT_USB);
15A0:  BSF    FA0.5
....................       enable_interrupts(GLOBAL);
15A2:  MOVLW  C0
15A4:  IORWF  FF2,F
....................      #endif
....................       UIE = __USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR
15A6:  MOVLW  11
15A8:  MOVWF  F69
....................      #if USB_USE_ERROR_COUNTER
....................       UIE |= __USB_UIF_ERROR;
....................      #endif
....................       usb_state=USB_STATE_POWERED;
15AA:  MOVLW  02
15AC:  MOVWF  22
....................       debug_usb_control(debug_putc, "\r\n\nUSB TASK: POWERED");
....................    }
15AE:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init(void) 
.................... {
....................    usb_init_cs();
*
18E0:  BRA    18DA
18E2:  CLRF   19
18E4:  BTFSC  FF2.7
18E6:  BSF    19.7
18E8:  BCF    FF2.7
.................... 
....................    do 
....................    {
....................       usb_task();
18EA:  RCALL  1586
18EC:  BTFSC  19.7
18EE:  BSF    FF2.7
....................    } while (usb_state != USB_STATE_POWERED);
18F0:  MOVF   22,W
18F2:  SUBLW  02
18F4:  BNZ   18E2
18F6:  GOTO   437E (RETURN)
.................... }
.................... 
.................... 
.................... // see pic18_usb.h for documentation
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
.................... 
....................    debug_usb_packet(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len);
.................... 
....................    if (usb_tbe(endpoint)) 
*
0EC4:  MOVFF  29F,2A4
0EC8:  RCALL  0E6E
0ECA:  MOVF   01,F
0ECC:  BTFSC  FD8.2
0ECE:  BRA    1006
....................    {
....................       EP_BDxCNT_I(endpoint)=len;
0ED0:  MOVLB  2
0ED2:  CLRF   xA6
0ED4:  MOVFF  29F,2A5
0ED8:  CLRF   xA8
0EDA:  MOVLW  08
0EDC:  MOVWF  xA7
0EDE:  MOVLB  0
0EE0:  CALL   04DE
0EE4:  MOVFF  02,2A5
0EE8:  MOVFF  01,2A4
0EEC:  MOVLW  04
0EEE:  MOVLB  2
0EF0:  ADDWF  xA4,F
0EF2:  MOVLW  00
0EF4:  ADDWFC xA5,F
0EF6:  MOVLW  01
0EF8:  ADDWF  xA4,W
0EFA:  MOVWF  01
0EFC:  MOVLW  00
0EFE:  ADDWFC xA5,W
0F00:  MOVWF  03
0F02:  MOVFF  01,FE9
0F06:  MOVLW  04
0F08:  ADDWF  03,W
0F0A:  MOVWF  FEA
0F0C:  MOVFF  2A0,FEF
.................... 
....................       debug_display_ram(len, EP_BDxADR_I(endpoint));
.................... 
....................      #if USB_IGNORE_TX_DTS
....................       i=0x80;
....................      #else
....................       if (tgl == USB_DTS_TOGGLE) 
0F10:  MOVF   xA2,W
0F12:  SUBLW  02
0F14:  BNZ   0F56
....................       {
....................          i = EP_BDxST_I(endpoint);
0F16:  CLRF   xA6
0F18:  MOVFF  29F,2A5
0F1C:  CLRF   xA8
0F1E:  MOVLW  08
0F20:  MOVWF  xA7
0F22:  MOVLB  0
0F24:  CALL   04DE
0F28:  MOVFF  02,2A5
0F2C:  MOVFF  01,2A4
0F30:  MOVLW  04
0F32:  MOVLB  2
0F34:  ADDWF  xA4,F
0F36:  MOVLW  00
0F38:  ADDWFC xA5,F
0F3A:  MOVFF  2A4,FE9
0F3E:  MOVLW  04
0F40:  ADDWF  xA5,W
0F42:  MOVWF  FEA
0F44:  MOVFF  FEF,2A3
....................          if (bit_test(i,6))
0F48:  BTFSS  xA3.6
0F4A:  BRA    0F50
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0F4C:  CLRF   xA2
0F4E:  BRA    0F54
....................          else
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0F50:  MOVLW  01
0F52:  MOVWF  xA2
....................       }
0F54:  BRA    0F8A
....................       else if (tgl == USB_DTS_USERX) 
0F56:  MOVF   xA2,W
0F58:  SUBLW  04
0F5A:  BNZ   0F8A
....................       {
....................          i = EP_BDxST_O(endpoint);
0F5C:  CLRF   xA6
0F5E:  MOVFF  29F,2A5
0F62:  CLRF   xA8
0F64:  MOVLW  08
0F66:  MOVWF  xA7
0F68:  MOVLB  0
0F6A:  CALL   04DE
0F6E:  MOVLB  2
0F70:  MOVFF  01,FE9
0F74:  MOVLW  04
0F76:  ADDWF  02,W
0F78:  MOVWF  FEA
0F7A:  MOVFF  FEF,2A3
....................          if (bit_test(i,6))
0F7E:  BTFSS  xA3.6
0F80:  BRA    0F88
....................             tgl = USB_DTS_DATA1;
0F82:  MOVLW  01
0F84:  MOVWF  xA2
0F86:  BRA    0F8A
....................          else
....................             tgl = USB_DTS_DATA0;
0F88:  CLRF   xA2
....................       }
....................       if (tgl == USB_DTS_DATA1) 
0F8A:  DECFSZ xA2,W
0F8C:  BRA    0F94
....................          i=0x48;  //DATA1, UOWN  //change mar2015
0F8E:  MOVLW  48
0F90:  MOVWF  xA3
0F92:  BRA    0F98
....................       else //if (tgl == USB_DTS_DATA0) 
....................          i=0x08; //DATA0, UOWN   //change mar2015
0F94:  MOVLW  08
0F96:  MOVWF  xA3
....................      #endif
.................... 
....................       //set BC8 and BC9
....................       //if (bit_test(len,8)) {bit_set(i,0);}
....................       //if (bit_test(len,9)) {bit_set(i,1);}
.................... 
....................       debug_usb_packet(debug_putc, " %X", i);
.................... 
....................       EP_BDxST_I(endpoint) = i;  //save changes
0F98:  CLRF   xA6
0F9A:  MOVFF  29F,2A5
0F9E:  CLRF   xA8
0FA0:  MOVLW  08
0FA2:  MOVWF  xA7
0FA4:  MOVLB  0
0FA6:  CALL   04DE
0FAA:  MOVFF  02,2A5
0FAE:  MOVFF  01,2A4
0FB2:  MOVLW  04
0FB4:  MOVLB  2
0FB6:  ADDWF  xA4,F
0FB8:  MOVLW  00
0FBA:  ADDWFC xA5,F
0FBC:  MOVFF  2A4,FE9
0FC0:  MOVLW  04
0FC2:  ADDWF  xA5,W
0FC4:  MOVWF  FEA
0FC6:  MOVFF  2A3,FEF
....................       
....................       EP_BDxST_I(endpoint) |= 0x80; //change mar2015
0FCA:  CLRF   xA6
0FCC:  MOVFF  29F,2A5
0FD0:  CLRF   xA8
0FD2:  MOVLW  08
0FD4:  MOVWF  xA7
0FD6:  MOVLB  0
0FD8:  CALL   04DE
0FDC:  MOVFF  02,2A5
0FE0:  MOVFF  01,2A4
0FE4:  MOVLW  04
0FE6:  MOVLB  2
0FE8:  ADDWF  xA4,F
0FEA:  MOVLW  00
0FEC:  ADDWFC xA5,F
0FEE:  MOVFF  2A4,FE9
0FF2:  MOVLW  04
0FF4:  ADDWF  xA5,W
0FF6:  MOVWF  FEA
0FF8:  MOVF   FEF,W
0FFA:  IORLW  80
0FFC:  MOVWF  FEF
....................       
....................       //putc('!');
....................       
....................       return(1);
0FFE:  MOVLW  01
1000:  MOVWF  01
1002:  BRA    100C
....................    }
1004:  MOVLB  0
....................    else 
....................    {
....................       //putc('_');
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
....................    return(0);
1006:  MOVLW  00
1008:  MOVWF  01
100A:  MOVLB  2
100C:  MOVLB  0
100E:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 * buff_add;    
.................... 
....................    if (usb_tbe(endpoint)) 
*
110C:  MOVFF  297,2A4
1110:  RCALL  0E6E
1112:  MOVF   01,F
1114:  BZ    11A4
....................    {
....................       buff_add = EP_BDxADR_I(endpoint);
1116:  MOVLB  2
1118:  CLRF   xA6
111A:  MOVFF  297,2A5
111E:  CLRF   xA8
1120:  MOVLW  08
1122:  MOVWF  xA7
1124:  MOVLB  0
1126:  CALL   04DE
112A:  MOVFF  02,2A0
112E:  MOVFF  01,29F
1132:  MOVLW  04
1134:  MOVLB  2
1136:  ADDWF  x9F,F
1138:  MOVLW  00
113A:  ADDWFC xA0,F
113C:  MOVLW  02
113E:  ADDWF  x9F,W
1140:  MOVWF  01
1142:  MOVLW  00
1144:  ADDWFC xA0,W
1146:  MOVWF  03
1148:  MOVFF  01,FE9
114C:  MOVLW  04
114E:  ADDWF  03,W
1150:  MOVWF  FEA
1152:  MOVFF  FEC,29E
1156:  MOVF   FED,F
1158:  MOVFF  FEF,29D
....................       memcpy(buff_add, ptr, len);     
115C:  MOVFF  29E,FEA
1160:  MOVFF  29D,FE9
1164:  MOVFF  299,FE2
1168:  MOVFF  298,FE1
116C:  MOVFF  29B,02
1170:  MOVFF  29A,01
1174:  MOVF   01,F
1176:  BZ    117C
1178:  INCF   02,F
117A:  BRA    1180
117C:  MOVF   02,F
117E:  BZ    118C
1180:  MOVFF  FE6,FEE
1184:  DECFSZ 01,F
1186:  BRA    1180
1188:  DECFSZ 02,F
118A:  BRA    1180
....................       
....................       return(usb_flush_in(endpoint, len, tgl));
118C:  MOVFF  297,29F
1190:  MOVFF  29B,2A1
1194:  MOVFF  29A,2A0
1198:  MOVFF  29C,2A2
119C:  MOVLB  0
119E:  RCALL  0EC4
11A0:  MOVF   01,W
11A2:  BRA    11A8
....................    }
....................    else 
....................    {
....................       //putc('-');
....................       //printf("%X", EP_BDxST_I(endpoint));
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
.................... 
....................    return(0);
11A4:  MOVLW  00
11A6:  MOVWF  01
11A8:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
....................    unsigned int16 len;
.................... 
....................   #if USB_IGNORE_RX_DTS
....................    if (tgl == USB_DTS_STALL) 
....................    {
....................       debug_usb_token(debug_putc, '*');
....................       EP_BDxCNT_O(endpoint) = 0x84;
....................       EP_BDxST_I(endpoint) = 0x84;
....................       return;
....................    }
....................    else
....................       i=0x80;
....................   #else
....................    i = EP_BDxST_O(endpoint);
*
0D6E:  MOVLB  2
0D70:  CLRF   xA6
0D72:  MOVFF  28D,2A5
0D76:  CLRF   xA8
0D78:  MOVLW  08
0D7A:  MOVWF  xA7
0D7C:  MOVLB  0
0D7E:  CALL   04DE
0D82:  MOVLB  2
0D84:  MOVFF  01,FE9
0D88:  MOVLW  04
0D8A:  ADDWF  02,W
0D8C:  MOVWF  FEA
0D8E:  MOVFF  FEF,28F
....................    if (tgl == USB_DTS_TOGGLE) 
0D92:  MOVF   x8E,W
0D94:  SUBLW  02
0D96:  BNZ   0DA4
....................    {
....................       if (bit_test(i,6))
0D98:  BTFSS  x8F.6
0D9A:  BRA    0DA0
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0D9C:  CLRF   x8E
0D9E:  BRA    0DA4
....................       else
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0DA0:  MOVLW  01
0DA2:  MOVWF  x8E
....................    }
....................    if (tgl == USB_DTS_STALL) 
0DA4:  MOVF   x8E,W
0DA6:  SUBLW  03
0DA8:  BNZ   0DE2
....................    {
....................       i = 0x84;
0DAA:  MOVLW  84
0DAC:  MOVWF  x8F
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints
0DAE:  CLRF   xA6
0DB0:  MOVFF  28D,2A5
0DB4:  CLRF   xA8
0DB6:  MOVLW  08
0DB8:  MOVWF  xA7
0DBA:  MOVLB  0
0DBC:  CALL   04DE
0DC0:  MOVFF  02,293
0DC4:  MOVFF  01,292
0DC8:  MOVLW  04
0DCA:  MOVLB  2
0DCC:  ADDWF  x92,F
0DCE:  MOVLW  00
0DD0:  ADDWFC x93,F
0DD2:  MOVFF  292,FE9
0DD6:  MOVLW  04
0DD8:  ADDWF  x93,W
0DDA:  MOVWF  FEA
0DDC:  MOVLW  84
0DDE:  MOVWF  FEF
....................    }
0DE0:  BRA    0DF0
....................    else if (tgl == USB_DTS_DATA1)
0DE2:  DECFSZ x8E,W
0DE4:  BRA    0DEC
....................       i = 0xC8;  //DATA1, UOWN
0DE6:  MOVLW  C8
0DE8:  MOVWF  x8F
0DEA:  BRA    0DF0
....................    else //if (tgl == USB_DTS_DATA0) 
....................       i = 0x88; //DATA0, UOWN
0DEC:  MOVLW  88
0DEE:  MOVWF  x8F
....................   #endif
.................... 
....................    //bit_clear(__usb_kbhit_status,endpoint);
.................... 
....................    len = usb_ep_rx_size[endpoint];
0DF0:  BCF    FD8.0
0DF2:  RLCF   x8D,W
0DF4:  CLRF   03
0DF6:  MOVLB  0
0DF8:  CALL   012A
0DFC:  TBLRD*+
0DFE:  MOVFF  FF5,03
0E02:  MOVLB  2
0E04:  MOVWF  x90
0E06:  MOVFF  03,291
....................    EP_BDxCNT_O(endpoint) = len;
0E0A:  CLRF   xA6
0E0C:  MOVFF  28D,2A5
0E10:  CLRF   xA8
0E12:  MOVLW  08
0E14:  MOVWF  xA7
0E16:  MOVLB  0
0E18:  CALL   04DE
0E1C:  MOVFF  01,292
0E20:  MOVLW  01
0E22:  MOVLB  2
0E24:  ADDWF  01,W
0E26:  MOVWF  01
0E28:  MOVLW  00
0E2A:  ADDWFC 02,W
0E2C:  MOVWF  03
0E2E:  MOVFF  01,FE9
0E32:  MOVLW  04
0E34:  ADDWF  03,W
0E36:  MOVWF  FEA
0E38:  MOVFF  290,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);}
0E3C:  BTFSS  x91.0
0E3E:  BRA    0E42
0E40:  BSF    x8F.0
....................    if (bit_test(len,9)) {bit_set(i,1);}
0E42:  BTFSS  x91.1
0E44:  BRA    0E48
0E46:  BSF    x8F.1
.................... 
....................    EP_BDxST_O(endpoint) = i;
0E48:  CLRF   xA6
0E4A:  MOVFF  28D,2A5
0E4E:  CLRF   xA8
0E50:  MOVLW  08
0E52:  MOVWF  xA7
0E54:  MOVLB  0
0E56:  CALL   04DE
0E5A:  MOVLB  2
0E5C:  MOVFF  01,FE9
0E60:  MOVLW  04
0E62:  ADDWF  02,W
0E64:  MOVWF  FEA
0E66:  MOVFF  28F,FEF
0E6A:  MOVLB  0
0E6C:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint) 
.................... {
....................    return(EP_BDxCNT_O(endpoint));
*
1058:  MOVLB  2
105A:  CLRF   xA6
105C:  MOVFF  28D,2A5
1060:  CLRF   xA8
1062:  MOVLW  08
1064:  MOVWF  xA7
1066:  MOVLB  0
1068:  CALL   04DE
106C:  MOVFF  02,28F
1070:  MOVFF  01,28E
1074:  MOVLW  01
1076:  MOVLB  2
1078:  ADDWF  01,W
107A:  MOVWF  01
107C:  MOVLW  00
107E:  ADDWFC 02,W
1080:  MOVWF  03
1082:  MOVFF  01,FE9
1086:  MOVLW  04
1088:  ADDWF  03,W
108A:  MOVWF  FEA
108C:  MOVFF  FEF,01
1090:  CLRF   02
1092:  MOVLB  0
1094:  GOTO   10B8 (RETURN)
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN Hardware layer functions required by USB.
.................... 
.................... /*****************************************************************************
.................... /* usb_get_packet_buffer(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer.
.................... /*
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC 
.................... /*          RAM.
.................... /*          Does not mark the endpoint as ready for more data.  Once you are
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready
.................... /*          to receive more data.
.................... /*
.................... /*****************************************************************************/
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) 
.................... {
....................    unsigned int8 * al;
....................    unsigned int8 st;
....................    unsigned int16 i;
.................... 
....................    al = EP_BDxADR_O(endpoint);
....................    i = EP_BDxCNT_O(endpoint);
....................    st = EP_BDxST_O(endpoint);
.................... 
....................    //read BC8 and BC9
....................    if (bit_test(st,0)) {bit_set(i,8);}
....................    if (bit_test(st,1)) {bit_set(i,9);}
.................... 
....................    if (i < max) {max = i;}
....................    
....................    memcpy(ptr, al ,max);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max)
.................... {
....................    max = usb_get_packet_buffer(endpoint, ptr, max);
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_stall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=s%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0B54:  MOVLB  2
0B56:  BCF    x8D.0
0B58:  BTFSC  x8C.7
0B5A:  BSF    x8D.0
....................    endpoint &= 0x7F;
0B5C:  BCF    x8C.7
....................    
....................    if (direction) 
0B5E:  BTFSS  x8D.0
0B60:  BRA    0B94
....................    {
....................       EP_BDxST_I(endpoint) = 0x84;
0B62:  CLRF   xA6
0B64:  MOVFF  28C,2A5
0B68:  CLRF   xA8
0B6A:  MOVLW  08
0B6C:  MOVWF  xA7
0B6E:  MOVLB  0
0B70:  RCALL  04DE
0B72:  MOVFF  02,28F
0B76:  MOVFF  01,28E
0B7A:  MOVLW  04
0B7C:  MOVLB  2
0B7E:  ADDWF  x8E,F
0B80:  MOVLW  00
0B82:  ADDWFC x8F,F
0B84:  MOVFF  28E,FE9
0B88:  MOVLW  04
0B8A:  ADDWF  x8F,W
0B8C:  MOVWF  FEA
0B8E:  MOVLW  84
0B90:  MOVWF  FEF
....................    }
0B92:  BRA    0BB4
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x84;
0B94:  CLRF   xA6
0B96:  MOVFF  28C,2A5
0B9A:  CLRF   xA8
0B9C:  MOVLW  08
0B9E:  MOVWF  xA7
0BA0:  MOVLB  0
0BA2:  RCALL  04DE
0BA4:  MOVLB  2
0BA6:  MOVFF  01,FE9
0BAA:  MOVLW  04
0BAC:  ADDWF  02,W
0BAE:  MOVWF  FEA
0BB0:  MOVLW  84
0BB2:  MOVWF  FEF
....................    }
0BB4:  MOVLB  0
0BB6:  GOTO   0C64 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_unstall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=u%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0ADA:  MOVLB  2
0ADC:  BCF    x8D.0
0ADE:  BTFSC  x8C.7
0AE0:  BSF    x8D.0
....................    endpoint &= 0x7F;
0AE2:  BCF    x8C.7
....................    
....................    if (direction) 
0AE4:  BTFSS  x8D.0
0AE6:  BRA    0B1A
....................    {
....................      #if USB_IGNORE_RX_DTS
....................       EP_BDxST_I(endpoint) = 0x80;
....................      #else
....................       EP_BDxST_I(endpoint) = 0x88;
0AE8:  CLRF   xA6
0AEA:  MOVFF  28C,2A5
0AEE:  CLRF   xA8
0AF0:  MOVLW  08
0AF2:  MOVWF  xA7
0AF4:  MOVLB  0
0AF6:  RCALL  04DE
0AF8:  MOVFF  02,28F
0AFC:  MOVFF  01,28E
0B00:  MOVLW  04
0B02:  MOVLB  2
0B04:  ADDWF  x8E,F
0B06:  MOVLW  00
0B08:  ADDWFC x8F,F
0B0A:  MOVFF  28E,FE9
0B0E:  MOVLW  04
0B10:  ADDWF  x8F,W
0B12:  MOVWF  FEA
0B14:  MOVLW  88
0B16:  MOVWF  FEF
....................      #endif
....................    }
0B18:  BRA    0B38
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x00;
0B1A:  CLRF   xA6
0B1C:  MOVFF  28C,2A5
0B20:  CLRF   xA8
0B22:  MOVLW  08
0B24:  MOVWF  xA7
0B26:  MOVLB  0
0B28:  RCALL  04DE
0B2A:  MOVLB  2
0B2C:  MOVFF  01,FE9
0B30:  MOVLW  04
0B32:  ADDWF  02,W
0B34:  MOVWF  FEA
0B36:  CLRF   FEF
....................    }
....................    
....................   #if defined(__STALL_ON_UEP_ERRATA__)
....................    bit_clear(UEP(endpoint), 0);
0B38:  CLRF   03
0B3A:  MOVF   x8C,W
0B3C:  ADDLW  70
0B3E:  MOVWF  01
0B40:  MOVLW  0F
0B42:  ADDWFC 03,F
0B44:  MOVFF  01,FE9
0B48:  MOVFF  03,FEA
0B4C:  BCF    FEF.0
....................   #endif
0B4E:  MOVLB  0
0B50:  GOTO   0C54 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    unsigned int8 st;
....................    
....................    direction = bit_test(endpoint,7);
*
0BBA:  MOVLB  2
0BBC:  BCF    x8D.0
0BBE:  BTFSC  x8C.7
0BC0:  BSF    x8D.0
....................    endpoint &= 0x7F;
0BC2:  BCF    x8C.7
....................    
....................    if (direction) 
0BC4:  BTFSS  x8D.0
0BC6:  BRA    0BFA
....................    {
....................       st=EP_BDxST_I(endpoint);
0BC8:  CLRF   xA6
0BCA:  MOVFF  28C,2A5
0BCE:  CLRF   xA8
0BD0:  MOVLW  08
0BD2:  MOVWF  xA7
0BD4:  MOVLB  0
0BD6:  RCALL  04DE
0BD8:  MOVFF  02,290
0BDC:  MOVFF  01,28F
0BE0:  MOVLW  04
0BE2:  MOVLB  2
0BE4:  ADDWF  x8F,F
0BE6:  MOVLW  00
0BE8:  ADDWFC x90,F
0BEA:  MOVFF  28F,FE9
0BEE:  MOVLW  04
0BF0:  ADDWF  x90,W
0BF2:  MOVWF  FEA
0BF4:  MOVFF  FEF,28E
....................    }
0BF8:  BRA    0C1A
....................    else 
....................    {
....................       st=EP_BDxST_O(endpoint);
0BFA:  CLRF   xA6
0BFC:  MOVFF  28C,2A5
0C00:  CLRF   xA8
0C02:  MOVLW  08
0C04:  MOVWF  xA7
0C06:  MOVLB  0
0C08:  RCALL  04DE
0C0A:  MOVLB  2
0C0C:  MOVFF  01,FE9
0C10:  MOVLW  04
0C12:  ADDWF  02,W
0C14:  MOVWF  FEA
0C16:  MOVFF  FEF,28E
....................    }
....................    
....................    return(bit_test(st,7) && bit_test(st,2));
0C1A:  BTFSS  x8E.7
0C1C:  BRA    0C22
0C1E:  BTFSC  x8E.2
0C20:  BRA    0C26
0C22:  MOVLW  00
0C24:  BRA    0C28
0C26:  MOVLW  01
0C28:  MOVWF  01
0C2A:  MOVLB  0
0C2C:  GOTO   0C7C (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_address(unsigned int8 address) 
.................... {
....................    UADDR = address;
*
10E4:  MOVFF  28D,F6E
....................    
....................    if (address) 
10E8:  MOVLB  2
10EA:  MOVF   x8D,F
10EC:  BZ    10F4
....................    {
....................       usb_state = USB_STATE_ADDRESS;
10EE:  MOVLW  04
10F0:  MOVWF  22
....................    }
10F2:  BRA    10F8
....................    else 
....................    {
....................       usb_state = USB_STATE_POWERED;
10F4:  MOVLW  02
10F6:  MOVWF  22
....................    }
10F8:  MOVLB  0
10FA:  GOTO   1108 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_configured(unsigned int8 config) 
.................... {
....................    unsigned int8 en;
....................    unsigned int16 addy;
....................    unsigned int8 new_uep;
....................    unsigned int16 len;
....................    unsigned int8 i;
....................    
....................    if (config == 0)
*
078E:  MOVLB  2
0790:  MOVF   x8C,F
0792:  BNZ   07A0
....................    {
....................       // if config=0 then set addressed state
....................       usb_state = USB_STATE_ADDRESS;
0794:  MOVLW  04
0796:  MOVWF  22
....................       usb_disable_endpoints();
0798:  MOVLB  0
079A:  RCALL  0570
....................    }
079C:  BRA    0976
079E:  MOVLB  2
....................    else 
....................    {
....................       // else set configed state
....................       usb_state = USB_STATE_CONFIGURED; 
07A0:  MOVLW  05
07A2:  MOVWF  22
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH);
07A4:  MOVLW  04
07A6:  MOVWF  x8F
07A8:  MOVLW  98
07AA:  MOVWF  x8E
....................       for (en=1; en<USB_NUM_UEP; en++) 
07AC:  MOVLW  01
07AE:  MOVWF  x8D
07B0:  MOVF   x8D,W
07B2:  SUBLW  0F
07B4:  BTFSS  FD8.0
07B6:  BRA    0976
....................       {
....................          // enable and config endpoints based upon user configuration
....................          usb_disable_endpoint(en);
07B8:  MOVFF  28D,295
07BC:  MOVLB  0
07BE:  RCALL  0500
....................          new_uep = 0;
07C0:  MOVLB  2
07C2:  CLRF   x90
....................          if (usb_ep_rx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
07C4:  CLRF   03
07C6:  MOVF   x8D,W
07C8:  MOVLB  0
07CA:  RCALL  00DA
07CC:  SUBLW  FF
07CE:  BZ    089E
....................          {
....................             new_uep = 0x04;
07D0:  MOVLW  04
07D2:  MOVLB  2
07D4:  MOVWF  x90
....................             len = usb_ep_rx_size[en];
07D6:  BCF    FD8.0
07D8:  RLCF   x8D,W
07DA:  CLRF   03
07DC:  MOVLB  0
07DE:  RCALL  012A
07E0:  TBLRD*+
07E2:  MOVFF  FF5,03
07E6:  MOVLB  2
07E8:  MOVWF  x91
07EA:  MOVFF  03,292
....................             EP_BDxCNT_O(en) = len;
07EE:  CLRF   xA6
07F0:  MOVFF  28D,2A5
07F4:  CLRF   xA8
07F6:  MOVLW  08
07F8:  MOVWF  xA7
07FA:  MOVLB  0
07FC:  RCALL  04DE
07FE:  MOVFF  01,294
0802:  MOVLW  01
0804:  MOVLB  2
0806:  ADDWF  01,W
0808:  MOVWF  01
080A:  MOVLW  00
080C:  ADDWFC 02,W
080E:  MOVWF  03
0810:  MOVFF  01,FE9
0814:  MOVLW  04
0816:  ADDWF  03,W
0818:  MOVWF  FEA
081A:  MOVFF  291,FEF
....................             EP_BDxADR_O(en) = addy;
081E:  CLRF   xA6
0820:  MOVFF  28D,2A5
0824:  CLRF   xA8
0826:  MOVLW  08
0828:  MOVWF  xA7
082A:  MOVLB  0
082C:  RCALL  04DE
082E:  MOVFF  01,294
0832:  MOVLW  02
0834:  MOVLB  2
0836:  ADDWF  01,W
0838:  MOVWF  01
083A:  MOVLW  00
083C:  ADDWFC 02,W
083E:  MOVWF  03
0840:  MOVFF  01,FE9
0844:  MOVLW  04
0846:  ADDWF  03,W
0848:  MOVWF  FEA
084A:  MOVFF  28F,FEC
084E:  MOVF   FED,F
0850:  MOVFF  28E,FEF
....................             addy += usb_ep_rx_size[en];
0854:  BCF    FD8.0
0856:  RLCF   x8D,W
0858:  CLRF   03
085A:  MOVLB  0
085C:  RCALL  012A
085E:  TBLRD*+
0860:  MOVFF  FF5,03
0864:  MOVLB  2
0866:  ADDWF  x8E,F
0868:  MOVF   03,W
086A:  ADDWFC x8F,F
....................            #if USB_IGNORE_RX_DTS
....................             i = 0x80;
....................            #else
....................             i = 0x88;
086C:  MOVLW  88
086E:  MOVWF  x93
....................            #endif
....................             if (bit_test(len,8)) {bit_set(i,0);}
0870:  BTFSS  x92.0
0872:  BRA    0876
0874:  BSF    x93.0
....................             if (bit_test(len,9)) {bit_set(i,1);}
0876:  BTFSS  x92.1
0878:  BRA    087C
087A:  BSF    x93.1
....................             EP_BDxST_O(en) = i;
087C:  CLRF   xA6
087E:  MOVFF  28D,2A5
0882:  CLRF   xA8
0884:  MOVLW  08
0886:  MOVWF  xA7
0888:  MOVLB  0
088A:  RCALL  04DE
088C:  MOVLB  2
088E:  MOVFF  01,FE9
0892:  MOVLW  04
0894:  ADDWF  02,W
0896:  MOVWF  FEA
0898:  MOVFF  293,FEF
089C:  MOVLB  0
....................          }
....................          if (usb_ep_tx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
089E:  CLRF   03
08A0:  MOVLB  2
08A2:  MOVF   x8D,W
08A4:  MOVLB  0
08A6:  RCALL  00BA
08A8:  SUBLW  FF
08AA:  BZ    093E
....................          {
....................             new_uep |= 0x02;
08AC:  MOVLB  2
08AE:  BSF    x90.1
....................             EP_BDxADR_I(en) = addy;
08B0:  CLRF   xA6
08B2:  MOVFF  28D,2A5
08B6:  CLRF   xA8
08B8:  MOVLW  08
08BA:  MOVWF  xA7
08BC:  MOVLB  0
08BE:  RCALL  04DE
08C0:  MOVFF  02,295
08C4:  MOVFF  01,294
08C8:  MOVLW  04
08CA:  MOVLB  2
08CC:  ADDWF  x94,F
08CE:  MOVLW  00
08D0:  ADDWFC x95,F
08D2:  MOVLW  02
08D4:  ADDWF  x94,W
08D6:  MOVWF  01
08D8:  MOVLW  00
08DA:  ADDWFC x95,W
08DC:  MOVWF  03
08DE:  MOVFF  01,FE9
08E2:  MOVLW  04
08E4:  ADDWF  03,W
08E6:  MOVWF  FEA
08E8:  MOVFF  28F,FEC
08EC:  MOVF   FED,F
08EE:  MOVFF  28E,FEF
....................             addy += usb_ep_tx_size[en];
08F2:  BCF    FD8.0
08F4:  RLCF   x8D,W
08F6:  CLRF   03
08F8:  MOVLB  0
08FA:  CALL   00FA
08FE:  TBLRD*+
0900:  MOVFF  FF5,03
0904:  MOVLB  2
0906:  ADDWF  x8E,F
0908:  MOVF   03,W
090A:  ADDWFC x8F,F
....................             EP_BDxST_I(en) = 0x40;
090C:  CLRF   xA6
090E:  MOVFF  28D,2A5
0912:  CLRF   xA8
0914:  MOVLW  08
0916:  MOVWF  xA7
0918:  MOVLB  0
091A:  RCALL  04DE
091C:  MOVFF  02,295
0920:  MOVFF  01,294
0924:  MOVLW  04
0926:  MOVLB  2
0928:  ADDWF  x94,F
092A:  MOVLW  00
092C:  ADDWFC x95,F
092E:  MOVFF  294,FE9
0932:  MOVLW  04
0934:  ADDWF  x95,W
0936:  MOVWF  FEA
0938:  MOVLW  40
093A:  MOVWF  FEF
093C:  MOVLB  0
....................          }
....................          if (new_uep == 0x06) {new_uep = 0x0E;}
093E:  MOVLB  2
0940:  MOVF   x90,W
0942:  SUBLW  06
0944:  BNZ   094A
0946:  MOVLW  0E
0948:  MOVWF  x90
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;}
094A:  CLRF   03
094C:  MOVF   x8D,W
094E:  MOVLB  0
0950:  CALL   00BA
0954:  SUBLW  01
0956:  BZ    095E
0958:  MOVLB  2
095A:  BSF    x90.4
095C:  MOVLB  0
....................          
....................          UEP(en) = new_uep;
095E:  CLRF   03
0960:  MOVLB  2
0962:  MOVF   x8D,W
0964:  ADDLW  70
0966:  MOVWF  FE9
0968:  MOVLW  0F
096A:  ADDWFC 03,W
096C:  MOVWF  FEA
096E:  MOVFF  290,FEF
0972:  INCF   x8D,F
0974:  BRA    07B0
0976:  MOVLB  0
....................       }
....................    }
0978:  GOTO   0A24 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoint(unsigned int8 en) 
.................... {
....................    UEP(en) = ENDPT_DISABLED;
*
0500:  CLRF   03
0502:  MOVLB  2
0504:  MOVF   x95,W
0506:  ADDLW  70
0508:  MOVWF  FE9
050A:  MOVLW  0F
050C:  ADDWFC 03,W
050E:  MOVWF  FEA
0510:  CLRF   FEF
....................    
....................    if (usb_endpoint_is_valid(en))
0512:  MOVFF  295,296
0516:  MOVLB  0
0518:  RCALL  0490
051A:  MOVF   01,F
051C:  BZ    056E
....................    {
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary      
051E:  MOVLB  2
0520:  CLRF   xA6
0522:  MOVFF  295,2A5
0526:  CLRF   xA8
0528:  MOVLW  08
052A:  MOVWF  xA7
052C:  MOVLB  0
052E:  RCALL  04DE
0530:  MOVLB  2
0532:  MOVFF  01,FE9
0536:  MOVLW  04
0538:  ADDWF  02,W
053A:  MOVWF  FEA
053C:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary
053E:  CLRF   xA6
0540:  MOVFF  295,2A5
0544:  CLRF   xA8
0546:  MOVLW  08
0548:  MOVWF  xA7
054A:  MOVLB  0
054C:  RCALL  04DE
054E:  MOVFF  02,297
0552:  MOVFF  01,296
0556:  MOVLW  04
0558:  MOVLB  2
055A:  ADDWF  x96,F
055C:  MOVLW  00
055E:  ADDWFC x97,F
0560:  MOVFF  296,FE9
0564:  MOVLW  04
0566:  ADDWF  x97,W
0568:  MOVWF  FEA
056A:  CLRF   FEF
056C:  MOVLB  0
....................    }
056E:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoints(void) 
.................... {
....................    unsigned int8 i;
....................    
....................    for (i=1; i<USB_NUM_UEP; i++)
0570:  MOVLW  01
0572:  MOVLB  2
0574:  MOVWF  x94
0576:  MOVF   x94,W
0578:  SUBLW  0F
057A:  BNC   058A
....................       usb_disable_endpoint(i);
057C:  MOVFF  294,295
0580:  MOVLB  0
0582:  RCALL  0500
0584:  MOVLB  2
0586:  INCF   x94,F
0588:  BRA    0576
058A:  MOVLB  0
058C:  RETURN 0
....................       
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... /// END Hardware layer functions required by USB.C
.................... 
.................... 
.................... /// BEGIN USB Interrupt Service Routine
.................... 
.................... static void usb_clear_trn(void)
.................... {
....................    //UIR_TRN = 0;
....................    //delay_cycles(6);
....................    UIR &= ~(1 << BIT_TRN);
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_handle_interrupt()
.................... /*
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished
.................... /*          tokens is the majority of this code, and is handled by usb.c
.................... /*
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt 
.................... /*       method), then you must call this function rapidly.  If there is more 
.................... /*       than 10ms latency the PC may think the USB device is stalled and
.................... /*       disable it.
.................... /*       To switch to a polling method, remove the #int_usb line above this 
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the 
.................... /*       USB interrupt.
.................... /******************************************************************************/
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR)
.................... #int_usb NOCLEAR
.................... #endif
.................... void usb_isr(void)
.................... {
....................    unsigned int8 TRNAttempts;
....................    
....................    clear_interrupt(INT_USB);
*
142C:  BCF    FA1.5
....................    
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though
142E:  MOVF   22,F
1430:  BTFSC  FD8.2
1432:  BRA    14AC
....................    if (UIR) 
1434:  MOVF   F68,F
1436:  BTFSC  FD8.2
1438:  BRA    14AC
....................    {
....................       //debug_usb(debug_putc,"\r\n\n[%X] ",UIR);
.................... 
....................       //activity detected.  (only enable after sleep)
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}
143A:  BTFSS  F68.2
143C:  BRA    1444
143E:  BTFSC  F69.2
1440:  GOTO   043E
.................... 
....................       if (UCON_SUSPND) return;
1444:  BTFSC  F6D.1
1446:  BRA    14AC
.................... 
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent
1448:  BTFSS  F68.5
144A:  BRA    1452
144C:  BTFSC  F69.5
144E:  GOTO   047A
.................... 
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected
1452:  BTFSS  F68.1
1454:  BRA    145C
1456:  BTFSC  F69.1
1458:  GOTO   0488
.................... 
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected
145C:  BTFSS  F68.0
145E:  BRA    1466
1460:  BTFSC  F69.0
1462:  GOTO   05FE
.................... 
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep
1466:  BTFSS  F68.4
1468:  BRA    1470
146A:  BTFSC  F69.4
146C:  GOTO   062E
....................       
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();}
1470:  BTFSS  F68.6
1472:  BRA    147A
1474:  BTFSC  F69.6
1476:  GOTO   0638
.................... 
....................       TRNAttempts = 0;
147A:  MOVLB  2
147C:  CLRF   x89
....................       do
....................       {
....................          if (UIR_TRN && UIE_TRN) 
147E:  BTFSS  F68.3
1480:  BRA    1496
1482:  BTFSS  F69.3
1484:  BRA    1496
....................          {
....................             USTATCopy = U1STAT;
1486:  MOVFF  F6C,21
....................             usb_clear_trn();
148A:  MOVLB  0
148C:  CALL   0004
....................             usb_isr_tok_dne();
1490:  BRA    1330
....................          }
1492:  BRA    149A
1494:  MOVLB  2
....................          else
....................             break;
1496:  BRA    14A4
1498:  MOVLB  0
....................       } while (TRNAttempts++ < 4);
149A:  MOVLB  2
149C:  MOVF   x89,W
149E:  INCF   x89,F
14A0:  SUBLW  03
14A2:  BC    147E
.................... 
....................      #if defined(USB_CDC_ISR)
....................       //has to be done here, can't be done until TRN is empty.
....................       if (usb_cdc_kbhit())
14A4:  BTFSS  1E.0
14A6:  BRA    14AE
....................       {
....................          USB_CDC_ISR();
14A8:  MOVLB  0
14AA:  BRA    1428
14AC:  MOVLB  2
....................       }
....................      #endif
....................    }
14AE:  MOVLB  0
14B0:  GOTO   006C
.................... }
.................... 
.................... // SOF interrupt not handled.  user must add this depending on application
.................... void usb_isr_sof(void) 
.................... {
....................    //debug_usb(debug_putc, "\r\nSOF");
....................    
....................    //UIR_SOF = 0;
....................    UIR &= ~(1 << BIT_SOF);
*
0638:  BCF    F68.6
063A:  GOTO   147A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_rst()
.................... /*
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device
.................... /*          and token handler code to initial state.
.................... /*
.................... /******************************************************************************/
.................... void usb_isr_rst(void) 
.................... {
....................    debug_usb_control(debug_putc,"-R-");
.................... 
....................    UEIE = 0;
*
05FE:  CLRF   F6B
....................    UIE = 0;
0600:  CLRF   F69
....................    UEIR = 0;
0602:  CLRF   F6A
....................    UIR = 0;
0604:  CLRF   F68
.................... 
....................    UADDR = 0;
0606:  CLRF   F6E
....................    
....................    UEP(0) = ENDPT_DISABLED;
0608:  CLRF   F70
.................... 
....................    usb_disable_endpoints();
060A:  RCALL  0570
....................    
....................    usb_token_reset();
060C:  RCALL  05CE
.................... 
....................    UEP(0) = ENDPT_CONTROL | 0x10;
060E:  MOVLW  16
0610:  MOVWF  F70
.................... 
....................    while (UIR_TRN) 
0612:  BTFSS  F68.3
0614:  BRA    061A
....................    {
....................       usb_clear_trn();
0616:  RCALL  0004
0618:  BRA    0612
....................    }
.................... 
.................... 
....................    UEIE = 0x9F;
061A:  MOVLW  9F
061C:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE;
061E:  MOVLW  3D
0620:  MOVWF  F69
.................... 
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled
0622:  BCF    F6D.4
.................... 
....................    usb_init_ep0_setup();
0624:  RCALL  0450
.................... 
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state
0626:  MOVLW  03
0628:  MOVWF  22
062A:  GOTO   1466 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_init_ep0_setup()
.................... /*
.................... /* Summary: Configure EP0 to receive setup packets
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_ep0_setup(void) 
.................... {
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH;
*
0450:  MOVLW  40
0452:  MOVLB  4
0454:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION;
0456:  MOVLW  04
0458:  MOVLB  2
045A:  MOVWF  x8B
045C:  MOVLW  18
045E:  MOVFF  28B,403
0462:  MOVFF  FE8,402
....................    #if USB_IGNORE_RX_DTS
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off
....................    #else
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on
0466:  MOVLW  88
0468:  MOVLB  4
046A:  MOVWF  x00
....................    #endif
.................... 
....................     EP_BDxST_I(0) = 0;
046C:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH;
046E:  MOVLW  04
0470:  MOVWF  x07
0472:  MOVLW  58
0474:  MOVWF  x06
0476:  MOVLB  0
0478:  RETURN 0
.................... }
.................... 
.................... /*******************************************************************************
.................... /* usb_isr_uerr()
.................... /*
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter
.................... /*          will incerement.  If having problems check the status of these 8 bytes.
.................... /*
.................... /* NOTE: This code is not enabled by default.
.................... /********************************************************************************/
.................... void usb_isr_uerr(void)
.................... {
....................   #if USB_USE_ERROR_COUNTER
....................    int ints;
....................   #endif
.................... 
....................    debug_usb_control(debug_putc,"-E%X-",UEIR);
.................... 
....................   #if USB_USE_ERROR_COUNTER
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled
.................... 
....................    if ( bit_test(ints,0) ) 
....................    { 
....................       //increment pid_error counter
....................       //debug_usb(debug_putc,"PID ");
....................       ERROR_COUNTER[0]++;
....................    }
.................... 
....................    if ( bit_test(ints,1) ) 
....................    {  
....................       //increment crc5 error counter
....................       //debug_usb(debug_putc,"CRC5 ");
....................       ERROR_COUNTER[1]++;
....................    }
.................... 
....................    if ( bit_test(ints,2) ) 
....................    {
....................       //increment crc16 error counter
....................       //debug_usb(debug_putc,"CRC16 ");
....................       ERROR_COUNTER[2]++;
....................    }
.................... 
....................    if ( bit_test(ints,3) ) 
....................    {  
....................       //increment dfn8 error counter
....................       //debug_usb(debug_putc,"DFN8 ");
....................       ERROR_COUNTER[3]++;
....................    }
.................... 
....................    if ( bit_test(ints,4) ) 
....................    {  
....................       //increment bto error counter
....................       //debug_usb(debug_putc,"BTO ");
....................       ERROR_COUNTER[4]++;
....................    }
.................... 
....................    if ( bit_test(ints,7) ) 
....................    { 
....................       //increment bts error counter
....................       //debug_usb(debug_putc,"BTS ");
....................       ERROR_COUNTER[5]++;
....................    }
....................   #endif
.................... 
....................    UEIR = 0;
*
0488:  CLRF   F6A
....................    
....................    //UIR_UERR = 0;
....................    UIR &= ~(1 << BIT_UERR);
048A:  BCF    F68.1
048C:  GOTO   145C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_uidle()
.................... /*
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_uidle(void)
.................... {
....................    debug_usb_control(debug_putc, "-I-");
.................... 
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice)
*
062E:  BSF    F69.2
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
....................    // turn off isr instead of clearing flag
....................    UIE &= ~(unsigned int16)__USB_UIF_IDLE;
0630:  BCF    F69.4
....................   #else
....................    UIR &= ~(1 << BIT_IDLE);
....................   #endif
....................    
....................    UCON_SUSPND = 1; //set suspend. we are now suspended
0632:  BSF    F6D.1
0634:  GOTO   1470 (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
.................... /* usb_isr_activity()
.................... /*
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB
.................... /*          peripheral.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_activity(void)
.................... {
....................    debug_usb_control(debug_putc, "-A-");
.................... 
....................    UCON_SUSPND = 0; //turn off low power suspending
*
043E:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling
0440:  BCF    F69.2
....................    
....................    while(UIR_ACTV)
0442:  BTFSS  F68.2
0444:  BRA    044A
....................    {
....................       //UIR_ACTV = 0;
....................       UIR &= ~(1 << BIT_ACTV);
0446:  BCF    F68.2
....................    }
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
0448:  BRA    0442
....................    // now it's safe to clear the flag
....................    UIR &= ~(1 << BIT_IDLE);
044A:  BCF    F68.4
....................   #endif   
044C:  GOTO   1444 (RETURN)
.................... }
.................... 
.................... /******************************************************************************
.................... /* usb_isr_stall()
.................... /*
.................... /* Summary: Stall handshake detected.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_stall(void) 
.................... {
....................    debug_usb_control(debug_putc, "-S-");
....................    
....................    
....................    if (bit_test(UEP(0),0)) 
*
047A:  BTFSS  F70.0
047C:  BRA    0482
....................    {
....................       usb_init_ep0_setup();
047E:  RCALL  0450
....................       bit_clear(UEP(0), 0);
0480:  BCF    F70.0
....................    }
....................    
....................    //UIR_STALL = 0;
....................    UIR &= ~(1 << BIT_STALL);
0482:  BCF    F68.5
0484:  GOTO   1452 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;}
*
063E:  MOVFF  28F,23
0642:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;}
*
0C9A:  MOVLW  FE
0C9C:  MOVWF  23
0C9E:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;}
*
0644:  SETF   23
0646:  RETURN 0
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_tok_dne()
.................... /*
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral.
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and
.................... /*          handle the request.
.................... /*          If an IN token on EP0 was received, continue transmitting any
.................... /*          unfinished requests that may take more than one packet to transmit
.................... /*          (if necessary).
.................... /*          If an OUT token on any other EP was received, mark that EP as ready
.................... /*          for a usb_get_packet().
.................... /*          Does not handle any IN or OUT tokens on EP0.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_tok_dne(void) 
.................... {
....................    unsigned int8 en;
.................... 
....................    en = USTATCopy>>3;
*
1330:  RRCF   21,W
1332:  MOVLB  2
1334:  MOVWF  x8A
1336:  RRCF   x8A,F
1338:  RRCF   x8A,F
133A:  MOVLW  1F
133C:  ANDWF  x8A,F
.................... 
....................    debug_usb_control(debug_putc, "-T%X-", USTATCopy);
.................... 
....................    if (USTATCopy == USTAT_OUT_SETUP_E0) 
133E:  MOVF   21,F
1340:  BNZ   13DE
....................    {
....................       //new out or setup token in the buffer
....................       int8 pidKey;
....................       
....................       //debug_usb(debug_putc,"%X ", EP_BDxST_O(0));
....................       
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID
1342:  MOVLB  4
1344:  MOVF   x00,W
1346:  ANDLW  3C
1348:  MOVLB  2
134A:  MOVWF  x8B
....................       
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion
134C:  MOVLW  43
134E:  MOVLB  4
1350:  ANDWF  x00,F
....................       
....................       if (pidKey == USB_PIC_PID_SETUP) 
1352:  MOVLB  2
1354:  MOVF   x8B,W
1356:  SUBLW  34
1358:  BNZ   13A4
....................       {
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00)
135A:  MOVLB  4
135C:  MOVF   x04,W
135E:  ANDLW  80
1360:  BZ    1364
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests)
1362:  CLRF   x04
.................... 
....................          //debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0));
....................          //debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer);
.................... 
....................          usb_isr_tok_setup_dne();
1364:  MOVLB  0
1366:  BRA    0D3C
.................... 
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
1368:  BCF    F6D.4
.................... 
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall())
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data())
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response())
....................          if (__setup_0_tx_size == 0xFF)
136A:  INCFSZ 23,W
136C:  BRA    137C
....................             usb_flush_out(0, USB_DTS_STALL);
136E:  MOVLB  2
1370:  CLRF   x8D
1372:  MOVLW  03
1374:  MOVWF  x8E
1376:  MOVLB  0
1378:  RCALL  0D6E
137A:  BRA    13A0
....................          else 
....................          {
....................             usb_flush_out(0, USB_DTS_TOGGLE);
137C:  MOVLB  2
137E:  CLRF   x8D
1380:  MOVLW  02
1382:  MOVWF  x8E
1384:  MOVLB  0
1386:  RCALL  0D6E
....................             if (__setup_0_tx_size != 0xFE)
1388:  MOVF   23,W
138A:  SUBLW  FE
138C:  BZ    13A0
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX);
138E:  MOVLB  2
1390:  CLRF   x9F
1392:  CLRF   xA1
1394:  MOVFF  23,2A0
1398:  MOVLW  04
139A:  MOVWF  xA2
139C:  MOVLB  0
139E:  RCALL  0EC4
....................          }
....................          //why was this here?
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
....................       }
13A0:  BRA    13DA
13A2:  MOVLB  2
....................       else if (pidKey == USB_PIC_PID_OUT) 
13A4:  MOVF   x8B,W
13A6:  SUBLW  04
13A8:  BNZ   13DC
....................       {
....................          usb_isr_tok_out_dne(0);
13AA:  CLRF   x8C
13AC:  MOVLB  0
13AE:  RCALL  10C6
....................          usb_flush_out(0, USB_DTS_TOGGLE);
13B0:  MOVLB  2
13B2:  CLRF   x8D
13B4:  MOVLW  02
13B6:  MOVWF  x8E
13B8:  MOVLB  0
13BA:  RCALL  0D6E
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF))
13BC:  MOVF   23,W
13BE:  SUBLW  FE
13C0:  BZ    13DA
13C2:  INCFSZ 23,W
13C4:  BRA    13C8
13C6:  BRA    13DA
....................          {
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len)
13C8:  MOVLB  2
13CA:  CLRF   x9F
13CC:  CLRF   xA1
13CE:  MOVFF  23,2A0
13D2:  MOVLW  01
13D4:  MOVWF  xA2
13D6:  MOVLB  0
13D8:  RCALL  0EC4
13DA:  MOVLB  2
....................          }
....................       }
....................       //else
....................       //{
....................       //   debug_usb(debug_putc, "!!! ");
....................       //}
....................    }
13DC:  BRA    1422
....................    else if (USTATCopy == USTAT_IN_E0) 
13DE:  MOVF   21,W
13E0:  SUBLW  04
13E2:  BNZ   1408
....................    {   
....................       //pic -> host transfer completed
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion
....................       __setup_0_tx_size = 0xFF;
13E4:  SETF   23
....................       usb_isr_tok_in_dne(0);
13E6:  CLRF   x8C
13E8:  MOVLB  0
13EA:  RCALL  12FE
....................       if (__setup_0_tx_size!=0xFF)
13EC:  INCFSZ 23,W
13EE:  BRA    13F2
13F0:  BRA    1404
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE);
13F2:  MOVLB  2
13F4:  CLRF   x9F
13F6:  CLRF   xA1
13F8:  MOVFF  23,2A0
13FC:  MOVLW  02
13FE:  MOVWF  xA2
1400:  MOVLB  0
1402:  RCALL  0EC4
....................       else
....................       {
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................       }  
....................    }
1404:  BRA    1420
1406:  MOVLB  2
....................    else 
....................    {
....................       if (!bit_test(USTATCopy, 2)) 
1408:  BTFSC  21.2
140A:  BRA    1418
....................       {
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_out_dne(en);
140C:  MOVFF  28A,28C
1410:  MOVLB  0
1412:  RCALL  10C6
....................       }
1414:  BRA    1420
1416:  MOVLB  2
....................       else 
....................       {
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_in_dne(en);
1418:  MOVFF  28A,28C
141C:  MOVLB  0
141E:  RCALL  12FE
1420:  MOVLB  2
....................       }
....................    }
1422:  MOVLB  0
1424:  GOTO   1492 (RETURN)
.................... }
.................... 
.................... /// END USB Interrupt Service Routine
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... #if defined(__PIC24_USB_H__)
....................  #include <pic24_usb.c>
.................... #endif
.................... 
.................... #if defined(__USBN960X_H__)
....................  #include <usbn960x.c>
.................... #endif
.................... 
.................... 
.................... #IFNDEF __USB_HARDWARE__
....................    #ERROR You must include USB hardware driver.
.................... #ENDIF
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
....................    #ERROR You must include USB descriptors.
.................... #ENDIF
.................... 
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1))
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  64
.................... #else
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  8
.................... #endif
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors
.................... 
.................... #IF USB_HID_BOOT_PROTOCOL
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES];
.................... #ENDIF
.................... 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size);
.................... 
.................... void usb_isr_tkn_setup_StandardEndpoint(void);
.................... void usb_isr_tkn_setup_StandardDevice(void);
.................... void usb_isr_tkn_setup_StandardInterface(void);
.................... #IF USB_HID_DEVICE
....................    void usb_isr_tkn_setup_ClassInterface(void);
.................... #ENDIF
.................... void usb_Get_Descriptor(void);
.................... void usb_copy_desc_seg_to_ep(void);
.................... void usb_finish_set_address(void);
.................... 
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors
.................... 
.................... /// BEGIN User Functions
.................... 
.................... // see usb.h for documentation
.................... int1 usb_enumerated(void)
.................... {
....................    return(USB_stack_status.curr_config);
*
1560:  MOVF   1B,W
1562:  MOVWF  01
1564:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_wait_for_enumeration(void) 
.................... {
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();}
.................... }
.................... 
.................... // see USB.H for documentation
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) {
....................    unsigned int16 i=0;
....................    int1 res;
....................    unsigned int16 this_packet_len;
....................    unsigned int16 packet_size;
....................    unsigned int32 timeout_1us;
.................... 
....................    packet_size = usb_ep_tx_size[endpoint];
....................    
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size);
.................... 
....................    //send data packets until timeout or no more packets to send
....................    while (i < len) 
....................    {
....................       timeout_1us = (int32)timeout*1000;
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;}
....................       else {this_packet_len = len-i;}
....................       //putc('*');
....................       do 
....................       {
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets
....................          //putc('.');
....................          if (!res)
....................          {
....................             delay_us(1);
....................             //delay_ms(500);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................       i += packet_size;
....................    }
.................... 
.................... 
....................    //send 0len packet if needed
....................    if (i==len) {
....................       timeout_1us=(int32)timeout*1000;
....................       do {
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message
....................          if (!res) {
....................             delay_us(1);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................    }
.................... 
....................    return(res);
.................... }
.................... 
.................... // see usb.h for documentation
.................... unsigned int16 usb_gets(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max, unsigned int16 timeout) {
....................    unsigned int16 ret=0;
....................    unsigned int16 to;
....................    unsigned int16 len;
....................    unsigned int16 packet_size;
....................    unsigned int16 this_packet_max;
.................... 
....................    packet_size=usb_ep_rx_size[endpoint];
.................... 
....................    do {
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;}
....................       to=0;
....................       do {
....................          len = packet_size;
....................          if (usb_kbhit(endpoint)) {
....................             len=usb_get_packet(endpoint,ptr,this_packet_max);
....................             ptr+=len;
....................             max-=len;
....................             ret+=len;
....................             break;
....................          }
....................          else {
....................             to++;
....................             delay_ms(1);
....................          }
....................       } while (to!=timeout);
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max);
.................... 
....................    return(ret);
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR)
.................... 
.................... // see usb.h for documentation
.................... void usb_token_reset(void) 
.................... {
....................    unsigned int i;
.................... 
....................    usb_getdesc_len = 0;
*
05CE:  CLRF   28
05D0:  CLRF   27
....................    
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++) 
05D2:  MOVLB  2
05D4:  CLRF   x92
05D6:  MOVF   x92,W
05D8:  SUBLW  01
05DA:  BNC   05F0
....................       USB_Interface[i] = 0;   //reset each interface to default
05DC:  CLRF   03
05DE:  MOVF   x92,W
05E0:  ADDLW  29
05E2:  MOVWF  FE9
05E4:  MOVLW  00
05E6:  ADDWFC 03,W
05E8:  MOVWF  FEA
05EA:  CLRF   FEF
.................... 
....................   #IF USB_HID_BOOT_PROTOCOL
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++)
....................       hid_protocol[i] = 1;
....................   #endif
.................... 
....................   #if USB_CDC_DEVICE
05EC:  INCF   x92,F
05EE:  BRA    05D6
....................    usb_cdc_init();
05F0:  MOVLB  0
05F2:  RCALL  058E
....................   #endif
.................... 
....................    USB_stack_status.curr_config = 0;      //unconfigured device
05F4:  CLRF   1B
.................... 
....................    USB_stack_status.status_device = 1;    //previous state.  init at none
05F6:  MOVLW  01
05F8:  MOVWF  1C
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none
05FA:  CLRF   1A
05FC:  RETURN 0
.................... }
.................... 
.................... //send a 0len packet to endpoint 0 (optimization)
.................... //notice that this doesnt return the status
.................... #define usb_put_0len_0() usb_request_send_response(0)
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    direction = bit_test(endpoint,7);
*
0490:  MOVLB  2
0492:  BCF    x97.0
0494:  BTFSC  x96.7
0496:  BSF    x97.0
....................    
....................    endpoint &= 0x7F;
0498:  BCF    x96.7
....................    
....................    if (endpoint > 16)
049A:  MOVF   x96,W
049C:  SUBLW  10
049E:  BC    04A6
....................       return(false);
04A0:  MOVLW  00
04A2:  MOVWF  01
04A4:  BRA    04DA
....................    
....................    if (direction) { //IN
04A6:  BTFSS  x97.0
04A8:  BRA    04C4
....................       return(usb_ep_tx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
04AA:  CLRF   03
04AC:  MOVF   x96,W
04AE:  MOVLB  0
04B0:  RCALL  00BA
04B2:  SUBLW  FF
04B4:  BNZ   04BA
04B6:  MOVLW  00
04B8:  BRA    04BC
04BA:  MOVLW  01
04BC:  MOVWF  01
04BE:  MOVLB  2
04C0:  BRA    04DA
....................    }
04C2:  BRA    04DA
....................    else {   //OUT
....................       return(usb_ep_rx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
04C4:  CLRF   03
04C6:  MOVF   x96,W
04C8:  MOVLB  0
04CA:  RCALL  00DA
04CC:  SUBLW  FF
04CE:  BNZ   04D4
04D0:  MOVLW  00
04D2:  BRA    04D6
04D4:  MOVLW  01
04D6:  MOVWF  01
04D8:  MOVLB  2
....................    }
04DA:  MOVLB  0
04DC:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) {
....................    if (endpoint==0) {
*
12FE:  MOVLB  2
1300:  MOVF   x8C,F
1302:  BNZ   1320
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor?
1304:  DECFSZ 1A,W
1306:  BRA    1312
1308:  MOVLB  0
130A:  CALL   0648
130E:  BRA    131C
1310:  MOVLB  2
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();}
1312:  MOVF   1A,W
1314:  SUBLW  02
1316:  BNZ   131E
1318:  MOVLB  0
131A:  BRA    10FE
131C:  MOVLB  2
....................    }
....................   #if USB_CDC_DEVICE
131E:  BRA    132C
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
1320:  MOVF   x8C,W
1322:  SUBLW  02
1324:  BNZ   132C
....................       usb_isr_tok_in_cdc_data_dne();
1326:  MOVLB  0
1328:  BRA    12F8
132A:  MOVLB  2
....................   }
....................   #endif
132C:  MOVLB  0
132E:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint)
.................... {
....................    //TODO:
....................    if (endpoint==0) {
*
10C6:  MOVLB  2
10C8:  MOVF   x8C,F
10CA:  BNZ   10D4
....................      debug_usb(debug_putc,"TOUT 0 ");
....................      #if USB_CDC_DEVICE
....................       usb_isr_tok_out_cdc_control_dne();
10CC:  MOVLB  0
10CE:  BRA    1010
....................      //#else   //REMOVED JUN/9/2009
....................      //usb_init_ep0_setup();
....................      #endif
....................    }
....................   #if USB_CDC_DEVICE
10D0:  BRA    10DE
10D2:  MOVLB  2
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
10D4:  MOVF   x8C,W
10D6:  SUBLW  02
10D8:  BNZ   10E0
....................       usb_isr_tok_out_cdc_data_dne();
10DA:  MOVLB  0
10DC:  BRA    10AA
10DE:  MOVLB  2
....................    }
....................   #endif
10E0:  MOVLB  0
10E2:  RETURN 0
....................    //else {
....................    //   bit_set(__usb_kbhit_status,endpoint);
....................    //}
.................... }
.................... 
.................... 
.................... //---- process setup message stage -----------//
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_setup_dne(void) 
.................... {
....................    USB_stack_status.dev_req=NONE; // clear the device request..
*
0D3C:  CLRF   1A
.................... 
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) {
0D3E:  MOVLB  4
0D40:  MOVF   x18,W
0D42:  ANDLW  7F
0D44:  XORLW  00
0D46:  MOVLB  0
0D48:  BZ    0D58
0D4A:  XORLW  01
0D4C:  BZ    0D5C
0D4E:  XORLW  03
0D50:  BZ    0D60
0D52:  XORLW  23
0D54:  BZ    0D64
0D56:  BRA    0D68
.................... 
....................       case 0x00:  //standard to device
....................          debug_usb_token(debug_putc," d");
....................          usb_isr_tkn_setup_StandardDevice();
0D58:  BRA    097C
....................          break;
0D5A:  BRA    0D6A
.................... 
....................       case 0x01:  //standard to interface
....................          debug_usb_token(debug_putc," i");
....................          usb_isr_tkn_setup_StandardInterface();
0D5C:  BRA    0A38
....................          break;
0D5E:  BRA    0D6A
.................... 
....................       case 0x02:  //standard to endpoint
....................          debug_usb_token(debug_putc," e");
....................          usb_isr_tkn_setup_StandardEndpoint();
0D60:  BRA    0C30
....................          break;
0D62:  BRA    0D6A
....................          
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case 0x21:  //class specific request.  the only class this driver supports is HID
....................          debug_usb_token(debug_putc, " class");
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE)
....................          {
....................             usb_isr_tkn_setup_ClassInterface();
....................          }
....................          else
....................          {
....................             usb_isr_tkn_cdc();
....................          }
....................         #elif USB_HID_DEVICE
....................          usb_isr_tkn_setup_ClassInterface();
....................         #else
....................          usb_isr_tkn_cdc();
0D64:  BRA    0CA0
....................         #endif
....................          break;
0D66:  BRA    0D6A
.................... #endif
.................... 
.................... 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE
.................... 
....................       default:
....................          usb_request_stall();
0D68:  RCALL  0644
....................          break;
....................    }
0D6A:  GOTO   1368 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardDevice()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Device request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardDevice(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
*
097C:  MOVLB  4
097E:  MOVF   x19,W
0980:  XORLW  00
0982:  MOVLB  0
0984:  BZ    09A0
0986:  XORLW  01
0988:  BZ    09B4
098A:  XORLW  02
098C:  BZ    09D0
098E:  XORLW  06
0990:  BZ    09EA
0992:  XORLW  03
0994:  BZ    09FC
0996:  XORLW  0E
0998:  BZ    0A00
099A:  XORLW  01
099C:  BZ    0A10
099E:  BRA    0A32
.................... 
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device;
09A0:  MOVFF  1C,458
....................             usb_ep0_tx_buffer[1]=0;
09A4:  MOVLB  4
09A6:  CLRF   x59
....................             usb_request_send_response(2);
09A8:  MOVLW  02
09AA:  MOVLB  2
09AC:  MOVWF  x8F
09AE:  MOVLB  0
09B0:  RCALL  063E
....................             break;
09B2:  BRA    0A34
.................... 
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1
....................             if (usb_ep0_rx_buffer[2] == 1) {
09B4:  MOVLB  4
09B6:  DECFSZ x1A,W
09B8:  BRA    09CA
....................                debug_usb_token(debug_putc,"CF");
....................                USB_stack_status.status_device &= 1;
09BA:  MOVLW  01
09BC:  ANDWF  1C,F
....................                usb_put_0len_0();
09BE:  MOVLB  2
09C0:  CLRF   x8F
09C2:  MOVLB  0
09C4:  RCALL  063E
....................             }
09C6:  BRA    09CE
09C8:  MOVLB  4
....................             else
....................                usb_request_stall();
09CA:  MOVLB  0
09CC:  RCALL  0644
....................             break;
09CE:  BRA    0A34
.................... 
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3
....................             if (usb_ep0_rx_buffer[2] == 1) {
09D0:  MOVLB  4
09D2:  DECFSZ x1A,W
09D4:  BRA    09E4
....................                debug_usb_token(debug_putc,"SF");
....................                USB_stack_status.status_device |= 2;
09D6:  BSF    1C.1
....................                usb_put_0len_0();
09D8:  MOVLB  2
09DA:  CLRF   x8F
09DC:  MOVLB  0
09DE:  RCALL  063E
....................             }
09E0:  BRA    09E8
09E2:  MOVLB  4
....................             else
....................                usb_request_stall();
09E4:  MOVLB  0
09E6:  RCALL  0644
....................             break;
09E8:  BRA    0A34
.................... 
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5
....................             debug_usb_token(debug_putc,"SA");
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request
09EA:  MOVLW  02
09EC:  MOVWF  1A
....................             USB_address_pending=usb_ep0_rx_buffer[2];
09EE:  MOVFF  41A,24
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request
....................             usb_set_address(USB_address_pending);
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0
....................             #endif
....................             usb_put_0len_0();
09F2:  MOVLB  2
09F4:  CLRF   x8F
09F6:  MOVLB  0
09F8:  RCALL  063E
....................             break;
09FA:  BRA    0A34
.................... 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6
....................             debug_usb_token(debug_putc,"GD");
....................             usb_Get_Descriptor();
09FC:  BRA    06D0
....................             break;
09FE:  BRA    0A34
.................... 
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8
....................             debug_usb_token(debug_putc,"GC");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config;
0A00:  MOVFF  1B,458
....................             usb_request_send_response(1);
0A04:  MOVLW  01
0A06:  MOVLB  2
0A08:  MOVWF  x8F
0A0A:  MOVLB  0
0A0C:  RCALL  063E
....................             break;
0A0E:  BRA    0A34
.................... 
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) {
0A10:  MOVLB  4
0A12:  MOVF   x1A,W
0A14:  SUBLW  01
0A16:  BNC   0A2E
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2];
0A18:  MOVFF  41A,1B
....................                usb_set_configured(usb_ep0_rx_buffer[2]);
0A1C:  MOVFF  41A,28C
0A20:  MOVLB  0
0A22:  BRA    078E
....................                debug_usb_token(debug_putc,"SC%U", USB_stack_status.curr_config);               
....................                usb_put_0len_0();
0A24:  MOVLB  2
0A26:  CLRF   x8F
0A28:  MOVLB  0
0A2A:  RCALL  063E
0A2C:  MOVLB  4
....................             }
....................             break;
0A2E:  MOVLB  0
0A30:  BRA    0A34
.................... 
....................       default:
....................             usb_request_stall();
0A32:  RCALL  0644
....................             break;
....................    }
0A34:  GOTO   0D6A (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Interface request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardInterface(void) {
....................    unsigned int8 curr_config;
.................... 
....................    curr_config=USB_stack_status.curr_config;
0A38:  MOVFF  1B,28C
.................... 
....................    switch (usb_ep0_rx_buffer[1]) {
0A3C:  MOVLB  4
0A3E:  MOVF   x19,W
0A40:  XORLW  00
0A42:  MOVLB  0
0A44:  BZ    0A50
0A46:  XORLW  0A
0A48:  BZ    0A62
0A4A:  XORLW  01
0A4C:  BZ    0AA8
0A4E:  BRA    0AD4
....................       case USB_STANDARD_REQUEST_GET_STATUS:
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=0;
0A50:  MOVLB  4
0A52:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0;
0A54:  CLRF   x59
....................             usb_request_send_response(2);
0A56:  MOVLW  02
0A58:  MOVLB  2
0A5A:  MOVWF  x8F
0A5C:  MOVLB  0
0A5E:  RCALL  063E
....................             break;
0A60:  BRA    0AD6
.................... 
....................       case USB_STANDARD_REQUEST_GET_INTERFACE:
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state
0A62:  MOVLB  2
0A64:  MOVF   x8C,F
0A66:  BZ    0AA2
0A68:  MOVLW  01
0A6A:  SUBWF  x8C,W
0A6C:  CLRF   03
0A6E:  MOVLB  0
0A70:  CALL   01AE
0A74:  MOVWF  01
0A76:  MOVLB  4
0A78:  SUBWF  x1C,W
0A7A:  BTFSS  FD8.0
0A7C:  BRA    0A82
0A7E:  MOVLB  2
0A80:  BRA    0AA2
....................                debug_usb_token(debug_putc,"GI");
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte
0A82:  CLRF   03
0A84:  MOVF   x1C,W
0A86:  ADDLW  29
0A88:  MOVWF  FE9
0A8A:  MOVLW  00
0A8C:  ADDWFC 03,W
0A8E:  MOVWF  FEA
0A90:  MOVFF  FEF,458
....................                usb_request_send_response(1); //send byte back
0A94:  MOVLW  01
0A96:  MOVLB  2
0A98:  MOVWF  x8F
0A9A:  MOVLB  0
0A9C:  RCALL  063E
....................             }
0A9E:  BRA    0AA6
0AA0:  MOVLB  2
....................             else
....................                usb_request_stall();
0AA2:  MOVLB  0
0AA4:  RCALL  0644
....................             break;
0AA6:  BRA    0AD6
.................... 
....................       case USB_STANDARD_REQUEST_SET_INTERFACE:
....................             if (curr_config) { //if configured state
0AA8:  MOVLB  2
0AAA:  MOVF   x8C,F
0AAC:  BZ    0ACE
....................                debug_usb_token(debug_putc,"SI");
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
0AAE:  CLRF   03
0AB0:  MOVLB  4
0AB2:  MOVF   x1C,W
0AB4:  ADDLW  29
0AB6:  MOVWF  FE9
0AB8:  MOVLW  00
0ABA:  ADDWFC 03,W
0ABC:  MOVWF  FEA
0ABE:  MOVFF  41A,FEF
....................                usb_put_0len_0();
0AC2:  MOVLB  2
0AC4:  CLRF   x8F
0AC6:  MOVLB  0
0AC8:  RCALL  063E
....................             }
0ACA:  BRA    0AD2
0ACC:  MOVLB  2
....................             else
....................                usb_request_stall();
0ACE:  MOVLB  0
0AD0:  RCALL  0644
....................             break;
0AD2:  BRA    0AD6
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR:
....................             debug_usb_token(debug_putc,"GDh");
....................             usb_Get_Descriptor();
....................             break;
.................... #endif
.................... 
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE:
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE:
.................... //                let default take care of these, goto wrongstate
....................       default:
....................             usb_request_stall();
0AD4:  RCALL  0644
....................             break;
....................    }
0AD6:  GOTO   0D6A (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardEndpoint()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardEndpoint(void) {
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) {
*
0C30:  MOVFF  41C,296
0C34:  RCALL  0490
0C36:  MOVF   01,F
0C38:  BZ    0C96
....................       switch(usb_ep0_rx_buffer[1]) {
0C3A:  MOVLB  4
0C3C:  MOVF   x19,W
0C3E:  XORLW  01
0C40:  MOVLB  0
0C42:  BZ    0C4E
0C44:  XORLW  02
0C46:  BZ    0C5E
0C48:  XORLW  03
0C4A:  BZ    0C6E
0C4C:  BRA    0C94
.................... 
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE:
....................                debug_usb_token(debug_putc,"CF");
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]);
0C4E:  MOVFF  41C,28C
0C52:  BRA    0ADA
....................                usb_put_0len_0();
0C54:  MOVLB  2
0C56:  CLRF   x8F
0C58:  MOVLB  0
0C5A:  RCALL  063E
....................                break;
0C5C:  BRA    0C96
.................... 
....................          case USB_STANDARD_REQUEST_SET_FEATURE:
....................                      debug_usb_token(debug_putc,"SF");
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]);
0C5E:  MOVFF  41C,28C
0C62:  BRA    0B54
....................                      usb_put_0len_0();
0C64:  MOVLB  2
0C66:  CLRF   x8F
0C68:  MOVLB  0
0C6A:  RCALL  063E
....................                      break;
0C6C:  BRA    0C96
.................... 
....................          case USB_STANDARD_REQUEST_GET_STATUS:
....................                debug_usb_token(debug_putc,"GS");
....................                usb_ep0_tx_buffer[0]=0;
0C6E:  MOVLB  4
0C70:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0;
0C72:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) {
0C74:  MOVFF  41C,28C
0C78:  MOVLB  0
0C7A:  BRA    0BBA
0C7C:  MOVF   01,F
0C7E:  BZ    0C88
....................                   usb_ep0_tx_buffer[0]=1;
0C80:  MOVLW  01
0C82:  MOVLB  4
0C84:  MOVWF  x58
0C86:  MOVLB  0
....................                }
....................                usb_request_send_response(2);
0C88:  MOVLW  02
0C8A:  MOVLB  2
0C8C:  MOVWF  x8F
0C8E:  MOVLB  0
0C90:  RCALL  063E
....................                break;
0C92:  BRA    0C96
.................... 
....................          default:
....................             usb_request_stall();
0C94:  RCALL  0644
....................             break;
....................       }
....................    }
0C96:  GOTO   0D6A (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_ClassInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /* Only compiled if HID_DEVICE is TRUE
.................... /***************************************************************/
.................... #IF USB_HID_DEVICE
.................... void usb_isr_tkn_setup_ClassInterface(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03
....................             debug_usb_token(debug_putc,"GP");
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]];
....................             usb_request_send_response(1);
....................             break;
....................     #ENDIF
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b
....................             debug_usb_token(debug_putc,"SP");
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
....................             usb_put_0len_0(); //send 0len packet69
....................             break;
....................     #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_SET_IDLE:   //0a
....................          #error TODO: if you want to support SET_IDLE, add code here
....................    #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_GET_IDLE:   //02
....................          #error TODO: if you want to support GET_IDLE, add code here
....................    #ENDIF
.................... 
....................       default:
....................             usb_request_stall();
....................             break;
....................    }
.................... }
.................... #ENDIF
.................... 
.................... /**************************************************************
.................... /* usb_Get_Descriptor()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept
.................... /*
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.),
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have
.................... /*          pointers to constants we must simulate or own by setting up global registers that say
.................... /*          which constant array to deal with, which position to start in this array, and the length.
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne()
.................... /*          which will send the rest of the data.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_Get_Descriptor() {
*
06D0:  MOVLB  2
06D2:  CLRF   x8C
....................    unsigned int8 i = 0;
....................    usb_getdesc_ptr=0;
06D4:  CLRF   26
06D6:  CLRF   25
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE;
06D8:  CLRF   1D
.................... 
....................    switch(usb_ep0_rx_buffer[3]) {
06DA:  MOVLB  4
06DC:  MOVF   x1B,W
06DE:  XORLW  01
06E0:  MOVLB  0
06E2:  BZ    06F2
06E4:  XORLW  03
06E6:  BZ    06FE
06E8:  XORLW  01
06EA:  BZ    0706
06EC:  XORLW  22
06EE:  BZ    073E
06F0:  BRA    0768
....................       case USB_DESC_DEVICE_TYPE:    //1
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN;
06F2:  CLRF   28
06F4:  MOVLW  12
06F6:  MOVWF  27
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE;
06F8:  MOVLW  03
06FA:  MOVWF  1D
....................             break;
06FC:  BRA    076C
.................... 
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually.
....................       case USB_DESC_CONFIG_TYPE:   //2
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN;
06FE:  CLRF   28
0700:  MOVLW  43
0702:  MOVWF  27
....................             break;
0704:  BRA    076C
.................... 
....................       case USB_DESC_STRING_TYPE: //3
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE;
0706:  MOVLW  02
0708:  MOVWF  1D
....................             //usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]];
....................             for(i=0; i<usb_ep0_rx_buffer[2]; i++)
070A:  MOVLB  2
070C:  CLRF   x8C
070E:  MOVLB  4
0710:  MOVF   x1A,W
0712:  MOVLB  2
0714:  SUBWF  x8C,W
0716:  BC    072E
....................             {
....................                usb_getdesc_ptr += USB_STRING_DESC[usb_getdesc_ptr];
0718:  MOVFF  26,03
071C:  MOVF   25,W
071E:  MOVLB  0
0720:  RCALL  01FA
0722:  ADDWF  25,F
0724:  MOVLW  00
0726:  ADDWFC 26,F
0728:  MOVLB  2
072A:  INCF   x8C,F
072C:  BRA    070E
....................             }
....................             usb_getdesc_len = USB_STRING_DESC[usb_getdesc_ptr];
072E:  MOVFF  26,03
0732:  MOVF   25,W
0734:  MOVLB  0
0736:  RCALL  01FA
0738:  MOVWF  27
073A:  CLRF   28
....................             break;
073C:  BRA    076C
.................... 
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06
....................       // this is needed so host can find out about differences about this
....................       // devices ability to handle full speed verses fast speed.
....................       // since we don't support fast speed then we ignore this.
....................       //      break;
.................... 
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case USB_DESC_CLASS_TYPE:  //0x21
....................             //TODO does this work for multiple interfaces or multiple languages?
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]];
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]];
073E:  CLRF   03
0740:  MOVLB  4
0742:  MOVF   x1A,W
0744:  MOVLB  0
0746:  RCALL  01C0
0748:  MOVWF  25
074A:  CLRF   26
....................             if (usb_getdesc_ptr!=0xFF) {
074C:  INCFSZ 25,W
074E:  BRA    0754
0750:  MOVF   26,F
0752:  BZ    0764
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr];
0754:  MOVFF  26,03
0758:  MOVF   25,W
075A:  RCALL  015A
075C:  MOVWF  27
075E:  CLRF   28
....................                break;
0760:  BRA    076C
....................             }
0762:  BRA    0768
....................             else {
....................                usb_request_stall();
0764:  RCALL  0644
....................                return;
0766:  BRA    078A
....................             }
.................... #endif
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_DESC_HIDREPORT_TYPE: //0x22
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]];
....................             if (usb_getdesc_ptr !=0xFF) {
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE;
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]];
....................                break;
....................             }
....................             else {
....................                usb_request_stall();
....................                return;
....................             }
.................... #endif
.................... 
....................       default:
....................             usb_request_stall();
0768:  RCALL  0644
....................             return;
076A:  BRA    078A
....................    }
....................    if (usb_ep0_rx_buffer[7]==0) {
076C:  MOVLB  4
076E:  MOVF   x1F,F
0770:  BNZ   0782
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6])
0772:  MOVF   28,F
0774:  BNZ   077C
0776:  MOVF   27,W
0778:  SUBWF  x1E,W
077A:  BC    0782
....................          usb_getdesc_len = usb_ep0_rx_buffer[6];
077C:  CLRF   28
077E:  MOVFF  41E,27
....................    }
....................    USB_stack_status.dev_req=GET_DESCRIPTOR;
0782:  MOVLW  01
0784:  MOVWF  1A
....................    usb_copy_desc_seg_to_ep();
0786:  MOVLB  0
0788:  RCALL  0648
078A:  GOTO   0A34 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_finish_set_address()
.................... /*
.................... /* Input: USB_address_pending holds the address we were asked to set to.
.................... /*
.................... /* Summary: Sets the address.
.................... /*
.................... /* This code should only be run on the PIC USB peripheral, and not the
.................... /* National peripheral.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
....................  void usb_finish_set_address() {
....................    debug_usb_token(debug_putc," FSA ");
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0
*
10FE:  CLRF   1B
.................... 
....................    #ifdef __PIC__
....................    USB_stack_status.dev_req=NONE;  // no request pending
1100:  CLRF   1A
....................    usb_set_address(USB_address_pending);
1102:  MOVFF  24,28D
1106:  BRA    10E4
....................    #endif
1108:  GOTO   131C (RETURN)
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// The following function retrieve data from constant arrays.  This may
.................... /// look un-optimized, but remember that you can't create a pointer to
.................... /// a constant array.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... void usb_copy_desc_seg_to_ep(void) {
*
0648:  MOVLB  2
064A:  CLRF   x8D
....................    unsigned int i=0;
....................    char c;
....................    
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]);
.................... 
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH))
064C:  MOVF   27,W
064E:  IORWF  28,W
0650:  BZ    06B8
0652:  MOVF   x8D,W
0654:  SUBLW  3F
0656:  BNC   06B8
....................    {
....................       switch(USB_stack_status.getdesc_type) {
0658:  MOVF   1D,W
065A:  XORLW  00
065C:  MOVLB  0
065E:  BZ    066A
0660:  XORLW  02
0662:  BZ    0678
0664:  XORLW  01
0666:  BZ    0686
0668:  BRA    0692
....................          case USB_GETDESC_CONFIG_TYPE:
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr];
066A:  MOVFF  26,03
066E:  MOVF   25,W
0670:  RCALL  015A
0672:  MOVFF  FE8,28E
....................             break;
0676:  BRA    0692
.................... 
....................         #IF USB_HID_DEVICE
....................          case USB_GETDESC_HIDREPORT_TYPE:
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr];
....................             break;
....................         #endif
.................... 
....................          case USB_GETDESC_STRING_TYPE:
....................             c=USB_STRING_DESC[usb_getdesc_ptr];
0678:  MOVFF  26,03
067C:  MOVF   25,W
067E:  RCALL  01FA
0680:  MOVFF  FE8,28E
....................             break;
0684:  BRA    0692
.................... 
....................          case USB_GETDESC_DEVICE_TYPE:
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr];
0686:  MOVFF  26,03
068A:  MOVF   25,W
068C:  RCALL  01D8
068E:  MOVFF  FE8,28E
....................             //debug_usb(debug_putc, "-%X- ", c);
....................             break;
....................       }
....................       usb_getdesc_ptr++;
0692:  INCF   25,F
0694:  BTFSC  FD8.2
0696:  INCF   26,F
....................       usb_getdesc_len--;
0698:  MOVF   27,W
069A:  BTFSC  FD8.2
069C:  DECF   28,F
069E:  DECF   27,F
....................       usb_ep0_tx_buffer[i++]=c;
06A0:  MOVLB  2
06A2:  MOVF   x8D,W
06A4:  INCF   x8D,F
06A6:  ADDLW  58
06A8:  MOVWF  FE9
06AA:  MOVLW  04
06AC:  MOVWF  FEA
06AE:  BTFSC  FD8.0
06B0:  INCF   FEA,F
06B2:  MOVFF  28E,FEF
06B6:  BRA    064C
....................    }
.................... 
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) {
06B8:  MOVF   27,W
06BA:  IORWF  28,W
06BC:  BNZ   06C6
06BE:  MOVF   x8D,W
06C0:  SUBLW  40
06C2:  BZ    06C6
....................          USB_stack_status.dev_req = NONE;
06C4:  CLRF   1A
....................    }
.................... 
....................    usb_request_send_response(i);
06C6:  MOVFF  28D,28F
06CA:  MOVLB  0
06CC:  RCALL  063E
06CE:  RETURN 0
.................... }
.................... 
.................... #ENDIF
.................... 
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk
....................    transfer endpoints is not supported on slow speed devices per the USB
....................    specification.  You may be able to find unofficial drivers for your
....................    operating system that allows CDC to operate on a slow speed device,
....................    but CCS doesn't have any that they can recommend to you.
.................... */
.................... #if (USB_USE_FULL_SPEED==0)
....................    #error CDC and slow speed is not supported.  See comments above.
.................... #endif
.................... 
.................... struct {
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2)
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space)
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16)
.................... } __attribute__((__packed__)) usb_cdc_line_coding;
.................... 
.................... //length of time, in ms, of break signal as we received in a SendBreak message.
.................... //if ==0xFFFF, send break signal until we receive a 0x0000.
.................... unsigned int16 usb_cdc_break;
.................... 
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1];
.................... #else
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE];
.................... #endif
.................... 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT)
.................... #if sizeof(usb_cdc_put_buffer)>=0x100
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this.
....................  typedef unsigned int16 usb_cdc_tx_t;
.................... #else
....................  typedef unsigned int8 usb_cdc_tx_t;
.................... #endif
.................... 
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin;
.................... //#locate usb_cdc_put_buffer_nextin=0x1800
.................... 
.................... 
.................... #if defined(__PIC__)
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer
.................... #else
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE];
.................... #endif
.................... 
.................... int1 usb_cdc_got_set_line_coding;
.................... 
.................... struct  {
....................    int1 dte_present; //1=DTE present, 0=DTE not present
....................    int1 active;      //1=activate carrier, 0=deactivate carrier
....................    unsigned int reserved:6;
.................... } usb_cdc_carrier;
.................... 
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state;
.................... 
.................... /*
.................... #if defined(__PCH__)
....................  #byte INTCON=0xFF2
....................  #bit INT_GIE=INTCON.7
.................... #else
....................  #word SR=0x42
.................... #endif
.................... */
.................... 
.................... #if defined(USB_CDC_USE_ENCAPSULATED)
.................... unsigned int16 g_UsbCdcSendEncapsSize;
.................... #endif
.................... 
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data]
.................... void usb_isr_tok_out_cdc_control_dne(void) 
.................... {
....................    switch (__usb_cdc_state) {
*
1010:  MOVF   xB7,W
1012:  XORLW  01
1014:  BZ    101C
1016:  XORLW  03
1018:  BZ    102A
101A:  BRA    1052
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state);
....................       case USB_CDC_OUT_COMMAND:
....................         #if defined(USB_CDC_USE_ENCAPSULATED)
....................          usb_cdc_SendEncapsulatedCommand(usb_ep0_rx_buffer, g_UsbCdcSendEncapsSize);
....................         #endif
....................          usb_put_0len_0();
101C:  MOVLB  2
101E:  CLRF   x8F
1020:  MOVLB  0
1022:  CALL   063E
....................          __usb_cdc_state=0;
1026:  CLRF   xB7
....................          break;
1028:  BRA    1054
.................... 
....................     #if USB_MAX_EP0_PACKET_LENGTH==8
....................       case USB_CDC_WAIT_0LEN:
....................          usb_put_0len_0();
....................          __usb_cdc_state=0;
....................          break;
....................     #endif
.................... 
....................       case USB_CDC_OUT_LINECODING:
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7);
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n");
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7);
102A:  CLRF   FEA
102C:  MOVLW  2B
102E:  MOVWF  FE9
1030:  MOVLW  04
1032:  MOVWF  FE2
1034:  MOVLW  18
1036:  MOVWF  FE1
1038:  MOVLW  07
103A:  MOVWF  01
103C:  MOVFF  FE6,FEE
1040:  DECFSZ 01,F
1042:  BRA    103C
....................          __usb_cdc_state=0;
1044:  CLRF   xB7
....................          usb_put_0len_0();
1046:  MOVLB  2
1048:  CLRF   x8F
104A:  MOVLB  0
104C:  CALL   063E
....................          break;
1050:  BRA    1054
.................... 
....................       default:
....................          __usb_cdc_state=0;
1052:  CLRF   xB7
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................          break;
....................    }
1054:  GOTO   10D0 (RETURN)
.................... }
.................... 
.................... //handle IN token on 0 (setup packet)
.................... void usb_isr_tkn_cdc(void) {
....................    unsigned int16 wLen;
....................    //make sure the request goes to a CDC interface
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) {
*
0CA0:  MOVLB  4
0CA2:  DECFSZ x1C,W
0CA4:  BRA    0CA8
0CA6:  BRA    0CAC
0CA8:  MOVF   x1C,F
0CAA:  BNZ   0D36
....................       wLen = make16(usb_ep0_rx_buffer[7], usb_ep0_rx_buffer[6]);
0CAC:  MOVFF  41F,28D
0CB0:  MOVFF  41E,28C
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]);
....................       switch(usb_ep0_rx_buffer[1]) {
0CB4:  MOVF   x19,W
0CB6:  XORLW  00
0CB8:  MOVLB  0
0CBA:  BZ    0CD2
0CBC:  XORLW  01
0CBE:  BZ    0CDA
0CC0:  XORLW  21
0CC2:  BZ    0CE2
0CC4:  XORLW  01
0CC6:  BZ    0CEC
0CC8:  XORLW  03
0CCA:  BZ    0D12
0CCC:  XORLW  01
0CCE:  BZ    0D20
0CD0:  BRA    0D32
....................          case 0x00:  //send_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             g_UsbCdcSendEncapsSize = wLen;
....................            #endif
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND;
0CD2:  MOVLW  01
0CD4:  MOVWF  xB7
....................             usb_request_get_data();
0CD6:  RCALL  0C9A
....................             break;
0CD8:  BRA    0D34
.................... 
....................          case 0x01:  //get_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             usb_cdc_GetEncapsulatedResponse(usb_ep0_tx_buffer, wLen);
....................            #endif
....................             usb_request_send_response(wLen);
0CDA:  MOVFF  28C,28F
0CDE:  RCALL  063E
....................             break;
0CE0:  BRA    0D34
.................... 
....................          case 0x20:  //set_line_coding
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING;
0CE2:  MOVLW  02
0CE4:  MOVWF  xB7
....................             usb_cdc_got_set_line_coding=true;
0CE6:  BSF    xB5.0
....................             usb_request_get_data();
0CE8:  RCALL  0C9A
....................             break;
0CEA:  BRA    0D34
.................... 
....................          case 0x21:  //get_line_coding
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding));
0CEC:  MOVLW  04
0CEE:  MOVWF  FEA
0CF0:  MOVLW  58
0CF2:  MOVWF  FE9
0CF4:  CLRF   FE2
0CF6:  MOVLW  2B
0CF8:  MOVWF  FE1
0CFA:  MOVLW  07
0CFC:  MOVWF  01
0CFE:  MOVFF  FE6,FEE
0D02:  DECFSZ 01,F
0D04:  BRA    0CFE
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes
0D06:  MOVLW  07
0D08:  MOVLB  2
0D0A:  MOVWF  x8F
0D0C:  MOVLB  0
0D0E:  RCALL  063E
....................             break;
0D10:  BRA    0D34
.................... 
....................          case 0x22:  //set_control_line_state
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2];
0D12:  MOVFF  41A,B6
....................             usb_put_0len_0();
0D16:  MOVLB  2
0D18:  CLRF   x8F
0D1A:  MOVLB  0
0D1C:  RCALL  063E
....................             break;
0D1E:  BRA    0D34
.................... 
....................          case 0x23:  //send_break
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]);
0D20:  MOVFF  41A,33
0D24:  MOVFF  41B,32
....................             usb_put_0len_0();
0D28:  MOVLB  2
0D2A:  CLRF   x8F
0D2C:  MOVLB  0
0D2E:  RCALL  063E
....................             break;
0D30:  BRA    0D34
.................... 
....................          default:
....................             usb_request_stall();
0D32:  RCALL  0644
....................             break;
0D34:  MOVLB  4
....................       }
....................    }
0D36:  MOVLB  0
0D38:  GOTO   0D6A (RETURN)
.................... }
.................... 
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars]
.................... void usb_isr_tok_out_cdc_data_dne(void) {
....................    usb_cdc_get_buffer_status.got=true;
*
10AA:  BSF    1E.0
....................    usb_cdc_get_buffer_status.index=0;
10AC:  CLRF   20
.................... #if (defined(__PIC__) && __PIC__)
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT);
10AE:  MOVLW  02
10B0:  MOVLB  2
10B2:  MOVWF  x8D
10B4:  MOVLB  0
10B6:  BRA    1058
10B8:  MOVFF  01,1F
.................... #else
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer(
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE);
.................... #endif
....................    if (!usb_cdc_get_buffer_status.len)
10BC:  MOVF   1F,F
10BE:  BNZ   10C2
....................    {
....................       usb_cdc_get_discard();
10C0:  BRA    1098
....................    }
10C2:  GOTO   10DE (RETURN)
....................    /*
....................   #if defined(USB_CDC_ISR)
....................    else
....................    {
....................       USB_CDC_ISR();
....................    }
....................   #endif
....................   */
.................... }
.................... 
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters]
.................... void usb_isr_tok_in_cdc_data_dne(void) 
.................... {
....................    usb_cdc_flush_tx_buffer();
*
12F8:  RCALL  1286
12FA:  GOTO   132A (RETURN)
.................... }
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
*
11AA:  MOVFF  29B,2A1
11AE:  MOVFF  29A,2A0
....................    sc2=s2;
11B2:  MOVFF  29D,2A3
11B6:  MOVFF  29C,2A2
....................    if(sc2<sc1 && sc1 <sc2 +n)
11BA:  MOVLB  2
11BC:  MOVF   xA3,W
11BE:  SUBWF  xA1,W
11C0:  BNC   123A
11C2:  BNZ   11CA
11C4:  MOVF   xA0,W
11C6:  SUBWF  xA2,W
11C8:  BC    123A
11CA:  MOVF   x9E,W
11CC:  ADDWF  xA2,W
11CE:  MOVWF  01
11D0:  MOVF   x9F,W
11D2:  ADDWFC xA3,W
11D4:  MOVWF  03
11D6:  MOVF   xA1,W
11D8:  SUBWF  03,W
11DA:  BNC   123A
11DC:  BNZ   11E4
11DE:  MOVF   01,W
11E0:  SUBWF  xA0,W
11E2:  BC    123A
....................       for(sc1+=n,sc2+=n;0<n;--n)
11E4:  MOVF   x9E,W
11E6:  ADDWF  xA0,F
11E8:  MOVF   x9F,W
11EA:  ADDWFC xA1,F
11EC:  MOVF   x9E,W
11EE:  ADDWF  xA2,F
11F0:  MOVF   x9F,W
11F2:  ADDWFC xA3,F
11F4:  MOVF   x9F,F
11F6:  BNZ   11FE
11F8:  MOVF   x9E,W
11FA:  SUBLW  00
11FC:  BC    1238
....................          *--sc1=*--sc2;
11FE:  MOVF   xA0,W
1200:  BTFSC  FD8.2
1202:  DECF   xA1,F
1204:  DECF   xA0,F
1206:  MOVFF  2A1,2A5
120A:  MOVFF  2A0,2A4
120E:  MOVF   xA2,W
1210:  BTFSC  FD8.2
1212:  DECF   xA3,F
1214:  DECF   xA2,F
1216:  MOVFF  2A3,FEA
121A:  MOVFF  2A2,FE9
121E:  MOVFF  FEF,2A6
1222:  MOVFF  2A1,FEA
1226:  MOVFF  2A0,FE9
122A:  MOVFF  2A6,FEF
122E:  MOVF   x9E,W
1230:  BTFSC  FD8.2
1232:  DECF   x9F,F
1234:  DECF   x9E,F
1236:  BRA    11F4
1238:  BRA    127A
....................    else
....................       for(;0<n;--n)
123A:  MOVF   x9F,F
123C:  BNZ   1244
123E:  MOVF   x9E,W
1240:  SUBLW  00
1242:  BC    127A
....................          *sc1++=*sc2++;
1244:  MOVFF  2A1,2A5
1248:  MOVF   xA0,W
124A:  INCF   xA0,F
124C:  BTFSC  FD8.2
124E:  INCF   xA1,F
1250:  MOVWF  xA4
1252:  MOVFF  2A3,FEA
1256:  MOVF   xA2,W
1258:  INCF   xA2,F
125A:  BTFSC  FD8.2
125C:  INCF   xA3,F
125E:  MOVWF  FE9
1260:  MOVFF  FEF,2A6
1264:  MOVFF  2A5,FEA
1268:  MOVFF  2A4,FE9
126C:  MOVFF  2A6,FEF
1270:  MOVF   x9E,W
1272:  BTFSC  FD8.2
1274:  DECF   x9F,F
1276:  DECF   x9E,F
1278:  BRA    123A
....................   return s1;
127A:  MOVFF  29A,01
127E:  MOVFF  29B,02
1282:  MOVLB  0
1284:  RETURN 0
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... void usb_cdc_flush_tx_buffer(void) 
.................... {
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE
....................    usb_cdc_tx_t n;
....................   #endif
....................   
....................    if (usb_cdc_put_buffer_nextin != 0)
1286:  MOVF   xB4,F
1288:  BZ    12F6
....................    {
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE))
....................       {
....................          usb_cdc_put_buffer_nextin = 0;
....................       }
....................      #else
....................       n = usb_cdc_put_buffer_nextin;
128A:  MOVFF  B4,296
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets
128E:  MOVLB  2
1290:  MOVF   x96,W
1292:  SUBLW  3F
1294:  BC    129A
....................          n = USB_CDC_DATA_IN_SIZE-1;
1296:  MOVLW  3F
1298:  MOVWF  x96
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE))
129A:  MOVLW  02
129C:  MOVWF  x97
129E:  CLRF   x99
12A0:  MOVLW  34
12A2:  MOVWF  x98
12A4:  CLRF   x9B
12A6:  MOVFF  296,29A
12AA:  MOVLW  02
12AC:  MOVWF  x9C
12AE:  MOVLB  0
12B0:  RCALL  110C
12B2:  MOVF   01,F
12B4:  BZ    12F6
....................       {
....................          //pull the buffer back
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n);
12B6:  CLRF   03
12B8:  MOVLB  2
12BA:  MOVF   x96,W
12BC:  ADDLW  34
12BE:  MOVWF  01
12C0:  MOVLW  00
12C2:  ADDWFC 03,F
12C4:  MOVFF  01,297
12C8:  MOVFF  03,298
12CC:  MOVF   x96,W
12CE:  MOVLB  0
12D0:  SUBWF  xB4,W
12D2:  MOVLB  2
12D4:  MOVWF  x99
12D6:  CLRF   x9B
12D8:  MOVLW  34
12DA:  MOVWF  x9A
12DC:  MOVFF  03,29D
12E0:  MOVFF  01,29C
12E4:  CLRF   x9F
12E6:  MOVFF  299,29E
12EA:  MOVLB  0
12EC:  RCALL  11AA
....................          usb_cdc_put_buffer_nextin -= n;
12EE:  MOVLB  2
12F0:  MOVF   x96,W
12F2:  MOVLB  0
12F4:  SUBWF  xB4,F
....................       }      
....................      #endif
....................    }
12F6:  RETURN 0
.................... }
.................... 
.................... void usb_cdc_init(void) 
.................... {
....................    usb_cdc_line_coding.dwDTERrate = 9600;
*
058E:  MOVLB  2
0590:  CLRF   x96
0592:  CLRF   x95
0594:  MOVLW  25
0596:  MOVWF  x94
0598:  MOVLW  80
059A:  MOVWF  x93
059C:  MOVFF  293,2B
05A0:  MOVFF  294,2C
05A4:  CLRF   2D
05A6:  CLRF   2E
....................    usb_cdc_line_coding.bCharFormat = 0;
05A8:  CLRF   x93
05AA:  MOVFF  293,2F
....................    usb_cdc_line_coding.bParityType = 0;
05AE:  CLRF   x93
05B0:  MOVFF  293,30
....................    usb_cdc_line_coding.bDataBits = 8;
05B4:  MOVLW  08
05B6:  MOVWF  x93
05B8:  MOVFF  293,31
....................    (int8)usb_cdc_carrier = 0;
05BC:  MOVLB  0
05BE:  CLRF   xB6
....................    usb_cdc_got_set_line_coding = false;
05C0:  BCF    xB5.0
....................    usb_cdc_break = 0;
05C2:  CLRF   33
05C4:  CLRF   32
....................    usb_cdc_put_buffer_nextin = 0;
05C6:  CLRF   xB4
....................    usb_cdc_get_buffer_status.got = 0;
05C8:  BCF    1E.0
....................    __usb_cdc_state = 0;
05CA:  CLRF   xB7
05CC:  RETURN 0
.................... }
.................... 
.................... ////////////////// END USB CONTROL HANDLING //////////////////////////////////
.................... 
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY /////////////////////////////
.................... 
.................... typedef struct
.................... {
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD.
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device.
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device. 
....................    unsigned int bFraming:1;   //A framing error has occurred.
....................    unsigned int bParity:1;    //A parity error has occurred.
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device.
....................    unsigned int reserved0:1;   //future use
....................    unsigned int reserved1:8;   //future use
.................... } cdc_serial_state_t;
.................... 
.................... /*
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring, 
....................    break signal and more (see cdc_serial_state_t).
....................    Some of these values are held by the host (meaning it's value only needs
....................    to be sent on change), but some values are one shot (meaning you continously
....................    need to send value to host while being held).
.................... */
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state)
.................... {
....................   #if __USB_PIC_PERIF__
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer
....................   #else
....................    unsigned int8 payload[10];
....................    #define CDC_EP1_NOTIFY_BUFFER payload
....................   #endif
.................... 
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT))
....................       return(false);
.................... 
....................    //bmRequestType
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001
....................    //bNotification
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE
....................    //wValue
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0;
....................    //wIndex
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0;
....................    //wLength
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t)
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0;
....................    //data
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state;
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8;
.................... 
....................   #if __USB_PIC_PERIF__
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE);
....................   #else
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE);
....................   #endif
....................    
....................    return(true);
.................... }
.................... 
.................... void usb_cdc_get_discard(void)
.................... {
....................    usb_cdc_get_buffer_status.got = false;
*
1098:  BCF    1E.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE);
109A:  MOVLW  02
109C:  MOVLB  2
109E:  MOVWF  x8D
10A0:  MOVWF  x8E
10A2:  MOVLB  0
10A4:  RCALL  0D6E
10A6:  GOTO   10C2 (RETURN)
.................... }
.................... 
.................... char usb_cdc_getc(void) 
.................... {
....................    char c;
.................... 
....................    while (!usb_cdc_kbhit()) 
....................    {
....................      #if defined(USB_ISR_POLLING)
....................       usb_task();
....................      #endif
....................    }
.................... 
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++];
.................... 
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len) 
....................    {
....................       usb_cdc_get_discard();
....................    }
.................... 
....................    return(c);
.................... }
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... #define __USB_PAUSE_ISR()
.................... #define __USB_RESTORE_ISR()
.................... #else
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1
.................... #endif
.................... 
.................... static void _usb_cdc_putc_fast_noflush(char c)
.................... {
....................    __USB_PAUSE_ISR();
*
15B0:  MOVLB  2
15B2:  BCF    x95.0
15B4:  BTFSC  FA0.5
15B6:  BSF    x95.0
15B8:  BCF    FA0.5
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) 
15BA:  MOVLB  0
15BC:  MOVF   xB4,W
15BE:  SUBLW  7F
15C0:  BC    15C4
....................    {
....................       usb_cdc_flush_tx_buffer();
15C2:  RCALL  1286
....................    }
....................   #endif
.................... 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) {
15C4:  MOVF   xB4,W
15C6:  SUBLW  7F
15C8:  BC    15CE
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer!
15CA:  MOVLW  7F
15CC:  MOVWF  xB4
....................    }
....................    
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c;
15CE:  MOVF   xB4,W
15D0:  INCF   xB4,F
15D2:  CLRF   03
15D4:  ADDLW  34
15D6:  MOVWF  FE9
15D8:  MOVLW  00
15DA:  ADDWFC 03,W
15DC:  MOVWF  FEA
15DE:  MOVFF  294,FEF
.................... 
....................    __USB_RESTORE_ISR();
15E2:  MOVLB  2
15E4:  BTFSS  x95.0
15E6:  BRA    15EA
15E8:  BSF    FA0.5
15EA:  MOVLB  0
15EC:  RETURN 0
.................... }
.................... 
.................... void usb_cdc_putc_fast(char c)
.................... {
....................    _usb_cdc_putc_fast_noflush(c);
15EE:  MOVFF  293,294
15F2:  RCALL  15B0
.................... 
....................   #if defined(USB_ISR_POLLING)
....................    // if interrupts are disabled, we should clear all activity isrs
....................    // before we attempt to put any data onto an endpoint.
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT))
....................       return;
....................    usb_task();
....................   #endif
....................   
....................   #if !defined(USB_CDC_DELAYED_FLUSH)
15F4:  RETURN 0
....................    //if (usb_cdc_put_buffer_free()) 
....................    {
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin);
....................       usb_cdc_flush_tx_buffer();
....................    }
....................   #endif
.................... 
....................    //putc('*');
.................... }
.................... 
.................... void usb_cdc_putc(char c)
.................... {
....................    while (!usb_cdc_putready()) 
15F6:  MOVLW  80
15F8:  BSF    FD8.0
15FA:  SUBFWB xB4,W
15FC:  BNZ   1610
....................    {
....................      #if 1
....................       if (usb_cdc_put_buffer_free()) 
15FE:  MOVLW  02
1600:  MOVLB  2
1602:  MOVWF  xA4
1604:  MOVLB  0
1606:  RCALL  0E6E
1608:  MOVF   01,F
160A:  BZ    160E
....................       {
....................          usb_cdc_flush_tx_buffer();
160C:  RCALL  1286
....................       }
....................      #endif
.................... 
....................      #if defined(USB_ISR_POLLING)
160E:  BRA    15F6
....................       usb_task();
....................      #endif
....................    }
....................    usb_cdc_putc_fast(c);
1610:  MOVFF  292,293
1614:  RCALL  15EE
1616:  RETURN 0
.................... }
.................... 
.................... int1 usb_cdc_putd(char *ptr, unsigned int8 len)
.................... {
....................  #if USB_EP2_TX_SIZE>=0x100
....................    unsigned int16 i;
....................  #else
....................    unsigned int8 i;
....................  #endif
....................    char c;
....................    
....................    i = 0;
....................    
....................    if (!usb_cdc_put_buffer_free())
....................       return(false);
....................    
....................    while(len--)
....................    {
....................       c = *ptr++;
....................       _usb_cdc_putc_fast_noflush(c);
....................       if (++i >= USB_EP2_TX_SIZE)
....................          break;
....................    }
....................    
....................    usb_cdc_flush_tx_buffer();
....................    
....................    return(true);
.................... }
.................... 
.................... int1 usb_cdc_puts(char *ptr)
.................... {   
....................    unsigned int8 len;
.................... 
....................    len = strlen(ptr);
....................   
....................    return(usb_cdc_putd(ptr, len));
.................... }
.................... 
.................... #endif //__USB_CDC_HELPERS_ONLY__
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... char gethex1_usb() 
.................... {
....................    char digit;
.................... 
....................    digit = usb_cdc_getc();
.................... 
....................    usb_cdc_putc(digit);
.................... 
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((toupper(digit)-'A')+10);
.................... }
.................... 
.................... char gethex_usb() {
....................    unsigned int8 lo,hi;
.................... 
....................    hi = gethex1_usb();
....................    lo = gethex1_usb();
....................    if(lo==0xdd)
....................      return(hi);
....................    else
....................      return( hi*16+lo );
.................... }
.................... 
.................... void get_string_usb(char* s, unsigned int max) {
....................    unsigned int len;
....................    char c;
.................... 
....................    --max;
....................    len=0;
....................    do {
....................      c=usb_cdc_getc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           usb_cdc_putc(c);
....................           usb_cdc_putc(' ');
....................           usb_cdc_putc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<max) {
....................          s[len++]=c;
....................          usb_cdc_putc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... 
.................... 
.................... // stdlib.h is required for the ato_ conversions
.................... // in the following functions
.................... #ifdef _STDLIB
.................... 
.................... signed int get_int_usb() {
....................   char s[7];
....................   signed int i;
.................... 
....................   get_string_usb(s, 7);
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... 
.................... signed long get_long_usb() {
....................   char s[13];
....................   signed long l;
.................... 
....................   get_string_usb(s, 13);
....................   l=atol(s);
....................   return(l);
.................... }
.................... 
.................... float get_float_usb() {
....................   char s[20];
....................   float f;
.................... 
....................   get_string_usb(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... uint16_t globalMs;
.................... uint8_t globalSec;
.................... uint16_t globalMin;
.................... uint8_t fifoNotEmpty = 0;
.................... uint8_t maxRecievedSize = 255;
.................... //DIO0
.................... uint8_t payloadReady = 0;
.................... uint8_t fifoThresh = 0;
.................... 
.................... uint8_t packet_length = 64;
.................... bool using_spi = false;
.................... uint8_t button3_last_state = 0;
.................... char str[15];
.................... /*Para la cantidad de mensajes que se quieran leer:
.................... un debug level de 0 no contiene mensajes
.................... un debug level de 1 son solo los datos recibidos
.................... un debug level de 2 contiene errores
.................... un debug level de 3 contiene mas informacion util
.................... */
.................... int debugLevel = 1;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #use spi (MASTER, SPI1, ENABLE=PIN_A5, BAUD=1000000, MODE=0, BITS=8, STREAM=SPI_1)
.................... 
.................... #byte porta = 0xf80 // Identificador para el puerto A. 
.................... #byte portb = 0xf81 // Identificador para el puerto B. 
.................... #byte portc = 0xf82 // Identificador para el puerto C. 
.................... #byte portd = 0xf83 // Identificador para el puerto D. 
.................... #byte porte = 0xf84 // Identificador para el puerto E.
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlibm.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /*********************************************************************/
.................... #ifndef _STDLIBM
.................... #define _STDLIBM
.................... 
.................... /* Memory Management Functions*/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #if defined(__PCB__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int8 next; }node_t;
.................... #elif defined(__PCM__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCH__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCD__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #endif
.................... 
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY)
....................    #USE DYNAMIC_MEMORY
.................... #endif
.................... 
.................... #ifndef debug_stdlibm
....................    #define debug_stdlibm(s)
.................... #else
....................    #define __DO_DEBUG_STDLIBM
....................    
....................    char g_DebugStdlibmStr[50];
....................    
....................    #if defined(__PCD__)
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__))
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0))
....................       #else
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0))
....................       #endif
....................    #else
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM"))
....................    #endif
.................... #endif
.................... 
.................... #if defined(STDLIBM_TRACK_WORST_CASE)
....................    static size_t _g_StdlibmCurrentBytesUsed = 0;
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0;
....................    
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \
....................       _g_StdlibmCurrentBytesUsed += _x;   \
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed
....................    
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x
.................... #else
....................    #define _STDLIBM_TRACK_WORST_INC(_x)
....................    #define _STDLIBM_TRACK_WORST_DEC(_x)
.................... #endif
.................... 
.................... #include <memmgmt.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__PCH__)
....................  #define _MEMMGMT_CSIZE 32768
....................  #define _MEMMGMT_POS 15
.................... #elif defined(__PCD__)
....................    #define _MEMMGMT_CSIZE 32768
....................    #define _MEMMGMT_POS 15
.................... #else
....................    #define _MEMMGMT_CSIZE 127
....................    #define _MEMMGMT_POS 7
.................... #endif
.................... 
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location
.................... {
....................    node_t *result;
....................    result =ptr;
*
3250:  MOVFF  220,222
3254:  MOVFF  21F,221
....................    result->size=size;
3258:  MOVLB  2
325A:  MOVFF  221,FE9
325E:  MOVFF  222,FEA
3262:  MOVFF  21E,FEC
3266:  MOVF   FED,F
3268:  MOVFF  21D,FEF
....................    result->next = NULL;
326C:  MOVLW  02
326E:  ADDWF  x21,W
3270:  MOVWF  FE9
3272:  MOVLW  00
3274:  ADDWFC x22,W
3276:  MOVWF  FEA
3278:  CLRF   FEC
327A:  MOVF   FED,F
327C:  CLRF   FEF
....................    return result;
327E:  MOVFF  221,01
3282:  MOVFF  222,02
3286:  MOVLB  0
3288:  GOTO   33DC (RETURN)
.................... }
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node
.................... {
....................    node->size=size;
*
3312:  MOVLB  2
3314:  MOVFF  21E,FE9
3318:  MOVFF  21F,FEA
331C:  MOVFF  221,FEC
3320:  MOVF   FED,F
3322:  MOVFF  220,FEF
3326:  MOVLB  0
3328:  RETURN 0
.................... }
.................... 
.................... /* Insert node immediately after place */ //old,new
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node
.................... {
....................     if (place->next==NULL)
*
328C:  MOVLW  02
328E:  MOVLB  2
3290:  ADDWF  x19,W
3292:  MOVWF  FE9
3294:  MOVLW  00
3296:  ADDWFC x1A,W
3298:  MOVWF  FEA
329A:  MOVFF  FEC,21E
329E:  MOVF   FED,F
32A0:  MOVFF  FEF,21D
32A4:  MOVF   x1D,F
32A6:  BNZ   32C0
32A8:  MOVF   x1E,F
32AA:  BNZ   32C0
....................        node->next= NULL;
32AC:  MOVLW  02
32AE:  ADDWF  x1B,W
32B0:  MOVWF  FE9
32B2:  MOVLW  00
32B4:  ADDWFC x1C,W
32B6:  MOVWF  FEA
32B8:  CLRF   FEC
32BA:  MOVF   FED,F
32BC:  CLRF   FEF
32BE:  BRA    32F6
....................     else
....................        node->next=place->next;
32C0:  MOVLW  02
32C2:  ADDWF  x1B,W
32C4:  MOVWF  01
32C6:  MOVLW  00
32C8:  ADDWFC x1C,W
32CA:  MOVWF  03
32CC:  MOVWF  x1E
32CE:  MOVLW  02
32D0:  ADDWF  x19,W
32D2:  MOVWF  FE9
32D4:  MOVLW  00
32D6:  ADDWFC x1A,W
32D8:  MOVWF  FEA
32DA:  MOVFF  FEC,03
32DE:  MOVF   FED,F
32E0:  MOVFF  FEF,21F
32E4:  MOVFF  21E,FEA
32E8:  MOVFF  01,FE9
32EC:  MOVFF  03,FEC
32F0:  MOVF   FED,F
32F2:  MOVFF  21F,FEF
....................     place->next=node;
32F6:  MOVLW  02
32F8:  ADDWF  x19,W
32FA:  MOVWF  FE9
32FC:  MOVLW  00
32FE:  ADDWFC x1A,W
3300:  MOVWF  FEA
3302:  MOVFF  21C,FEC
3306:  MOVF   FED,F
3308:  MOVFF  21B,FEF
330C:  MOVLB  0
330E:  GOTO   33F6 (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void remove_node(node_t *node) {// remove the given node from the memlist
....................    node_t *ptr;
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next);
*
346C:  MOVFF  D6,221
3470:  MOVFF  D5,220
3474:  MOVLW  02
3476:  MOVLB  2
3478:  ADDWF  x20,W
347A:  MOVWF  FE9
347C:  MOVLW  00
347E:  ADDWFC x21,W
3480:  MOVWF  FEA
3482:  MOVFF  FEC,223
3486:  MOVF   FED,F
3488:  MOVFF  FEF,222
348C:  MOVF   x1E,W
348E:  SUBWF  x22,W
3490:  BNZ   3498
3492:  MOVF   x1F,W
3494:  SUBWF  x23,W
3496:  BZ    34B4
3498:  MOVLW  02
349A:  ADDWF  x20,W
349C:  MOVWF  FE9
349E:  MOVLW  00
34A0:  ADDWFC x21,W
34A2:  MOVWF  FEA
34A4:  MOVFF  FEC,221
34A8:  MOVF   FED,F
34AA:  MOVFF  FEF,220
34AE:  MOVLB  0
34B0:  BRA    3474
34B2:  MOVLB  2
....................    ptr->next=node->next;
34B4:  MOVLW  02
34B6:  ADDWF  x20,W
34B8:  MOVWF  01
34BA:  MOVLW  00
34BC:  ADDWFC x21,W
34BE:  MOVWF  03
34C0:  MOVWF  x23
34C2:  MOVLW  02
34C4:  ADDWF  x1E,W
34C6:  MOVWF  FE9
34C8:  MOVLW  00
34CA:  ADDWFC x1F,W
34CC:  MOVWF  FEA
34CE:  MOVFF  FEC,03
34D2:  MOVF   FED,F
34D4:  MOVFF  FEF,224
34D8:  MOVFF  223,FEA
34DC:  MOVFF  01,FE9
34E0:  MOVFF  03,FEC
34E4:  MOVF   FED,F
34E6:  MOVFF  224,FEF
....................    node=NULL;
34EA:  CLRF   x1F
34EC:  CLRF   x1E
34EE:  MOVLB  0
34F0:  GOTO   35B2 (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__DO_DEBUG_STDLIBM)
.................... void print_list() { // print the current memlist
....................     node_t *node;
....................     debug_stdlibm("\r\nThe list is \n\r");
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next)
....................     {
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next);
....................         debug_stdlibm(g_DebugStdlibmStr);
....................         if (INVALID_MEMORY_LOCATION(node->next))
....................         {
....................            debug_stdlibm("Breaking because of invalid next node\r\n");
....................            break;
....................         }   
....................     }
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t));
....................     debug_stdlibm(g_DebugStdlibmStr);
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void traverse()
.................... {
....................    node_t *node,*temp;
....................    unsigned int16 nsize,nextsize;
....................    node=__DYNAMIC_HEAD;
34F4:  MOVFF  D6,217
34F8:  MOVFF  D5,216
....................    while(node!=NULL)
34FC:  MOVLB  2
34FE:  MOVF   x16,F
3500:  BNZ   3508
3502:  MOVF   x17,F
3504:  BTFSC  FD8.2
3506:  BRA    3600
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          break;
....................       }   
....................      #endif
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free
3508:  MOVFF  216,FE9
350C:  MOVFF  217,FEA
3510:  MOVFF  FEC,21F
3514:  MOVF   FED,F
3516:  MOVFF  FEF,21E
351A:  BTFSC  x1F.7
351C:  BRA    35E4
....................       {
....................          nsize=node->size;
351E:  MOVFF  216,FE9
3522:  MOVFF  217,FEA
3526:  MOVFF  FEC,21B
352A:  MOVF   FED,F
352C:  MOVFF  FEF,21A
....................          temp=(unsigned int16)node->next;
3530:  MOVLW  02
3532:  ADDWF  x16,W
3534:  MOVWF  FE9
3536:  MOVLW  00
3538:  ADDWFC x17,W
353A:  MOVWF  FEA
353C:  MOVFF  FEC,219
3540:  MOVF   FED,F
3542:  MOVFF  FEF,218
....................         #if defined(__DO_DEBUG_STDLIBM)
....................          if (INVALID_MEMORY_LOCATION(temp))
....................          {
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node);
....................             debug_stdlibm(g_DebugStdlibmStr);
....................             break;
....................          }
....................         #endif
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine
3546:  MOVFF  218,FE9
354A:  MOVFF  219,FEA
354E:  MOVFF  FEC,21F
3552:  MOVF   FED,F
3554:  MOVFF  FEF,21E
3558:  BTFSC  x1F.7
355A:  BRA    35C8
355C:  MOVF   x1A,W
355E:  ADDWF  x16,W
3560:  MOVWF  x20
3562:  MOVF   x1B,W
3564:  ADDWFC x17,W
3566:  MOVWF  x21
3568:  MOVLW  04
356A:  ADDWF  x20,W
356C:  MOVWF  01
356E:  MOVLW  00
3570:  ADDWFC x21,W
3572:  MOVWF  03
3574:  MOVF   01,W
3576:  SUBWF  x18,W
3578:  BNZ   35C8
357A:  MOVF   03,W
357C:  SUBWF  x19,W
357E:  BNZ   35C8
....................          {
....................             nextsize=temp->size;
3580:  MOVFF  218,FE9
3584:  MOVFF  219,FEA
3588:  MOVFF  FEC,21D
358C:  MOVF   FED,F
358E:  MOVFF  FEF,21C
....................             nsize+=nextsize+sizeof(node_t);
3592:  MOVLW  04
3594:  ADDWF  x1C,W
3596:  MOVWF  01
3598:  MOVLW  00
359A:  ADDWFC x1D,W
359C:  MOVWF  03
359E:  MOVF   01,W
35A0:  ADDWF  x1A,F
35A2:  MOVF   03,W
35A4:  ADDWFC x1B,F
....................             remove_node(temp);
35A6:  MOVFF  219,21F
35AA:  MOVFF  218,21E
35AE:  MOVLB  0
35B0:  BRA    346C
....................             update_node(node,nsize);
35B2:  MOVFF  217,21F
35B6:  MOVFF  216,21E
35BA:  MOVFF  21B,221
35BE:  MOVFF  21A,220
35C2:  RCALL  3312
....................          }
35C4:  BRA    35E0
35C6:  MOVLB  2
....................          else
....................          node=node->next;
35C8:  MOVLW  02
35CA:  ADDWF  x16,W
35CC:  MOVWF  FE9
35CE:  MOVLW  00
35D0:  ADDWFC x17,W
35D2:  MOVWF  FEA
35D4:  MOVFF  FEC,217
35D8:  MOVF   FED,F
35DA:  MOVFF  FEF,216
35DE:  MOVLB  0
....................       }
35E0:  BRA    35FC
35E2:  MOVLB  2
....................       else
....................       node=node->next;
35E4:  MOVLW  02
35E6:  ADDWF  x16,W
35E8:  MOVWF  FE9
35EA:  MOVLW  00
35EC:  ADDWFC x17,W
35EE:  MOVWF  FEA
35F0:  MOVFF  FEC,217
35F4:  MOVF   FED,F
35F6:  MOVFF  FEF,216
35FA:  MOVLB  0
35FC:  BRA    34FC
35FE:  MOVLB  2
....................    }
3600:  MOVLB  0
3602:  GOTO   367A (RETURN)
.................... }
.................... 
.................... char *malloc(size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize;
....................    #if defined(__PCD__)
....................    if (size % 2)
....................       size++;
....................    #endif
....................    node=__DYNAMIC_HEAD;
*
332A:  MOVFF  D6,214
332E:  MOVFF  D5,213
....................    
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
....................         
....................    while(node!=NULL) // chk until end of memlist
3332:  MOVLB  2
3334:  MOVF   x13,F
3336:  BNZ   333E
3338:  MOVF   x14,F
333A:  BTFSC  FD8.2
333C:  BRA    3448
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size
333E:  MOVFF  213,FE9
3342:  MOVFF  214,FEA
3346:  MOVFF  FEC,21A
334A:  MOVF   FED,F
334C:  MOVFF  FEF,219
3350:  BTFSC  x1A.7
3352:  BRA    3430
3354:  MOVFF  213,FE9
3358:  MOVFF  214,FEA
335C:  MOVFF  FEC,21C
3360:  MOVF   FED,F
3362:  MOVFF  FEF,21B
3366:  MOVF   x12,W
3368:  SUBWF  x1C,W
336A:  BNC   3430
336C:  BNZ   3374
336E:  MOVF   x11,W
3370:  SUBWF  x1B,W
3372:  BNC   3430
....................       {
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at
3374:  MOVFF  213,FE9
3378:  MOVFF  214,FEA
337C:  MOVFF  FEC,218
3380:  MOVF   FED,F
3382:  MOVFF  FEF,217
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist
3386:  MOVLW  04
3388:  ADDWF  x11,W
338A:  MOVWF  01
338C:  MOVLW  00
338E:  ADDWFC x12,W
3390:  MOVWF  03
3392:  MOVF   03,W
3394:  SUBWF  x18,W
3396:  BNC   3414
3398:  BNZ   33A0
339A:  MOVF   x17,W
339C:  SUBWF  01,W
339E:  BC    3414
....................          {
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
33A0:  MOVF   x11,W
33A2:  SUBWF  x17,W
33A4:  MOVWF  x19
33A6:  MOVF   x12,W
33A8:  SUBWFB x18,W
33AA:  MOVWF  x1A
33AC:  MOVLW  04
33AE:  SUBWF  x19,F
33B0:  MOVLW  00
33B2:  SUBWFB x1A,F
33B4:  MOVLW  04
33B6:  ADDWF  x13,W
33B8:  MOVWF  x1B
33BA:  MOVLW  00
33BC:  ADDWFC x14,W
33BE:  MOVWF  x1C
33C0:  MOVF   x11,W
33C2:  ADDWF  x1B,F
33C4:  MOVF   x12,W
33C6:  ADDWFC x1C,F
33C8:  MOVFF  21A,21E
33CC:  MOVFF  219,21D
33D0:  MOVFF  21C,220
33D4:  MOVFF  21B,21F
33D8:  MOVLB  0
33DA:  BRA    3250
33DC:  MOVFF  02,216
33E0:  MOVFF  01,215
....................             insert_node_after(node,new);
33E4:  MOVFF  214,21A
33E8:  MOVFF  213,219
33EC:  MOVFF  216,21C
33F0:  MOVFF  215,21B
33F4:  BRA    328C
....................             update_node(node,size+_MEMMGMT_CSIZE);
33F6:  MOVLB  2
33F8:  MOVLW  80
33FA:  ADDWF  x12,W
33FC:  MOVWF  x1A
33FE:  MOVFF  214,21F
3402:  MOVFF  213,21E
3406:  MOVWF  x21
3408:  MOVFF  211,220
340C:  MOVLB  0
340E:  RCALL  3312
....................          }
3410:  BRA    342C
3412:  MOVLB  2
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
3414:  MOVLW  80
3416:  ADDWF  x18,W
3418:  MOVWF  x1A
341A:  MOVFF  214,21F
341E:  MOVFF  213,21E
3422:  MOVWF  x21
3424:  MOVFF  217,220
3428:  MOVLB  0
342A:  RCALL  3312
....................          //end if
....................          break;
342C:  MOVLB  2
342E:  BRA    3448
....................       }//end if
....................       node=node->next;
3430:  MOVLW  02
3432:  ADDWF  x13,W
3434:  MOVWF  FE9
3436:  MOVLW  00
3438:  ADDWFC x14,W
343A:  MOVWF  FEA
343C:  MOVFF  FEC,214
3440:  MOVF   FED,F
3442:  MOVFF  FEF,213
3446:  BRA    3334
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
3448:  MOVF   x13,F
344A:  BNZ   345A
344C:  MOVF   x14,F
344E:  BNZ   345A
....................    {
....................       debug_stdlibm("Not enough memory for mallocation\r\n");
....................       return NULL;
3450:  MOVLW  00
3452:  MOVWF  01
3454:  MOVWF  02
3456:  BRA    3468
....................    }
3458:  BRA    3468
....................    else
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t));
....................       debug_stdlibm(g_DebugStdlibmStr);
....................      #endif
....................       _STDLIBM_TRACK_WORST_INC(size);
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space
345A:  MOVLW  04
345C:  ADDWF  x13,W
345E:  MOVWF  01
3460:  MOVLW  00
3462:  ADDWFC x14,W
3464:  MOVWF  03
3466:  MOVWF  02
....................    }
3468:  MOVLB  0
346A:  RETURN 0
.................... }
.................... 
.................... char *calloc(size_t nmemb,size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize,resize;
....................    node=__DYNAMIC_HEAD;
....................    resize=nmemb*size;
....................    #if defined(__PCD__)
....................    if(resize%2)
....................       resize++;
....................    #endif
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size
....................       {
....................          nsize=node->size;
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize);
....................             insert_node_after(node,new);
....................             update_node(node,resize+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for callocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0
....................       _STDLIBM_TRACK_WORST_INC(resize);
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space
....................    }
.................... }
.................... void free( void * ptr)
.................... {
....................    node_t *node;
....................    unsigned int16 nsize;
.................... 
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
.................... 
....................    if(ptr==NULL) // not a valid pounsigned int8er
*
3606:  MOVLB  2
3608:  MOVF   x10,F
360A:  BNZ   3614
360C:  MOVF   x11,F
360E:  BNZ   3614
....................       return;
3610:  BRA    367C
3612:  BRA    3676
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
3614:  MOVLW  04
3616:  SUBWF  x10,W
3618:  MOVWF  x12
361A:  MOVLW  00
361C:  SUBWFB x11,W
361E:  MOVWF  x13
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied
3620:  MOVFF  212,FE9
3624:  MOVFF  213,FEA
3628:  MOVFF  FEC,217
362C:  MOVF   FED,F
362E:  MOVFF  FEF,216
3632:  BTFSS  x17.7
3634:  BRA    3670
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
3636:  MOVFF  212,FE9
363A:  MOVFF  213,FEA
363E:  MOVFF  FEC,217
3642:  MOVF   FED,F
3644:  MOVFF  FEF,216
3648:  MOVLW  00
364A:  SUBWF  x16,W
364C:  MOVWF  x14
364E:  MOVLW  80
3650:  SUBWFB x17,W
3652:  MOVWF  x15
....................          update_node(node,nsize);
3654:  MOVFF  213,21F
3658:  MOVFF  212,21E
365C:  MOVFF  215,221
3660:  MOVFF  214,220
3664:  MOVLB  0
3666:  RCALL  3312
....................          ptr=NULL;
3668:  MOVLB  2
366A:  CLRF   x11
366C:  CLRF   x10
....................          _STDLIBM_TRACK_WORST_DEC(nsize);
....................       }
366E:  BRA    3676
....................       else // wrong input, return
....................       {
....................          ptr=NULL;
3670:  CLRF   x11
3672:  CLRF   x10
....................          return;
3674:  BRA    367C
....................       }
....................    }
....................    traverse();
3676:  MOVLB  0
3678:  BRA    34F4
367A:  MOVLB  2
367C:  MOVLB  0
367E:  RETURN 0
.................... }
.................... 
.................... char *realloc(void *ptr,size_t size)
.................... {
....................    node_t *node,*new,*temp;
....................    unsigned int16 nsize,nextsize;
....................    char *newptr;
....................    #if defined(__PCD__)
....................    if(size %2)
....................       size++;
....................    #endif
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory
....................       return(malloc(size));
....................    else if(size==0)
....................    {
....................       free(ptr);
....................       return(NULL);
....................    }
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          temp=(unsigned int16)node->next;
....................          if(nsize>size)// block > req size
....................          {
....................        
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   nextsize=temp->size;
....................                   remove_node(temp);
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t));
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else//not enough space for new node so use original size
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block
.................... 
....................          }
....................          else // block < req size
....................          {
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................             {
....................                nextsize=temp->size;
....................                if(nextsize>=size-nsize) // next block >=difference
....................                {
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist
....................                   {
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t));
....................                       insert_node_after(node,new);
....................                      _STDLIBM_TRACK_WORST_DEC(nsize);
....................                      _STDLIBM_TRACK_WORST_INC(size);
....................                   }
....................                   else//not enough space for new node in next node, so use original size
....................                   {
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                   }
....................                }
....................                else  //next block free but too small for new size
....................                {
....................                   newptr = malloc(size);  //use malloc to find new block
....................                   if(newptr == NULL)
....................                      return(NULL);        //return NULL if malloc was unable to find new block
....................                    
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                   free(ptr);                    //free original block
....................                   return(newptr);               //return new pointer
....................                }
....................             }
....................             else  //next block not free
....................             {
....................                newptr = malloc(size);  //use malloc to find new block
....................                if(newptr == NULL)      
....................                   return(NULL);        //return NULL if malloc was unable to find new block
....................                
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                free(ptr);                    //free original block
....................                return(newptr);               //return new pointer
....................             }
....................          }
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block
....................       }
....................       else // not allocated use malloc
....................       {
....................          return(malloc(size));
....................       }
....................    }
....................  }
....................  
.................... typedef struct
.................... {
....................    size_t bytesUsed;
....................    size_t largestUsedSeg;
....................    int segmentsUsed;
....................    size_t bytesFree;
....................    size_t largestFreeSeg;
....................    int segmentsFree;
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    size_t worstCaseBytesUsed;
....................   #endif
.................... } heap_status_t;
.................... 
.................... void GetHeapStatus(heap_status_t *pHeapStatus)
.................... {
....................    heap_status_t status;
....................    node_t *node;
....................    unsigned int16 nsize;
....................    
....................    node=__DYNAMIC_HEAD;
....................    
....................    memset(&status, 0, sizeof(status));
.................... 
....................    while(node!=NULL)
....................    {
....................       nsize = node->size;
....................       node = node->next;
....................       
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free
....................       {
....................          status.bytesFree += nsize;
....................          
....................          status.segmentsFree++;
....................          
....................          if (nsize > status.largestFreeSeg)
....................          {
....................             status.largestFreeSeg = nsize;
....................          }
....................       }
....................       else
....................       {
....................          bit_clear(nsize, _MEMMGMT_POS);
....................          
....................          status.bytesUsed += nsize;
....................          
....................          status.segmentsUsed++;
....................          
....................          if (nsize > status.largestUsedSeg)
....................          {
....................             status.largestUsedSeg = nsize;
....................          }
....................       }
....................    }
.................... 
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed;
....................   #endif
.................... 
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t));
.................... }
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include <adafruit_rfm69_registers.h>
.................... 
.................... //Internal constants:
.................... #define _REG_FIFO 0x00
.................... #define _REG_OP_MODE 0x01
.................... #define _REG_DATA_MOD 0x02
.................... #define _REG_BITRATE_MSB 0x03
.................... #define _REG_BITRATE_LSB 0x04
.................... #define _REG_FDEV_MSB 0x05
.................... #define _REG_FDEV_LSB 0x06
.................... #define _REG_FRF_MSB 0x07
.................... #define _REG_FRF_MID 0x08
.................... #define _REG_FRF_LSB 0x09
.................... #define _REG_VERSION 0x10
.................... #define _REG_PA_LEVEL 0x11
.................... #define _REG_RX_BW 0x19
.................... #define _REG_AFC_BW 0x1A
.................... #define _REG_RSSI_VALUE 0x24
.................... #define _REG_DIO_MAPPING1 0x25
.................... #define _REG_IRQ_FLAGS1 0x27
.................... #define _REG_IRQ_FLAGS2 0x28
.................... #define _REG_PREAMBLE_MSB 0x2C
.................... #define _REG_PREAMBLE_LSB 0x2D
.................... #define _REG_SYNC_CONFIG 0x2E
.................... #define _REG_SYNC_VALUE1 0x2F
.................... #define _REG_PACKET_CONFIG1 0x37
.................... 
.................... #define _REG_FIFO_THRESH 0x3C
.................... #define _REG_PACKET_CONFIG2 0x3D
.................... #define _REG_AES_KEY1 0x3E
.................... #define _REG_TEMP1 0x4E
.................... #define _REG_TEMP2 0x4F
.................... #define _REG_TEST_PA1 0x5A
.................... #define _REG_TEST_PA2 0x5C
.................... #define _REG_TEST_DAGC 0x6F
.................... 
.................... #define _TEST_PA1_NORMAL 0x55
.................... #define _TEST_PA1_BOOST 0x5D
.................... #define _TEST_PA2_NORMAL 0x70
.................... #define _TEST_PA2_BOOST 0x7C
.................... 
.................... //The crystal oscillator frequency and frequency synthesizer step size.
.................... //See the datasheet for details of this calculation.
.................... 
.................... //        #define _FXOSC = 32000000.0
.................... //        #define _FSTEP = _FXOSC / 524288
.................... 
.................... //RadioHead specific compatibility constants.
.................... #define _RH_BROADCAST_ADDRESS 0xFF
.................... //The acknowledgement bit in the FLAGS
.................... //The top 4 bits of the flags are reserved for RadioHead. The lower 4 bits are reserved
.................... //for application layer use.
.................... #define _RH_FLAGS_ACK 0x80
.................... #define _RH_FLAGS_RETRY 0x40
.................... 
.................... //User facing constants:
.................... #define SLEEP_MODE 0b000
.................... #define STANDBY_MODE 0b001
.................... #define FS_MODE 0b010
.................... #define TX_MODE 0b011
.................... #define RX_MODE 0b100
.................... //supervisor.ticks_ms() contants
.................... //          #define _TICKS_PERIOD = const(1 << 29)
.................... //          #define _TICKS_MAX = const(_TICKS_PERIOD - 1)
.................... //          #define _TICKS_HALFPERIOD = const(_TICKS_PERIOD // 2)
.................... 
.................... #include <utils.h>
.................... //Global buffer for SPI commands
.................... uint8_t _BUFFER[4];
.................... uint8_t readBytes;
.................... 
.................... void setOutput(int pin, int value){
....................     output_bit(pin,value);
*
163E:  MOVLB  2
1640:  MOVF   x92,F
1642:  BNZ   1648
1644:  MOVLW  00
1646:  BRA    164A
1648:  MOVLW  01
164A:  MOVFF  291,293
164E:  MOVWF  x94
1650:  MOVLW  0F
1652:  MOVWF  x96
1654:  MOVLW  89
1656:  MOVWF  x95
1658:  MOVLB  0
165A:  RCALL  14B4
165C:  MOVFF  291,293
1660:  MOVLB  2
1662:  CLRF   x94
1664:  MOVLW  0F
1666:  MOVWF  x96
1668:  MOVLW  92
166A:  MOVWF  x95
166C:  MOVLB  0
166E:  RCALL  14B4
1670:  RETURN 0
.................... }
.................... int digitalRead(int pin){
....................    return input(pin);
*
152E:  MOVFF  289,293
1532:  MOVLW  01
1534:  MOVLB  2
1536:  MOVWF  x94
1538:  MOVLW  0F
153A:  MOVWF  x96
153C:  MOVLW  92
153E:  MOVWF  x95
1540:  MOVLB  0
1542:  RCALL  14B4
1544:  MOVFF  289,28A
1548:  MOVLW  0F
154A:  MOVLB  2
154C:  MOVWF  x8C
154E:  MOVLW  80
1550:  MOVWF  x8B
1552:  MOVLB  0
1554:  BRA    14F6
1556:  MOVLW  00
1558:  BTFSC  01.0
155A:  MOVLW  01
155C:  MOVWF  01
155E:  RETURN 0
.................... }
.................... void usbPrint(char* str, int debug = 0){
*
1BB0:  CLRF   19
1BB2:  BTFSC  FF2.7
1BB4:  BSF    19.7
1BB6:  BCF    FF2.7
....................       usb_task();  //Verifica la comunicacin USB
1BB8:  RCALL  1586
1BBA:  BTFSC  19.7
1BBC:  BSF    FF2.7
....................       if(usb_enumerated() && debug <= debugLevel) {
1BBE:  RCALL  1560
1BC0:  MOVF   01,F
1BC2:  BZ    1BD8
1BC4:  MOVLB  2
1BC6:  MOVF   x6E,W
1BC8:  MOVLB  0
1BCA:  SUBWF  xD4,W
1BCC:  BNC   1BD8
....................       
....................          printf(usb_cdc_putc,str); 
1BCE:  MOVFF  26D,FEA
1BD2:  MOVFF  26C,FE9
1BD6:  BRA    1B7E
....................       }
1BD8:  RETURN 0
.................... }
.................... void usbPrint(char str, int debug = 0){
....................       usb_task();  //Verifica la comunicacin USB
*
1618:  RCALL  1586
....................       if(usb_enumerated() && debug <= debugLevel) {
161A:  RCALL  1560
161C:  MOVF   01,F
161E:  BZ    1630
1620:  MOVLB  2
1622:  MOVF   x91,W
1624:  MOVLB  0
1626:  SUBWF  xD4,W
1628:  BNC   1630
....................          printf(usb_cdc_putc,"%c",str); 
162A:  MOVFF  290,292
162E:  RCALL  15F6
....................       }
1630:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void spiBegin(){
.................... //SPI.beginTransaction(SPISettings(SPIBAUD, MSBFIRST, SPI_MODE0));
.................... setOutput(SSPin, 0);
*
1684:  MOVLW  05
1686:  MOVLB  2
1688:  MOVWF  x91
168A:  CLRF   x92
168C:  MOVLB  0
168E:  RCALL  163E
.................... using_spi = true;
1690:  BSF    xB5.1
1692:  RETURN 0
.................... 
.................... }
.................... void spiEnd(){
.................... setOutput(SSPin, 1); 
*
1672:  MOVLW  05
1674:  MOVLB  2
1676:  MOVWF  x91
1678:  MOVLW  01
167A:  MOVWF  x92
167C:  MOVLB  0
167E:  RCALL  163E
.................... using_spi = false;
1680:  BCF    xB5.1
1682:  RETURN 0
.................... //SPI.endTransaction();
.................... }
.................... 
.................... void print(char* str, int debug = 0){
....................     //Serial.print(str);
....................     usbPrint(str, debug);
*
1D68:  MOVFF  256,26D
1D6C:  MOVFF  255,26C
1D70:  MOVFF  257,26E
1D74:  RCALL  1BB0
1D76:  RETURN 0
.................... }
.................... 
.................... void printch(char str, int debug = 0){
....................    usbPrint(str, debug);
*
1632:  MOVFF  28D,290
1636:  MOVFF  28E,291
163A:  RCALL  1618
163C:  RETURN 0
.................... 
.................... }
.................... void print(int16 str, int format, int debug = 0){
....................     char converted[11];
....................     int i;
....................     if (format == HEX) sprintf(converted,"0x%02X",str);
*
1BDA:  MOVLB  2
1BDC:  MOVF   x5C,W
1BDE:  SUBLW  10
1BE0:  BNZ   1C14
1BE2:  MOVLW  02
1BE4:  MOVLB  0
1BE6:  MOVWF  xDD
1BE8:  MOVLW  5E
1BEA:  MOVWF  xDC
1BEC:  MOVLW  30
1BEE:  MOVLB  2
1BF0:  MOVWF  x73
1BF2:  MOVLB  0
1BF4:  RCALL  1952
1BF6:  MOVLW  78
1BF8:  MOVLB  2
1BFA:  MOVWF  x73
1BFC:  MOVLB  0
1BFE:  RCALL  1952
1C00:  MOVFF  25A,26A
1C04:  MOVLW  37
1C06:  MOVLB  2
1C08:  MOVWF  x6B
1C0A:  MOVLB  0
1C0C:  BRA    1970
1C0E:  MOVLB  0
1C10:  BRA    1CAC
1C12:  MOVLB  2
....................     else if (format == BIN){
1C14:  MOVF   x5C,W
1C16:  SUBLW  02
1C18:  BNZ   1C6C
....................     //Conversion manual
....................     converted[0] = '0';
1C1A:  MOVLW  30
1C1C:  MOVWF  x5E
....................     converted[1] = 'b';
1C1E:  MOVLW  62
1C20:  MOVWF  x5F
....................     for (i=0;i<8;i++){
1C22:  CLRF   x69
1C24:  MOVF   x69,W
1C26:  SUBLW  07
1C28:  BNC   1C68
....................     converted[i+2] = ((str >> (7-i)) & 0x01) + '0';
1C2A:  MOVLW  02
1C2C:  ADDWF  x69,W
1C2E:  CLRF   03
1C30:  ADDLW  5E
1C32:  MOVWF  FE9
1C34:  MOVLW  02
1C36:  ADDWFC 03,W
1C38:  MOVWF  FEA
1C3A:  MOVLW  07
1C3C:  BSF    FD8.0
1C3E:  SUBFWB x69,W
1C40:  MOVWF  00
1C42:  MOVFF  25B,26D
1C46:  MOVFF  25A,26C
1C4A:  MOVF   00,F
1C4C:  BZ    1C58
1C4E:  BCF    FD8.0
1C50:  RRCF   x6D,F
1C52:  RRCF   x6C,F
1C54:  DECFSZ 00,F
1C56:  BRA    1C4E
1C58:  MOVLW  01
1C5A:  ANDWF  x6C,F
1C5C:  CLRF   x6D
1C5E:  MOVLW  30
1C60:  ADDWF  x6C,W
1C62:  MOVWF  FEF
1C64:  INCF   x69,F
1C66:  BRA    1C24
....................     }
....................     converted[10] = '\0';
1C68:  CLRF   x68
....................     }
1C6A:  BRA    1CAE
....................     else if (format == DEC){
1C6C:  MOVF   x5C,W
1C6E:  SUBLW  0A
1C70:  BNZ   1C8E
....................       sprintf(converted,"%Ld",str);
1C72:  MOVLW  02
1C74:  MOVLB  0
1C76:  MOVWF  xDD
1C78:  MOVLW  5E
1C7A:  MOVWF  xDC
1C7C:  MOVLW  10
1C7E:  MOVWF  FE9
1C80:  MOVFF  25B,26B
1C84:  MOVFF  25A,26A
1C88:  BRA    19B8
....................     }
1C8A:  BRA    1CAC
1C8C:  MOVLB  2
....................     else if (format == UDEC){
1C8E:  MOVF   x5C,W
1C90:  SUBLW  0B
1C92:  BNZ   1CAE
....................       sprintf(converted,"%Lu",str);
1C94:  MOVLW  02
1C96:  MOVLB  0
1C98:  MOVWF  xDD
1C9A:  MOVLW  5E
1C9C:  MOVWF  xDC
1C9E:  MOVLW  10
1CA0:  MOVWF  FE9
1CA2:  MOVFF  25B,26B
1CA6:  MOVFF  25A,26A
1CAA:  RCALL  1AB8
1CAC:  MOVLB  2
....................     }
....................     usbPrint(converted, debug);
1CAE:  MOVLW  02
1CB0:  MOVWF  x6D
1CB2:  MOVLW  5E
1CB4:  MOVWF  x6C
1CB6:  MOVFF  25D,26E
1CBA:  MOVLB  0
1CBC:  RCALL  1BB0
1CBE:  RETURN 0
....................     //Serial.print(str,format);
.................... }
.................... void println(char* str, int debug = 0){
....................     usbPrint(str, debug);
*
1CF6:  MOVFF  256,26D
1CFA:  MOVFF  255,26C
1CFE:  MOVFF  257,26E
1D02:  RCALL  1BB0
....................     usbPrint((char*)"\n", debug);
1D04:  MOVLW  0A
1D06:  MOVLB  2
1D08:  MOVWF  x58
1D0A:  CLRF   x59
1D0C:  MOVLW  02
1D0E:  MOVWF  x6D
1D10:  MOVLW  58
1D12:  MOVWF  x6C
1D14:  MOVFF  257,26E
1D18:  MOVLB  0
1D1A:  RCALL  1BB0
1D1C:  RETURN 0
....................     //Serial.println(str);
.................... }
.................... void println(int str, int format, int debug = 0){
....................     print(str,format, debug);
*
1E4A:  MOVLB  2
1E4C:  CLRF   x5B
1E4E:  MOVFF  253,25A
1E52:  MOVFF  254,25C
1E56:  MOVFF  255,25D
1E5A:  MOVLB  0
1E5C:  RCALL  1BDA
....................     usbPrint((char*)"\n", debug);
1E5E:  MOVLW  0A
1E60:  MOVLB  2
1E62:  MOVWF  x56
1E64:  CLRF   x57
1E66:  MOVLW  02
1E68:  MOVWF  x6D
1E6A:  MOVLW  56
1E6C:  MOVWF  x6C
1E6E:  MOVFF  255,26E
1E72:  MOVLB  0
1E74:  RCALL  1BB0
1E76:  RETURN 0
....................     //Serial.println(str,format);
.................... }
.................... void print(float str, int debug = 0){
....................  char converted[11];
....................  sprintf(converted,"%03f",str);
....................  usbPrint(converted, debug);
.................... }
.................... void println(float str, int debug = 0){
....................     print(str, debug);
....................     usbPrint((char*)"\n", debug);
.................... }
.................... 
.................... float timeSec(){
*
2DEA:  CLRF   19
2DEC:  BTFSC  FF2.7
2DEE:  BSF    19.7
2DF0:  BCF    FF2.7
....................    float t;
....................    t = (float)(60*globalMin);
2DF2:  MOVLB  2
2DF4:  CLRF   xA6
2DF6:  MOVLW  3C
2DF8:  MOVWF  xA5
2DFA:  MOVFF  BE,2A8
2DFE:  MOVFF  BD,2A7
2E02:  MOVLB  0
2E04:  CALL   04DE
2E08:  BTFSC  19.7
2E0A:  BSF    FF2.7
2E0C:  MOVFF  02,215
2E10:  MOVFF  01,214
2E14:  MOVLB  0
2E16:  RCALL  2CBE
2E18:  MOVFF  03,213
2E1C:  MOVFF  02,212
2E20:  MOVFF  01,211
2E24:  MOVFF  00,210
....................    t += (float)globalSec;
2E28:  MOVLB  2
2E2A:  CLRF   x15
2E2C:  MOVFF  BC,214
2E30:  MOVLB  0
2E32:  RCALL  2CBE
2E34:  BCF    FD8.1
2E36:  MOVFF  213,219
2E3A:  MOVFF  212,218
2E3E:  MOVFF  211,217
2E42:  MOVFF  210,216
2E46:  MOVFF  03,21D
2E4A:  MOVFF  02,21C
2E4E:  MOVFF  01,21B
2E52:  MOVFF  00,21A
2E56:  CALL   2354
2E5A:  MOVFF  03,213
2E5E:  MOVFF  02,212
2E62:  MOVFF  01,211
2E66:  MOVFF  00,210
....................    t += (float)((float)globalMs*0.001);
2E6A:  MOVFF  BB,215
2E6E:  MOVFF  BA,214
2E72:  RCALL  2CBE
2E74:  MOVFF  03,217
2E78:  MOVFF  02,216
2E7C:  MOVFF  01,215
2E80:  MOVFF  00,214
2E84:  MOVFF  03,21B
2E88:  MOVFF  02,21A
2E8C:  MOVFF  01,219
2E90:  MOVFF  00,218
2E94:  MOVLW  6F
2E96:  MOVLB  2
2E98:  MOVWF  x1F
2E9A:  MOVLW  12
2E9C:  MOVWF  x1E
2E9E:  MOVLW  03
2EA0:  MOVWF  x1D
2EA2:  MOVLW  75
2EA4:  MOVWF  x1C
2EA6:  MOVLB  0
2EA8:  RCALL  2CF4
2EAA:  BCF    FD8.1
2EAC:  MOVFF  213,219
2EB0:  MOVFF  212,218
2EB4:  MOVFF  211,217
2EB8:  MOVFF  210,216
2EBC:  MOVFF  03,21D
2EC0:  MOVFF  02,21C
2EC4:  MOVFF  01,21B
2EC8:  MOVFF  00,21A
2ECC:  CALL   2354
2ED0:  MOVFF  03,213
2ED4:  MOVFF  02,212
2ED8:  MOVFF  01,211
2EDC:  MOVFF  00,210
....................    //println(t);
....................    return t;
2EE0:  MOVFF  210,00
2EE4:  MOVFF  211,01
2EE8:  MOVFF  212,02
2EEC:  MOVFF  213,03
2EF0:  RETURN 0
.................... }
.................... //Retorna cuantos bytes se leyeron
.................... void spi_read_into(uint8_t address,uint8_t* array, uint8_t length){
....................     readBytes =0;
*
172C:  CLRF   xDB
....................     //Select
....................     spiBegin();
172E:  RCALL  1684
....................     _BUFFER[0] = address & 0x7F; //Strip MSB byte to read
1730:  MOVLB  2
1732:  MOVF   x8D,W
1734:  ANDLW  7F
1736:  MOVLB  0
1738:  MOVWF  xD7
....................     //Write address
....................     spi_write(_BUFFER[0]);
173A:  MOVF   FC9,W
173C:  MOVFF  D7,FC9
1740:  RRCF   FC7,W
1742:  BNC   1740
....................     delay_us(100);  // Tiempo para que el esclavo responda
1744:  MOVLW  64
1746:  MOVLB  2
1748:  MOVWF  x91
174A:  MOVLB  0
174C:  RCALL  1694
....................     for (readBytes=0;readBytes<length;readBytes++)
174E:  CLRF   xDB
1750:  MOVLB  2
1752:  MOVF   x90,W
1754:  MOVLB  0
1756:  SUBWF  xDB,W
1758:  BC    177A
....................         array[readBytes] = spi_read(0xFF);
175A:  MOVF   xDB,W
175C:  MOVLB  2
175E:  ADDWF  x8E,W
1760:  MOVWF  FE9
1762:  MOVLW  00
1764:  ADDWFC x8F,W
1766:  MOVWF  FEA
1768:  MOVF   FC9,W
176A:  SETF   FC9
176C:  RRCF   FC7,W
176E:  BNC   176C
1770:  MOVFF  FC9,FEF
1774:  MOVLB  0
1776:  INCF   xDB,F
1778:  BRA    1750
....................     spiEnd();
177A:  RCALL  1672
177C:  RETURN 0
.................... 
.................... }
.................... void spi_write_from(uint8_t address,uint8_t* array, uint8_t length){
*
1D78:  MOVLB  2
1D7A:  CLRF   x57
1D7C:  CLRF   19
1D7E:  BTFSC  FF2.7
1D80:  BSF    19.7
1D82:  BCF    FF2.7
....................     int i=0;
....................     spiBegin();
1D84:  MOVLB  0
1D86:  RCALL  1684
1D88:  BTFSC  19.7
1D8A:  BSF    FF2.7
....................     spi_write(address | 0b10000000);
1D8C:  MOVLB  2
1D8E:  MOVF   x53,W
1D90:  IORLW  80
1D92:  MOVWF  x58
1D94:  MOVF   FC9,W
1D96:  MOVFF  258,FC9
1D9A:  RRCF   FC7,W
1D9C:  BNC   1D9A
....................     //El address se aumenta en 1 automaticamente
....................    //Serial.println("Writing SPI");
....................     for (i=0;i<length;i++){
1D9E:  CLRF   x57
1DA0:  MOVF   x56,W
1DA2:  SUBWF  x57,W
1DA4:  BC    1DC4
....................       // Serial.println((char)array[i]);
....................       spi_write(array[i]);}
1DA6:  MOVF   x57,W
1DA8:  ADDWF  x54,W
1DAA:  MOVWF  FE9
1DAC:  MOVLW  00
1DAE:  ADDWFC x55,W
1DB0:  MOVWF  FEA
1DB2:  MOVFF  FEF,258
1DB6:  MOVF   FC9,W
1DB8:  MOVFF  258,FC9
1DBC:  RRCF   FC7,W
1DBE:  BNC   1DBC
1DC0:  INCF   x57,F
1DC2:  BRA    1DA0
1DC4:  CLRF   19
1DC6:  BTFSC  FF2.7
1DC8:  BSF    19.7
1DCA:  BCF    FF2.7
....................     spiEnd();    
1DCC:  MOVLB  0
1DCE:  RCALL  1672
1DD0:  BTFSC  19.7
1DD2:  BSF    FF2.7
1DD4:  RETURN 0
.................... }
.................... uint8_t spi_read_u8(uint8_t address){
*
192C:  CLRF   19
192E:  BTFSC  FF2.7
1930:  BSF    19.7
1932:  BCF    FF2.7
....................     spi_read_into(address,_BUFFER,1);
1934:  MOVFF  255,28D
1938:  MOVLB  2
193A:  CLRF   x8F
193C:  MOVLW  D7
193E:  MOVWF  x8E
1940:  MOVLW  01
1942:  MOVWF  x90
1944:  MOVLB  0
1946:  RCALL  172C
1948:  BTFSC  19.7
194A:  BSF    FF2.7
....................     return _BUFFER[0];
194C:  MOVFF  D7,01
1950:  RETURN 0
.................... }
.................... uint8_t spi_write_u8(uint8_t address,uint8_t val){
....................     _BUFFER[0] = val;
*
1DD6:  MOVFF  252,D7
....................     spi_write_from(address,_BUFFER,1);
1DDA:  MOVFF  251,253
1DDE:  MOVLB  2
1DE0:  CLRF   x55
1DE2:  MOVLW  D7
1DE4:  MOVWF  x54
1DE6:  MOVLW  01
1DE8:  MOVWF  x56
1DEA:  MOVLB  0
1DEC:  RCALL  1D78
....................     return _BUFFER[0];
1DEE:  MOVFF  D7,01
1DF2:  RETURN 0
.................... }
.................... void sleep_ms(int ms){
....................     delay_ms(ms);
*
1924:  MOVFF  1EB,251
1928:  RCALL  18FA
192A:  RETURN 0
.................... }
.................... 
.................... #include <afadruit_rfm69.h>
.................... 
.................... // # The crystal oscillator frequency and frequency synthesizer step size.
.................... // # See the datasheet for details of this calculation.
.................... const float _FXOSC = 32000000.0;
.................... const float _FSTEP = _FXOSC / 524288;
.................... 
.................... void readAllRegs();
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL);
.................... void reset();
.................... void set_boost(uint8_t setting);
.................... void idle();
.................... void rfm_sleep();
.................... void listen();
.................... void transmit();
.................... float temperature_get();
.................... uint8_t operation_mode_get();
.................... void operation_mode_set(uint8_t val);
.................... uint8_t* sync_word_get();
.................... void sync_word_set(uint8_t* wrd);
.................... uint16_t preamble_length_get();
.................... void preamble_length_set(uint16_t val);
.................... float frequency_mhz_get();
.................... void frequency_mhz_set();
.................... uint8_t* encryption_key_get();
.................... void encryption_key_set(uint8_t* val);
.................... int8_t tx_power_get();
.................... void tx_power_set(int8_t val);
.................... float rssi_get();
.................... float bitrate_get();
.................... void bitrate_set(float val);
.................... float frequency_deviation_get();
.................... void frequency_deviation_set(float val);
.................... bool packet_sent();
.................... bool payload_ready();
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256);
.................... bool send_with_ack(uint8_t* data,uint8_t len);
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false);
.................... 
.................... struct _RegisterBits{
.................... uint8_t address;
.................... uint8_t mask;
.................... uint8_t offset;
.................... };
.................... 
.................... void set(uint8_t val,struct _RegisterBits obj){
*
20D2:  MOVFF  211,255
20D6:  RCALL  192C
20D8:  MOVFF  01,214
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         regVal &= ~obj.mask;
20DC:  MOVLB  2
20DE:  MOVF   x12,W
20E0:  XORLW  FF
20E2:  ANDWF  x14,F
....................         regVal |= (val & 0xFF) << obj.offset;
20E4:  MOVFF  210,00
20E8:  MOVF   x13,W
20EA:  MOVWF  01
20EC:  BZ    20F6
20EE:  BCF    FD8.0
20F0:  RLCF   00,F
20F2:  DECFSZ 01,F
20F4:  BRA    20EE
20F6:  MOVF   00,W
20F8:  IORWF  x14,F
....................         spi_write_u8(obj.address,regVal);
20FA:  MOVFF  211,251
20FE:  MOVFF  214,252
2102:  MOVLB  0
2104:  RCALL  1DD6
2106:  RETURN 0
.................... }
.................... uint8_t get(struct _RegisterBits obj){
*
1E22:  MOVFF  251,255
1E26:  RCALL  192C
1E28:  MOVFF  01,254
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         return ((regVal & obj.mask) >> obj.offset);
1E2C:  MOVLB  2
1E2E:  MOVF   x54,W
1E30:  ANDWF  x52,W
1E32:  MOVWF  00
1E34:  MOVF   x53,W
1E36:  MOVWF  01
1E38:  BZ    1E42
1E3A:  BCF    FD8.0
1E3C:  RRCF   00,F
1E3E:  DECFSZ 01,F
1E40:  BRA    1E3A
1E42:  MOVF   00,W
1E44:  MOVWF  01
1E46:  MOVLB  0
1E48:  RETURN 0
....................     }
.................... uint8_t _debug_(struct _RegisterBits obj){
....................       print ((char*)"Mask: ",3);
....................       println(obj.mask,BIN,3);
....................       return obj.mask; 
.................... }
.................... 
.................... struct _RegisterBits _RegisterBits_(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
*
1872:  MOVLB  1
1874:  CLRF   xBC
.................... 
....................         uint8_t i=0;
....................         struct _RegisterBits ret;
....................         ret.mask=0;
1876:  CLRF   xBE
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         ret.address = _address;
1878:  MOVFF  1B9,1BD
....................         for (i=0;i<bits;i++){
187C:  CLRF   xBC
187E:  MOVF   xBB,W
1880:  SUBWF  xBC,W
1882:  BC    188E
....................             ret.mask<<=1;
1884:  BCF    FD8.0
1886:  RLCF   xBE,F
....................             ret.mask|=1;
1888:  BSF    xBE.0
188A:  INCF   xBC,F
188C:  BRA    187E
....................         }
....................         ret.mask <<= _offset;
188E:  MOVF   xBA,W
1890:  MOVWF  01
1892:  BZ    189C
1894:  BCF    FD8.0
1896:  RLCF   xBE,F
1898:  DECFSZ 01,F
189A:  BRA    1894
....................         ret.offset = _offset;
189C:  MOVFF  1BA,1BF
....................         return ret;
18A0:  MOVFF  1BD,01
18A4:  MOVFF  1BE,02
18A8:  MOVFF  1BF,03
18AC:  MOVLB  0
18AE:  RETURN 0
....................  }
....................  
....................     
.................... //Configuraciones que solo utilizan ciertos bits   
.................... struct _RegisterBits data_mode = _RegisterBits_(_REG_DATA_MOD, 5, 2);
.................... struct _RegisterBits modulation_type = _RegisterBits_(_REG_DATA_MOD, 3, 2);
.................... struct _RegisterBits modulation_shaping = _RegisterBits_(_REG_DATA_MOD, 0, 2);
.................... struct _RegisterBits temp_start = _RegisterBits_(_REG_TEMP1, 3);
.................... struct _RegisterBits temp_running = _RegisterBits_(_REG_TEMP1, 2);
.................... struct _RegisterBits sync_on = _RegisterBits_(_REG_SYNC_CONFIG, 7);
.................... struct _RegisterBits sync_size = _RegisterBits_(_REG_SYNC_CONFIG, 3, 3);
.................... struct _RegisterBits aes_on = _RegisterBits_(_REG_PACKET_CONFIG2, 0);
.................... struct _RegisterBits pa_0_on = _RegisterBits_(_REG_PA_LEVEL, 7);
.................... struct _RegisterBits pa_1_on = _RegisterBits_(_REG_PA_LEVEL, 6);
.................... struct _RegisterBits pa_2_on = _RegisterBits_(_REG_PA_LEVEL, 5);
.................... struct _RegisterBits output_power = _RegisterBits_(_REG_PA_LEVEL, 0, 5);
.................... struct _RegisterBits rx_bw_dcc_freq = _RegisterBits_(_REG_RX_BW, 5, 3);
.................... struct _RegisterBits rx_bw_mantissa = _RegisterBits_(_REG_RX_BW, 3, 2);
.................... struct _RegisterBits rx_bw_exponent = _RegisterBits_(_REG_RX_BW, 0, 3);
.................... struct _RegisterBits afc_bw_dcc_freq = _RegisterBits_(_REG_AFC_BW, 5, 3);
.................... struct _RegisterBits afc_bw_mantissa = _RegisterBits_(_REG_AFC_BW, 3, 2);
.................... struct _RegisterBits afc_bw_exponent = _RegisterBits_(_REG_AFC_BW, 0, 3);
.................... struct _RegisterBits packet_format = _RegisterBits_(_REG_PACKET_CONFIG1, 7, 1);
.................... struct _RegisterBits dc_free = _RegisterBits_(_REG_PACKET_CONFIG1, 5, 2);
.................... struct _RegisterBits crc_on = _RegisterBits_(_REG_PACKET_CONFIG1, 4, 1);
.................... struct _RegisterBits crc_auto_clear_off = _RegisterBits_(_REG_PACKET_CONFIG1, 3, 1);
.................... struct _RegisterBits address_filter = _RegisterBits_(_REG_PACKET_CONFIG1, 1, 2);
.................... struct _RegisterBits mode_ready = _RegisterBits_(_REG_IRQ_FLAGS1, 7);
.................... struct _RegisterBits dio_0_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 6, 2);
.................... struct _RegisterBits dio_1_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 4, 2);
.................... struct _RegisterBits dio_2_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 2, 2);
.................... struct _RegisterBits dio_3_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 0, 2);
.................... struct _RegisterBits dio_4_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 6, 2);
.................... struct _RegisterBits dio_5_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 4, 2);
.................... 
.................... //Extras
.................... #define _REG_PAYLOAD_LENGTH 0x38
.................... struct _RegisterBits payload_length = _RegisterBits_(_REG_PAYLOAD_LENGTH, 0, 8);
.................... int8_t _tx_power;
.................... int8_t tx_power;
.................... bool high_power;
.................... uint8_t* sync_word;
.................... uint16_t preamble_length;
.................... uint32_t frequency_mhz;
.................... float bitrate;
.................... float rssi;
.................... float last_rssi;
.................... float ack_wait;
.................... float receive_timeout;
.................... float xmit_timeout;
.................... uint8_t ack_retries;
.................... float ack_delay;
.................... uint8_t sequence_number;
.................... uint8_t seen_ids[8];
.................... uint8_t node;
.................... uint8_t destination;
.................... uint8_t identifier;
.................... uint8_t flags;
.................... uint8_t operation_mode;
.................... float temperature;
.................... uint8_t encryption_key[16];
.................... float frequency_deviation;
.................... int _reset_pin;
.................... 
.................... 
.................... void readAllRegs()
.................... {
....................   uint8_t regVal;
....................   
....................   println((char*)"Address - HEX - BIN",2);
....................   for (uint8_t regAddr = 1; regAddr <= 0x4F; regAddr++)
....................   {
....................     /*
....................     spiBegin();
....................     SPI.transfer(regAddr & 0x7F); // send address + r/w bit
....................     regVal = SPI.transfer(0);
....................     spiEnd();*/
....................     regVal = spi_read_u8(regAddr);
....................     print(regAddr, HEX,2);
....................     print((char*)" - ",2);
....................     print(regVal,HEX,2);
....................     print((char*)" - ",2);
....................     println(regVal,BIN,2);
....................   }
....................   spiEnd();
.................... }    
.................... 
.................... bool checkId(){
.................... uint8_t version;
.................... version = spi_read_u8(_REG_VERSION);
*
1CC0:  MOVLW  10
1CC2:  MOVLB  2
1CC4:  MOVWF  x55
1CC6:  MOVLB  0
1CC8:  RCALL  192C
1CCA:  MOVFF  01,1B9
.................... print(version,3);
1CCE:  MOVLB  2
1CD0:  CLRF   x5B
1CD2:  MOVFF  1B9,25A
1CD6:  MOVLW  03
1CD8:  MOVWF  x5C
1CDA:  CLRF   x5D
1CDC:  MOVLB  0
1CDE:  RCALL  1BDA
.................... return version==0x24;
1CE0:  MOVLB  1
1CE2:  MOVF   xB9,W
1CE4:  SUBLW  24
1CE6:  BZ    1CEC
1CE8:  MOVLW  00
1CEA:  BRA    1CEE
1CEC:  MOVLW  01
1CEE:  MOVWF  01
1CF0:  MOVLB  0
1CF2:  GOTO   438E (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL){
*
2800:  MOVLB  1
2802:  CLRF   xC4
....................     uint8_t version=0;
....................     println((char*)"Initial conf starts",3);
2804:  MOVLW  01
2806:  MOVWF  FEA
2808:  MOVLW  C5
280A:  MOVWF  FE9
280C:  MOVLW  14
280E:  MOVWF  01
2810:  CLRF   FF7
2812:  MOVLW  00
2814:  MOVLB  0
2816:  CALL   0236
281A:  TBLRD*-
281C:  TBLRD*+
281E:  MOVFF  FF5,FEE
2822:  DECFSZ 01,F
2824:  BRA    281C
2826:  MOVLW  01
2828:  MOVLB  2
282A:  MOVWF  x56
282C:  MOVLW  C5
282E:  MOVWF  x55
2830:  MOVLW  03
2832:  MOVWF  x57
2834:  MOVLB  0
2836:  CALL   1CF6
....................     //Serial.println("HOLA 2");
....................     _tx_power = 13;
283A:  MOVLW  0D
283C:  MOVLB  1
283E:  MOVWF  x3B
....................     _reset_pin = resetPin;
2840:  MOVFF  1BB,188
....................     high_power = _high_power;
2844:  MOVLB  0
2846:  BCF    xB5.2
2848:  MOVLB  1
284A:  BTFSS  xBD.0
284C:  BRA    2854
284E:  MOVLB  0
2850:  BSF    xB5.2
2852:  MOVLB  1
....................     reset();
2854:  MOVLB  0
2856:  GOTO   1D1E
....................     //readAllRegs();
....................     
....................     version = spi_read_u8(_REG_VERSION);
285A:  MOVLW  10
285C:  MOVLB  2
285E:  MOVWF  x55
2860:  MOVLB  0
2862:  CALL   192C
2866:  MOVFF  01,1C4
....................     if (version != 0x24){
286A:  MOVLB  1
286C:  MOVF   xC4,W
286E:  SUBLW  24
2870:  BZ    28F0
....................         println((char*)"Error: ID del RFM incorrecta",1);
2872:  MOVLW  01
2874:  MOVWF  FEA
2876:  MOVLW  C5
2878:  MOVWF  FE9
287A:  MOVLW  1D
287C:  MOVWF  01
287E:  CLRF   FF7
2880:  MOVLW  00
2882:  MOVLB  0
2884:  CALL   025A
2888:  TBLRD*-
288A:  TBLRD*+
288C:  MOVFF  FF5,FEE
2890:  DECFSZ 01,F
2892:  BRA    288A
2894:  MOVLW  01
2896:  MOVLB  2
2898:  MOVWF  x56
289A:  MOVLW  C5
289C:  MOVWF  x55
289E:  MOVLW  01
28A0:  MOVWF  x57
28A2:  MOVLB  0
28A4:  CALL   1CF6
....................         while(1){
....................         println((char*)"ID Loop",2);
28A8:  MOVLW  01
28AA:  MOVWF  FEA
28AC:  MOVLW  C5
28AE:  MOVWF  FE9
28B0:  MOVLW  08
28B2:  MOVWF  01
28B4:  CLRF   FF7
28B6:  MOVLW  00
28B8:  CALL   0288
28BC:  TBLRD*-
28BE:  TBLRD*+
28C0:  MOVFF  FF5,FEE
28C4:  DECFSZ 01,F
28C6:  BRA    28BE
28C8:  MOVLW  01
28CA:  MOVLB  2
28CC:  MOVWF  x56
28CE:  MOVLW  C5
28D0:  MOVWF  x55
28D2:  MOVLW  02
28D4:  MOVWF  x57
28D6:  MOVLB  0
28D8:  CALL   1CF6
28DC:  CLRF   19
28DE:  BTFSC  FF2.7
28E0:  BSF    19.7
28E2:  BCF    FF2.7
....................         usb_task();
28E4:  CALL   1586
28E8:  BTFSC  19.7
28EA:  BSF    FF2.7
28EC:  BRA    28A8
28EE:  MOVLB  1
....................         }
....................         //exit(-1);
....................     }
....................     print((char*)"Idle",3);
28F0:  MOVLW  49
28F2:  MOVWF  xC5
28F4:  MOVLW  64
28F6:  MOVWF  xC6
28F8:  MOVLW  6C
28FA:  MOVWF  xC7
28FC:  MOVLW  65
28FE:  MOVWF  xC8
2900:  CLRF   xC9
2902:  MOVLW  01
2904:  MOVLB  2
2906:  MOVWF  x56
2908:  MOVLW  C5
290A:  MOVWF  x55
290C:  MOVLW  03
290E:  MOVWF  x57
2910:  MOVLB  0
2912:  CALL   1D68
....................     idle();
2916:  CALL   20BC
....................     println((char*)"Ready",2);
291A:  MOVLW  52
291C:  MOVLB  1
291E:  MOVWF  xC5
2920:  MOVLW  65
2922:  MOVWF  xC6
2924:  MOVLW  61
2926:  MOVWF  xC7
2928:  MOVLW  64
292A:  MOVWF  xC8
292C:  MOVLW  79
292E:  MOVWF  xC9
2930:  CLRF   xCA
2932:  MOVLW  01
2934:  MOVLB  2
2936:  MOVWF  x56
2938:  MOVLW  C5
293A:  MOVWF  x55
293C:  MOVLW  02
293E:  MOVWF  x57
2940:  MOVLB  0
2942:  CALL   1CF6
....................     //Chip setup
....................     //Set FIFO TX condition to not empty and the default FIFO threshold to 15.
....................     spi_write_u8(_REG_FIFO_THRESH, 0b10001111);
2946:  MOVLW  3C
2948:  MOVLB  2
294A:  MOVWF  x51
294C:  MOVLW  8F
294E:  MOVWF  x52
2950:  MOVLB  0
2952:  CALL   1DD6
....................     //Configure low beta off.
....................     spi_write_u8(_REG_TEST_DAGC, 0x30);
2956:  MOVLW  6F
2958:  MOVLB  2
295A:  MOVWF  x51
295C:  MOVLW  30
295E:  MOVWF  x52
2960:  MOVLB  0
2962:  CALL   1DD6
....................     //Disable boost.
....................     spi_write_u8(_REG_TEST_PA1, _TEST_PA1_NORMAL);
2966:  MOVLW  5A
2968:  MOVLB  2
296A:  MOVWF  x51
296C:  MOVLW  55
296E:  MOVWF  x52
2970:  MOVLB  0
2972:  CALL   1DD6
....................     spi_write_u8(_REG_TEST_PA2, _TEST_PA2_NORMAL);
2976:  MOVLW  5C
2978:  MOVLB  2
297A:  MOVWF  x51
297C:  MOVLW  70
297E:  MOVWF  x52
2980:  MOVLB  0
2982:  CALL   1DD6
....................     //set sync word
....................     //IMPORTANTE: Recuerda alocar el espacio para que no se sobreescriba
....................     print((char*)"Freq",3);
2986:  MOVLW  46
2988:  MOVLB  1
298A:  MOVWF  xC5
298C:  MOVLW  72
298E:  MOVWF  xC6
2990:  MOVLW  65
2992:  MOVWF  xC7
2994:  MOVLW  71
2996:  MOVWF  xC8
2998:  CLRF   xC9
299A:  MOVLW  01
299C:  MOVLB  2
299E:  MOVWF  x56
29A0:  MOVLW  C5
29A2:  MOVWF  x55
29A4:  MOVLW  03
29A6:  MOVWF  x57
29A8:  MOVLB  0
29AA:  CALL   1D68
....................     sync_word_set( _sync_word); 
29AE:  MOVFF  1BA,1E3
29B2:  MOVFF  1B9,1E2
29B6:  GOTO   2108
....................     preamble_length_set(_preamble_length);
29BA:  MOVLB  1
29BC:  CLRF   xE3
29BE:  MOVFF  1BC,1E2
29C2:  MOVLB  0
29C4:  GOTO   2192
....................     frequency_mhz_set(); 
29C8:  GOTO   21BC
....................     println((char*)"Ready",3);
29CC:  MOVLW  52
29CE:  MOVLB  1
29D0:  MOVWF  xC5
29D2:  MOVLW  65
29D4:  MOVWF  xC6
29D6:  MOVLW  61
29D8:  MOVWF  xC7
29DA:  MOVLW  64
29DC:  MOVWF  xC8
29DE:  MOVLW  79
29E0:  MOVWF  xC9
29E2:  CLRF   xCA
29E4:  MOVLW  01
29E6:  MOVLB  2
29E8:  MOVWF  x56
29EA:  MOVLW  C5
29EC:  MOVWF  x55
29EE:  MOVLW  03
29F0:  MOVWF  x57
29F2:  MOVLB  0
29F4:  CALL   1CF6
....................     //TODO: set encryption key
....................     //encryption_key = encrypt;
....................     //encryption_key_set(encrypt);
....................     
....................     //PARA USUARIOS AVANZADOS ----------------------------------------------------------------------------------------------
....................     // Configure modulation for RadioHead library GFSK_Rb250Fd250 mode
....................     // by default.  Users with advanced knowledge can manually reconfigure
....................     // for any other mode (consulting the datasheet is absolutely
....................     // necessary!).
....................     bitrate_set(250000);  // 250kbs
29F8:  MOVLB  1
29FA:  CLRF   xE5
29FC:  MOVLW  24
29FE:  MOVWF  xE4
2A00:  MOVLW  74
2A02:  MOVWF  xE3
2A04:  MOVLW  90
2A06:  MOVWF  xE2
2A08:  MOVLB  0
2A0A:  BRA    2608
....................     frequency_deviation_set(250000);  // 250khz
2A0C:  MOVLB  1
2A0E:  CLRF   xE5
2A10:  MOVLW  24
2A12:  MOVWF  xE4
2A14:  MOVLW  74
2A16:  MOVWF  xE3
2A18:  MOVLW  90
2A1A:  MOVWF  xE2
2A1C:  MOVLB  0
2A1E:  BRA    26AA
....................     set(0b01,modulation_shaping);  // Gaussian filter, BT=1.0
2A20:  MOVLW  01
2A22:  MOVLB  2
2A24:  MOVWF  x10
2A26:  MOVFF  E6,213
2A2A:  MOVFF  E5,212
2A2E:  MOVFF  E4,211
2A32:  MOVLB  0
2A34:  CALL   20D2
....................     set(0b111,rx_bw_dcc_freq);  // RxBw register = 0xE0
2A38:  MOVLW  07
2A3A:  MOVLB  2
2A3C:  MOVWF  x10
2A3E:  MOVFF  104,213
2A42:  MOVFF  103,212
2A46:  MOVFF  102,211
2A4A:  MOVLB  0
2A4C:  CALL   20D2
....................     set(0b00,rx_bw_mantissa);
2A50:  MOVLB  2
2A52:  CLRF   x10
2A54:  MOVFF  107,213
2A58:  MOVFF  106,212
2A5C:  MOVFF  105,211
2A60:  MOVLB  0
2A62:  CALL   20D2
....................     set(0b000,rx_bw_exponent);
2A66:  MOVLB  2
2A68:  CLRF   x10
2A6A:  MOVFF  10A,213
2A6E:  MOVFF  109,212
2A72:  MOVFF  108,211
2A76:  MOVLB  0
2A78:  CALL   20D2
....................     set(0b111,afc_bw_dcc_freq); // AfcBw register = 0xE0
2A7C:  MOVLW  07
2A7E:  MOVLB  2
2A80:  MOVWF  x10
2A82:  MOVFF  10D,213
2A86:  MOVFF  10C,212
2A8A:  MOVFF  10B,211
2A8E:  MOVLB  0
2A90:  CALL   20D2
....................     set(0b00,afc_bw_mantissa);
2A94:  MOVLB  2
2A96:  CLRF   x10
2A98:  MOVFF  110,213
2A9C:  MOVFF  10F,212
2AA0:  MOVFF  10E,211
2AA4:  MOVLB  0
2AA6:  CALL   20D2
....................     set(0b000,afc_bw_exponent);
2AAA:  MOVLB  2
2AAC:  CLRF   x10
2AAE:  MOVFF  113,213
2AB2:  MOVFF  112,212
2AB6:  MOVFF  111,211
2ABA:  MOVLB  0
2ABC:  CALL   20D2
....................     set(1,packet_format);  // Variable length.
2AC0:  MOVLW  01
2AC2:  MOVLB  2
2AC4:  MOVWF  x10
2AC6:  MOVFF  116,213
2ACA:  MOVFF  115,212
2ACE:  MOVFF  114,211
2AD2:  MOVLB  0
2AD4:  CALL   20D2
....................     set(0b10,dc_free);  // Whitening
2AD8:  MOVLW  02
2ADA:  MOVLB  2
2ADC:  MOVWF  x10
2ADE:  MOVFF  119,213
2AE2:  MOVFF  118,212
2AE6:  MOVFF  117,211
2AEA:  MOVLB  0
2AEC:  CALL   20D2
....................     //-----------------------------------------------------------------------------------------------------------------------
....................     // Set transmit power to 13 dBm, a safe value any module supports.
....................     tx_power_set(13);
2AF0:  MOVLW  0D
2AF2:  MOVLB  1
2AF4:  MOVWF  xE2
2AF6:  MOVLB  0
2AF8:  BRA    274C
....................     //
....................     // initialize last RSSI reading
....................     last_rssi = 0.0;
2AFA:  MOVLB  1
2AFC:  CLRF   x50
2AFE:  CLRF   x4F
2B00:  CLRF   x4E
2B02:  CLRF   x4D
....................     // """The RSSI of the last received packet. Stored when the packet was received.
....................     //    This instantaneous RSSI value may not be accurate once the
....................     //    operating mode has been changed.
....................     // """
....................     // initialize timeouts and delays delays
....................     ack_wait = 0.5;
2B04:  CLRF   x54
2B06:  CLRF   x53
2B08:  CLRF   x52
2B0A:  MOVLW  7E
2B0C:  MOVWF  x51
....................     // """The delay time before attempting a retry after not receiving an ACK"""
....................     receive_timeout = 0.5;
2B0E:  CLRF   x58
2B10:  CLRF   x57
2B12:  CLRF   x56
2B14:  MOVWF  x55
....................     // """The amount of time to poll for a received packet.
....................     //    If no packet is received, the returned packet will be None
....................     // """
....................     xmit_timeout = 2.0;
2B16:  CLRF   x5C
2B18:  CLRF   x5B
2B1A:  CLRF   x5A
2B1C:  MOVLW  80
2B1E:  MOVWF  x59
....................     // """The amount of time to wait for the HW to transmit the packet.
....................     //    This is mainly used to prevent a hang due to a HW issue
....................     // """
....................     ack_retries = 5;
2B20:  MOVLW  05
2B22:  MOVWF  x5D
....................     // """The number of ACK retries before reporting a failure."""
....................     ack_delay = 0;
2B24:  CLRF   x61
2B26:  CLRF   x60
2B28:  CLRF   x5F
2B2A:  CLRF   x5E
....................     // """The delay time before attemting to send an ACK.
....................     //    If ACKs are being missed try setting this to .1 or .2.
....................     // """
....................     //print("<------------------------------------------------------------------------------------------------------------------------------------------>")
....................     // initialize sequence number counter for reliabe datagram mode
....................     sequence_number = 0;
2B2C:  CLRF   x62
....................     // create seen Ids list
....................     //seen_ids = {0};
....................     // initialize packet header
....................     // node address - default is broadcast
....................     node = _RH_BROADCAST_ADDRESS;
2B2E:  SETF   x6B
....................     // """The default address of this Node. (0-255).
....................     //    If not 255 (0xff) then only packets address to this node will be accepted.
....................     //    First byte of the RadioHead header.
....................     // """
....................     // destination address - default is broadcast
....................     destination = _RH_BROADCAST_ADDRESS;
2B30:  SETF   x6C
....................     // """The default destination address for packet transmissions. (0-255).
....................     //    If 255 (0xff) then any receiving node should accept the packet.
....................     //    Second byte of the RadioHead header.
....................     // """
....................     // ID - contains seq count for reliable datagram mode
....................     identifier = 0;
2B32:  CLRF   x6D
....................     // """Automatically set to the sequence number when send_with_ack() used.
....................     //    Third byte of the RadioHead header.
....................     // """
....................     // flags - identifies ack/reetry packet for reliable datagram mode
....................     flags = 0;
2B34:  CLRF   x6E
....................     // """Upper 4 bits reserved for use by Reliable Datagram Mode.
....................     //    Lower 4 bits may be used to pass information.
....................     //    Fourth byte of the RadioHead header.
....................     // """
....................     //Extras: paara algunos registros que no coinciden con la libreria del micropython
....................     // RSSI_CONFIG: 0x2
....................     spi_write_u8(0x23,0x02);
2B36:  MOVLW  23
2B38:  MOVLB  2
2B3A:  MOVWF  x51
2B3C:  MOVLW  02
2B3E:  MOVWF  x52
2B40:  MOVLB  0
2B42:  CALL   1DD6
....................     //_REG_DIO_MAPPING1
....................     spi_write_u8(_REG_DIO_MAPPING1,0x00);
2B46:  MOVLW  25
2B48:  MOVLB  2
2B4A:  MOVWF  x51
2B4C:  CLRF   x52
2B4E:  MOVLB  0
2B50:  CALL   1DD6
....................     //101  FXOSC / 32
....................     spi_write_u8(_REG_DIO_MAPPING1+1,0b101);
2B54:  MOVLW  26
2B56:  MOVLB  2
2B58:  MOVWF  x51
2B5A:  MOVLW  05
2B5C:  MOVWF  x52
2B5E:  MOVLB  0
2B60:  CALL   1DD6
....................     //RSSI_THRESH
....................     spi_write_u8(0x29,0xFF);
2B64:  MOVLW  29
2B66:  MOVLB  2
2B68:  MOVWF  x51
2B6A:  SETF   x52
2B6C:  MOVLB  0
2B6E:  CALL   1DD6
....................     //INIT payload length to 0
....................     spi_write_u8(0x38,0x40);
2B72:  MOVLW  38
2B74:  MOVLB  2
2B76:  MOVWF  x51
2B78:  MOVLW  40
2B7A:  MOVWF  x52
2B7C:  MOVLB  0
2B7E:  CALL   1DD6
....................     //AutoRxRestartOn
....................     spi_write_u8(_REG_PACKET_CONFIG2,0x02);
2B82:  MOVLW  3D
2B84:  MOVLB  2
2B86:  MOVWF  x51
2B88:  MOVLW  02
2B8A:  MOVWF  x52
2B8C:  MOVLB  0
2B8E:  CALL   1DD6
....................     //Con esto se puede colocar un LED en DIO2 y ver los datos que se reciben y se envian
....................     set(0b01,dio_2_mapping);
2B92:  MOVLW  01
2B94:  MOVLB  2
2B96:  MOVWF  x10
2B98:  MOVFF  12E,213
2B9C:  MOVFF  12D,212
2BA0:  MOVFF  12C,211
2BA4:  MOVLB  0
2BA6:  CALL   20D2
....................     //Asi se puede saber si el buffer FIFO tiene algun dato
....................     set(0b10,dio_1_mapping);
2BAA:  MOVLW  02
2BAC:  MOVLB  2
2BAE:  MOVWF  x10
2BB0:  MOVFF  12B,213
2BB4:  MOVFF  12A,212
2BB8:  MOVFF  129,211
2BBC:  MOVLB  0
2BBE:  CALL   20D2
....................     //En modo rx, da informacion acerca del RSSI (Recieved Signal Strength Indicator)
....................     set(0b01,dio_3_mapping);
2BC2:  MOVLW  01
2BC4:  MOVLB  2
2BC6:  MOVWF  x10
2BC8:  MOVFF  131,213
2BCC:  MOVFF  130,212
2BD0:  MOVFF  12F,211
2BD4:  MOVLB  0
2BD6:  CALL   20D2
....................     print((char*)"Initial configuration end\n",2);
2BDA:  MOVLW  01
2BDC:  MOVWF  FEA
2BDE:  MOVLW  C5
2BE0:  MOVWF  FE9
2BE2:  MOVLW  1B
2BE4:  MOVWF  01
2BE6:  CLRF   FF7
2BE8:  MOVLW  00
2BEA:  CALL   02A0
2BEE:  TBLRD*-
2BF0:  TBLRD*+
2BF2:  MOVFF  FF5,FEE
2BF6:  DECFSZ 01,F
2BF8:  BRA    2BF0
2BFA:  MOVLW  01
2BFC:  MOVLB  2
2BFE:  MOVWF  x56
2C00:  MOVLW  C5
2C02:  MOVWF  x55
2C04:  MOVLW  02
2C06:  MOVWF  x57
2C08:  MOVLB  0
2C0A:  CALL   1D68
2C0E:  GOTO   4406 (RETURN)
.................... }
.................... void reset(){
*
1D1E:  CLRF   19
1D20:  BTFSC  FF2.7
1D22:  BSF    19.7
1D24:  BCF    FF2.7
....................     setOutput(_reset_pin,1);
1D26:  MOVFF  188,291
1D2A:  MOVLW  01
1D2C:  MOVLB  2
1D2E:  MOVWF  x92
1D30:  MOVLB  0
1D32:  RCALL  163E
1D34:  BTFSC  19.7
1D36:  BSF    FF2.7
....................     sleep_ms(1);
1D38:  MOVLW  01
1D3A:  MOVLB  1
1D3C:  MOVWF  xEB
1D3E:  MOVLB  0
1D40:  RCALL  1924
1D42:  CLRF   19
1D44:  BTFSC  FF2.7
1D46:  BSF    19.7
1D48:  BCF    FF2.7
....................     setOutput(_reset_pin,0);
1D4A:  MOVFF  188,291
1D4E:  MOVLB  2
1D50:  CLRF   x92
1D52:  MOVLB  0
1D54:  RCALL  163E
1D56:  BTFSC  19.7
1D58:  BSF    FF2.7
....................     sleep_ms(5);
1D5A:  MOVLW  05
1D5C:  MOVLB  1
1D5E:  MOVWF  xEB
1D60:  MOVLB  0
1D62:  RCALL  1924
1D64:  GOTO   285A (RETURN)
.................... }
.................... void set_boost(uint8_t setting){
....................     //Set preamp boost if needed.
....................     if (_tx_power >= 18){
*
1DF4:  MOVLB  1
1DF6:  BTFSC  x3B.7
1DF8:  BRA    1E1E
1DFA:  MOVF   x3B,W
1DFC:  SUBLW  11
1DFE:  BC    1E1E
....................         spi_write_u8(_REG_TEST_PA1, setting);
1E00:  MOVLW  5A
1E02:  MOVLB  2
1E04:  MOVWF  x51
1E06:  MOVFF  210,252
1E0A:  MOVLB  0
1E0C:  RCALL  1DD6
....................         spi_write_u8(_REG_TEST_PA2, setting);
1E0E:  MOVLW  5C
1E10:  MOVLB  2
1E12:  MOVWF  x51
1E14:  MOVFF  210,252
1E18:  MOVLB  0
1E1A:  RCALL  1DD6
1E1C:  MOVLB  1
....................     }
1E1E:  MOVLB  0
1E20:  RETURN 0
.................... }
.................... void idle(){
....................     //Enter idle standby mode (switching off high power amplifiers if necessary).
....................     //Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
*
20BC:  MOVLW  55
20BE:  MOVLB  2
20C0:  MOVWF  x10
20C2:  MOVLB  0
20C4:  RCALL  1DF4
....................     operation_mode_set(STANDBY_MODE);
20C6:  MOVLW  01
20C8:  MOVLB  2
20CA:  MOVWF  x10
20CC:  MOVLB  0
20CE:  RCALL  1E78
20D0:  RETURN 0
....................            
.................... }
.................... void rfm_sleep(){
....................     operation_mode_set(SLEEP_MODE); 
.................... }
.................... void listen(){
....................     //Listen for packets to be received by the chip.  Use :py:func:`receive` to listen, wait
....................     //and retrieve packets as they're available.
....................     
....................     // Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
*
2C8C:  MOVLW  55
2C8E:  MOVLB  2
2C90:  MOVWF  x10
2C92:  MOVLB  0
2C94:  CALL   1DF4
....................     // Enable payload ready interrupt for D0 line.
....................     set(0b01,dio_0_mapping);
2C98:  MOVLW  01
2C9A:  MOVLB  2
2C9C:  MOVWF  x10
2C9E:  MOVFF  128,213
2CA2:  MOVFF  127,212
2CA6:  MOVFF  126,211
2CAA:  MOVLB  0
2CAC:  CALL   20D2
....................     // Enter RX mode (will clear FIFO!).
....................           
....................     operation_mode_set(RX_MODE); 
2CB0:  MOVLW  04
2CB2:  MOVLB  2
2CB4:  MOVWF  x10
2CB6:  MOVLB  0
2CB8:  CALL   1E78
2CBC:  RETURN 0
.................... }
.................... void transmit(){
....................     // Transmit a packet which is queued in the FIFO.  This is a low level function for
....................     // entering transmit mode and more.  For generating and transmitting a packet of data use
....................     // :py:func:`send` instead.
....................     
....................     // # Like RadioHead library, turn on high power boost if enabled.
....................     set_boost(_TEST_PA1_BOOST);
*
3680:  MOVLW  5D
3682:  MOVLB  2
3684:  MOVWF  x10
3686:  MOVLB  0
3688:  CALL   1DF4
....................     // # Enable packet sent interrupt for D0 line.
....................     set(0b00,dio_0_mapping);
368C:  MOVLB  2
368E:  CLRF   x10
3690:  MOVFF  128,213
3694:  MOVFF  127,212
3698:  MOVFF  126,211
369C:  MOVLB  0
369E:  CALL   20D2
....................     //readAllRegs(); 
....................     // # Enter TX mode (will clear FIFO!).
....................     operation_mode_set(TX_MODE);  
36A2:  MOVLW  03
36A4:  MOVLB  2
36A6:  MOVWF  x10
36A8:  MOVLB  0
36AA:  CALL   1E78
36AE:  GOTO   3898 (RETURN)
.................... }
.................... // .. warning:: Reading this will STOP any receiving/sending that might be happening!
.................... //WARNING:LOOP infinito
.................... float temperature_get(){
....................     // The internal temperature of the chip in degrees Celsius. Be warned this is not
....................     // calibrated or very accurate.
....................     // .. warning:: Reading this will STOP any receiving/sending that might be happening!
....................     // # Start a measurement then poll the measurement finished bit.
....................     set(1,temp_start);
....................     //WARNING:LOOP infinito
....................     while (get(temp_running) > 0){
....................     usb_task();
....................     
....................     }
....................     temperature = 166.0 - (float)spi_read_u8(_REG_TEMP2);
....................     return temperature;
.................... }
.................... uint8_t operation_mode_get(){
....................     // """The operation mode value.  Unless you're manually controlling the chip you shouldn't
....................     // change the operation_mode with this property as other side-effects are required for
....................     // changing logical modes--use :py:func:`idle`, :py:func:`sleep`, :py:func:`transmit`,
....................     // :py:func:`listen` instead to signal intent for explicit logical modes.
....................     // """
....................     operation_mode = (spi_read_u8(_REG_OP_MODE) >> 2) &0b111;
....................     return operation_mode;
.................... }
.................... void operation_mode_set(uint8_t val){
....................     //float start;
....................     uint16_t n;
....................     //TODO: assert 0 <= val <= 4
....................     n=0;
*
1E78:  MOVLB  2
1E7A:  CLRF   x12
1E7C:  CLRF   x11
....................     
....................     while (!get(mode_ready)){
1E7E:  MOVFF  125,253
1E82:  MOVFF  124,252
1E86:  MOVFF  123,251
1E8A:  MOVLB  0
1E8C:  RCALL  1E22
1E8E:  MOVF   01,F
1E90:  BNZ   1F66
....................       delay_ms(100);
1E92:  MOVLW  64
1E94:  MOVLB  2
1E96:  MOVWF  x51
1E98:  MOVLB  0
1E9A:  RCALL  18FA
....................       n+=100;
1E9C:  MOVLW  64
1E9E:  MOVLB  2
1EA0:  ADDWF  x11,F
1EA2:  MOVLW  00
1EA4:  ADDWFC x12,F
1EA6:  CLRF   19
1EA8:  BTFSC  FF2.7
1EAA:  BSF    19.7
1EAC:  BCF    FF2.7
....................       usb_task();
1EAE:  MOVLB  0
1EB0:  CALL   1586
1EB4:  BTFSC  19.7
1EB6:  BSF    FF2.7
....................       println((char*)"OP Loop 1",3);
1EB8:  MOVLW  02
1EBA:  MOVWF  FEA
1EBC:  MOVLW  13
1EBE:  MOVWF  FE9
1EC0:  MOVLW  0A
1EC2:  MOVWF  01
1EC4:  CLRF   FF7
1EC6:  MOVLW  00
1EC8:  CALL   02CC
1ECC:  TBLRD*-
1ECE:  TBLRD*+
1ED0:  MOVFF  FF5,FEE
1ED4:  DECFSZ 01,F
1ED6:  BRA    1ECE
1ED8:  MOVLW  02
1EDA:  MOVLB  2
1EDC:  MOVWF  x56
1EDE:  MOVLW  13
1EE0:  MOVWF  x55
1EE2:  MOVLW  03
1EE4:  MOVWF  x57
1EE6:  MOVLB  0
1EE8:  RCALL  1CF6
....................         if (n >= 3000){
1EEA:  MOVLB  2
1EEC:  MOVF   x12,W
1EEE:  SUBLW  0A
1EF0:  BC    1F62
1EF2:  XORLW  FF
1EF4:  BNZ   1EFC
1EF6:  MOVF   x11,W
1EF8:  SUBLW  B7
1EFA:  BC    1F62
....................                  
....................             print ((char*)"Operation Mode couldnt be set\n",2);
1EFC:  MOVLW  02
1EFE:  MOVWF  FEA
1F00:  MOVLW  13
1F02:  MOVWF  FE9
1F04:  MOVLW  1F
1F06:  MOVWF  01
1F08:  CLRF   FF7
1F0A:  MOVLW  00
1F0C:  MOVLB  0
1F0E:  CALL   02E6
1F12:  TBLRD*-
1F14:  TBLRD*+
1F16:  MOVFF  FF5,FEE
1F1A:  DECFSZ 01,F
1F1C:  BRA    1F14
1F1E:  MOVLW  02
1F20:  MOVLB  2
1F22:  MOVWF  x56
1F24:  MOVLW  13
1F26:  MOVWF  x55
1F28:  MOVLW  02
1F2A:  MOVWF  x57
1F2C:  MOVLB  0
1F2E:  RCALL  1D68
....................             println(spi_read_u8(0x27),BIN,2);
1F30:  MOVLW  27
1F32:  MOVLB  2
1F34:  MOVWF  x55
1F36:  MOVLB  0
1F38:  RCALL  192C
1F3A:  MOVFF  01,251
1F3E:  MOVFF  01,253
1F42:  MOVLW  02
1F44:  MOVLB  2
1F46:  MOVWF  x54
1F48:  MOVWF  x55
1F4A:  MOVLB  0
1F4C:  RCALL  1E4A
1F4E:  CLRF   19
1F50:  BTFSC  FF2.7
1F52:  BSF    19.7
1F54:  BCF    FF2.7
....................             while (1){ 
....................             usb_task();
1F56:  CALL   1586
1F5A:  BTFSC  19.7
1F5C:  BSF    FF2.7
1F5E:  BRA    1F4E
1F60:  MOVLB  2
....................             }
....................             
....................             //exit(-2);
....................         }
1F62:  BRA    1E7E
1F64:  MOVLB  0
....................     }      
....................     // Set the mode bits inside the operation mode register.
....................     operation_mode = spi_read_u8(_REG_OP_MODE);
1F66:  MOVLW  01
1F68:  MOVLB  2
1F6A:  MOVWF  x55
1F6C:  MOVLB  0
1F6E:  RCALL  192C
1F70:  MOVFF  01,16F
....................     operation_mode &= 0b11100011;
1F74:  MOVLW  E3
1F76:  MOVLB  1
1F78:  ANDWF  x6F,F
....................     operation_mode |= val << 2;
1F7A:  MOVLB  2
1F7C:  RLCF   x10,W
1F7E:  MOVWF  00
1F80:  RLCF   00,F
1F82:  MOVLW  FC
1F84:  ANDWF  00,F
1F86:  MOVF   00,W
1F88:  MOVLB  1
1F8A:  IORWF  x6F,F
....................     //Serial.println(operation_mode,BIN);
....................     spi_write_u8(_REG_OP_MODE,operation_mode);
1F8C:  MOVLW  01
1F8E:  MOVLB  2
1F90:  MOVWF  x51
1F92:  MOVFF  16F,252
1F96:  MOVLB  0
1F98:  RCALL  1DD6
....................    
....................     // Wait for mode to change by polling interrupt bit.
....................     // start = timeSec();
....................     n=0;
1F9A:  MOVLB  2
1F9C:  CLRF   x12
1F9E:  CLRF   x11
....................     while (!get(mode_ready)){
1FA0:  MOVFF  125,253
1FA4:  MOVFF  124,252
1FA8:  MOVFF  123,251
1FAC:  MOVLB  0
1FAE:  RCALL  1E22
1FB0:  MOVF   01,F
1FB2:  BTFSS  FD8.2
1FB4:  BRA    20BA
1FB6:  CLRF   19
1FB8:  BTFSC  FF2.7
1FBA:  BSF    19.7
1FBC:  BCF    FF2.7
....................     usb_task();
1FBE:  CALL   1586
1FC2:  BTFSC  19.7
1FC4:  BSF    FF2.7
....................     delay_ms(100);
1FC6:  MOVLW  64
1FC8:  MOVLB  2
1FCA:  MOVWF  x51
1FCC:  MOVLB  0
1FCE:  RCALL  18FA
....................     n+=100;
1FD0:  MOVLW  64
1FD2:  MOVLB  2
1FD4:  ADDWF  x11,F
1FD6:  MOVLW  00
1FD8:  ADDWFC x12,F
....................     println((char*)"OP Loop 2",2);
1FDA:  MOVLW  02
1FDC:  MOVWF  FEA
1FDE:  MOVLW  32
1FE0:  MOVWF  FE9
1FE2:  MOVLW  0A
1FE4:  MOVWF  01
1FE6:  CLRF   FF7
1FE8:  MOVLW  00
1FEA:  MOVLB  0
1FEC:  CALL   0316
1FF0:  TBLRD*-
1FF2:  TBLRD*+
1FF4:  MOVFF  FF5,FEE
1FF8:  DECFSZ 01,F
1FFA:  BRA    1FF2
1FFC:  MOVLW  02
1FFE:  MOVLB  2
2000:  MOVWF  x56
2002:  MOVLW  32
2004:  MOVWF  x55
2006:  MOVLW  02
2008:  MOVWF  x57
200A:  MOVLB  0
200C:  RCALL  1CF6
....................     println(spi_read_u8(_REG_OP_MODE),BIN,2)  ;  
200E:  MOVLW  01
2010:  MOVLB  2
2012:  MOVWF  x55
2014:  MOVLB  0
2016:  RCALL  192C
2018:  MOVFF  01,251
201C:  MOVFF  01,253
2020:  MOVLW  02
2022:  MOVLB  2
2024:  MOVWF  x54
2026:  MOVWF  x55
2028:  MOVLB  0
202A:  RCALL  1E4A
....................     println(n,DEC,2);
202C:  MOVFF  211,253
2030:  MOVLW  0A
2032:  MOVLB  2
2034:  MOVWF  x54
2036:  MOVLW  02
2038:  MOVWF  x55
203A:  MOVLB  0
203C:  RCALL  1E4A
....................         if (n >= 3000){
203E:  MOVLB  2
2040:  MOVF   x12,W
2042:  SUBLW  0A
2044:  BC    20B6
2046:  XORLW  FF
2048:  BNZ   2050
204A:  MOVF   x11,W
204C:  SUBLW  B7
204E:  BC    20B6
....................             print ((char*)"Timeout on Operation Mode Set\n",2);
2050:  MOVLW  02
2052:  MOVWF  FEA
2054:  MOVLW  32
2056:  MOVWF  FE9
2058:  MOVLW  1F
205A:  MOVWF  01
205C:  CLRF   FF7
205E:  MOVLW  00
2060:  MOVLB  0
2062:  CALL   0330
2066:  TBLRD*-
2068:  TBLRD*+
206A:  MOVFF  FF5,FEE
206E:  DECFSZ 01,F
2070:  BRA    2068
2072:  MOVLW  02
2074:  MOVLB  2
2076:  MOVWF  x56
2078:  MOVLW  32
207A:  MOVWF  x55
207C:  MOVLW  02
207E:  MOVWF  x57
2080:  MOVLB  0
2082:  RCALL  1D68
....................             println(spi_read_u8(_REG_OP_MODE),BIN,2)  ;     
2084:  MOVLW  01
2086:  MOVLB  2
2088:  MOVWF  x55
208A:  MOVLB  0
208C:  RCALL  192C
208E:  MOVFF  01,251
2092:  MOVFF  01,253
2096:  MOVLW  02
2098:  MOVLB  2
209A:  MOVWF  x54
209C:  MOVWF  x55
209E:  MOVLB  0
20A0:  RCALL  1E4A
20A2:  CLRF   19
20A4:  BTFSC  FF2.7
20A6:  BSF    19.7
20A8:  BCF    FF2.7
....................             while (1){
....................             usb_task();
20AA:  CALL   1586
20AE:  BTFSC  19.7
20B0:  BSF    FF2.7
20B2:  BRA    20A2
20B4:  MOVLB  2
....................             
....................             }
....................             //exit(-2);
....................         }
20B6:  BRA    1FA0
20B8:  MOVLB  0
....................     }
20BA:  RETURN 0
.................... }
.................... //WARNING must free allocated memory after using
.................... uint8_t* sync_word_get(){
....................     
....................     // """The synchronization word value.  This is a byte string up to 8 bytes long (64 bits)
....................     // which indicates the synchronization word for transmitted and received packets. Any
....................     // received packet which does not include this sync word will be ignored. The default value
....................     // is 0x2D, 0xD4 which matches the RadioHead RFM69 library. Setting a value of None will
....................     // disable synchronization word matching entirely.
....................     // """
....................     // # Handle when sync word is disabled..
....................     if (!get(sync_on))return NULL;
....................     //WARNING must free allocated memory after using
....................     sync_word = (uint8_t*)malloc(get(sync_size)+2);
....................     sync_word[0] = get(sync_size)+1;
....................     spi_read_into(_REG_SYNC_VALUE1,sync_word+1,get(sync_size)+1);
....................     return sync_word;
.................... }
.................... void sync_word_set(uint8_t* wrd){
*
2108:  MOVLB  1
210A:  MOVFF  1E2,FE9
210E:  MOVFF  1E3,FEA
2112:  MOVFF  FEF,1E4
....................   uint8_t len = wrd[0];
....................     if (len == 0 || wrd == NULL)set(0,sync_on);
2116:  MOVF   xE4,F
2118:  BZ    2122
211A:  MOVF   xE2,F
211C:  BNZ   213A
211E:  MOVF   xE3,F
2120:  BNZ   213A
2122:  MOVLB  2
2124:  CLRF   x10
2126:  MOVFF  EF,213
212A:  MOVFF  EE,212
212E:  MOVFF  ED,211
2132:  MOVLB  0
2134:  RCALL  20D2
2136:  BRA    218E
2138:  MOVLB  1
....................     
....................     else{
....................         //TODO: assert 1 <= len(val) <= 8
....................         spi_write_from(_REG_SYNC_VALUE1,wrd+1,len);
213A:  MOVLW  01
213C:  ADDWF  xE2,W
213E:  MOVWF  xE5
2140:  MOVLW  00
2142:  ADDWFC xE3,W
2144:  MOVWF  xE6
2146:  MOVLW  2F
2148:  MOVLB  2
214A:  MOVWF  x53
214C:  MOVFF  1E6,255
2150:  MOVFF  1E5,254
2154:  MOVFF  1E4,256
2158:  MOVLB  0
215A:  RCALL  1D78
....................         //Sync_size: len(SYNC_WORD) - 1
....................         set(len-1,sync_size);
215C:  MOVLW  01
215E:  MOVLB  1
2160:  SUBWF  xE4,W
2162:  MOVWF  xE5
2164:  MOVFF  FE8,210
2168:  MOVFF  F2,213
216C:  MOVFF  F1,212
2170:  MOVFF  F0,211
2174:  MOVLB  0
2176:  RCALL  20D2
....................         set(1,sync_on);
2178:  MOVLW  01
217A:  MOVLB  2
217C:  MOVWF  x10
217E:  MOVFF  EF,213
2182:  MOVFF  EE,212
2186:  MOVFF  ED,211
218A:  MOVLB  0
218C:  RCALL  20D2
....................     }
218E:  GOTO   29BA (RETURN)
.................... }
.................... uint16_t preamble_length_get(){
....................     // The length of the preamble for sent and received packets, an unsigned 16-bit value.
....................     // Received packets must match this length or they are ignored! Set to 4 to match the
....................     // RadioHead RFM69 library.
....................     uint8_t msb = spi_read_u8(_REG_PREAMBLE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_PREAMBLE_LSB);
....................     return ((msb << 8) | lsb) & 0xFFFF;
.................... }
.................... void preamble_length_set(uint16_t val){
....................     spi_write_u8(_REG_PREAMBLE_MSB, (val >> 8) & 0xFF);
2192:  MOVLB  1
2194:  CLRF   xE5
2196:  CLRF   xE5
2198:  MOVLW  2C
219A:  MOVLB  2
219C:  MOVWF  x51
219E:  MOVFF  1E3,252
21A2:  MOVLB  0
21A4:  RCALL  1DD6
....................     spi_write_u8(_REG_PREAMBLE_LSB, val & 0xFF);
21A6:  MOVLB  1
21A8:  CLRF   xE5
21AA:  MOVLW  2D
21AC:  MOVLB  2
21AE:  MOVWF  x51
21B0:  MOVFF  1E2,252
21B4:  MOVLB  0
21B6:  RCALL  1DD6
21B8:  GOTO   29C8 (RETURN)
.................... }
.................... float frequency_mhz_get(){
....................     // """The frequency of the radio in Megahertz. Only the allowed values for your radio must be
....................     // specified (i.e. 433 vs. 915 mhz)!
....................     // """
....................     // # FRF register is computed from the frequency following the datasheet.
....................     // # See section 6.2 and FRF register description.
....................     // # Read bytes of FRF register and assemble into a 24-bit unsigned value.
....................     uint8_t msb = spi_read_u8(_REG_FRF_MSB);
....................     uint8_t mid = spi_read_u8(_REG_FRF_MID);
....................     uint8_t lsb = spi_read_u8(_REG_FRF_LSB);
....................     uint32_t frf = ((msb << 16) | (mid << 8) | lsb) & 0xFFFFFF;
....................     float frequency = (frf * _FSTEP) / 1000000.0;
....................     return frequency;
.................... }
.................... //WARNING: No funciona en micros porque requiere de enteros de 32 bits    
.................... void frequency_mhz_set(){
....................     //FRF = int((freq/_FSTEP)*1,000,000) & 0xFFFFFF
....................     uint8_t msb,lsb,mid;
....................     #ifdef FREQ_433
....................     msb = 0x6C;
21BC:  MOVLW  6C
21BE:  MOVLB  1
21C0:  MOVWF  xE2
....................     mid = 0x40;
21C2:  MOVLW  40
21C4:  MOVWF  xE4
....................     lsb = 0x00;
21C6:  CLRF   xE3
....................     #endif
....................     //TODO: aadir soporte para otras frecuencias
....................     
....................     //TODO: assert 290 <= val <= 1020
....................     // Calculate FRF register 24-bit value using section 6.2 of the datasheet.
....................     // unsigned long frf = int((val/_FSTEP)* 1000000.0) ;
....................     // Serial.print("FRF: ");
....................     // Serial.println(frf);
....................     
....................     // frf &=  0xFFFFFF;
....................     // // Extract byte values and update registers.
....................     // uint8_t msb = frf >> 16;
....................     // uint8_t mid = (frf >> 8) & 0xFF;
....................     // uint8_t lsb = frf & 0xFF;
....................     spi_write_u8(_REG_FRF_MSB, msb);
21C8:  MOVLW  07
21CA:  MOVLB  2
21CC:  MOVWF  x51
21CE:  MOVFF  1E2,252
21D2:  MOVLB  0
21D4:  RCALL  1DD6
....................     spi_write_u8(_REG_FRF_MID, mid);
21D6:  MOVLW  08
21D8:  MOVLB  2
21DA:  MOVWF  x51
21DC:  MOVFF  1E4,252
21E0:  MOVLB  0
21E2:  RCALL  1DD6
....................     spi_write_u8(_REG_FRF_LSB, lsb);
21E4:  MOVLW  09
21E6:  MOVLB  2
21E8:  MOVWF  x51
21EA:  MOVFF  1E3,252
21EE:  MOVLB  0
21F0:  RCALL  1DD6
21F2:  GOTO   29CC (RETURN)
.................... }
.................... uint8_t* encryption_key_get(){
....................     // """The AES encryption key used to encrypt and decrypt packets by the chip. This can be set
....................     // to None to disable encryption (the default), otherwise it must be a 16 byte long byte
....................     // string which defines the key (both the transmitter and receiver must use the same key
....................     // value).
....................     // """
....................     // # Handle if encryption is disabled.
....................     if(get(aes_on)==0)return NULL;
....................     spi_read_into(_REG_AES_KEY1,encryption_key,16);
....................     return encryption_key;
.................... }
.................... void encryption_key_set(uint8_t* val){
....................     if (val==0)set(0,aes_on);
....................     else{
....................         // Set the encryption key and enable encryption.
....................         //TODO: assert len(val) == 16
....................         spi_write_from(_REG_AES_KEY1,val,16);
....................         set(1,aes_on);
....................     }
.................... }
.................... int8_t tx_power_get(){
....................     // The transmit power in dBm. Can be set to a value from -2 to 20 for high power devices
....................     // (RFM69HCW, high_power=True) or -18 to 13 for low power devices. Only integer power
....................     // levels are actually set (i.e. 12.5 will result in a value of 12 dBm).
....................     // """
....................     // # Follow table 10 truth table from the datasheet for determining power
....................     // # level from the individual PA level bits and output power register.
....................     uint8_t pa0 = get(pa_0_on);
....................     uint8_t pa1 = get(pa_1_on);
....................     uint8_t pa2 = get(pa_2_on);
....................     uint8_t current_output_power = get(output_power);
....................     if (pa0 &&  !pa1 &&  !pa2)
....................         //# -18 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && !pa2)
....................         //# -2 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && !high_power)
....................         //# 2 to 17 dBm range
....................         return -14 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && high_power)
....................         //# 5 to 20 dBm range
....................         return -11 + current_output_power;
....................     print((char*)"Tx power power amps state unknown!",2);
....................     while (1){
....................     usb_task();
....................     }
....................     //exit(-3);
.................... }
.................... void tx_power_set(int8_t val){
*
274C:  MOVLB  1
274E:  CLRF   xE3
2750:  CLRF   xE4
2752:  CLRF   xE5
2754:  CLRF   xE6
....................     // Determine power amplifier and output power values depending on
....................     // high power state and requested power.
....................     uint8_t _pa_0_on = 0;
....................     uint8_t _pa_1_on = 0;
....................     uint8_t _pa_2_on = 0;
....................     uint8_t _output_power = 0;
....................     if (high_power){
2756:  MOVLB  0
2758:  BTFSS  xB5.2
275A:  BRA    27A2
....................         // Handle high power mode.
....................         //TODO: assert -2 <= val <= 20
....................         _pa_1_on = 1;
275C:  MOVLW  01
275E:  MOVLB  1
2760:  MOVWF  xE4
....................         if (val <= 13)
2762:  BTFSC  xE2.7
2764:  BRA    276C
2766:  MOVF   xE2,W
2768:  SUBLW  0D
276A:  BNC   2774
....................             _output_power = val + 18;
276C:  MOVLW  12
276E:  ADDWF  xE2,W
2770:  MOVWF  xE6
2772:  BRA    279E
....................         else if (13 < val && val <= 17){
2774:  BTFSC  xE2.7
2776:  BRA    2794
2778:  MOVF   xE2,W
277A:  SUBLW  0D
277C:  BC    2794
277E:  BTFSC  xE2.7
2780:  BRA    2788
2782:  MOVF   xE2,W
2784:  SUBLW  11
2786:  BNC   2794
....................             _pa_2_on = 1;
2788:  MOVLW  01
278A:  MOVWF  xE5
....................             _output_power = val + 14;
278C:  MOVLW  0E
278E:  ADDWF  xE2,W
2790:  MOVWF  xE6
....................             }
2792:  BRA    279E
....................         else{
....................             //  # power >= 18 dBm
....................             //# Note this also needs PA boost enabled separately!
....................             _pa_2_on = 1;
2794:  MOVLW  01
2796:  MOVWF  xE5
....................             _output_power = val + 11;
2798:  MOVLW  0B
279A:  ADDWF  xE2,W
279C:  MOVWF  xE6
....................             }
....................     }
279E:  BRA    27AE
27A0:  MOVLB  0
....................     else{
....................         //Handle non-high power mode.
....................         //TODO: assert -18 <= val <= 13
....................         // Enable only power amplifier 0 and set output power.
....................         _pa_0_on = 1;
27A2:  MOVLW  01
27A4:  MOVLB  1
27A6:  MOVWF  xE3
....................         _output_power = (val+ 18);
27A8:  MOVLW  12
27AA:  ADDWF  xE2,W
27AC:  MOVWF  xE6
....................     }
....................     //# Set power amplifiers and output power as computed above.
....................     set(_pa_0_on,pa_0_on);
27AE:  MOVFF  1E3,210
27B2:  MOVFF  F8,213
27B6:  MOVFF  F7,212
27BA:  MOVFF  F6,211
27BE:  MOVLB  0
27C0:  RCALL  20D2
....................     set(_pa_1_on,pa_1_on);
27C2:  MOVFF  1E4,210
27C6:  MOVFF  FB,213
27CA:  MOVFF  FA,212
27CE:  MOVFF  F9,211
27D2:  RCALL  20D2
....................     set(_pa_2_on,pa_2_on);
27D4:  MOVFF  1E5,210
27D8:  MOVFF  FE,213
27DC:  MOVFF  FD,212
27E0:  MOVFF  FC,211
27E4:  RCALL  20D2
....................     set(_output_power,output_power);
27E6:  MOVFF  1E6,210
27EA:  MOVFF  101,213
27EE:  MOVFF  100,212
27F2:  MOVFF  FF,211
27F6:  RCALL  20D2
....................     _tx_power = val;
27F8:  MOVFF  1E2,13B
27FC:  GOTO   2AFA (RETURN)
.................... }
.................... float rssi_get(){
....................     // ""The received strength indicator (in dBm).
....................     // May be inaccuate if not read immediatey. last_rssi contains the value read immediately
....................     // receipt of the last packet.
....................     // """
....................     // # Read RSSI register and convert to value using formula in datasheet.
....................     rssi = -((float)spi_read_u8(_REG_RSSI_VALUE)) / 2.0;
*
2F1C:  MOVLW  24
2F1E:  MOVLB  2
2F20:  MOVWF  x55
2F22:  MOVLB  0
2F24:  CALL   192C
2F28:  MOVLB  2
2F2A:  CLRF   x15
2F2C:  MOVFF  01,214
2F30:  MOVLB  0
2F32:  RCALL  2CBE
2F34:  MOVFF  00,1EA
2F38:  MOVF   01,W
2F3A:  XORLW  80
2F3C:  MOVLB  1
2F3E:  MOVWF  xEB
2F40:  MOVFF  02,1EC
2F44:  MOVFF  03,1ED
2F48:  MOVFF  03,1F1
2F4C:  MOVFF  02,1F0
2F50:  MOVWF  xEF
2F52:  MOVFF  00,1EE
2F56:  CLRF   xF5
2F58:  CLRF   xF4
2F5A:  CLRF   xF3
2F5C:  MOVLW  80
2F5E:  MOVWF  xF2
2F60:  MOVLB  0
2F62:  CALL   21F6
2F66:  MOVFF  03,14C
2F6A:  MOVFF  02,14B
2F6E:  MOVFF  01,14A
2F72:  MOVFF  00,149
....................     return rssi;
2F76:  MOVFF  149,00
2F7A:  MOVFF  14A,01
2F7E:  MOVFF  14B,02
2F82:  MOVFF  14C,03
2F86:  GOTO   3AF0 (RETURN)
.................... }
.................... float bitrate_get(){
....................     //         """The modulation bitrate in bits/second (or chip rate if Manchester encoding is enabled).
....................     // Can be a value from ~489 to 32mbit/s, but see the datasheet for the exact supported
....................     // values.
....................     // """
....................     uint8_t msb = spi_read_u8(_REG_BITRATE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_BITRATE_LSB);
....................     bitrate = _FXOSC / ((msb << 8) | lsb);
....................     return bitrate;
.................... }
.................... void bitrate_set(float val){
*
2608:  MOVLB  1
260A:  CLRF   xF1
260C:  MOVLW  24
260E:  MOVWF  xF0
2610:  MOVLW  74
2612:  MOVWF  xEF
2614:  MOVLW  97
2616:  MOVWF  xEE
2618:  MOVFF  1E5,1F5
261C:  MOVFF  1E4,1F4
2620:  MOVFF  1E3,1F3
2624:  MOVFF  1E2,1F2
2628:  MOVLB  0
262A:  RCALL  21F6
262C:  MOVFF  03,1ED
2630:  MOVFF  02,1EC
2634:  MOVFF  01,1EB
2638:  MOVFF  00,1EA
263C:  BCF    FD8.1
263E:  MOVFF  03,219
2642:  MOVFF  02,218
2646:  MOVFF  01,217
264A:  MOVFF  00,216
264E:  MOVLB  2
2650:  CLRF   x1D
2652:  CLRF   x1C
2654:  CLRF   x1B
2656:  MOVLW  7E
2658:  MOVWF  x1A
265A:  MOVLB  0
265C:  RCALL  2354
265E:  MOVFF  03,1ED
2662:  MOVFF  02,1EC
2666:  MOVFF  01,1EB
266A:  MOVFF  00,1EA
266E:  RCALL  25CC
2670:  MOVFF  01,1E6
2674:  MOVLB  1
2676:  CLRF   xE7
2678:  CLRF   xE8
267A:  CLRF   xE9
....................     //TODO: assert (_FXOSC / 65535) <= val <= 32000000.0
....................     //# Round up to the next closest bit-rate value with addition of 0.5.
....................     uint32_t _bitrate = (int)((_FXOSC/val)+0.5) & 0xFFF;
....................     spi_write_u8(_REG_BITRATE_MSB, _bitrate >> 8);
267C:  CLRF   xEE
267E:  MOVLW  03
2680:  MOVLB  2
2682:  MOVWF  x51
2684:  MOVFF  1E7,252
2688:  MOVLB  0
268A:  CALL   1DD6
....................     spi_write_u8(_REG_BITRATE_LSB, _bitrate & 0xFF);
268E:  MOVLB  1
2690:  CLRF   xEB
2692:  CLRF   xEC
2694:  CLRF   xED
2696:  MOVLW  04
2698:  MOVLB  2
269A:  MOVWF  x51
269C:  MOVFF  1E6,252
26A0:  MOVLB  0
26A2:  CALL   1DD6
26A6:  GOTO   2A0C (RETURN)
.................... }
.................... float frequency_deviation_get(){
....................     //"""The frequency deviation in Hertz."""
....................     uint8_t msb = spi_read_u8(_REG_FDEV_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_FDEV_LSB);
....................     frequency_deviation = _FSTEP * ((msb << 8) | lsb);
....................     return frequency_deviation;
.................... }
.................... void frequency_deviation_set(float val){
26AA:  MOVFF  1E5,1F1
26AE:  MOVFF  1E4,1F0
26B2:  MOVFF  1E3,1EF
26B6:  MOVFF  1E2,1EE
26BA:  MOVLB  1
26BC:  CLRF   xF5
26BE:  MOVLW  24
26C0:  MOVWF  xF4
26C2:  MOVLW  74
26C4:  MOVWF  xF3
26C6:  MOVLW  84
26C8:  MOVWF  xF2
26CA:  MOVLB  0
26CC:  RCALL  21F6
26CE:  MOVFF  03,1ED
26D2:  MOVFF  02,1EC
26D6:  MOVFF  01,1EB
26DA:  MOVFF  00,1EA
26DE:  BCF    FD8.1
26E0:  MOVFF  03,219
26E4:  MOVFF  02,218
26E8:  MOVFF  01,217
26EC:  MOVFF  00,216
26F0:  MOVLB  2
26F2:  CLRF   x1D
26F4:  CLRF   x1C
26F6:  CLRF   x1B
26F8:  MOVLW  7E
26FA:  MOVWF  x1A
26FC:  MOVLB  0
26FE:  RCALL  2354
2700:  MOVFF  03,1ED
2704:  MOVFF  02,1EC
2708:  MOVFF  01,1EB
270C:  MOVFF  00,1EA
2710:  RCALL  25CC
2712:  MOVFF  01,1E6
2716:  MOVLB  1
2718:  CLRF   xE7
271A:  CLRF   xE8
271C:  CLRF   xE9
....................     //TODO: assert 0 <= val <= (_FSTEP * 16383)  # fdev is a 14-bit unsigned value
....................     // # Round up to the next closest integer value with addition of 0.5.
....................     uint32_t fdev = (int)((val / _FSTEP) + 0.5) & 0x3FFF;
....................     spi_write_u8(_REG_FDEV_MSB, fdev >> 8);
271E:  CLRF   xEE
2720:  MOVLW  05
2722:  MOVLB  2
2724:  MOVWF  x51
2726:  MOVFF  1E7,252
272A:  MOVLB  0
272C:  CALL   1DD6
....................     spi_write_u8(_REG_FDEV_LSB, fdev & 0xFF);
2730:  MOVLB  1
2732:  CLRF   xEB
2734:  CLRF   xEC
2736:  CLRF   xED
2738:  MOVLW  06
273A:  MOVLB  2
273C:  MOVWF  x51
273E:  MOVFF  1E6,252
2742:  MOVLB  0
2744:  CALL   1DD6
2748:  GOTO   2A20 (RETURN)
.................... }
.................... bool packet_sent(){
....................     //Transmit status
....................     return (spi_read_u8(_REG_IRQ_FLAGS2) & 0x8) >> 3;
*
36B2:  MOVLW  28
36B4:  MOVLB  2
36B6:  MOVWF  x55
36B8:  MOVLB  0
36BA:  CALL   192C
36BE:  MOVF   01,W
36C0:  ANDLW  08
36C2:  MOVWF  00
36C4:  RRCF   00,F
36C6:  RRCF   00,F
36C8:  RRCF   00,F
36CA:  MOVLW  1F
36CC:  ANDWF  00,F
36CE:  MOVFF  00,01
36D2:  GOTO   38B8 (RETURN)
.................... }
.................... bool payload_ready(){
*
2EF2:  MOVLW  28
2EF4:  MOVLB  2
2EF6:  MOVWF  x55
2EF8:  MOVLB  0
2EFA:  CALL   192C
2EFE:  MOVFF  01,1EA
....................             // """Receive status"""
....................     uint8_t p = spi_read_u8(_REG_IRQ_FLAGS2);
....................     //Serial.println(p,BIN);
....................     return (p & 0x4) >> 2;
2F02:  MOVLB  1
2F04:  MOVF   xEA,W
2F06:  ANDLW  04
2F08:  MOVWF  00
2F0A:  RRCF   00,F
2F0C:  RRCF   00,F
2F0E:  MOVLW  3F
2F10:  ANDWF  00,F
2F12:  MOVFF  00,01
2F16:  MOVLB  0
2F18:  GOTO   3A14 (RETURN)
.................... }
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256){
....................     // """Send a string of data using the transmitter.
....................     // You can only send 60 bytes at a time
....................     // (limited by chip's FIFO size and appended headers).
....................     // This appends a 4 byte header to be compatible with the RadioHead library.
....................     // The header defaults to using the initialized attributes:
....................     // (destination,node,identifier,flags)
....................     // It may be temporarily overidden via the kwargs - destination,node,identifier,flags.
....................     // Values passed via kwargs do not alter the attribute settings.
....................     // The keep_listening argument should be set to True if you want to start listening
....................     // automatically after the packet is sent. The default setting is False.
....................     // Returns: True if success or False if the send timed out.
....................     // """
....................     // # Disable pylint warning to not use length as a check for zero.
....................     // # This is a puzzling warning as the below code is clearly the most
....................     // # efficient and proper way to ensure a precondition that the provided
....................     // # buffer be within an expected range of bounds.  Disable this check.
....................     // # pylint: disable=len-as-condition
....................     // TODO: assert 0 < len(data) <= 60
....................     // # pylint: enable=len-as-condition
....................     idle(); //# Stop receiving to clear FIFO and keep it clear.
*
36D6:  CALL   20BC
....................     // # Fill the FIFO with a packet to send.
....................     // # Combine header and data to form payload
....................     uint32_t i=0;
....................     char* payload = (char*)malloc(5 + len + 1);
36DA:  MOVLB  1
36DC:  CLRF   xFE
36DE:  CLRF   xFD
36E0:  CLRF   xFC
36E2:  CLRF   xFB
36E4:  MOVLW  05
36E6:  ADDWF  xF1,W
36E8:  ADDLW  01
36EA:  MOVLB  2
36EC:  MOVWF  x10
36EE:  CLRF   x12
36F0:  MOVWF  x11
36F2:  MOVLB  0
36F4:  RCALL  332A
36F6:  MOVFF  02,200
36FA:  MOVFF  01,1FF
....................     
....................     payload[0] = 4 + len;
36FE:  MOVFF  1FF,FE9
3702:  MOVFF  200,FEA
3706:  MOVLW  04
3708:  MOVLB  1
370A:  ADDWF  xF1,W
370C:  MOVWF  FEF
....................     if (_destination >=256 )  // use attribute
370E:  MOVF   xF4,W
3710:  SUBLW  00
3712:  BC    372A
....................         payload[1] = destination;
3714:  MOVLW  01
3716:  ADDWF  xFF,W
3718:  MOVWF  FE9
371A:  MOVLW  00
371C:  MOVLB  2
371E:  ADDWFC x00,W
3720:  MOVWF  FEA
3722:  MOVFF  16C,FEF
3726:  BRA    373C
3728:  MOVLB  1
....................     else//  # use kwarg
....................         payload[1] = _destination;
372A:  MOVLW  01
372C:  ADDWF  xFF,W
372E:  MOVWF  FE9
3730:  MOVLW  00
3732:  MOVLB  2
3734:  ADDWFC x00,W
3736:  MOVWF  FEA
3738:  MOVFF  1F3,FEF
....................     if (_node >= 256) // use attribute
373C:  MOVLB  1
373E:  MOVF   xF6,W
3740:  SUBLW  00
3742:  BC    375A
....................         payload[2] = node;
3744:  MOVLW  02
3746:  ADDWF  xFF,W
3748:  MOVWF  FE9
374A:  MOVLW  00
374C:  MOVLB  2
374E:  ADDWFC x00,W
3750:  MOVWF  FEA
3752:  MOVFF  16B,FEF
3756:  BRA    376C
3758:  MOVLB  1
....................     else  //# use kwarg
....................         payload[2] = _node;
375A:  MOVLW  02
375C:  ADDWF  xFF,W
375E:  MOVWF  FE9
3760:  MOVLW  00
3762:  MOVLB  2
3764:  ADDWFC x00,W
3766:  MOVWF  FEA
3768:  MOVFF  1F5,FEF
....................     if (identifier >=256)  // use attribute
....................         payload[3] = identifier;
....................     else  //# use kwarg
....................         payload[3] = _identifier;
376C:  MOVLW  03
376E:  MOVLB  1
3770:  ADDWF  xFF,W
3772:  MOVWF  FE9
3774:  MOVLW  00
3776:  MOVLB  2
3778:  ADDWFC x00,W
377A:  MOVWF  FEA
377C:  MOVFF  1F7,FEF
....................     if (flags >=256)  // use attribute
....................         payload[4] = flags;
....................     else  // use kwarg
....................         payload[4] = _flags;
3780:  MOVLW  04
3782:  MOVLB  1
3784:  ADDWF  xFF,W
3786:  MOVWF  FE9
3788:  MOVLW  00
378A:  MOVLB  2
378C:  ADDWFC x00,W
378E:  MOVWF  FEA
3790:  MOVFF  1F9,FEF
....................     for (i=0;i<= len;i++)
3794:  MOVLB  1
3796:  CLRF   xFE
3798:  CLRF   xFD
379A:  CLRF   xFC
379C:  CLRF   xFB
379E:  MOVF   xFE,F
37A0:  BNZ   381E
37A2:  MOVF   xFD,F
37A4:  BNZ   381E
37A6:  MOVF   xFC,F
37A8:  BNZ   381E
37AA:  MOVF   xFB,W
37AC:  SUBWF  xF1,W
37AE:  BNC   381E
....................         payload[5+i] = data[i];
37B0:  MOVLW  05
37B2:  ADDWF  xFB,W
37B4:  MOVLB  2
37B6:  MOVWF  x10
37B8:  MOVLW  00
37BA:  MOVLB  1
37BC:  ADDWFC xFC,W
37BE:  MOVLB  2
37C0:  MOVWF  x11
37C2:  MOVLW  00
37C4:  MOVLB  1
37C6:  ADDWFC xFD,W
37C8:  MOVLB  2
37CA:  MOVWF  x12
37CC:  MOVLW  00
37CE:  MOVLB  1
37D0:  ADDWFC xFE,W
37D2:  MOVLB  2
37D4:  MOVWF  x13
37D6:  MOVLB  1
37D8:  MOVF   xFF,W
37DA:  MOVLB  2
37DC:  ADDWF  x10,W
37DE:  MOVWF  01
37E0:  MOVF   x00,W
37E2:  ADDWFC x11,W
37E4:  MOVWF  03
37E6:  MOVFF  01,214
37EA:  MOVWF  x15
37EC:  MOVLB  1
37EE:  MOVF   xEF,W
37F0:  ADDWF  xFB,W
37F2:  MOVWF  FE9
37F4:  MOVF   xF0,W
37F6:  ADDWFC xFC,W
37F8:  MOVWF  FEA
37FA:  MOVFF  FEF,216
37FE:  MOVFF  03,FEA
3802:  MOVFF  01,FE9
3806:  MOVFF  216,FEF
380A:  MOVLW  01
380C:  MOVLB  1
380E:  ADDWF  xFB,F
3810:  BTFSC  FD8.0
3812:  INCF   xFC,F
3814:  BTFSC  FD8.2
3816:  INCF   xFD,F
3818:  BTFSC  FD8.2
381A:  INCF   xFE,F
381C:  BRA    379E
....................        
....................     // # Write payload to transmit fifo
....................     spi_write_from(_REG_FIFO, payload,5+len);
381E:  MOVLW  05
3820:  ADDWF  xF1,W
3822:  MOVLB  2
3824:  MOVWF  x10
3826:  CLRF   x53
3828:  MOVFF  200,255
382C:  MOVFF  1FF,254
3830:  MOVWF  x56
3832:  MOVLB  0
3834:  CALL   1D78
....................     print((char*)"Payload: ",2);
3838:  MOVLW  02
383A:  MOVWF  FEA
383C:  MOVLW  01
383E:  MOVWF  FE9
3840:  MOVLW  0A
3842:  MOVWF  01
3844:  CLRF   FF7
3846:  MOVLW  00
3848:  CALL   0360
384C:  TBLRD*-
384E:  TBLRD*+
3850:  MOVFF  FF5,FEE
3854:  DECFSZ 01,F
3856:  BRA    384E
3858:  MOVLW  02
385A:  MOVLB  2
385C:  MOVWF  x56
385E:  MOVLW  01
3860:  MOVWF  x55
3862:  MOVLW  02
3864:  MOVWF  x57
3866:  MOVLB  0
3868:  CALL   1D68
....................     println(payload+5,2);
386C:  MOVLW  05
386E:  MOVLB  1
3870:  ADDWF  xFF,W
3872:  MOVLB  2
3874:  MOVWF  x10
3876:  MOVLW  00
3878:  ADDWFC x00,W
387A:  MOVWF  x11
387C:  MOVWF  x56
387E:  MOVFF  210,255
3882:  MOVLW  02
3884:  MOVWF  x57
3886:  MOVLB  0
3888:  CALL   1CF6
....................     // Serial.println((char)spi_read_u8(_REG_FIFO));              
.................... 
....................     free(payload);
388C:  MOVFF  200,211
3890:  MOVFF  1FF,210
3894:  RCALL  3606
....................     // # Turn on transmit mode to send out the packet.       
....................     transmit();
3896:  BRA    3680
....................    
....................     // # Wait for packet sent interrupt with explicit polling (not ideal but
....................     // # best that can be done right now without interrupts).
....................     
....................     float start = timeSec();
....................     bool timed_out = false;
3898:  CALL   2DEA
389C:  MOVFF  03,20E
38A0:  MOVFF  02,20D
38A4:  MOVFF  01,20C
38A8:  MOVFF  00,20B
38AC:  MOVLB  2
38AE:  BCF    x0F.0
....................     while (!timed_out && !packet_sent()){
38B0:  BTFSC  x0F.0
38B2:  BRA    395C
38B4:  MOVLB  0
38B6:  BRA    36B2
38B8:  MOVF   01,F
38BA:  BTFSC  FD8.2
38BC:  BRA    38C2
38BE:  MOVLB  2
38C0:  BRA    395C
38C2:  CLRF   19
38C4:  BTFSC  FF2.7
38C6:  BSF    19.7
38C8:  BCF    FF2.7
....................     usb_task();
38CA:  CALL   1586
38CE:  BTFSC  19.7
38D0:  BSF    FF2.7
....................         if ((timeSec() - start) >= xmit_timeout)
38D2:  CALL   2DEA
38D6:  MOVFF  03,213
38DA:  MOVFF  02,212
38DE:  MOVFF  01,211
38E2:  MOVFF  00,210
38E6:  MOVFF  FEA,215
38EA:  MOVFF  FE9,214
38EE:  BSF    FD8.1
38F0:  MOVFF  03,219
38F4:  MOVFF  02,218
38F8:  MOVFF  01,217
38FC:  MOVFF  00,216
3900:  MOVFF  20E,21D
3904:  MOVFF  20D,21C
3908:  MOVFF  20C,21B
390C:  MOVFF  20B,21A
3910:  CALL   2354
3914:  MOVFF  215,FEA
3918:  MOVFF  214,FE9
391C:  MOVFF  03,213
3920:  MOVFF  02,212
3924:  MOVFF  01,211
3928:  MOVFF  00,210
392C:  MOVFF  15C,219
3930:  MOVFF  15B,218
3934:  MOVFF  15A,217
3938:  MOVFF  159,216
393C:  MOVFF  03,21D
3940:  MOVFF  02,21C
3944:  MOVFF  01,21B
3948:  MOVFF  00,21A
394C:  CALL   2C12
3950:  BC    3954
3952:  BNZ   3958
....................             timed_out = true;
3954:  MOVLB  2
3956:  BSF    x0F.0
3958:  MOVLB  2
395A:  BRA    38B0
....................     }
....................     // # Listen again if requested.
....................     if (keep_listening)
395C:  MOVLB  1
395E:  MOVF   xF2,F
3960:  BZ    396C
....................         listen();
3962:  MOVLB  0
3964:  CALL   2C8C
3968:  BRA    3972
396A:  MOVLB  1
....................     else  //# Enter idle mode to stop receiving other packets.
....................   
....................         idle();
396C:  MOVLB  0
396E:  CALL   20BC
....................     return !timed_out;
3972:  MOVLW  00
3974:  MOVLB  2
3976:  BTFSS  x0F.0
3978:  MOVLW  01
397A:  MOVWF  01
397C:  MOVLB  0
397E:  GOTO   3DB4 (RETURN)
.................... }
.................... bool send_with_ack(uint8_t* data,uint8_t len){
....................     // Reliable Datagram mode:
....................     // Send a packet with data and wait for an ACK response.
....................     // The packet header is automatically generated.
....................     // If enabled, the packet transmission will be retried on failure
....................     int retries_remaining = 0;
....................     bool got_ack = false;
....................     uint8_t* ack_packet;
....................     if (ack_retries)retries_remaining = ack_retries;
....................     else retries_remaining=1;
....................     sequence_number = (sequence_number+1) & 0xFF;
....................     while (!got_ack && retries_remaining){
....................         identifier = sequence_number;
....................         send(data,len,true);
....................         // Don't look for ACK from Broadcast message
....................         if (destination == _RH_BROADCAST_ADDRESS)got_ack = true;
....................         else{
....................             ack_packet = receive(true,false,ack_wait,true);
....................             if(ack_packet != NULL){
....................                 if (ack_packet[4] & _RH_FLAGS_ACK){
....................                     //Check id:
....................                     if (ack_packet[3] == identifier){
....................                         got_ack = true;
....................                         break;
....................                     }
....................                 }
....................             }
....................             
....................         }
....................         //# pause before next retry -- random delay
....................         if (!got_ack){
....................             sleep_ms(ack_wait * (1.5));
....................         }
....................         retries_remaining -= 1;
....................         //# set retry flag in packet header
....................         flags |= _RH_FLAGS_RETRY;
....................     }
....................     flags = 0;  //# clear flags
....................     return got_ack;
.................... }
.................... //IMPORTANTE: La funcion es igual a la de adafruit, excepto porque retorna un array donde el primer valor es la longitud del array
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false){
3982:  MOVLB  1
3984:  BCF    xC0.0
3986:  CLRF   xC1
3988:  CLRF   xC2
398A:  CLRF   xC4
398C:  CLRF   xC3
398E:  CLRF   xC8
3990:  CLRF   xC7
....................     // Wait to receive a packet from the receiver. If a packet is found the payload bytes
....................     // are returned, otherwise None is returned (which indicates the timeout elapsed with no
....................     // reception).
....................     // If keep_listening is True (the default) the chip will immediately enter listening mode
....................     // after reception of a packet, otherwise it will fall back to idle mode and ignore any
....................     // future reception.
....................     // All packets must have a 4 byte header for compatibilty with the
....................     // RadioHead library.
....................     // The header consists of 4 bytes (To,From,ID,Flags). The default setting will  strip
....................     // the header before returning the packet to the caller.
....................     // If with_header is True then the 4 byte header will be returned with the packet.
....................     // The payload then begins at packet[4].
....................     // If with_ack is True, send an ACK after receipt (Reliable Datagram mode)
....................     // """
....................     bool timed_out = false;
....................     int start = 0;
....................     int i=0;
....................     uint16_t n=0;
....................     uint16_t fifo_length;
....................     //IMPORTANTE: Segun el compilador CCS, el maximo de este array es aproximadamente 350 bytes, lo que llena la RAM al 98%
....................     char* packet= NULL;
....................     char fifo_len_str [4];
....................     if (timeout == 0)timeout = receive_timeout;
3992:  MOVFF  1BE,219
3996:  MOVFF  1BD,218
399A:  MOVFF  1BC,217
399E:  MOVFF  1BB,216
39A2:  MOVLB  2
39A4:  CLRF   x1D
39A6:  CLRF   x1C
39A8:  CLRF   x1B
39AA:  CLRF   x1A
39AC:  MOVLB  0
39AE:  CALL   2C12
39B2:  BNZ   39C4
39B4:  MOVFF  158,1BE
39B8:  MOVFF  157,1BD
39BC:  MOVFF  156,1BC
39C0:  MOVFF  155,1BB
....................     if (timeout!=0){
39C4:  MOVFF  1BE,219
39C8:  MOVFF  1BD,218
39CC:  MOVFF  1BC,217
39D0:  MOVFF  1BB,216
39D4:  MOVLB  2
39D6:  CLRF   x1D
39D8:  CLRF   x1C
39DA:  CLRF   x1B
39DC:  CLRF   x1A
39DE:  MOVLB  0
39E0:  CALL   2C12
39E4:  BTFSC  FD8.2
39E6:  BRA    3AE8
....................         //readAllRegs();
....................         //while(1){}
....................         listen();
39E8:  CALL   2C8C
....................         start = timeSec();
39EC:  CALL   2DEA
39F0:  MOVFF  03,1ED
39F4:  MOVFF  02,1EC
39F8:  MOVFF  01,1EB
39FC:  MOVFF  00,1EA
3A00:  CALL   25CC
3A04:  MOVFF  01,1C1
....................         while (!timed_out && !payload_ready()){
3A08:  MOVLB  1
3A0A:  BTFSC  xC0.0
3A0C:  BRA    3AEA
3A0E:  MOVLB  0
3A10:  GOTO   2EF2
3A14:  MOVF   01,F
3A16:  BTFSC  FD8.2
3A18:  BRA    3A1E
3A1A:  MOVLB  1
3A1C:  BRA    3AEA
3A1E:  CLRF   19
3A20:  BTFSC  FF2.7
3A22:  BSF    19.7
3A24:  BCF    FF2.7
....................         usb_task();
3A26:  CALL   1586
3A2A:  BTFSC  19.7
3A2C:  BSF    FF2.7
....................         delay_ms(1);
3A2E:  MOVLW  01
3A30:  MOVLB  2
3A32:  MOVWF  x51
3A34:  MOVLB  0
3A36:  CALL   18FA
....................         n+=1;
3A3A:  MOVLW  01
3A3C:  MOVLB  1
3A3E:  ADDWF  xC3,F
3A40:  MOVLW  00
3A42:  ADDWFC xC4,F
....................             //delay(20);
....................             if (n >= (1000*xmit_timeout)){
3A44:  MOVLB  2
3A46:  CLRF   x1B
3A48:  CLRF   x1A
3A4A:  MOVLW  7A
3A4C:  MOVWF  x19
3A4E:  MOVLW  88
3A50:  MOVWF  x18
3A52:  MOVFF  15C,21F
3A56:  MOVFF  15B,21E
3A5A:  MOVFF  15A,21D
3A5E:  MOVFF  159,21C
3A62:  MOVLB  0
3A64:  CALL   2CF4
3A68:  MOVFF  03,1ED
3A6C:  MOVFF  02,1EC
3A70:  MOVFF  01,1EB
3A74:  MOVFF  00,1EA
3A78:  MOVFF  1C4,215
3A7C:  MOVFF  1C3,214
3A80:  CALL   2CBE
3A84:  MOVFF  1ED,219
3A88:  MOVFF  1EC,218
3A8C:  MOVFF  1EB,217
3A90:  MOVFF  1EA,216
3A94:  MOVFF  03,21D
3A98:  MOVFF  02,21C
3A9C:  MOVFF  01,21B
3AA0:  MOVFF  00,21A
3AA4:  CALL   2C12
3AA8:  BC    3AAC
3AAA:  BNZ   3AE6
....................                 println((char*)"Timed out",3);
3AAC:  MOVLW  01
3AAE:  MOVWF  FEA
3AB0:  MOVLW  CD
3AB2:  MOVWF  FE9
3AB4:  MOVLW  0A
3AB6:  MOVWF  01
3AB8:  CLRF   FF7
3ABA:  MOVLW  00
3ABC:  CALL   037A
3AC0:  TBLRD*-
3AC2:  TBLRD*+
3AC4:  MOVFF  FF5,FEE
3AC8:  DECFSZ 01,F
3ACA:  BRA    3AC2
3ACC:  MOVLW  01
3ACE:  MOVLB  2
3AD0:  MOVWF  x56
3AD2:  MOVLW  CD
3AD4:  MOVWF  x55
3AD6:  MOVLW  03
3AD8:  MOVWF  x57
3ADA:  MOVLB  0
3ADC:  CALL   1CF6
....................                 timed_out = true;
3AE0:  MOVLB  1
3AE2:  BSF    xC0.0
3AE4:  MOVLB  0
....................                 }
3AE6:  BRA    3A08
3AE8:  MOVLB  1
....................         }
....................     }
....................    
....................     last_rssi = rssi_get();
3AEA:  MOVLB  0
3AEC:  GOTO   2F1C
3AF0:  MOVFF  03,150
3AF4:  MOVFF  02,14F
3AF8:  MOVFF  01,14E
3AFC:  MOVFF  00,14D
....................     print((char*)"\nSignal Strength: ",2);
3B00:  MOVLW  01
3B02:  MOVWF  FEA
3B04:  MOVLW  D7
3B06:  MOVWF  FE9
3B08:  MOVLW  13
3B0A:  MOVWF  01
3B0C:  CLRF   FF7
3B0E:  MOVLW  00
3B10:  CALL   0394
3B14:  TBLRD*-
3B16:  TBLRD*+
3B18:  MOVFF  FF5,FEE
3B1C:  DECFSZ 01,F
3B1E:  BRA    3B16
3B20:  MOVLW  01
3B22:  MOVLB  2
3B24:  MOVWF  x56
3B26:  MOVLW  D7
3B28:  MOVWF  x55
3B2A:  MOVLW  02
3B2C:  MOVWF  x57
3B2E:  MOVLB  0
3B30:  CALL   1D68
....................     sprintf(str,"%f",last_rssi);
3B34:  CLRF   xDD
3B36:  MOVLW  C5
3B38:  MOVWF  xDC
3B3A:  MOVLW  89
3B3C:  MOVWF  FE9
3B3E:  MOVFF  150,1ED
3B42:  MOVFF  14F,1EC
3B46:  MOVFF  14E,1EB
3B4A:  MOVFF  14D,1EA
3B4E:  MOVLW  02
3B50:  MOVLB  1
3B52:  MOVWF  xEE
3B54:  MOVLB  0
3B56:  GOTO   3098
....................     println(str,2);
3B5A:  MOVLB  2
3B5C:  CLRF   x56
3B5E:  MOVLW  C5
3B60:  MOVWF  x55
3B62:  MOVLW  02
3B64:  MOVWF  x57
3B66:  MOVLB  0
3B68:  CALL   1CF6
....................     // Enter idle mode to stop receiving other packets.
....................     idle();
3B6C:  CALL   20BC
....................      
....................     if (!timed_out){
3B70:  MOVLB  1
3B72:  BTFSC  xC0.0
3B74:  BRA    3EA4
....................         fifo_length = spi_read_u8(_REG_FIFO);
3B76:  MOVLB  2
3B78:  CLRF   x55
3B7A:  MOVLB  0
3B7C:  CALL   192C
3B80:  MOVLB  1
3B82:  CLRF   xC6
3B84:  MOVFF  01,1C5
....................         //fifo_length = packet_length;
....................         print((char*)"FIFO LEN: ",3);
3B88:  MOVLW  01
3B8A:  MOVWF  FEA
3B8C:  MOVLW  D7
3B8E:  MOVWF  FE9
3B90:  MOVLW  0B
3B92:  MOVWF  01
3B94:  CLRF   FF7
3B96:  MOVLW  00
3B98:  MOVLB  0
3B9A:  CALL   03B8
3B9E:  TBLRD*-
3BA0:  TBLRD*+
3BA2:  MOVFF  FF5,FEE
3BA6:  DECFSZ 01,F
3BA8:  BRA    3BA0
3BAA:  MOVLW  01
3BAC:  MOVLB  2
3BAE:  MOVWF  x56
3BB0:  MOVLW  D7
3BB2:  MOVWF  x55
3BB4:  MOVLW  03
3BB6:  MOVWF  x57
3BB8:  MOVLB  0
3BBA:  CALL   1D68
....................         sprintf(fifo_len_str,"%lu",fifo_length);
3BBE:  MOVLW  01
3BC0:  MOVWF  xDD
3BC2:  MOVLW  C9
3BC4:  MOVWF  xDC
3BC6:  MOVLW  10
3BC8:  MOVWF  FE9
3BCA:  MOVFF  1C6,26B
3BCE:  MOVFF  1C5,26A
3BD2:  CALL   1AB8
....................         println(fifo_len_str,3);
3BD6:  MOVLW  01
3BD8:  MOVLB  2
3BDA:  MOVWF  x56
3BDC:  MOVLW  C9
3BDE:  MOVWF  x55
3BE0:  MOVLW  03
3BE2:  MOVWF  x57
3BE4:  MOVLB  0
3BE6:  CALL   1CF6
....................         //  # Handle if the received packet is too small to include the 4 byte
....................         // # RadioHead header and at least one byte of data --reject this packet and ignore it.
....................         if (fifo_length > 0){
3BEA:  MOVLB  1
3BEC:  MOVF   xC5,F
3BEE:  BNZ   3BF4
3BF0:  MOVF   xC6,F
3BF2:  BZ    3C6C
....................             packet = (uint8_t*)malloc(fifo_length+2);
3BF4:  MOVLW  02
3BF6:  ADDWF  xC5,W
3BF8:  MOVWF  xEA
3BFA:  MOVLW  00
3BFC:  ADDWFC xC6,W
3BFE:  MOVWF  xEB
3C00:  MOVFF  FE8,212
3C04:  MOVFF  1EA,211
3C08:  MOVLB  0
3C0A:  CALL   332A
3C0E:  MOVFF  02,1C8
3C12:  MOVFF  01,1C7
....................             packet[0] = fifo_length;
3C16:  MOVLB  1
3C18:  MOVFF  1C7,FE9
3C1C:  MOVFF  1C8,FEA
3C20:  MOVFF  1C5,FEF
....................             packet[fifo_length+1] = '\0';
3C24:  MOVLW  01
3C26:  ADDWF  xC5,W
3C28:  MOVWF  xEA
3C2A:  MOVLW  00
3C2C:  ADDWFC xC6,W
3C2E:  MOVWF  xEB
3C30:  MOVF   xC7,W
3C32:  ADDWF  xEA,W
3C34:  MOVWF  FE9
3C36:  MOVF   xC8,W
3C38:  ADDWFC xEB,W
3C3A:  MOVWF  FEA
3C3C:  CLRF   FEF
....................             spi_read_into(_REG_FIFO,packet+1,fifo_length);
3C3E:  MOVLW  01
3C40:  ADDWF  xC7,W
3C42:  MOVWF  xEA
3C44:  MOVLW  00
3C46:  ADDWFC xC8,W
3C48:  MOVWF  xEB
3C4A:  CLRF   19
3C4C:  BTFSC  FF2.7
3C4E:  BSF    19.7
3C50:  BCF    FF2.7
3C52:  MOVLB  2
3C54:  CLRF   x8D
3C56:  MOVWF  x8F
3C58:  MOVFF  1EA,28E
3C5C:  MOVFF  1C5,290
3C60:  MOVLB  0
3C62:  CALL   172C
3C66:  BTFSC  19.7
3C68:  BSF    FF2.7
3C6A:  MOVLB  1
....................             //print(packet);
....................         }
....................         if (fifo_length < 5){
3C6C:  MOVF   xC6,F
3C6E:  BNZ   3C7C
3C70:  MOVF   xC5,W
3C72:  SUBLW  04
3C74:  BNC   3C7C
....................             packet = NULL;
3C76:  CLRF   xC8
3C78:  CLRF   xC7
....................         }
3C7A:  BRA    3EA4
....................         else{
....................             if (node != _RH_BROADCAST_ADDRESS && packet[1] != _RH_BROADCAST_ADDRESS && packet[1] != node){
3C7C:  INCFSZ x6B,W
3C7E:  BRA    3C82
3C80:  BRA    3CBA
3C82:  MOVLW  01
3C84:  ADDWF  xC7,W
3C86:  MOVWF  FE9
3C88:  MOVLW  00
3C8A:  ADDWFC xC8,W
3C8C:  MOVWF  FEA
3C8E:  INCFSZ FEF,W
3C90:  BRA    3C94
3C92:  BRA    3CBA
3C94:  MOVLW  01
3C96:  ADDWF  xC7,W
3C98:  MOVWF  FE9
3C9A:  MOVLW  00
3C9C:  ADDWFC xC8,W
3C9E:  MOVWF  FEA
3CA0:  MOVF   x6B,W
3CA2:  SUBWF  FEF,W
3CA4:  BZ    3CBA
....................                 free(packet);
3CA6:  MOVFF  1C8,211
3CAA:  MOVFF  1C7,210
3CAE:  MOVLB  0
3CB0:  RCALL  3606
....................                 packet = NULL;
3CB2:  MOVLB  1
3CB4:  CLRF   xC8
3CB6:  CLRF   xC7
....................             }
3CB8:  BRA    3E3E
....................             //# send ACK unless this was an ACK or a broadcast
....................             else if (with_ack && (packet[4]&_RH_FLAGS_ACK)==0 && packet[1] != _RH_BROADCAST_ADDRESS){
3CBA:  MOVF   xBA,F
3CBC:  BTFSC  FD8.2
3CBE:  BRA    3E3E
3CC0:  MOVLW  04
3CC2:  ADDWF  xC7,W
3CC4:  MOVWF  FE9
3CC6:  MOVLW  00
3CC8:  ADDWFC xC8,W
3CCA:  MOVWF  FEA
3CCC:  MOVF   FEF,W
3CCE:  ANDLW  80
3CD0:  BTFSS  FD8.2
3CD2:  BRA    3E3E
3CD4:  MOVLW  01
3CD6:  ADDWF  xC7,W
3CD8:  MOVWF  FE9
3CDA:  MOVLW  00
3CDC:  ADDWFC xC8,W
3CDE:  MOVWF  FEA
3CE0:  INCFSZ FEF,W
3CE2:  BRA    3CE6
3CE4:  BRA    3E3E
....................                 if (ack_delay != 0)sleep_ms((int)(ack_delay/1000));
3CE6:  MOVFF  161,219
3CEA:  MOVFF  160,218
3CEE:  MOVFF  15F,217
3CF2:  MOVFF  15E,216
3CF6:  MOVLB  2
3CF8:  CLRF   x1D
3CFA:  CLRF   x1C
3CFC:  CLRF   x1B
3CFE:  CLRF   x1A
3D00:  MOVLB  0
3D02:  CALL   2C12
3D06:  BZ    3D4C
3D08:  MOVFF  161,1F1
3D0C:  MOVFF  160,1F0
3D10:  MOVFF  15F,1EF
3D14:  MOVFF  15E,1EE
3D18:  MOVLB  1
3D1A:  CLRF   xF5
3D1C:  CLRF   xF4
3D1E:  MOVLW  7A
3D20:  MOVWF  xF3
3D22:  MOVLW  88
3D24:  MOVWF  xF2
3D26:  MOVLB  0
3D28:  CALL   21F6
3D2C:  MOVFF  03,1ED
3D30:  MOVFF  02,1EC
3D34:  MOVFF  01,1EB
3D38:  MOVFF  00,1EA
3D3C:  CALL   25CC
3D40:  MOVFF  01,1EA
3D44:  MOVFF  01,1EB
3D48:  CALL   1924
....................                 //# send ACK packet to sender (data is b'!')
....................                 send((char*)"!",false,packet[2],packet[1],packet[3],packet[4]|_RH_FLAGS_ACK);
3D4C:  MOVLW  21
3D4E:  MOVLB  1
3D50:  MOVWF  xD7
3D52:  CLRF   xD8
3D54:  MOVLW  02
3D56:  ADDWF  xC7,W
3D58:  MOVWF  FE9
3D5A:  MOVLW  00
3D5C:  ADDWFC xC8,W
3D5E:  MOVWF  FEA
3D60:  MOVFF  FEF,1F2
3D64:  MOVLW  01
3D66:  ADDWF  xC7,W
3D68:  MOVWF  FE9
3D6A:  MOVLW  00
3D6C:  ADDWFC xC8,W
3D6E:  MOVWF  FEA
3D70:  MOVFF  FEF,1F3
3D74:  MOVLW  03
3D76:  ADDWF  xC7,W
3D78:  MOVWF  FE9
3D7A:  MOVLW  00
3D7C:  ADDWFC xC8,W
3D7E:  MOVWF  FEA
3D80:  MOVFF  FEF,1F5
3D84:  MOVLW  04
3D86:  ADDWF  xC7,W
3D88:  MOVWF  FE9
3D8A:  MOVLW  00
3D8C:  ADDWFC xC8,W
3D8E:  MOVWF  FEA
3D90:  MOVF   FEF,W
3D92:  IORLW  80
3D94:  MOVWF  xEE
3D96:  MOVLW  01
3D98:  MOVWF  xF0
3D9A:  MOVLW  D7
3D9C:  MOVWF  xEF
3D9E:  CLRF   xF1
3DA0:  CLRF   xF4
3DA2:  CLRF   xF6
3DA4:  CLRF   xF8
3DA6:  MOVFF  1EE,1F7
3DAA:  MOVLW  01
3DAC:  MOVWF  xFA
3DAE:  CLRF   xF9
3DB0:  MOVLB  0
3DB2:  BRA    36D6
....................                 // # reject Retries if we have seen this idetifier from this source before
....................                 if (seen_ids[packet[2]] == packet[3] && packet[4]&_RH_FLAGS_RETRY){
3DB4:  MOVLW  02
3DB6:  MOVLB  1
3DB8:  ADDWF  xC7,W
3DBA:  MOVWF  FE9
3DBC:  MOVLW  00
3DBE:  ADDWFC xC8,W
3DC0:  MOVWF  FEA
3DC2:  CLRF   03
3DC4:  MOVF   FEF,W
3DC6:  ADDLW  63
3DC8:  MOVWF  FE9
3DCA:  MOVLW  01
3DCC:  ADDWFC 03,W
3DCE:  MOVWF  FEA
3DD0:  MOVFF  FEF,1EA
3DD4:  MOVLW  03
3DD6:  ADDWF  xC7,W
3DD8:  MOVWF  FE9
3DDA:  MOVLW  00
3DDC:  ADDWFC xC8,W
3DDE:  MOVWF  FEA
3DE0:  MOVF   FEF,W
3DE2:  SUBWF  xEA,W
3DE4:  BNZ   3E0A
3DE6:  MOVLW  04
3DE8:  ADDWF  xC7,W
3DEA:  MOVWF  FE9
3DEC:  MOVLW  00
3DEE:  ADDWFC xC8,W
3DF0:  MOVWF  FEA
3DF2:  BTFSS  FEF.6
3DF4:  BRA    3E0A
....................                     free(packet);
3DF6:  MOVFF  1C8,211
3DFA:  MOVFF  1C7,210
3DFE:  MOVLB  0
3E00:  RCALL  3606
....................                     packet= NULL;
3E02:  MOVLB  1
3E04:  CLRF   xC8
3E06:  CLRF   xC7
....................                 }
3E08:  BRA    3E3E
....................                 else{ //Save identifier from source
....................                     seen_ids[packet[2]] = packet[3];
3E0A:  MOVLW  02
3E0C:  ADDWF  xC7,W
3E0E:  MOVWF  FE9
3E10:  MOVLW  00
3E12:  ADDWFC xC8,W
3E14:  MOVWF  FEA
3E16:  CLRF   03
3E18:  MOVF   FEF,W
3E1A:  ADDLW  63
3E1C:  MOVWF  01
3E1E:  MOVLW  01
3E20:  ADDWFC 03,F
3E22:  MOVLW  03
3E24:  ADDWF  xC7,W
3E26:  MOVWF  FE9
3E28:  MOVLW  00
3E2A:  ADDWFC xC8,W
3E2C:  MOVWF  FEA
3E2E:  MOVFF  FEF,1EC
3E32:  MOVFF  03,FEA
3E36:  MOVFF  01,FE9
3E3A:  MOVFF  1EC,FEF
....................                 }
....................             }
....................             if (!with_header && packet != NULL){
3E3E:  MOVF   xBF,F
3E40:  BNZ   3EA4
3E42:  MOVF   xC7,F
3E44:  BNZ   3E4A
3E46:  MOVF   xC8,F
3E48:  BZ    3EA4
....................                  //skip the header if not wanted
....................                  for (i=1; i< fifo_length-4;i++){
3E4A:  MOVLW  01
3E4C:  MOVWF  xC2
3E4E:  MOVLW  04
3E50:  SUBWF  xC5,W
3E52:  MOVWF  00
3E54:  MOVLW  00
3E56:  SUBWFB xC6,W
3E58:  MOVWF  03
3E5A:  MOVFF  00,01
3E5E:  MOVF   03,F
3E60:  BNZ   3E68
3E62:  MOVF   01,W
3E64:  SUBWF  xC2,W
3E66:  BC    3E96
....................                     packet[i] = packet[i+4];
3E68:  MOVF   xC2,W
3E6A:  ADDWF  xC7,W
3E6C:  MOVWF  01
3E6E:  MOVLW  00
3E70:  ADDWFC xC8,W
3E72:  MOVWF  03
3E74:  MOVLW  04
3E76:  ADDWF  xC2,W
3E78:  ADDWF  xC7,W
3E7A:  MOVWF  FE9
3E7C:  MOVLW  00
3E7E:  ADDWFC xC8,W
3E80:  MOVWF  FEA
3E82:  MOVFF  FEF,1EC
3E86:  MOVFF  03,FEA
3E8A:  MOVFF  01,FE9
3E8E:  MOVFF  1EC,FEF
3E92:  INCF   xC2,F
3E94:  BRA    3E4E
....................                  }
....................                  //reduce indicated length
....................                  packet[0] -= 4;
3E96:  MOVFF  1C7,FE9
3E9A:  MOVFF  1C8,FEA
3E9E:  MOVLW  04
3EA0:  SUBWF  FEF,W
3EA2:  MOVWF  FEF
....................             }
....................         }
....................     }
....................     if (keep_listening)listen();
3EA4:  MOVF   xB9,F
3EA6:  BZ    3EB0
3EA8:  MOVLB  0
3EAA:  CALL   2C8C
3EAE:  BRA    3EB6
....................     else idle();
3EB0:  MOVLB  0
3EB2:  CALL   20BC
....................     return (char*)packet;
3EB6:  MOVLB  1
3EB8:  MOVFF  1C7,01
3EBC:  MOVFF  1C8,02
3EC0:  MOVLB  0
3EC2:  GOTO   4468 (RETURN)
.................... }
.................... 
.................... //IMPORTANTE: La funcion es igual a la de adafruit, excepto porque retorna un array donde el primer valor es la longitud del array
.................... void receiveFast(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false){
....................     // Wait to receive a packet from the receiver. If a packet is found the payload bytes
....................     // are returned, otherwise None is returned (which indicates the timeout elapsed with no
....................     // reception).
....................     // If keep_listening is True (the default) the chip will immediately enter listening mode
....................     // after reception of a packet, otherwise it will fall back to idle mode and ignore any
....................     // future reception.
....................     // All packets must have a 4 byte header for compatibilty with the
....................     // RadioHead library.
....................     // The header consists of 4 bytes (To,From,ID,Flags). The default setting will  strip
....................     // the header before returning the packet to the caller.
....................     // If with_header is True then the 4 byte header will be returned with the packet.
....................     // The payload then begins at packet[4].
....................     // If with_ack is True, send an ACK after receipt (Reliable Datagram mode)
....................     // """
....................     bool timed_out = false;
....................     bool doneReading = false;
....................     uint8_t i=0;
....................     uint16_t n=0;
.................... 
....................     uint8_t B;
....................     //IMPORTANTE: Segun el compilador CCS, el maximo de este array es aproximadamente 350 bytes, lo que llena la RAM al 98%
....................     // char* packet= NULL;
....................     if (timeout == 0)timeout = receive_timeout;
....................     if (timeout!=0){
....................         //readAllRegs();
....................         //while(1){}
....................         listen();
....................         
....................         while (!timed_out && !digitalRead(DIO_2) /*&& !payload_ready()*/){
....................         usb_task();
....................         delay_ms(100);
....................         n+=100;
....................             //delay(20);
....................             if (n >= (1000*xmit_timeout)){
....................                 println((char*)"Timed out",2);
....................                 timed_out = true;
....................                 }
....................         }
....................     }
....................    
....................     last_rssi = rssi_get();
....................     // Enter idle mode to stop receiving other packets.
....................     // idle();
....................     if(!timed_out){
....................          //Comenzar a leer 
....................          spiBegin();
....................          //Write address
....................          spi_write(_REG_FIFO & 0x7F); //Strip MSB byte to read
....................          delay_us(100);  // Tiempo para que el esclavo responda
....................          
....................          while(!doneReading){
....................             //Start reading bytes from the FIFO when FifoNotEmpty or FifoThreshold becomes set.
....................             if (digitalRead(DIO_2) && !digitalRead(DIO_0)){//FIFO not empty and payload not ready
....................                B = spi_read(0xFF);
....................                printch(B,1);
....................             }
....................             //Suspend reading from the FIFO if FifoNotEmpty clears before all bytes of the message have been read
....................             else if (!digitalRead(DIO_2) && !digitalRead(DIO_0)){//FIFO empty and payload not ready
....................                spiEnd();
....................                //Comenzar a leer 
....................                spiBegin();
....................                //Write address
....................                spi_write(_REG_FIFO & 0x7F); //Strip MSB byte to read
....................                delay_us(100);  // Tiempo para que el esclavo responda
....................             }
....................             //Continue to step 1 until PayloadReady or CrcOk fires
....................             else if (digitalRead(DIO_0)){//PayloadReady
....................                doneReading = true;
....................                
....................                //Read all remaining bytes from the FIFO either in Rx or Sleep/Standby mode
....................                
....................                spiEnd();
....................                //Comenzar a leer 
....................                spiBegin();
....................                //Write address
....................                spi_write(_REG_FIFO & 0x7F); //Strip MSB byte to read
....................                delay_us(100);  // Tiempo para que el esclavo responda
....................                while (!digitalRead(DIO_2)) {//FIFO Not Empty
....................                   B = spi_read(0xFF);
....................                   printch(B,1);
....................                }
....................                spiEnd();
.................... 
....................             }
....................          }
....................     }
....................     if (keep_listening)listen();
....................     else idle();
.................... }
.................... 
.................... #include <plain_rfm.h>
.................... #include <barerfm69_const.h>
.................... /*
....................  *  Copyright (c) 2014, Ivor Wanders
....................  *  MIT License, see the LICENSE.md file in the root folder.
.................... */
.................... 
....................  
.................... #define RFM69_FIFO           0x00
.................... #define RFM69_OPMODE         0x01
.................... #define RFM69_DATA_MODUL     0x02
.................... 
.................... #define RFM69_BITRATE_MSB    0x03
.................... #define RFM69_BITRATE_LSB    0x04
.................... 
.................... #define RFM69_FDEV_MSB       0x05
.................... #define RFM69_FDEV_LSB       0x06
.................... 
.................... #define RFM69_FRF_MSB        0x07
.................... #define RFM69_FRF_MID        0x08
.................... #define RFM69_FRF_LSB        0x09
.................... 
.................... #define RFM69_OSC1           0x0A
.................... #define RFM69_AFC_CTRL       0x0B
.................... 
.................... #define RFM69_LISTEN1        0x0D
.................... #define RFM69_LISTEN2        0x0E
.................... #define RFM69_LISTEN3        0x0F
.................... 
.................... #define RFM69_VERSION        0x10
.................... 
.................... #define RFM69_PA_LEVEL       0x11
.................... #define RFM69_PA_RAMP        0x12
.................... 
.................... #define RFM69_OCP            0x13
.................... 
.................... #define RFM69_LNA            0x18
.................... #define RFM69_RX_BW          0x19
.................... #define RFM69_AFC_BW         0x1A
.................... 
.................... #define RFM69_OOK_PEAK       0x1B
.................... #define RFM69_OOK_AVG        0x1C
.................... #define RFM69_OOK_FIX        0x1D
.................... 
.................... #define RFM69_AFC_FEI        0x1E
.................... #define RFM69_AFC_MSB        0x1F
.................... #define RFM69_AFC_LSB        0x20
.................... 
.................... #define RFM69_FEI_MSB        0x21
.................... #define RFM69_FEI_LSB        0x22
.................... 
.................... #define RFM69_RSSI_CONFIG   0x23
.................... #define RFM69_RSSI_VALUE    0x24
.................... 
.................... #define RFM69_DIO_MAPPING1  0x25
.................... #define RFM69_DIO_MAPPING2  0x26
.................... 
.................... #define RFM69_IRQ_FLAGS1    0x27
.................... #define RFM69_IRQ_FLAGS2    0x28
.................... 
.................... #define RFM69_RSSI_THRESH   0x29
.................... 
.................... 
.................... #define RFM69_RX_TIMEOUT1   0x2A
.................... #define RFM69_RX_TIMEOUT2   0x2B
.................... 
.................... #define RFM69_PREAMBLE_MSB  0x2C
.................... #define RFM69_PREAMBLE_LSB  0x2D
.................... 
.................... #define RFM69_SYNC_CONFIG   0x2E
.................... 
.................... #define RFM69_SYNC_VALUE1   0x2F
.................... #define RFM69_SYNC_VALUE2   0x30
.................... #define RFM69_SYNC_VALUE3   0x31
.................... #define RFM69_SYNC_VALUE4   0x32
.................... #define RFM69_SYNC_VALUE5   0x33
.................... #define RFM69_SYNC_VALUE6   0x34
.................... #define RFM69_SYNC_VALUE7   0x35
.................... #define RFM69_SYNC_VALUE8   0x36
.................... 
.................... #define RFM69_PACKET_CONFIG1 0x37
.................... #define RFM69_PAYLOAD_LENGTH 0x38
.................... 
.................... #define RFM69_NODE_ADRESS         0x39
.................... #define RFM69_BROADCAST_ADRESS    0x3A
.................... 
.................... #define RFM69_AUTO_MODES        0x3B
.................... 
.................... #define RFM69_FIFO_THRESH       0x3C
.................... 
.................... #define RFM69_PACKET_CONFIG2    0x3D
.................... 
.................... #define RFM69_AES_KEY1      0x3E
.................... #define RFM69_AES_KEY2      0x3F
.................... #define RFM69_AES_KEY3      0x40
.................... #define RFM69_AES_KEY4      0x41
.................... #define RFM69_AES_KEY5      0x42
.................... #define RFM69_AES_KEY6      0x43
.................... #define RFM69_AES_KEY7      0x44
.................... #define RFM69_AES_KEY8      0x45
.................... #define RFM69_AES_KEY9      0x46
.................... #define RFM69_AES_KEY10     0x47
.................... #define RFM69_AES_KEY11     0x48
.................... #define RFM69_AES_KEY12     0x49
.................... #define RFM69_AES_KEY13     0x4A
.................... #define RFM69_AES_KEY14     0x4B
.................... #define RFM69_AES_KEY15     0x4C
.................... #define RFM69_AES_KEY16     0x4D
.................... 
.................... #define RFM69_TEMP1     0x4E
.................... #define RFM69_TEMP2     0x4F
.................... 
.................... #define RFM69_TEST_LNA  0x58
.................... #define RFM69_TEST_PA1  0x5A
.................... #define RFM69_TEST_PA2  0x5C
.................... #define RFM69_TEST_DAGC 0x6F
.................... #define RFM69_TEST_AFC  0x71
.................... 
.................... #define RFM69_WRITE_REG_MASK 0x80
.................... #define RFM69_READ_REG_MASK 0x7F
.................... 
.................... 
.................... // defines for various bitshifts and constants, per register.
.................... 
.................... 
.................... #define RFM69_MODE_SLEEP        0b00000
.................... #define RFM69_MODE_STANDBY      0b00100
.................... #define RFM69_MODE_FREQ_SYNTH   0b01000
.................... #define RFM69_MODE_TRANSMITTER  0b01100
.................... #define RFM69_MODE_RECEIVER     0b10000
.................... 
.................... 
.................... #define RFM69_MODE_SEQUENCER_OFF (1<<7)
.................... #define RFM69_MODE_SEQUENCER_ON 0
.................... #define RFM69_MODE_LISTEN_ON (1<<6)
.................... #define RFM69_MODE_LISTEN_OFF 0
.................... #define RFM69_MODE_LISTEN_ABORT (1<<5)
.................... 
.................... 
.................... #define RFM69_DATAMODUL_PROCESSING_PACKET 0b00
.................... #define RFM69_DATAMODUL_PROCESSING_CONT_SYNCRHONISER 0b10
.................... #define RFM69_DATAMODUL_PROCESSING_CONT 0b11
.................... #define RFM69_DATAMODUL_OOK true
.................... #define RFM69_DATAMODUL_FSK false
.................... 
.................... #define RFM69_DATAMODUL_SHAPING_GFSK_NONE 0
.................... #define RFM69_DATAMODUL_SHAPING_GFSK_BT_1_0 0b01
.................... #define RFM69_DATAMODUL_SHAPING_GFSK_BT_0_5 0b10
.................... #define RFM69_DATAMODUL_SHAPING_GFSK_BT_0_3 0b11
.................... 
.................... #define RFM69_DATAMODUL_SHAPING_OOK_NONE 0
.................... #define RFM69_DATAMODUL_SHAPING_OOK_FCUTOFF_BR 0b01
.................... #define RFM69_DATAMODUL_SHAPING_OOK_FCUTOFF_2BR 0b10
.................... 
.................... #define RFM69_PA_LEVEL_PA0_ON 0b10000000
.................... #define RFM69_PA_LEVEL_PA1_ON 0b01000000
.................... #define RFM69_PA_LEVEL_PA2_ON 0b00100000
.................... 
.................... #define RFM69_PA_RAMP_3400US 0b0000
.................... #define RFM69_PA_RAMP_2000US 0b0001
.................... #define RFM69_PA_RAMP_1000US 0b0010
.................... #define RFM69_PA_RAMP_500US 0b0011
.................... #define RFM69_PA_RAMP_250US 0b0100
.................... #define RFM69_PA_RAMP_125US 0b0101
.................... #define RFM69_PA_RAMP_100US 0b0110
.................... #define RFM69_PA_RAMP_62US 0b0111
.................... #define RFM69_PA_RAMP_50US 0b1000
.................... #define RFM69_PA_RAMP_40US 0b1001
.................... #define RFM69_PA_RAMP_31US 0b1010
.................... #define RFM69_PA_RAMP_25US 0b1011
.................... #define RFM69_PA_RAMP_20US 0b1100
.................... #define RFM69_PA_RAMP_15US 0b1101
.................... #define RFM69_PA_RAMP_12US 0b1110
.................... #define RFM69_PA_RAMP_10US 0b1111
.................... 
.................... #define RFM69_PACKET_CONFIG_LENGTH_FIXED 0b0
.................... #define RFM69_PACKET_CONFIG_LENGTH_VARIABLE (1<<7)
.................... 
.................... #define RFM69_PACKET_CONFIG_DC_FREE_NONE (0b00<<5)
.................... #define RFM69_PACKET_CONFIG_DC_FREE_MANCHESTER (0b01<<5)
.................... #define RFM69_PACKET_CONFIG_DC_FREE_WHITENING (0b10<<5)
.................... #define RFM69_PACKET_CONFIG_CRC_ON (1<<4)
.................... #define RFM69_PACKET_CONFIG_CRC_OFF 0
.................... #define RFM69_PACKET_CONFIG_CRC_FAIL_KEEP (1<<3)
.................... #define RFM69_PACKET_CONFIG_CRC_FAIL_DISCARD 0
.................... #define RFM69_PACKET_CONFIG_ADDRESS_FILTER_NONE 0
.................... #define RFM69_PACKET_CONFIG_ADDRESS_FILTER_NODE (0b01<<1)
.................... #define RFM69_PACKET_CONFIG_ADDRESS_FILTER_NODE_BROADCAST (0b10<<1)
.................... 
.................... #define RFM69_THRESHOLD_CONDITION_NOT_EMPTY (1<<7)
.................... #define RFM69_THRESHOLD_CONDITION_FIFOLEVEL 0
.................... 
.................... #define RFM69_AFC_CTRL_STANDARD 0
.................... #define RFM69_AFC_CTRL_IMPROVED 1
.................... 
.................... 
.................... #define RFM69_LISTEN_RESOL_IDLE_64US (0b01<<6)
.................... #define RFM69_LISTEN_RESOL_IDLE_4_1MS (0b10<<6)
.................... #define RFM69_LISTEN_RESOL_IDLE_262MS (0b11<<6)
.................... 
.................... #define RFM69_LISTEN_RESOL_RX_64US (0b01<<4)
.................... #define RFM69_LISTEN_RESOL_RX_4_1MS (0b10<<4)
.................... #define RFM69_LISTEN_RESOL_RX_262MS (0b11<<4)
.................... #define RFM69_LISTEN_CRITERIA_RSSI  (0 << 3)
.................... #define RFM69_LISTEN_CRITERIA_RSSI_SYNC  (1 << 3)
.................... #define RFM69_LISTEN_END_STAY_RX_LISTEN_STOP (0b00 << 1)
.................... #define RFM69_LISTEN_END_RX_UNTIL_LISTEN_STOP (0b01 << 1)
.................... #define RFM69_LISTEN_END_RX_UNTIL_LISTEN_RESUME (0b10 << 1)
.................... 
.................... 
.................... #define RFM69_AUTOMODE_ENTER_NONE_AUTOMODES_OFF (0b000<<5)
.................... #define RFM69_AUTOMODE_ENTER_RISING_FIFONOTEMPTY (0b001<<5)
.................... #define RFM69_AUTOMODE_ENTER_RISING_FIFOLEVEL (0b010<<5)
.................... #define RFM69_AUTOMODE_ENTER_RISING_CRCOK (0b011<<5)
.................... #define RFM69_AUTOMODE_ENTER_RISING_PAYLOADREADY (0b100<<5)
.................... #define RFM69_AUTOMODE_ENTER_RISING_SYNCADDRESS (0b101<<5)
.................... #define RFM69_AUTOMODE_ENTER_RISING_PACKETSENT (0b110<<5)
.................... #define RFM69_AUTOMODE_ENTER_FALLING_FIFONOTEMPTY (0b111<<5)
.................... //(I.E.FIFOEMPTY) 
.................... 
.................... 
.................... #define RFM69_AUTOMODE_EXIT_NONE_AUTOMODES_OFF (0b000<<2)
.................... #define RFM69_AUTOMODE_EXIT_FALLING_FIFONOTEMPTY (0b001<<2)
.................... //(I.E._FIFOEMPTY)
.................... #define RFM69_AUTOMODE_EXIT_RISING_FIFOLEVEL_OR_TIMEOUT (0b010<<2)
.................... #define RFM69_AUTOMODE_EXIT_RISING_CRCOK_OR_TIMEOUT (0b011<<2)
.................... #define RFM69_AUTOMODE_EXIT_RISING_PAYLOADREADY_OR_TIMEOUT (0b100<<2)
.................... #define RFM69_AUTOMODE_EXIT_RISING_SYNCADDRESS_OR_TIMEOUT (0b101<<2)
.................... #define RFM69_AUTOMODE_EXIT_RISING_PACKETSENT (0b110<<2)
.................... #define RFM69_AUTOMODE_EXIT_RISING_TIMEOUT (0b111<<2)
.................... 
.................... #define RFM69_AUTOMODE_INTERMEDIATEMODE_SLEEP (0b00)
.................... #define RFM69_AUTOMODE_INTERMEDIATEMODE_STANDBY (0b01)
.................... #define RFM69_AUTOMODE_INTERMEDIATEMODE_RECEIVER (0b10)
.................... #define RFM69_AUTOMODE_INTERMEDIATEMODE_TRANSMITTER (0b11)
.................... 
.................... #define RFM69_DIO_0_MAP_SHIFT 6
.................... #define RFM69_DIO_1_MAP_SHIFT 4
.................... #define RFM69_DIO_2_MAP_SHIFT 2
.................... #define RFM69_DIO_3_MAP_SHIFT 0
.................... 
.................... #define RFM69_PACKET_DIO_0_RX_CRC_OK (0b00 << RFM69_DIO_0_MAP_SHIFT)
.................... #define RFM69_PACKET_DIO_0_RX_PAYLOAD_READY (0b01 << RFM69_DIO_0_MAP_SHIFT)
.................... #define RFM69_PACKET_DIO_0_RX_SYNC_ADDRESS (0b10 << RFM69_DIO_0_MAP_SHIFT)
.................... #define RFM69_PACKET_DIO_0_RX_RSII (0b11 << RFM69_DIO_0_MAP_SHIFT)
.................... 
.................... #define RFM69_PACKET_DIO_0_TX_PACKET_SENT (0b00 << RFM69_DIO_0_MAP_SHIFT)
.................... #define RFM69_PACKET_DIO_0_TX_TX_READY (0b01 << RFM69_DIO_0_MAP_SHIFT)
.................... #define RFM69_PACKET_DIO_0_TX_PLL (0b11 << RFM69_DIO_0_MAP_SHIFT)
.................... 
.................... #define RFM69_PACKET_DIO_1_FIFO_LEVEL (0b00 << RFM69_DIO_1_MAP_SHIFT)
.................... #define RFM69_PACKET_DIO_1_FIFO_FULL (0b01 << RFM69_DIO_1_MAP_SHIFT)
.................... #define RFM69_PACKET_DIO_1_FIFO_NOT_EMPTY (0b10 << RFM69_DIO_1_MAP_SHIFT)
.................... 
.................... #define RFM69_PACKET_DIO_2_FIFO_NOT_EMPTY (0b00 << RFM69_DIO_2_MAP_SHIFT)
.................... #define RFM69_PACKET_DIO_2_AUTOMODE (0b11 << RFM69_DIO_2_MAP_SHIFT)
.................... 
.................... #define RFM69_PACKET_DIO_3_FIFO_FULL (0b00 << RFM69_DIO_3_MAP_SHIFT)
.................... 
.................... 
.................... // the above DIO constants are not extensive!
.................... // only the ones which were deemed useful in packet mode are listed.
.................... // See page 48 of the datasheet.
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #define RFM69_IRQ1_MODEREADY (1<<7)
.................... #define RFM69_IRQ1_RXREADY (1<<6)
.................... #define RFM69_IRQ1_TXREADY (1<<5)
.................... #define RFM69_IRQ1_PLLLOCK (1<<4)
.................... #define RFM69_IRQ1_RSSI (1<<3)
.................... #define RFM69_IRQ1_TIMEOUT (1<<2)
.................... #define RFM69_IRQ1_AUTOMODE (1<<1)
.................... #define RFM69_IRQ1_SYNCADDRESSMATCH (1<< 0)
.................... 
.................... 
.................... #define RFM69_IRQ2_FIFOFULL  (1<<7)
.................... #define RFM69_IRQ2_FIFONOTEMPTY  (1<<6)
.................... #define RFM69_IRQ2_FIFOLEVEL  (1<<5)
.................... #define RFM69_IRQ2_FIFOOVERRUN  (1<<4)
.................... #define RFM69_IRQ2_PACKETSENT  (1<<3)
.................... #define RFM69_IRQ2_PAYLOADREADY  (1<< 2)
.................... #define RFM69_IRQ2_CRCOK  (1<<1)
.................... 
.................... #define RFM69_LNA_GAIN_AGC_LOOP 0b000
.................... #define RFM69_LNA_GAIN_0DB 0b001
.................... #define RFM69_LNA_GAIN_6DB 0b010
.................... #define RFM69_LNA_GAIN_12DB 0b011
.................... #define RFM69_LNA_GAIN_24DB 0b100
.................... #define RFM69_LNA_GAIN_36DB 0b101
.................... #define RFM69_LNA_GAIN_48DB 0b110
.................... #define RFM69_LNA_IMP_50OHM (0<<7)
.................... #define RFM69_LNA_IMP_200OHM (1<<7)
.................... 
.................... #define RFM69_CONTINUOUS_DAGC_NORMAL 0x00
.................... #define RFM69_CONTINUOUS_DAGC_IMPROVED_AFCLOWBETAON 0x20
.................... #define RFM69_CONTINUOUS_DAGC_IMPROVED_AFCLOWBETAOFF 0x30
.................... 
.................... 
.................... 
.................... #define RFM69_PLAIN_STATE_RECEIVING 0
.................... #define RFM69_PLAIN_STATE_SENDING 1
.................... //Globales
.................... uint8_t state = 0;
.................... uint16_t buffer_write_index = 0;
.................... uint16_t buffer_read_index = 0;
.................... uint16_t buffer_size = 0;
.................... uint8_t **packet_buffer = 0;
.................... bool use_variable_length = 0 ;
.................... bool use_addressing = 0;
....................          
....................  /*
....................             Returns IRQ1 flags, bitmask, the following bits can be set:
.................... 
.................... RFM69_IRQ1_MODEREADY
....................                 Set when the operation mode requested in Mode, is ready 
....................                     - Sleep: Entering Sleep mode
....................                     - Standby: XO is running
....................                     - FS: PLL is locked
....................                     - Rx: RSSI sampling starts
....................                     - Tx: PA ramp-up completed
....................                 Cleared when changing operating mode.
....................             RFM69_IRQ1_RXREADY
....................                 Set in Rx mode, after RSSI, AGC and AFC. Cleared when leaving
....................                 Rx.
....................             RFM69_IRQ1_TXREADY
....................                 Set in Tx mode, after PA ramp-up. Cleared when leaving Tx.
....................             RFM69_IRQ1_PLLLOCK
....................                 Set (in FS, Rx or Tx) when the PLL is locked.
....................                 Cleared when it is not.
....................             RFM69_IRQ1_RSSI
....................                 Set in Rx when the RssiValue exceeds RssiThreshold.
....................                 Cleared when leaving Rx.
....................             RFM69_IRQ1_TIMEOUT
....................                 Set when a timeout occurs (see TimeoutRxStart and
....................                 TimeoutRssiThresh) Cleared when leaving Rx or FIFO is emptied.
....................             RFM69_IRQ1_AUTOMODE
....................                 Set when entering Intermediate mode. Cleared when exiting
....................                 Intermediate mode. Please note that in Sleep mode a small delay
....................                 can be observed between AutoMode interrupt and the corresponding
....................                 enter/exit condition.
....................             RFM69_IRQ1_SYNCADDRESSMATCH
....................                 Set when Sync and Address (if enabled) are detected. Cleared
....................                 when leaving Rx or FIFO is emptied.This bit is read only in
....................                 Packet mode, rwc in Continuous mode.
.................... 
....................         */
....................  uint8_t getIRQ1Flags(){
....................     return spi_read_u8(_REG_IRQ_FLAGS1);
....................  }
....................   uint8_t getIRQ2Flags(){
....................     return spi_read_u8(_REG_IRQ_FLAGS2);
....................  }
....................  
....................         /*
....................             The enter and exit conditions cannot be used independently of each
....................             other i.e. both should be enabled at the same time.
.................... 
....................             The initial and the final state is the one configured in Mode in RegOpMode.
....................             The initial & final states can be different by configuring the modes
....................             register while the module is in intermediate mode.
....................             The pictorial description of the auto modes is shown below.
.................... 
....................             Initial state defined       Intermediate State  Final state defined
....................             By Mode in RegOpMode       -------------------- By Mode in RegOpMode
....................                                        |                  |
....................                                        |                  |
....................             ----------------------------                  ----------
....................                         EnterCondition ^    ExitCondition ^
.................... 
....................             Where Enter condition is one of:
....................                 RFM69_AUTOMODE_ENTER_NONE_AUTOMODES_OFF
....................                 RFM69_AUTOMODE_ENTER_RISING_FIFONOTEMPTY
....................                 RFM69_AUTOMODE_ENTER_RISING_FIFOLEVEL
....................                 RFM69_AUTOMODE_ENTER_RISING_CRCOK
....................                 RFM69_AUTOMODE_ENTER_RISING_PAYLOADREADY
....................                 RFM69_AUTOMODE_ENTER_RISING_SYNCADDRESS
....................                 RFM69_AUTOMODE_ENTER_RISING_PACKETSENT
....................                 RFM69_AUTOMODE_ENTER_FALLING_FIFONOTEMPTY (I.E. FIFOEMPTY)
.................... 
....................             Where Exit condition is one of:
....................                 RFM69_AUTOMODE_EXIT_NONE_AUTOMODES_OFF
....................                 RFM69_AUTOMODE_EXIT_FALLING_FIFONOTEMPTY (I.E._FIFOEMPTY)
....................                 RFM69_AUTOMODE_EXIT_RISING_FIFOLEVEL_OR_TIMEOUT
....................                 RFM69_AUTOMODE_EXIT_RISING_CRCOK_OR_TIMEOUT
....................                 RFM69_AUTOMODE_EXIT_RISING_PAYLOADREADY_OR_TIMEOUT
....................                 RFM69_AUTOMODE_EXIT_RISING_SYNCADDRESS_OR_TIMEOUT
....................                 RFM69_AUTOMODE_EXIT_RISING_PACKETSENT
....................                 RFM69_AUTOMODE_EXIT_RISING_TIMEOUT
.................... 
....................             And Intermediate state:
....................                 RFM69_AUTOMODE_INTERMEDIATEMODE_SLEEP
....................                 RFM69_AUTOMODE_INTERMEDIATEMODE_STANDBY
....................                 RFM69_AUTOMODE_INTERMEDIATEMODE_RECEIVER
....................                 RFM69_AUTOMODE_INTERMEDIATEMODE_TRANSMITTER
.................... 
....................         */
....................         
....................   
....................  void setAutoMode(uint8_t enter, uint8_t exit, uint8_t intermediate_mode){
....................    spi_write_u8(RFM69_AUTO_MODES, enter+exit+intermediate_mode);
....................    }
.................... void setMode(uint8_t mode){
.................... spi_write_u8(RFM69_OPMODE,mode);
.................... }
.................... 
.................... 
.................... //Funcion que setea los parametros del RFM para recibir
.................... void recibe(){
....................     /*
....................         Setup the automode such that we go into standby mode when a packet is
....................         available in the FIFO. Automatically go back into receiving mode when it
....................         is read.
.................... 
....................         See the datasheet, p42 for information.
....................     */
.................... 
....................     setAutoMode(RFM69_AUTOMODE_ENTER_RISING_PAYLOADREADY, RFM69_AUTOMODE_EXIT_FALLING_FIFONOTEMPTY, RFM69_AUTOMODE_INTERMEDIATEMODE_STANDBY);
....................     // one disadvantage of this is that the PayloadReady Interrupt is not asserted.
....................     // however, the intermediate mode can be detected easily.
.................... 
....................     // p22 - Turn off the high power boost registers in receiving mode.
....................     if (tx_power_get()>13)
....................     {
....................         set(0,pa_1_on);
....................         set(0,pa_2_on);
....................     }
.................... 
....................     // set the mode to receiver.
....................     setMode(RFM69_MODE_SEQUENCER_ON+RFM69_MODE_RECEIVER);
....................     
....................     state = RFM69_PLAIN_STATE_RECEIVING;
.................... }
.................... 
.................... 
.................... 
.................... //Funcion para leer el FIFO
.................... void readPacket(){
.................... //!    // read it into the buffer.
.................... //!    if (this->use_variable_length) {
.................... //!        this->readVariableFIFO(this->packet_buffer[this->buffer_write_index], this->packet_length + this->use_variable_length);
.................... //!    } else{
.................... //!     
.................... //!    }
....................    //spi_read_into(_REG_FIFO,packet_buffer[buffer_write_index],packet_length);
.................... 
....................     spi_read_into(_REG_FIFO,packet_buffer[0],packet_length);
....................     for (uint16_t i=0;i<packet_length;i++){
....................       printch(packet_buffer[i],1);
....................       }
....................    // increase the write index.
....................    buffer_write_index = (buffer_write_index+1) % buffer_size;
.................... }
.................... 
.................... 
.................... 
.................... //Funcion de interrupcion del DIO2
.................... void poll(){
....................     println((char*)"Poll", 3);
....................     uint8_t flags1;
....................     // uint8_t flags2;
.................... 
....................     flags1 = getIRQ1Flags();
....................     // flags2 = this->getIRQ2Flags();
....................     
.................... 
....................     // debug_rfm("Flags1: "); debug_rfmln(flags1);
....................     switch (state){
....................         case (RFM69_PLAIN_STATE_RECEIVING):
....................             if (flags1 & RFM69_IRQ1_AUTOMODE){
....................                 println((char*)"Automode in receiving!",2);
....................                 print((char*)"Flags1: ",2); println(flags1,2);
....................                 print((char*)"Flags2: ",2); println(getIRQ2Flags(),2);
.................... 
....................                 readPacket();
....................             }
....................             break;
.................... 
....................         case (RFM69_PLAIN_STATE_SENDING):
....................             if ((flags1 & RFM69_IRQ1_AUTOMODE)==0){ // no longer in automode
....................                 print((char*)"Flags1: ",2); println(flags1,2);
....................                 print((char*)"Flags2: ",2); println(getIRQ2Flags(),2);
.................... 
....................                 recibe(); // we're done sending, set the receiving mode.
....................             }
....................             break;
....................         default:
....................             // this should not happen... 
....................             println((char*)"In undefined state!",2);
....................     };
.................... }
.................... 
.................... 
.................... 
.................... bool available(){
....................     // return whether the indices do not align. If they do not align, read 
....................     // index has to catch up.
....................     // Overflows are not handled.
....................     // TODO: handle buffer overflows.
....................     return (buffer_read_index != buffer_write_index);
.................... }
.................... 
.................... 
.................... uint8_t read(void* buffer){
....................     println((char*)"Read",2);
.................... 
....................     // no data to return.
....................     if (buffer_read_index == buffer_write_index){
....................         return 0;
....................     }
.................... 
....................     // read packet length.
....................     uint8_t length = packet_length;
....................     uint8_t payload_start = 0;
....................     if (use_variable_length){
.................... 
....................         // if variable length is used, read length from the first byte.
....................         length = packet_buffer[buffer_read_index][0];
....................         // debug_rfm("Length from packet: ");debug_rfm(length);
....................         // prevent buffer overflow, take shortest length of Rx length and packet length.
....................         length = (length > packet_length) ? packet_length : length;
....................         // debug_rfm("maxed length: ");debug_rfm(length);
.................... 
....................         // payload starts one byte later.
....................         payload_start++;
....................     }
.................... 
....................     // copy the message into the buffer.
....................     memcpy(buffer, &(packet_buffer[buffer_read_index][payload_start]), length);
....................     
....................     // increase the read index.
....................     buffer_read_index = (buffer_read_index+1) % buffer_size;
.................... 
....................     // return the length of the packet written.
....................     return length;
.................... }
.................... 
.................... 
.................... 
.................... void setBufferSize(uint8_t size){
....................     buffer_size = size;
.................... }
.................... 
.................... void setPayloadLength(uint8_t length){
.................... spi_write_u8(RFM69_PAYLOAD_LENGTH, length);
.................... }
.................... void setRawPacketLength(){
.................... //!    // allocate the Tx Buffer
.................... //!    this->tx_buffer = (uint8_t*) malloc(this->packet_length + this->use_variable_length);
....................     // set the length in the hardware.
....................     setPayloadLength(packet_length); // packet length byte is not included in length count. So NOT +1
.................... 
....................     
.................... 
.................... }
.................... 
.................... void setPacketLength(uint8_t length){
....................     packet_length = length + use_addressing;
.................... 
....................     // allocate the packet buffer, first allocate a list of pointers
....................     packet_buffer = (uint8_t**) malloc(buffer_size * sizeof(uint8_t*));
....................     for (uint8_t i = 0; i < buffer_size; i++){
....................         // then allocate the packet length per buffer slot.
....................         packet_buffer[i] = (uint8_t*) malloc(packet_length + use_variable_length);
....................     }
.................... 
....................     // this is mostly a separate function such that it can be overloaded.
....................     setRawPacketLength();
.................... 
.................... }
.................... 
.................... 
.................... 
.................... 
.................... #ZERO_RAM
.................... 
.................... 
.................... //Define la interrupcin por recepcin Serial
.................... static void RDA_isr(void)
.................... {  
*
1428:  GOTO   14AC (RETURN)
....................  
.................... }
.................... 
.................... 
.................... /* TODO: Use usb_cdc_putc() to transmit data to the USB
.................... virtual COM port. Use usb_cdc_kbhit() and usb_cdc_getc() to
.................... receive data from the USB virtual COM port. usb_enumerated()
.................... can be used to see if connected to a host and ready to
.................... communicate. */
.................... 
.................... /*
.................... Conexiones
.................... MOSI: RX (23)
.................... MISO: B0 (00) (SDI)
.................... CLK: B1 (01) (SCK)
.................... CS: A5 (13)
.................... Reset: E0
.................... */
.................... 
.................... uint8_t* buff;
.................... uint16_t buff_len = 256;
.................... uint16_t buff_i = 0;
.................... void poll2(){
....................  printch('?',2);
*
16BA:  MOVLW  3F
16BC:  MOVLB  2
16BE:  MOVWF  x8D
16C0:  MOVLW  02
16C2:  MOVWF  x8E
16C4:  MOVLB  0
16C6:  RCALL  1632
....................  //println((char*)"FIFO Not Empty", 2);
....................  if (using_spi)spiEnd();
16C8:  BTFSC  xB5.1
16CA:  RCALL  1672
....................     readBytes =0;
16CC:  CLRF   xDB
....................     //Select
....................     spiBegin();
16CE:  RCALL  1684
....................     //Write address
....................     spi_write(_REG_FIFO& 0x7F);
16D0:  MOVF   FC9,W
16D2:  CLRF   FC9
16D4:  RRCF   FC7,W
16D6:  BNC   16D4
....................     delay_us(100);  // Tiempo para que el esclavo responda
16D8:  MOVLW  64
16DA:  MOVLB  2
16DC:  MOVWF  x91
16DE:  MOVLB  0
16E0:  RCALL  1694
....................     for (readBytes=0;readBytes<packet_length;readBytes++){
16E2:  CLRF   xDB
16E4:  MOVF   xC3,W
16E6:  SUBWF  xDB,W
16E8:  BC    1726
....................         buff[readBytes] = spi_read(0xFF);
16EA:  MOVF   xDB,W
16EC:  MOVLB  1
16EE:  ADDWF  x92,W
16F0:  MOVWF  FE9
16F2:  MOVLW  00
16F4:  ADDWFC x93,W
16F6:  MOVWF  FEA
16F8:  MOVF   FC9,W
16FA:  SETF   FC9
16FC:  RRCF   FC7,W
16FE:  BNC   16FC
1700:  MOVFF  FC9,FEF
....................         printch(buff[readBytes],1);
1704:  MOVLB  0
1706:  MOVF   xDB,W
1708:  MOVLB  1
170A:  ADDWF  x92,W
170C:  MOVWF  FE9
170E:  MOVLW  00
1710:  ADDWFC x93,W
1712:  MOVWF  FEA
1714:  MOVFF  FEF,28D
1718:  MOVLW  01
171A:  MOVLB  2
171C:  MOVWF  x8E
171E:  MOVLB  0
1720:  RCALL  1632
1722:  INCF   xDB,F
1724:  BRA    16E4
....................         }
....................     spiEnd();
1726:  RCALL  1672
1728:  GOTO   1864 (RETURN)
.................... 
....................  //spi_read_into(_REG_FIFO,packet_buffer[buff_i],packet_length);
....................  
.................... }
.................... void onReady(){
....................    printch('!',2);
*
177E:  MOVLW  21
1780:  MOVLB  2
1782:  MOVWF  x8D
1784:  MOVLW  02
1786:  MOVWF  x8E
1788:  MOVLB  0
178A:  RCALL  1632
....................    //println((char*)"Payload Ready", 2);
....................    if (using_spi)spiEnd();
178C:  BTFSC  xB5.1
178E:  RCALL  1672
....................    buff_i += readBytes;
1790:  MOVF   xDB,W
1792:  MOVLB  1
1794:  ADDWF  x96,F
1796:  MOVLW  00
1798:  ADDWFC x97,F
....................    spi_read_into(_REG_FIFO,packet_buffer[buff_i],packet_length);
179A:  BCF    FD8.0
179C:  RLCF   x96,W
179E:  MOVWF  02
17A0:  RLCF   x97,W
17A2:  MOVWF  03
17A4:  MOVF   02,W
17A6:  ADDWF  x90,W
17A8:  MOVWF  FE9
17AA:  MOVF   x91,W
17AC:  ADDWFC 03,W
17AE:  MOVWF  FEA
17B0:  MOVFF  FEC,28F
17B4:  MOVF   FED,F
17B6:  MOVFF  FEF,28E
17BA:  MOVLB  2
17BC:  CLRF   x8D
17BE:  MOVFF  C3,290
17C2:  MOVLB  0
17C4:  RCALL  172C
....................    buff_i += readBytes;
17C6:  MOVF   xDB,W
17C8:  MOVLB  1
17CA:  ADDWF  x96,F
17CC:  MOVLW  00
17CE:  ADDWFC x97,F
....................    for (uint16_t i=0;i<buff_i;i++)printch(packet_buffer[i],1);
17D0:  MOVLB  2
17D2:  CLRF   x8A
17D4:  CLRF   x89
17D6:  MOVF   x8A,W
17D8:  MOVLB  1
17DA:  SUBWF  x97,W
17DC:  BNC   182A
17DE:  BNZ   17F0
17E0:  MOVF   x96,W
17E2:  MOVLB  2
17E4:  SUBWF  x89,W
17E6:  BTFSS  FD8.0
17E8:  BRA    17EE
17EA:  MOVLB  1
17EC:  BRA    182A
17EE:  MOVLB  1
17F0:  BCF    FD8.0
17F2:  MOVLB  2
17F4:  RLCF   x89,W
17F6:  MOVWF  02
17F8:  RLCF   x8A,W
17FA:  MOVWF  03
17FC:  MOVF   02,W
17FE:  MOVLB  1
1800:  ADDWF  x90,W
1802:  MOVWF  FE9
1804:  MOVF   x91,W
1806:  ADDWFC 03,W
1808:  MOVWF  FEA
180A:  MOVFF  FEC,28C
180E:  MOVF   FED,F
1810:  MOVFF  FEF,28D
1814:  MOVLW  01
1816:  MOVLB  2
1818:  MOVWF  x8E
181A:  MOVLB  0
181C:  RCALL  1632
181E:  MOVLB  2
1820:  INCF   x89,F
1822:  BTFSC  FD8.2
1824:  INCF   x8A,F
1826:  BRA    17D6
1828:  MOVLB  1
....................    buff_i = 0;
182A:  CLRF   x97
182C:  CLRF   x96
182E:  MOVLB  0
1830:  GOTO   186C (RETURN)
.................... }
.................... 
.................... #INT_EXT2            //Funcion de la Interrupcion
.................... void DIO_INT()
.................... {
....................    fifoNotEmpty = digitalRead(DIO_2);
1834:  MOVLW  0C
1836:  MOVLB  2
1838:  MOVWF  x89
183A:  MOVLB  0
183C:  RCALL  152E
183E:  MOVFF  01,BF
....................    payloadReady = digitalRead(DIO_0);
1842:  MOVLW  0B
1844:  MOVLB  2
1846:  MOVWF  x89
1848:  MOVLB  0
184A:  RCALL  152E
184C:  MOVFF  01,C1
....................    fifoThresh  = digitalRead(DIO_1);
1850:  MOVLW  04
1852:  MOVLB  2
1854:  MOVWF  x89
1856:  MOVLB  0
1858:  RCALL  152E
185A:  MOVFF  01,C2
....................    if (fifoThresh) poll2();
185E:  MOVF   xC2,F
1860:  BTFSS  FD8.2
1862:  BRA    16BA
....................    if (payloadReady) onReady();
1864:  MOVF   xC1,F
1866:  BTFSC  FD8.2
1868:  BRA    186C
186A:  BRA    177E
....................    
....................    //println((char*)"DIO INT", 2);
....................    
186C:  BCF    FF0.1
186E:  GOTO   006C
.................... }
.................... 
.................... 
.................... 
.................... void main1(){
....................    uint8_t synch[] = {3,0xAA,0x2D,0xD4};
....................    int ResetPin = RF_Reset;
....................    buff = (uint8_t*)malloc(buff_len);
....................    //setOutput(INDICATOR_LED,0);
....................    //radio.init(synch,ResetPin);
....................    setup_adc_ports(NO_ANALOGS, VSS_VDD);
....................    usb_init();
....................    //Esperar un segundo antes de iniciar
....................    sleep_ms(1000);
....................    while (!checkId()){
....................    usb_task();
....................    println((char*)"Id incorrecto", 2);
....................    }
....................    //setOutput(INDICATOR_LED,1);
....................    
....................    init(synch,ResetPin);
....................    println((char*)"INIT DONE", 3);
....................    set(0x00,dio_2_mapping);
....................    set(0x00,dio_1_mapping);
....................    
....................    //Interrupciones
.................... //!   enable_interrupts(GLOBAL);    //Habilita todas las interrupciones
.................... //!   enable_interrupts(INT_EXT2);   //Habilita la interrupcin externa en el pin B2
.................... //!   //Interrucion en el cambio de Low to High
.................... //!   ext_int_edge(L_TO_H); 
....................   
....................   listen();
....................   int notEmpty=0;
....................   set(1,packet_format);  // 1 - Variable length, 0 - Fixed Length
....................   set(64,payload_length);
....................   packet_length = get(payload_length);
.................... 
....................    while(TRUE)
....................    {
....................    notEmpty = (spi_read_u8(_REG_IRQ_FLAGS2)&0b01000000) >> 6;
....................    payloadReady = payload_ready();
....................    
....................    if (payloadReady){
....................    idle();
....................    //println((char*)"DATOS",3);
....................    packet_length = spi_read_u8(_REG_FIFO);
....................    print((char*)"FIFO LEN: ",2);
....................    sprintf(str,"%u",packet_length);
....................    println(str,2);
....................    
....................        readBytes =0;
....................        //Select
....................        spiBegin();
....................        //Write address
....................        spi_write(_REG_FIFO& 0x7F);
....................        delay_us(100);  // Tiempo para que el esclavo responda
....................        //packet_length = spi_read(0xFF);
.................... 
....................        for (readBytes=0;readBytes<packet_length;readBytes++){
....................         buff[readBytes] = spi_read(0xFF);
....................         //if (buff[readBytes]==0)break;
....................         printch(buff[readBytes],1);
....................         }
....................     spiEnd();
....................     listen();
....................    }
....................    }
.................... }
.................... 
.................... void main()
*
3EC6:  CLRF   FF8
3EC8:  BCF    FD0.7
3ECA:  BSF    07.7
3ECC:  MOVLW  FE
3ECE:  MOVWF  00
3ED0:  MOVLW  04
3ED2:  MOVWF  01
3ED4:  MOVLW  02
3ED6:  MOVWF  FE9
3ED8:  MOVLW  00
3EDA:  MOVWF  FEA
3EDC:  CLRF   FEE
3EDE:  DECFSZ 00,F
3EE0:  BRA    3EDC
3EE2:  DECFSZ 01,F
3EE4:  BRA    3EDC
3EE6:  MOVLW  DD
3EE8:  MOVWF  00
3EEA:  MOVLW  03
3EEC:  MOVWF  01
3EEE:  MOVLW  23
3EF0:  MOVWF  FE9
3EF2:  MOVLW  05
3EF4:  MOVWF  FEA
3EF6:  CLRF   FEE
3EF8:  DECFSZ 00,F
3EFA:  BRA    3EF6
3EFC:  DECFSZ 01,F
3EFE:  BRA    3EF6
3F00:  CLRF   xBF
3F02:  SETF   xC0
3F04:  CLRF   xC1
3F06:  CLRF   xC2
3F08:  MOVLW  40
3F0A:  MOVWF  xC3
3F0C:  BCF    xB5.1
3F0E:  CLRF   xC4
3F10:  MOVLW  01
3F12:  MOVWF  xD4
3F14:  BCF    FC6.5
3F16:  MOVLW  40
3F18:  MOVWF  FC7
3F1A:  MOVLW  22
3F1C:  MOVWF  FC6
3F1E:  BCF    F94.7
3F20:  BSF    F93.0
3F22:  BSF    F89.5
3F24:  BCF    F92.5
3F26:  BCF    F93.1
3F28:  CLRF   xDD
3F2A:  CLRF   xDC
3F2C:  MOVLW  02
3F2E:  MOVLB  1
3F30:  MOVWF  xB9
3F32:  MOVLW  05
3F34:  MOVWF  xBA
3F36:  MOVLW  02
3F38:  MOVWF  xBB
3F3A:  MOVLB  0
3F3C:  CALL   1872
3F40:  MOVFF  03,E0
3F44:  MOVFF  02,DF
3F48:  MOVFF  01,DE
3F4C:  MOVLW  02
3F4E:  MOVLB  1
3F50:  MOVWF  xB9
3F52:  MOVLW  03
3F54:  MOVWF  xBA
3F56:  MOVLW  02
3F58:  MOVWF  xBB
3F5A:  MOVLB  0
3F5C:  CALL   1872
3F60:  MOVFF  03,E3
3F64:  MOVFF  02,E2
3F68:  MOVFF  01,E1
3F6C:  MOVLW  02
3F6E:  MOVLB  1
3F70:  MOVWF  xB9
3F72:  CLRF   xBA
3F74:  MOVWF  xBB
3F76:  MOVLB  0
3F78:  CALL   1872
3F7C:  MOVFF  03,E6
3F80:  MOVFF  02,E5
3F84:  MOVFF  01,E4
3F88:  MOVLW  4E
3F8A:  MOVLB  1
3F8C:  MOVWF  xB9
3F8E:  MOVLW  03
3F90:  MOVWF  xBA
3F92:  MOVLW  01
3F94:  MOVWF  xBB
3F96:  MOVLB  0
3F98:  CALL   1872
3F9C:  MOVFF  03,E9
3FA0:  MOVFF  02,E8
3FA4:  MOVFF  01,E7
3FA8:  MOVLW  4E
3FAA:  MOVLB  1
3FAC:  MOVWF  xB9
3FAE:  MOVLW  02
3FB0:  MOVWF  xBA
3FB2:  MOVLW  01
3FB4:  MOVWF  xBB
3FB6:  MOVLB  0
3FB8:  CALL   1872
3FBC:  MOVFF  03,EC
3FC0:  MOVFF  02,EB
3FC4:  MOVFF  01,EA
3FC8:  MOVLW  2E
3FCA:  MOVLB  1
3FCC:  MOVWF  xB9
3FCE:  MOVLW  07
3FD0:  MOVWF  xBA
3FD2:  MOVLW  01
3FD4:  MOVWF  xBB
3FD6:  MOVLB  0
3FD8:  CALL   1872
3FDC:  MOVFF  03,EF
3FE0:  MOVFF  02,EE
3FE4:  MOVFF  01,ED
3FE8:  MOVLW  2E
3FEA:  MOVLB  1
3FEC:  MOVWF  xB9
3FEE:  MOVLW  03
3FF0:  MOVWF  xBA
3FF2:  MOVWF  xBB
3FF4:  MOVLB  0
3FF6:  CALL   1872
3FFA:  MOVFF  03,F2
3FFE:  MOVFF  02,F1
4002:  MOVFF  01,F0
4006:  MOVLW  3D
4008:  MOVLB  1
400A:  MOVWF  xB9
400C:  CLRF   xBA
400E:  MOVLW  01
4010:  MOVWF  xBB
4012:  MOVLB  0
4014:  CALL   1872
4018:  MOVFF  03,F5
401C:  MOVFF  02,F4
4020:  MOVFF  01,F3
4024:  MOVLW  11
4026:  MOVLB  1
4028:  MOVWF  xB9
402A:  MOVLW  07
402C:  MOVWF  xBA
402E:  MOVLW  01
4030:  MOVWF  xBB
4032:  MOVLB  0
4034:  CALL   1872
4038:  MOVFF  03,F8
403C:  MOVFF  02,F7
4040:  MOVFF  01,F6
4044:  MOVLW  11
4046:  MOVLB  1
4048:  MOVWF  xB9
404A:  MOVLW  06
404C:  MOVWF  xBA
404E:  MOVLW  01
4050:  MOVWF  xBB
4052:  MOVLB  0
4054:  CALL   1872
4058:  MOVFF  03,FB
405C:  MOVFF  02,FA
4060:  MOVFF  01,F9
4064:  MOVLW  11
4066:  MOVLB  1
4068:  MOVWF  xB9
406A:  MOVLW  05
406C:  MOVWF  xBA
406E:  MOVLW  01
4070:  MOVWF  xBB
4072:  MOVLB  0
4074:  CALL   1872
4078:  MOVFF  03,FE
407C:  MOVFF  02,FD
4080:  MOVFF  01,FC
4084:  MOVLW  11
4086:  MOVLB  1
4088:  MOVWF  xB9
408A:  CLRF   xBA
408C:  MOVLW  05
408E:  MOVWF  xBB
4090:  MOVLB  0
4092:  CALL   1872
4096:  MOVFF  03,101
409A:  MOVFF  02,100
409E:  MOVFF  01,FF
40A2:  MOVLW  19
40A4:  MOVLB  1
40A6:  MOVWF  xB9
40A8:  MOVLW  05
40AA:  MOVWF  xBA
40AC:  MOVLW  03
40AE:  MOVWF  xBB
40B0:  MOVLB  0
40B2:  CALL   1872
40B6:  MOVFF  03,104
40BA:  MOVFF  02,103
40BE:  MOVFF  01,102
40C2:  MOVLW  19
40C4:  MOVLB  1
40C6:  MOVWF  xB9
40C8:  MOVLW  03
40CA:  MOVWF  xBA
40CC:  MOVLW  02
40CE:  MOVWF  xBB
40D0:  MOVLB  0
40D2:  CALL   1872
40D6:  MOVFF  03,107
40DA:  MOVFF  02,106
40DE:  MOVFF  01,105
40E2:  MOVLW  19
40E4:  MOVLB  1
40E6:  MOVWF  xB9
40E8:  CLRF   xBA
40EA:  MOVLW  03
40EC:  MOVWF  xBB
40EE:  MOVLB  0
40F0:  CALL   1872
40F4:  MOVFF  03,10A
40F8:  MOVFF  02,109
40FC:  MOVFF  01,108
4100:  MOVLW  1A
4102:  MOVLB  1
4104:  MOVWF  xB9
4106:  MOVLW  05
4108:  MOVWF  xBA
410A:  MOVLW  03
410C:  MOVWF  xBB
410E:  MOVLB  0
4110:  CALL   1872
4114:  MOVFF  03,10D
4118:  MOVFF  02,10C
411C:  MOVFF  01,10B
4120:  MOVLW  1A
4122:  MOVLB  1
4124:  MOVWF  xB9
4126:  MOVLW  03
4128:  MOVWF  xBA
412A:  MOVLW  02
412C:  MOVWF  xBB
412E:  MOVLB  0
4130:  CALL   1872
4134:  MOVFF  03,110
4138:  MOVFF  02,10F
413C:  MOVFF  01,10E
4140:  MOVLW  1A
4142:  MOVLB  1
4144:  MOVWF  xB9
4146:  CLRF   xBA
4148:  MOVLW  03
414A:  MOVWF  xBB
414C:  MOVLB  0
414E:  CALL   1872
4152:  MOVFF  03,113
4156:  MOVFF  02,112
415A:  MOVFF  01,111
415E:  MOVLW  37
4160:  MOVLB  1
4162:  MOVWF  xB9
4164:  MOVLW  07
4166:  MOVWF  xBA
4168:  MOVLW  01
416A:  MOVWF  xBB
416C:  MOVLB  0
416E:  CALL   1872
4172:  MOVFF  03,116
4176:  MOVFF  02,115
417A:  MOVFF  01,114
417E:  MOVLW  37
4180:  MOVLB  1
4182:  MOVWF  xB9
4184:  MOVLW  05
4186:  MOVWF  xBA
4188:  MOVLW  02
418A:  MOVWF  xBB
418C:  MOVLB  0
418E:  CALL   1872
4192:  MOVFF  03,119
4196:  MOVFF  02,118
419A:  MOVFF  01,117
419E:  MOVLW  37
41A0:  MOVLB  1
41A2:  MOVWF  xB9
41A4:  MOVLW  04
41A6:  MOVWF  xBA
41A8:  MOVLW  01
41AA:  MOVWF  xBB
41AC:  MOVLB  0
41AE:  CALL   1872
41B2:  MOVFF  03,11C
41B6:  MOVFF  02,11B
41BA:  MOVFF  01,11A
41BE:  MOVLW  37
41C0:  MOVLB  1
41C2:  MOVWF  xB9
41C4:  MOVLW  03
41C6:  MOVWF  xBA
41C8:  MOVLW  01
41CA:  MOVWF  xBB
41CC:  MOVLB  0
41CE:  CALL   1872
41D2:  MOVFF  03,11F
41D6:  MOVFF  02,11E
41DA:  MOVFF  01,11D
41DE:  MOVLW  37
41E0:  MOVLB  1
41E2:  MOVWF  xB9
41E4:  MOVLW  01
41E6:  MOVWF  xBA
41E8:  MOVLW  02
41EA:  MOVWF  xBB
41EC:  MOVLB  0
41EE:  CALL   1872
41F2:  MOVFF  03,122
41F6:  MOVFF  02,121
41FA:  MOVFF  01,120
41FE:  MOVLW  27
4200:  MOVLB  1
4202:  MOVWF  xB9
4204:  MOVLW  07
4206:  MOVWF  xBA
4208:  MOVLW  01
420A:  MOVWF  xBB
420C:  MOVLB  0
420E:  CALL   1872
4212:  MOVFF  03,125
4216:  MOVFF  02,124
421A:  MOVFF  01,123
421E:  MOVLW  25
4220:  MOVLB  1
4222:  MOVWF  xB9
4224:  MOVLW  06
4226:  MOVWF  xBA
4228:  MOVLW  02
422A:  MOVWF  xBB
422C:  MOVLB  0
422E:  CALL   1872
4232:  MOVFF  03,128
4236:  MOVFF  02,127
423A:  MOVFF  01,126
423E:  MOVLW  25
4240:  MOVLB  1
4242:  MOVWF  xB9
4244:  MOVLW  04
4246:  MOVWF  xBA
4248:  MOVLW  02
424A:  MOVWF  xBB
424C:  MOVLB  0
424E:  CALL   1872
4252:  MOVFF  03,12B
4256:  MOVFF  02,12A
425A:  MOVFF  01,129
425E:  MOVLW  25
4260:  MOVLB  1
4262:  MOVWF  xB9
4264:  MOVLW  02
4266:  MOVWF  xBA
4268:  MOVWF  xBB
426A:  MOVLB  0
426C:  CALL   1872
4270:  MOVFF  03,12E
4274:  MOVFF  02,12D
4278:  MOVFF  01,12C
427C:  MOVLW  25
427E:  MOVLB  1
4280:  MOVWF  xB9
4282:  CLRF   xBA
4284:  MOVLW  02
4286:  MOVWF  xBB
4288:  MOVLB  0
428A:  CALL   1872
428E:  MOVFF  03,131
4292:  MOVFF  02,130
4296:  MOVFF  01,12F
429A:  MOVLW  26
429C:  MOVLB  1
429E:  MOVWF  xB9
42A0:  MOVLW  06
42A2:  MOVWF  xBA
42A4:  MOVLW  02
42A6:  MOVWF  xBB
42A8:  MOVLB  0
42AA:  CALL   1872
42AE:  MOVFF  03,134
42B2:  MOVFF  02,133
42B6:  MOVFF  01,132
42BA:  MOVLW  26
42BC:  MOVLB  1
42BE:  MOVWF  xB9
42C0:  MOVLW  04
42C2:  MOVWF  xBA
42C4:  MOVLW  02
42C6:  MOVWF  xBB
42C8:  MOVLB  0
42CA:  CALL   1872
42CE:  MOVFF  03,137
42D2:  MOVFF  02,136
42D6:  MOVFF  01,135
42DA:  MOVLW  38
42DC:  MOVLB  1
42DE:  MOVWF  xB9
42E0:  CLRF   xBA
42E2:  MOVLW  08
42E4:  MOVWF  xBB
42E6:  MOVLB  0
42E8:  CALL   1872
42EC:  MOVFF  03,13A
42F0:  MOVFF  02,139
42F4:  MOVFF  01,138
42F8:  MOVLB  1
42FA:  CLRF   x89
42FC:  CLRF   x8B
42FE:  CLRF   x8A
4300:  CLRF   x8D
4302:  CLRF   x8C
4304:  CLRF   x8F
4306:  CLRF   x8E
4308:  CLRF   x91
430A:  CLRF   x90
430C:  MOVLB  0
430E:  BCF    xB5.3
4310:  BCF    xB5.4
4312:  MOVLW  01
4314:  MOVLB  1
4316:  MOVWF  x95
4318:  CLRF   x94
431A:  CLRF   x97
431C:  CLRF   x96
431E:  MOVF   FC1,W
4320:  ANDLW  C0
4322:  IORLW  0F
4324:  MOVWF  FC1
4326:  MOVLW  07
4328:  MOVWF  FB4
432A:  MOVLW  02
432C:  MOVLB  0
432E:  MOVWF  xD6
4330:  MOVLW  AA
4332:  MOVWF  xD5
4334:  MOVLW  01
4336:  MOVLB  2
4338:  MOVWF  xAB
433A:  MOVLW  52
433C:  MOVWF  xAA
433E:  MOVLW  05
4340:  MOVWF  xAD
4342:  MOVLW  23
4344:  MOVWF  xAC
4346:  MOVLW  02
4348:  MOVLB  5
434A:  MOVWF  x24
434C:  MOVLW  D9
434E:  MOVWF  x23
4350:  CLRF   x26
4352:  CLRF   x25
4354:  MOVLB  0
4356:  CLRF   xB8
4358:  CLRF   xB9
*
436C:  MOVLW  20
436E:  MOVWF  x9C
.................... {
.................... 
....................    
.................... 
.................... /*
....................    //Timer de 8 bits
.................... //timer0 (RTCC_INTERNAL), Preescaler de 256, timer de 8 bits
.................... setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256 | RTCC_8_bit); 
.................... //el timer se va a desbordar dependiendo de la formula:
.................... //tiempo_desbordamiento =  (Valor_maximo_del_timer * (4*Preescaler))/Freq
.................... 
.................... //EJEMPLO, 
.................... //para un divisor de 64, reloj de 48 MHZ y tiempo de 1ms
.................... //Dado que el oscilador funciona a 48 Mhz, la formula es:
.................... //t = 256*4*64 / 48000000 = 1.365 ms (aprox. 1ms),
.................... //Para hacerlo mas preciso, es posible inicializar el timer a un valor mayor a 0, por lo que el desbordamiento ocurriria antes:
.................... //con un valor de inicio de 67 (contando el 0, esto es 68 pasos) (256-68 = 180), el valor da 1.0026ms
.................... 
.................... 
.................... set_rtcc(TIMER_START);
.................... //Interrupciones del timer
.................... enable_interrupts(INT_RTCC);
.................... enable_interrupts(GLOBAL);
.................... 
.................... */
....................    //RFM69 radio;
....................    //PRIMER BYTE es el tamao del array 
....................    uint8_t synch[] = {3,0xAA,0x2D,0xD4};
*
435A:  MOVLW  03
435C:  MOVLB  1
435E:  MOVWF  x98
4360:  MOVLW  AA
4362:  MOVWF  x99
4364:  MOVLW  2D
4366:  MOVWF  x9A
4368:  MOVLW  D4
436A:  MOVWF  x9B
....................    int ResetPin = RF_Reset;
....................    //setOutput(INDICATOR_LED,0);
....................    //radio.init(synch,ResetPin);
....................    
....................    setup_adc_ports(NO_ANALOGS, VSS_VDD);
*
4370:  MOVF   FC1,W
4372:  ANDLW  C0
4374:  IORLW  0F
4376:  MOVWF  FC1
....................    usb_init();
4378:  MOVLB  0
437A:  GOTO   18E0
....................    
....................    //Esperar un segundo antes de iniciar
....................    sleep_ms(1000);
437E:  MOVLW  E8
4380:  MOVLB  1
4382:  MOVWF  xEB
4384:  MOVLB  0
4386:  CALL   1924
....................    while (!checkId()){
438A:  GOTO   1CC0
438E:  MOVF   01,F
4390:  BNZ   43D8
4392:  CLRF   19
4394:  BTFSC  FF2.7
4396:  BSF    19.7
4398:  BCF    FF2.7
....................    usb_task();
439A:  CALL   1586
439E:  BTFSC  19.7
43A0:  BSF    FF2.7
....................    println((char*)"Id incorrecto", 2);
43A2:  MOVLW  01
43A4:  MOVWF  FEA
43A6:  MOVLW  9D
43A8:  MOVWF  FE9
43AA:  MOVLW  0E
43AC:  MOVWF  01
43AE:  CLRF   FF7
43B0:  MOVLW  00
43B2:  CALL   03D4
43B6:  TBLRD*-
43B8:  TBLRD*+
43BA:  MOVFF  FF5,FEE
43BE:  DECFSZ 01,F
43C0:  BRA    43B8
43C2:  MOVLW  01
43C4:  MOVLB  2
43C6:  MOVWF  x56
43C8:  MOVLW  9D
43CA:  MOVWF  x55
43CC:  MOVLW  02
43CE:  MOVWF  x57
43D0:  MOVLB  0
43D2:  CALL   1CF6
43D6:  BRA    438A
....................    }
....................    //setOutput(INDICATOR_LED,1);
....................    
....................    init(synch,ResetPin);
43D8:  MOVLW  01
43DA:  MOVLB  1
43DC:  MOVWF  xBA
43DE:  MOVLW  98
43E0:  MOVWF  xB9
43E2:  MOVFF  19C,1BB
43E6:  MOVLW  04
43E8:  MOVWF  xBC
43EA:  MOVLW  01
43EC:  MOVWF  xBD
43EE:  CLRF   xC1
43F0:  MOVLW  1E
43F2:  MOVWF  xC0
43F4:  MOVLW  84
43F6:  MOVWF  xBF
43F8:  MOVLW  80
43FA:  MOVWF  xBE
43FC:  CLRF   xC3
43FE:  CLRF   xC2
4400:  MOVLB  0
4402:  GOTO   2800
....................    println((char*)"INIT DONE", 3);
4406:  MOVLW  01
4408:  MOVWF  FEA
440A:  MOVLW  AB
440C:  MOVWF  FE9
440E:  MOVLW  0A
4410:  MOVWF  01
4412:  CLRF   FF7
4414:  MOVLW  00
4416:  CALL   03F2
441A:  TBLRD*-
441C:  TBLRD*+
441E:  MOVFF  FF5,FEE
4422:  DECFSZ 01,F
4424:  BRA    441C
4426:  MOVLW  01
4428:  MOVLB  2
442A:  MOVWF  x56
442C:  MOVLW  AB
442E:  MOVWF  x55
4430:  MOVLW  03
4432:  MOVWF  x57
4434:  MOVLB  0
4436:  CALL   1CF6
....................    set(0x00,dio_2_mapping);
443A:  MOVLB  2
443C:  CLRF   x10
443E:  MOVFF  12E,213
4442:  MOVFF  12D,212
4446:  MOVFF  12C,211
444A:  MOVLB  0
444C:  CALL   20D2
....................    //Interrupciones
.................... //!   enable_interrupts(GLOBAL);    //Habilita todas las interrupciones
.................... //!   enable_interrupts(INT_EXT2);   //Habilita la interrupcin externa en el pin B2
.................... //!   //Interrucion en el cambio de Low to High
.................... //!   ext_int_edge(L_TO_H); 
....................   
....................   //Esto ya funciona
.................... 
....................    while(TRUE)
....................    {
....................    //Depuracion
.................... //!   int b3 = digitalRead(BUTTON_3);
.................... //!   if (b3 == 0){
.................... //!      //Alternar el nivel de verbosidad
.................... //!      debugLevel = (debugLevel + 1) % 4;
.................... //!      print((char*)"Verbose level ",1);
.................... //!      sprintf(str,"%u",debugLevel);
.................... //!      println(str,1);
.................... //!   }
.................... //!   button3_last_state = b3;
....................    char* packet = receive(1,0,0,0);
4450:  MOVLW  01
4452:  MOVLB  1
4454:  MOVWF  xB9
4456:  CLRF   xBA
4458:  CLRF   xBE
445A:  CLRF   xBD
445C:  CLRF   xBC
445E:  CLRF   xBB
4460:  CLRF   xBF
4462:  MOVLB  0
4464:  GOTO   3982
4468:  MOVFF  02,1B6
446C:  MOVFF  01,1B5
....................    if (!(packet == NULL || packet[0] == 0)){
4470:  MOVLB  1
4472:  MOVF   xB5,F
4474:  BNZ   447A
4476:  MOVF   xB6,F
4478:  BZ    4516
447A:  MOVFF  1B5,FE9
447E:  MOVFF  1B6,FEA
4482:  MOVF   FEF,F
4484:  BZ    4516
....................     println ((char*)"Packet",3);
4486:  MOVLW  01
4488:  MOVWF  FEA
448A:  MOVLW  AB
448C:  MOVWF  FE9
448E:  MOVLW  07
4490:  MOVWF  01
4492:  CLRF   FF7
4494:  MOVLW  00
4496:  MOVLB  0
4498:  CALL   040C
449C:  TBLRD*-
449E:  TBLRD*+
44A0:  MOVFF  FF5,FEE
44A4:  DECFSZ 01,F
44A6:  BRA    449E
44A8:  MOVLW  01
44AA:  MOVLB  2
44AC:  MOVWF  x56
44AE:  MOVLW  AB
44B0:  MOVWF  x55
44B2:  MOVLW  03
44B4:  MOVWF  x57
44B6:  MOVLB  0
44B8:  CALL   1CF6
....................     for (uint16_t i=0;i<packet[0]-1;i++){
44BC:  MOVLB  1
44BE:  CLRF   xB8
44C0:  CLRF   xB7
44C2:  MOVFF  1B5,FE9
44C6:  MOVFF  1B6,FEA
44CA:  MOVLW  01
44CC:  SUBWF  FEF,W
44CE:  MOVF   xB8,F
44D0:  BNZ   4514
44D2:  SUBWF  xB7,W
44D4:  BC    4514
....................       printch(packet[i+1],1);
44D6:  MOVLW  01
44D8:  ADDWF  xB7,W
44DA:  MOVWF  xB9
44DC:  MOVLW  00
44DE:  ADDWFC xB8,W
44E0:  MOVWF  xBA
44E2:  MOVF   xB5,W
44E4:  ADDWF  xB9,W
44E6:  MOVWF  FE9
44E8:  MOVF   xB6,W
44EA:  ADDWFC xBA,W
44EC:  MOVWF  FEA
44EE:  CLRF   19
44F0:  BTFSC  FF2.7
44F2:  BSF    19.7
44F4:  BCF    FF2.7
44F6:  MOVFF  FEF,28D
44FA:  MOVLW  01
44FC:  MOVLB  2
44FE:  MOVWF  x8E
4500:  MOVLB  0
4502:  CALL   1632
4506:  BTFSC  19.7
4508:  BSF    FF2.7
450A:  MOVLB  1
450C:  INCF   xB7,F
450E:  BTFSC  FD8.2
4510:  INCF   xB8,F
4512:  BRA    44C2
....................       }
....................    }
4514:  BRA    454E
....................    else println((char*) "Esperando",1);
4516:  MOVLW  01
4518:  MOVWF  FEA
451A:  MOVLW  AB
451C:  MOVWF  FE9
451E:  MOVLW  0A
4520:  MOVWF  01
4522:  CLRF   FF7
4524:  MOVLW  00
4526:  MOVLB  0
4528:  CALL   0424
452C:  TBLRD*-
452E:  TBLRD*+
4530:  MOVFF  FF5,FEE
4534:  DECFSZ 01,F
4536:  BRA    452E
4538:  MOVLW  01
453A:  MOVLB  2
453C:  MOVWF  x56
453E:  MOVLW  AB
4540:  MOVWF  x55
4542:  MOVLW  01
4544:  MOVWF  x57
4546:  MOVLB  0
4548:  CALL   1CF6
454C:  MOVLB  1
....................   //radio.readAllRegs();
....................   free(packet);
454E:  MOVFF  1B6,211
4552:  MOVFF  1B5,210
4556:  MOVLB  0
4558:  CALL   3606
455C:  BRA    4450
.................... 
....................    }
....................    
....................    //Esto quizas sea mejor
....................    //while (true){
....................    //receiveFast(1,0,0,0);
....................    //}
.................... 
.................... }
.................... 
455E:  SLEEP 
.................... 
.................... 
.................... 
.................... void main2(){
.................... 
.................... uint8_t synch[] = {3,0xAA,0x2D,0xD4};
.................... int ResetPin = RF_Reset;
.................... //setOutput(INDICATOR_LED,0);
.................... 
.................... setup_adc_ports(NO_ANALOGS, VSS_VDD);
.................... usb_init();
.................... //Esperar un segundo antes de iniciar
.................... sleep_ms(1000);
.................... while (!checkId()){
....................    usb_task();
....................    println((char*)"Id incorrecto", 2);
.................... }
.................... println((char*)"Hola", 3);
.................... //setOutput(INDICATOR_LED,1);
....................    
.................... init(synch,ResetPin);
.................... println((char*)"INIT DONE", 3);
.................... set(0x00,dio_2_mapping);
.................... //Interrupciones
.................... enable_interrupts(GLOBAL);    //Habilita todas las interrupciones
.................... enable_interrupts(INT_EXT2);   //Habilita la interrupcin externa en el pin B2
....................    //Interrucion en el cambio de High-Low
.................... ext_int_edge(H_TO_L); 
....................   
.................... // tell the RFM to represent whether we are in automode on DIO 2.
.................... set(0b11,dio_2_mapping);
.................... setBufferSize(5);
.................... setPacketLength(64);
.................... 
.................... 
.................... uint8_t buffer[64] = {0}; // receive buffer.
.................... 
.................... // use first four bytes of that buffer as uint32.
.................... uint16_t counter = 0;
.................... 
.................... uint16_t oldcounter = 0; // keep track of the counter.
.................... uint16_t packetloss = 0; // counter for missed packets.
.................... 
.................... // counter to indicate total number of received packets.
.................... uint16_t received_packets = 0;
.................... 
.................... // time on which we start receiving.
.................... /////uint32_t start_time = millis();
.................... 
.................... 
....................    while(TRUE)
....................    {
....................          println((char*)"Loop",3);
....................         uint8_t packets=0;
....................         while(available()){
....................             packets++;
....................             received_packets++;
.................... 
....................             // on the receipt of 100 packets, print some information.
....................             if ((received_packets % 100 == 0)){
....................                 print((char*)"Total packets: ",2); println(received_packets,2);
....................                 print((char*)"Packetloss count: ",2); println(packetloss,2);
....................                 //print("Per second: ",2); Serial.println(received_packets / ((millis() - start_time)/1000));
....................             }
.................... 
....................             uint8_t len = read(&buffer); // read the packet into the buffer.
....................             for (int i=0;i<len;i++){
....................             print((char)buffer[i],1);
....................                }
.................... 
....................             // check the entire message if it consists of the same 4 byte blocks.
....................             uint16_t* this_counter = (uint16_t*) &(buffer[0]);
....................             for (int i=1; i < (64/4); i++){
....................                 if (*(this_counter) != *((uint16_t*) &(buffer[i*4]))){
....................                     println((char*)"Message not correct!",2);
....................                     packetloss++;
....................                     continue;
....................                 }
....................             }
.................... 
....................             if ((counter+1) != *this_counter){
....................                 println((char*)"Packetloss detected!",2);
....................                 packetloss++;
....................             }
.................... 
....................             counter = *this_counter;
....................         }
.................... 
....................         // we can add some delay here, to show that the internal buffering works.
....................         // delayMicroseconds(4000);
....................         // try uncommenting this delay, the if statement below will be true from time to time.
....................         if (packets > 1){
....................             print((char*)"Packets this loop: ",2); println(packets,2);
....................         }
....................         
.................... 
....................    }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... }
.................... 
.................... 
.................... /*
.................... 
.................... //Interrupcion del timer
.................... #INT_RTCC  //TIMER0
.................... void timer0(void){
....................    set_rtcc(TIMER_START); //Timer0
....................    //println((char*)"Timer INT");
....................    globalMs += TIMER_STEP_MS ;       
....................    if (globalMs >= 1000){
....................    globalSec ++;
....................    globalMs -= 1000;
....................    }
....................    if (globalSec >= 60){
....................    globalMin ++;
....................    globalSec -= 60;
....................    }
....................    //Inicializar todo al llegar a 60 minutos
....................    //Puede introducir un bug rarisimo en el que una diferencia entre tiempos de negativa, pero es muy poco probable
....................    //Y aun asi el bug ocurrira cuando gloabalMin desborde
....................    if (globalMin >= 60){
....................    globalMs = 0;
....................    globalSec= 0;
....................    globalMin = 0;
....................    }
.................... }
.................... 
.................... */

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
