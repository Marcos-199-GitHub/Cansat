CCS PCH C Compiler, Version 5.112, 29001               29-may.-23 23:05

               Filename:   I:\CanSat\Cansat\Assets\RFM69\Receptor\ArduPort\Receptor.lst

               ROM used:   15826 bytes (48%)
                           Largest free fragment is 16942
               RAM used:   682 (33%) at main() level
                           895 (44%) worst case
               Stack used: 17 locations (10 in main + 7 for interrupts)
               Stack size: 31

*
0000:  GOTO   37DE
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   1476
0060:  BTFSS  FA0.5
0062:  GOTO   006C
0066:  BTFSC  FA1.5
0068:  GOTO   13EE
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #define HEX 16
.................... #define BIN 2
.................... #define DEC 10
.................... #define SSPin PIN_A5
.................... #define TIMER_START 114
.................... #define TIMER_STEP_MS 3
.................... #include <Receptor.h>
.................... #include <18LF4550.h>
.................... //////////// Standard Header file for the PIC18LF4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18LF4550
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 00,03
00CC:  DATA 02,FF
00CE:  DATA FF,FF
00D0:  DATA FF,FF
00D2:  DATA FF,FF
00D4:  DATA FF,FF
00D6:  DATA FF,FF
00D8:  DATA FF,FF
00DA:  CLRF   FF7
00DC:  ADDLW  EA
00DE:  MOVWF  FF6
00E0:  MOVLW  00
00E2:  ADDWFC FF7,F
00E4:  TBLRD*+
00E6:  MOVF   FF5,W
00E8:  RETURN 0
00EA:  DATA 00,FF
00EC:  DATA 02,FF
00EE:  DATA FF,FF
00F0:  DATA FF,FF
00F2:  DATA FF,FF
00F4:  DATA FF,FF
00F6:  DATA FF,FF
00F8:  DATA FF,FF
00FA:  CLRF   FF7
00FC:  ADDLW  0A
00FE:  MOVWF  FF6
0100:  MOVLW  01
0102:  ADDWFC FF7,F
0104:  TBLRD*+
0106:  MOVF   FF5,W
0108:  RETURN 0
010A:  DATA 40,00
010C:  DATA 0B,00
010E:  DATA 40,00
0110:  DATA 00,00
0112:  DATA 00,00
0114:  DATA 00,00
0116:  DATA 00,00
0118:  DATA 00,00
011A:  DATA 00,00
011C:  DATA 00,00
011E:  DATA 00,00
0120:  DATA 00,00
0122:  DATA 00,00
0124:  DATA 00,00
0126:  DATA 00,00
0128:  DATA 00,00
012A:  CLRF   FF7
012C:  ADDLW  3A
012E:  MOVWF  FF6
0130:  MOVLW  01
0132:  ADDWFC FF7,F
0134:  TBLRD*+
0136:  MOVF   FF5,W
0138:  RETURN 0
013A:  DATA 40,00
013C:  DATA 00,00
013E:  DATA 40,00
0140:  DATA 00,00
0142:  DATA 00,00
0144:  DATA 00,00
0146:  DATA 00,00
0148:  DATA 00,00
014A:  DATA 00,00
014C:  DATA 00,00
014E:  DATA 00,00
0150:  DATA 00,00
0152:  DATA 00,00
0154:  DATA 00,00
0156:  DATA 00,00
0158:  DATA 00,00
015A:  CLRF   FF7
015C:  ADDLW  6A
015E:  MOVWF  FF6
0160:  MOVLW  01
0162:  ADDWFC FF7,F
0164:  TBLRD*+
0166:  MOVF   FF5,W
0168:  RETURN 0
016A:  DATA 09,02
016C:  DATA 43,00
016E:  DATA 02,01
0170:  DATA 00,80
0172:  DATA FA,09
0174:  DATA 04,00
0176:  DATA 00,01
0178:  DATA 02,02
017A:  DATA 01,00
017C:  DATA 05,24
017E:  DATA 00,10
0180:  DATA 01,04
0182:  DATA 24,02
0184:  DATA 02,05
0186:  DATA 24,06
0188:  DATA 00,01
018A:  DATA 05,24
018C:  DATA 01,00
018E:  DATA 01,07
0190:  DATA 05,81
0192:  DATA 03,0B
0194:  DATA 00,FA
0196:  DATA 09,04
0198:  DATA 01,00
019A:  DATA 02,0A
019C:  DATA 00,00
019E:  DATA 00,07
01A0:  DATA 05,02
01A2:  DATA 02,40
01A4:  DATA 00,01
01A6:  DATA 07,05
01A8:  DATA 82,02
01AA:  DATA 40,00
01AC:  DATA 01,00
01AE:  CLRF   FF7
01B0:  ADDLW  BE
01B2:  MOVWF  FF6
01B4:  MOVLW  01
01B6:  ADDWFC FF7,F
01B8:  TBLRD*+
01BA:  MOVF   FF5,W
01BC:  RETURN 0
01BE:  DATA 02,00
01C0:  CLRF   FF7
01C2:  ADDLW  D0
01C4:  MOVWF  FF6
01C6:  MOVLW  01
01C8:  ADDWFC FF7,F
01CA:  TBLRD*+
01CC:  MOVF   FF5,W
01CE:  RETURN 0
01D0:  DATA 12,17
01D2:  DATA 1B,20
01D4:  DATA FF,FF
01D6:  DATA FF,FF
01D8:  CLRF   FF7
01DA:  ADDLW  E8
01DC:  MOVWF  FF6
01DE:  MOVLW  01
01E0:  ADDWFC FF7,F
01E2:  TBLRD*+
01E4:  MOVF   FF5,W
01E6:  RETURN 0
01E8:  DATA 12,01
01EA:  DATA 10,01
01EC:  DATA 02,00
01EE:  DATA 00,40
01F0:  DATA 05,24
01F2:  DATA 0B,00
01F4:  DATA 00,01
01F6:  DATA 01,02
01F8:  DATA 00,01
01FA:  CLRF   FF7
01FC:  ADDLW  0A
01FE:  MOVWF  FF6
0200:  MOVLW  02
0202:  ADDWFC FF7,F
0204:  TBLRD*+
0206:  MOVF   FF5,W
0208:  RETURN 0
020A:  DATA 04,03
020C:  DATA 09,04
020E:  DATA 08,03
0210:  DATA 43,00
0212:  DATA 43,00
0214:  DATA 53,00
0216:  DATA 20,03
0218:  DATA 43,00
021A:  DATA 43,00
021C:  DATA 53,00
021E:  DATA 20,00
0220:  DATA 55,00
0222:  DATA 53,00
0224:  DATA 42,00
0226:  DATA 20,00
0228:  DATA 74,00
022A:  DATA 6F,00
022C:  DATA 20,00
022E:  DATA 55,00
0230:  DATA 41,00
0232:  DATA 52,00
0234:  DATA 54,00
0236:  CLRF   FF7
0238:  ADDLW  46
023A:  MOVWF  FF6
023C:  MOVLW  02
023E:  ADDWFC FF7,F
0240:  TBLRD*+
0242:  MOVF   FF5,W
0244:  RETURN 0
0246:  DATA 49,6E
0248:  DATA 69,74
024A:  DATA 69,61
024C:  DATA 6C,20
024E:  DATA 63,6F
0250:  DATA 6E,66
0252:  DATA 20,73
0254:  DATA 74,61
0256:  DATA 72,74
0258:  DATA 73,00
025A:  CLRF   FF7
025C:  ADDLW  6A
025E:  MOVWF  FF6
0260:  MOVLW  02
0262:  ADDWFC FF7,F
0264:  TBLRD*+
0266:  MOVF   FF5,W
0268:  RETURN 0
026A:  DATA 45,72
026C:  DATA 72,6F
026E:  DATA 72,3A
0270:  DATA 20,49
0272:  DATA 44,20
0274:  DATA 64,65
0276:  DATA 6C,20
0278:  DATA 52,46
027A:  DATA 4D,20
027C:  DATA 69,6E
027E:  DATA 63,6F
0280:  DATA 72,72
0282:  DATA 65,63
0284:  DATA 74,61
0286:  DATA 00,00
0288:  CLRF   FF7
028A:  ADDLW  98
028C:  MOVWF  FF6
028E:  MOVLW  02
0290:  ADDWFC FF7,F
0292:  TBLRD*+
0294:  MOVF   FF5,W
0296:  RETURN 0
0298:  DATA 49,44
029A:  DATA 20,4C
029C:  DATA 6F,6F
029E:  DATA 70,00
02A0:  CLRF   FF7
02A2:  ADDLW  B0
02A4:  MOVWF  FF6
02A6:  MOVLW  02
02A8:  ADDWFC FF7,F
02AA:  TBLRD*+
02AC:  MOVF   FF5,W
02AE:  RETURN 0
02B0:  DATA 49,6E
02B2:  DATA 69,74
02B4:  DATA 69,61
02B6:  DATA 6C,20
02B8:  DATA 63,6F
02BA:  DATA 6E,66
02BC:  DATA 69,67
02BE:  DATA 75,72
02C0:  DATA 61,74
02C2:  DATA 69,6F
02C4:  DATA 6E,20
02C6:  DATA 65,6E
02C8:  DATA 64,0A
02CA:  DATA 00,00
02CC:  CLRF   FF7
02CE:  ADDLW  DC
02D0:  MOVWF  FF6
02D2:  MOVLW  02
02D4:  ADDWFC FF7,F
02D6:  TBLRD*+
02D8:  MOVF   FF5,W
02DA:  RETURN 0
02DC:  DATA 4F,50
02DE:  DATA 20,4C
02E0:  DATA 6F,6F
02E2:  DATA 70,20
02E4:  DATA 31,00
02E6:  CLRF   FF7
02E8:  ADDLW  F6
02EA:  MOVWF  FF6
02EC:  MOVLW  02
02EE:  ADDWFC FF7,F
02F0:  TBLRD*+
02F2:  MOVF   FF5,W
02F4:  RETURN 0
02F6:  DATA 4F,70
02F8:  DATA 65,72
02FA:  DATA 61,74
02FC:  DATA 69,6F
02FE:  DATA 6E,20
0300:  DATA 4D,6F
0302:  DATA 64,65
0304:  DATA 20,63
0306:  DATA 6F,75
0308:  DATA 6C,64
030A:  DATA 6E,74
030C:  DATA 20,62
030E:  DATA 65,20
0310:  DATA 73,65
0312:  DATA 74,0A
0314:  DATA 00,00
0316:  CLRF   FF7
0318:  ADDLW  26
031A:  MOVWF  FF6
031C:  MOVLW  03
031E:  ADDWFC FF7,F
0320:  TBLRD*+
0322:  MOVF   FF5,W
0324:  RETURN 0
0326:  DATA 4F,50
0328:  DATA 20,4C
032A:  DATA 6F,6F
032C:  DATA 70,20
032E:  DATA 32,00
0330:  CLRF   FF7
0332:  ADDLW  40
0334:  MOVWF  FF6
0336:  MOVLW  03
0338:  ADDWFC FF7,F
033A:  TBLRD*+
033C:  MOVF   FF5,W
033E:  RETURN 0
0340:  DATA 54,69
0342:  DATA 6D,65
0344:  DATA 6F,75
0346:  DATA 74,20
0348:  DATA 6F,6E
034A:  DATA 20,4F
034C:  DATA 70,65
034E:  DATA 72,61
0350:  DATA 74,69
0352:  DATA 6F,6E
0354:  DATA 20,4D
0356:  DATA 6F,64
0358:  DATA 65,20
035A:  DATA 53,65
035C:  DATA 74,0A
035E:  DATA 00,00
0360:  CLRF   FF7
0362:  ADDLW  70
0364:  MOVWF  FF6
0366:  MOVLW  03
0368:  ADDWFC FF7,F
036A:  TBLRD*+
036C:  MOVF   FF5,W
036E:  RETURN 0
0370:  DATA 50,61
0372:  DATA 79,6C
0374:  DATA 6F,61
0376:  DATA 64,3A
0378:  DATA 20,00
037A:  CLRF   FF7
037C:  ADDLW  8A
037E:  MOVWF  FF6
0380:  MOVLW  03
0382:  ADDWFC FF7,F
0384:  TBLRD*+
0386:  MOVF   FF5,W
0388:  RETURN 0
038A:  DATA 54,69
038C:  DATA 6D,65
038E:  DATA 64,20
0390:  DATA 6F,75
0392:  DATA 74,00
0394:  CLRF   FF7
0396:  ADDLW  A4
0398:  MOVWF  FF6
039A:  MOVLW  03
039C:  ADDWFC FF7,F
039E:  TBLRD*+
03A0:  MOVF   FF5,W
03A2:  RETURN 0
03A4:  DATA 46,49
03A6:  DATA 46,4F
03A8:  DATA 20,4C
03AA:  DATA 45,4E
03AC:  DATA 3A,20
03AE:  DATA 00,00
03B0:  CLRF   FF7
03B2:  ADDLW  C0
03B4:  MOVWF  FF6
03B6:  MOVLW  03
03B8:  ADDWFC FF7,F
03BA:  TBLRD*+
03BC:  MOVF   FF5,W
03BE:  RETURN 0
03C0:  DATA 49,64
03C2:  DATA 20,69
03C4:  DATA 6E,63
03C6:  DATA 6F,72
03C8:  DATA 72,65
03CA:  DATA 63,74
03CC:  DATA 6F,00
03CE:  CLRF   FF7
03D0:  ADDLW  DE
03D2:  MOVWF  FF6
03D4:  MOVLW  03
03D6:  ADDWFC FF7,F
03D8:  TBLRD*+
03DA:  MOVF   FF5,W
03DC:  RETURN 0
03DE:  DATA 49,4E
03E0:  DATA 49,54
03E2:  DATA 20,44
03E4:  DATA 4F,4E
03E6:  DATA 45,00
03E8:  CLRF   FF7
03EA:  ADDLW  F8
03EC:  MOVWF  FF6
03EE:  MOVLW  03
03F0:  ADDWFC FF7,F
03F2:  TBLRD*+
03F4:  MOVF   FF5,W
03F6:  RETURN 0
03F8:  DATA 45,73
03FA:  DATA 70,65
03FC:  DATA 72,61
03FE:  DATA 6E,64
0400:  DATA 6F,00
*
04A2:  MOVLB  2
04A4:  MOVF   x57,W
04A6:  MULWF  x59
04A8:  MOVFF  FF3,01
04AC:  MOVFF  FF4,00
04B0:  MULWF  x5A
04B2:  MOVF   FF3,W
04B4:  ADDWF  00,F
04B6:  MOVF   x58,W
04B8:  MULWF  x59
04BA:  MOVF   FF3,W
04BC:  ADDWFC 00,W
04BE:  MOVWF  02
04C0:  MOVLB  0
04C2:  RETURN 0
*
15E6:  MOVLB  2
15E8:  MOVF   x20,W
15EA:  ANDLW  07
15EC:  MOVWF  00
15EE:  RRCF   x20,W
15F0:  MOVWF  01
15F2:  RRCF   01,F
15F4:  RRCF   01,F
15F6:  MOVLW  1F
15F8:  ANDWF  01,F
15FA:  MOVF   01,W
15FC:  ADDWF  x22,W
15FE:  MOVWF  FE9
1600:  MOVLW  00
1602:  ADDWFC x23,W
1604:  MOVWF  FEA
1606:  CLRF   01
1608:  INCF   01,F
160A:  INCF   00,F
160C:  BRA    1610
160E:  RLCF   01,F
1610:  DECFSZ 00,F
1612:  BRA    160E
1614:  MOVF   x21,F
1616:  BZ    161E
1618:  MOVF   01,W
161A:  IORWF  FEF,F
161C:  BRA    1624
161E:  COMF   01,F
1620:  MOVF   01,W
1622:  ANDWF  FEF,F
1624:  MOVLB  0
1626:  RETURN 0
*
17C6:  MOVF   FEF,F
17C8:  BZ    17E8
17CA:  MOVFF  FEA,22B
17CE:  MOVFF  FE9,22A
17D2:  MOVFF  FEF,22C
17D6:  BRA    1788
17D8:  MOVFF  22B,FEA
17DC:  MOVFF  22A,FE9
17E0:  INCF   FE9,F
17E2:  BTFSC  FD8.2
17E4:  INCF   FEA,F
17E6:  BRA    17C6
17E8:  GOTO   17FE (RETURN)
*
18F8:  MOVLW  8E
18FA:  MOVWF  00
18FC:  MOVFF  219,01
1900:  MOVFF  218,02
1904:  CLRF   03
1906:  MOVF   01,F
1908:  BNZ   191C
190A:  MOVFF  02,01
190E:  CLRF   02
1910:  MOVLW  08
1912:  SUBWF  00,F
1914:  MOVF   01,F
1916:  BNZ   191C
1918:  CLRF   00
191A:  BRA    192C
191C:  BCF    FD8.0
191E:  BTFSC  01.7
1920:  BRA    192A
1922:  RLCF   02,F
1924:  RLCF   01,F
1926:  DECF   00,F
1928:  BRA    191C
192A:  BCF    01.7
192C:  RETURN 0
192E:  MOVLW  80
1930:  BTFSS  FD8.1
1932:  BRA    1938
1934:  MOVLB  2
1936:  XORWF  x1F,F
1938:  MOVLB  2
193A:  CLRF   x24
193C:  CLRF   x25
193E:  MOVFF  21B,223
1942:  MOVF   x1F,W
1944:  XORWF  x23,F
1946:  MOVF   x1A,W
1948:  BTFSC  FD8.2
194A:  BRA    1B0A
194C:  MOVWF  x22
194E:  MOVWF  00
1950:  MOVF   x1E,W
1952:  BTFSC  FD8.2
1954:  BRA    1B1C
1956:  SUBWF  x22,F
1958:  BTFSC  FD8.2
195A:  BRA    1A62
195C:  BNC   19DA
195E:  MOVFF  21F,228
1962:  BSF    x28.7
1964:  MOVFF  220,227
1968:  MOVFF  221,226
196C:  CLRF   x25
196E:  BCF    FD8.0
1970:  RRCF   x28,F
1972:  RRCF   x27,F
1974:  RRCF   x26,F
1976:  RRCF   x25,F
1978:  DECFSZ x22,F
197A:  BRA    196C
197C:  BTFSS  x23.7
197E:  BRA    1986
1980:  BSF    x24.0
1982:  BRA    1B44
1984:  BCF    x24.0
1986:  BCF    x22.0
1988:  BSF    x24.4
198A:  MOVLW  02
198C:  MOVWF  FEA
198E:  MOVLW  1D
1990:  MOVWF  FE9
1992:  BRA    1B6A
1994:  BCF    x24.4
1996:  BTFSC  x23.7
1998:  BRA    19AE
199A:  BTFSS  x22.0
199C:  BRA    19C4
199E:  RRCF   x28,F
19A0:  RRCF   x27,F
19A2:  RRCF   x26,F
19A4:  RRCF   x25,F
19A6:  INCF   00,F
19A8:  BTFSC  FD8.2
19AA:  BRA    1B3A
19AC:  BRA    19C4
19AE:  BTFSC  x28.7
19B0:  BRA    19CA
19B2:  BCF    FD8.0
19B4:  RLCF   x25,F
19B6:  RLCF   x26,F
19B8:  RLCF   x27,F
19BA:  RLCF   x28,F
19BC:  DECF   00,F
19BE:  BTFSC  FD8.2
19C0:  BRA    1B3A
19C2:  BRA    19AE
19C4:  BSF    x24.6
19C6:  BRA    1AA2
19C8:  BCF    x24.6
19CA:  MOVFF  21B,223
19CE:  BTFSS  x1B.7
19D0:  BRA    19D6
19D2:  BSF    x28.7
19D4:  BRA    1B2C
19D6:  BCF    x28.7
19D8:  BRA    1B2C
19DA:  MOVFF  21E,222
19DE:  MOVFF  21E,00
19E2:  MOVF   x1A,W
19E4:  SUBWF  x22,F
19E6:  MOVFF  21B,228
19EA:  BSF    x28.7
19EC:  MOVFF  21C,227
19F0:  MOVFF  21D,226
19F4:  CLRF   x25
19F6:  BCF    FD8.0
19F8:  RRCF   x28,F
19FA:  RRCF   x27,F
19FC:  RRCF   x26,F
19FE:  RRCF   x25,F
1A00:  DECFSZ x22,F
1A02:  BRA    19F4
1A04:  BTFSS  x23.7
1A06:  BRA    1A0E
1A08:  BSF    x24.1
1A0A:  BRA    1B44
1A0C:  BCF    x24.1
1A0E:  BCF    x22.0
1A10:  BSF    x24.5
1A12:  MOVLW  02
1A14:  MOVWF  FEA
1A16:  MOVLW  21
1A18:  MOVWF  FE9
1A1A:  BRA    1B6A
1A1C:  BCF    x24.5
1A1E:  BTFSC  x23.7
1A20:  BRA    1A36
1A22:  BTFSS  x22.0
1A24:  BRA    1A4C
1A26:  RRCF   x28,F
1A28:  RRCF   x27,F
1A2A:  RRCF   x26,F
1A2C:  RRCF   x25,F
1A2E:  INCF   00,F
1A30:  BTFSC  FD8.2
1A32:  BRA    1B3A
1A34:  BRA    1A4C
1A36:  BTFSC  x28.7
1A38:  BRA    1A52
1A3A:  BCF    FD8.0
1A3C:  RLCF   x25,F
1A3E:  RLCF   x26,F
1A40:  RLCF   x27,F
1A42:  RLCF   x28,F
1A44:  DECF   00,F
1A46:  BTFSC  FD8.2
1A48:  BRA    1B3A
1A4A:  BRA    1A36
1A4C:  BSF    x24.7
1A4E:  BRA    1AA2
1A50:  BCF    x24.7
1A52:  MOVFF  21F,223
1A56:  BTFSS  x1F.7
1A58:  BRA    1A5E
1A5A:  BSF    x28.7
1A5C:  BRA    1B2C
1A5E:  BCF    x28.7
1A60:  BRA    1B2C
1A62:  MOVFF  21F,228
1A66:  BSF    x28.7
1A68:  MOVFF  220,227
1A6C:  MOVFF  221,226
1A70:  BTFSS  x23.7
1A72:  BRA    1A7C
1A74:  BCF    x28.7
1A76:  BSF    x24.2
1A78:  BRA    1B44
1A7A:  BCF    x24.2
1A7C:  CLRF   x25
1A7E:  BCF    x22.0
1A80:  MOVLW  02
1A82:  MOVWF  FEA
1A84:  MOVLW  1D
1A86:  MOVWF  FE9
1A88:  BRA    1B6A
1A8A:  BTFSC  x23.7
1A8C:  BRA    1AC6
1A8E:  MOVFF  21B,223
1A92:  BTFSS  x22.0
1A94:  BRA    1AA2
1A96:  RRCF   x28,F
1A98:  RRCF   x27,F
1A9A:  RRCF   x26,F
1A9C:  RRCF   x25,F
1A9E:  INCF   00,F
1AA0:  BZ    1B3A
1AA2:  BTFSS  x25.7
1AA4:  BRA    1ABC
1AA6:  INCF   x26,F
1AA8:  BNZ   1ABC
1AAA:  INCF   x27,F
1AAC:  BNZ   1ABC
1AAE:  INCF   x28,F
1AB0:  BNZ   1ABC
1AB2:  RRCF   x28,F
1AB4:  RRCF   x27,F
1AB6:  RRCF   x26,F
1AB8:  INCF   00,F
1ABA:  BZ    1B3A
1ABC:  BTFSC  x24.6
1ABE:  BRA    19C8
1AC0:  BTFSC  x24.7
1AC2:  BRA    1A50
1AC4:  BRA    1AFE
1AC6:  MOVLW  80
1AC8:  XORWF  x28,F
1ACA:  BTFSS  x28.7
1ACC:  BRA    1AD6
1ACE:  BRA    1B44
1AD0:  MOVFF  21F,223
1AD4:  BRA    1AEA
1AD6:  MOVFF  21B,223
1ADA:  MOVF   x28,F
1ADC:  BNZ   1AEA
1ADE:  MOVF   x27,F
1AE0:  BNZ   1AEA
1AE2:  MOVF   x26,F
1AE4:  BNZ   1AEA
1AE6:  CLRF   00
1AE8:  BRA    1B2C
1AEA:  BTFSC  x28.7
1AEC:  BRA    1AFE
1AEE:  BCF    FD8.0
1AF0:  RLCF   x25,F
1AF2:  RLCF   x26,F
1AF4:  RLCF   x27,F
1AF6:  RLCF   x28,F
1AF8:  DECFSZ 00,F
1AFA:  BRA    1AEA
1AFC:  BRA    1B3A
1AFE:  BTFSS  x23.7
1B00:  BRA    1B06
1B02:  BSF    x28.7
1B04:  BRA    1B2C
1B06:  BCF    x28.7
1B08:  BRA    1B2C
1B0A:  MOVFF  21E,00
1B0E:  MOVFF  21F,228
1B12:  MOVFF  220,227
1B16:  MOVFF  221,226
1B1A:  BRA    1B2C
1B1C:  MOVFF  21A,00
1B20:  MOVFF  21B,228
1B24:  MOVFF  21C,227
1B28:  MOVFF  21D,226
1B2C:  MOVFF  228,01
1B30:  MOVFF  227,02
1B34:  MOVFF  226,03
1B38:  BRA    1BA2
1B3A:  CLRF   00
1B3C:  CLRF   01
1B3E:  CLRF   02
1B40:  CLRF   03
1B42:  BRA    1BA2
1B44:  CLRF   x25
1B46:  COMF   x26,F
1B48:  COMF   x27,F
1B4A:  COMF   x28,F
1B4C:  COMF   x25,F
1B4E:  INCF   x25,F
1B50:  BNZ   1B5C
1B52:  INCF   x26,F
1B54:  BNZ   1B5C
1B56:  INCF   x27,F
1B58:  BNZ   1B5C
1B5A:  INCF   x28,F
1B5C:  BTFSC  x24.0
1B5E:  BRA    1984
1B60:  BTFSC  x24.1
1B62:  BRA    1A0C
1B64:  BTFSC  x24.2
1B66:  BRA    1A7A
1B68:  BRA    1AD0
1B6A:  MOVF   FEF,W
1B6C:  ADDWF  x26,F
1B6E:  BNC   1B7A
1B70:  INCF   x27,F
1B72:  BNZ   1B7A
1B74:  INCF   x28,F
1B76:  BTFSC  FD8.2
1B78:  BSF    x22.0
1B7A:  MOVF   FED,F
1B7C:  MOVF   FEF,W
1B7E:  ADDWF  x27,F
1B80:  BNC   1B88
1B82:  INCF   x28,F
1B84:  BTFSC  FD8.2
1B86:  BSF    x22.0
1B88:  MOVF   FED,F
1B8A:  MOVF   FEF,W
1B8C:  BTFSC  FEF.7
1B8E:  BRA    1B92
1B90:  XORLW  80
1B92:  ADDWF  x28,F
1B94:  BTFSC  FD8.0
1B96:  BSF    x22.0
1B98:  BTFSC  x24.4
1B9A:  BRA    1994
1B9C:  BTFSC  x24.5
1B9E:  BRA    1A1C
1BA0:  BRA    1A8A
1BA2:  MOVLB  0
1BA4:  RETURN 0
1BA6:  MOVLB  2
1BA8:  MOVF   x1C,W
1BAA:  BTFSC  FD8.2
1BAC:  BRA    1C90
1BAE:  MOVWF  00
1BB0:  MOVF   x20,W
1BB2:  BTFSC  FD8.2
1BB4:  BRA    1C90
1BB6:  ADDWF  00,F
1BB8:  BNC   1BC2
1BBA:  MOVLW  81
1BBC:  ADDWF  00,F
1BBE:  BC    1C90
1BC0:  BRA    1BCA
1BC2:  MOVLW  7F
1BC4:  SUBWF  00,F
1BC6:  BNC   1C90
1BC8:  BZ    1C90
1BCA:  MOVFF  21D,224
1BCE:  MOVF   x21,W
1BD0:  XORWF  x24,F
1BD2:  BSF    x1D.7
1BD4:  BSF    x21.7
1BD6:  MOVF   x1F,W
1BD8:  MULWF  x23
1BDA:  MOVFF  FF4,226
1BDE:  MOVF   x1E,W
1BE0:  MULWF  x22
1BE2:  MOVFF  FF4,03
1BE6:  MOVFF  FF3,225
1BEA:  MULWF  x23
1BEC:  MOVF   FF3,W
1BEE:  ADDWF  x26,F
1BF0:  MOVF   FF4,W
1BF2:  ADDWFC x25,F
1BF4:  MOVLW  00
1BF6:  ADDWFC 03,F
1BF8:  MOVF   x1F,W
1BFA:  MULWF  x22
1BFC:  MOVF   FF3,W
1BFE:  ADDWF  x26,F
1C00:  MOVF   FF4,W
1C02:  ADDWFC x25,F
1C04:  MOVLW  00
1C06:  CLRF   02
1C08:  ADDWFC 03,F
1C0A:  ADDWFC 02,F
1C0C:  MOVF   x1D,W
1C0E:  MULWF  x23
1C10:  MOVF   FF3,W
1C12:  ADDWF  x25,F
1C14:  MOVF   FF4,W
1C16:  ADDWFC 03,F
1C18:  MOVLW  00
1C1A:  ADDWFC 02,F
1C1C:  MOVF   x1D,W
1C1E:  MULWF  x22
1C20:  MOVF   FF3,W
1C22:  ADDWF  03,F
1C24:  MOVF   FF4,W
1C26:  ADDWFC 02,F
1C28:  MOVLW  00
1C2A:  CLRF   01
1C2C:  ADDWFC 01,F
1C2E:  MOVF   x1F,W
1C30:  MULWF  x21
1C32:  MOVF   FF3,W
1C34:  ADDWF  x25,F
1C36:  MOVF   FF4,W
1C38:  ADDWFC 03,F
1C3A:  MOVLW  00
1C3C:  ADDWFC 02,F
1C3E:  ADDWFC 01,F
1C40:  MOVF   x1E,W
1C42:  MULWF  x21
1C44:  MOVF   FF3,W
1C46:  ADDWF  03,F
1C48:  MOVF   FF4,W
1C4A:  ADDWFC 02,F
1C4C:  MOVLW  00
1C4E:  ADDWFC 01,F
1C50:  MOVF   x1D,W
1C52:  MULWF  x21
1C54:  MOVF   FF3,W
1C56:  ADDWF  02,F
1C58:  MOVF   FF4,W
1C5A:  ADDWFC 01,F
1C5C:  INCF   00,F
1C5E:  BTFSC  01.7
1C60:  BRA    1C6C
1C62:  RLCF   x25,F
1C64:  RLCF   03,F
1C66:  RLCF   02,F
1C68:  RLCF   01,F
1C6A:  DECF   00,F
1C6C:  MOVLW  00
1C6E:  BTFSS  x25.7
1C70:  BRA    1C86
1C72:  INCF   03,F
1C74:  ADDWFC 02,F
1C76:  ADDWFC 01,F
1C78:  MOVF   01,W
1C7A:  BNZ   1C86
1C7C:  MOVF   02,W
1C7E:  BNZ   1C86
1C80:  MOVF   03,W
1C82:  BNZ   1C86
1C84:  INCF   00,F
1C86:  BTFSC  x24.7
1C88:  BSF    01.7
1C8A:  BTFSS  x24.7
1C8C:  BCF    01.7
1C8E:  BRA    1C98
1C90:  CLRF   00
1C92:  CLRF   01
1C94:  CLRF   02
1C96:  CLRF   03
1C98:  MOVLB  0
1C9A:  GOTO   1D5C (RETURN)
*
1DCA:  MOVFF  21B,222
1DCE:  MOVLB  2
1DD0:  MOVF   x1F,W
1DD2:  XORWF  x22,F
1DD4:  BTFSS  x22.7
1DD6:  BRA    1DE2
1DD8:  BCF    FD8.2
1DDA:  BCF    FD8.0
1DDC:  BTFSC  x1B.7
1DDE:  BSF    FD8.0
1DE0:  BRA    1E40
1DE2:  MOVFF  21B,222
1DE6:  MOVFF  21E,223
1DEA:  MOVF   x1A,W
1DEC:  SUBWF  x23,F
1DEE:  BZ    1DFC
1DF0:  BTFSS  x22.7
1DF2:  BRA    1E40
1DF4:  MOVF   FD8,W
1DF6:  XORLW  01
1DF8:  MOVWF  FD8
1DFA:  BRA    1E40
1DFC:  MOVFF  21F,223
1E00:  MOVF   x1B,W
1E02:  SUBWF  x23,F
1E04:  BZ    1E12
1E06:  BTFSS  x22.7
1E08:  BRA    1E40
1E0A:  MOVF   FD8,W
1E0C:  XORLW  01
1E0E:  MOVWF  FD8
1E10:  BRA    1E40
1E12:  MOVFF  220,223
1E16:  MOVF   x1C,W
1E18:  SUBWF  x23,F
1E1A:  BZ    1E28
1E1C:  BTFSS  x22.7
1E1E:  BRA    1E40
1E20:  MOVF   FD8,W
1E22:  XORLW  01
1E24:  MOVWF  FD8
1E26:  BRA    1E40
1E28:  MOVFF  221,223
1E2C:  MOVF   x1D,W
1E2E:  SUBWF  x23,F
1E30:  BZ    1E3E
1E32:  BTFSS  x22.7
1E34:  BRA    1E40
1E36:  MOVF   FD8,W
1E38:  XORLW  01
1E3A:  MOVWF  FD8
1E3C:  BRA    1E40
1E3E:  BCF    FD8.0
1E40:  MOVLB  0
1E42:  RETURN 0
1E44:  MOVFF  C6,FEA
1E48:  MOVFF  C5,FE9
1E4C:  MOVFF  22E,FEF
1E50:  INCF   FE9,F
1E52:  BTFSC  FD8.2
1E54:  INCF   FEA,F
1E56:  CLRF   FEF
1E58:  MOVLB  0
1E5A:  INCF   xC5,F
1E5C:  BTFSC  FD8.2
1E5E:  INCF   xC6,F
1E60:  RETURN 0
1E62:  MOVLB  2
1E64:  BTFSC  x29.7
1E66:  BRA    1E8A
1E68:  MOVLW  0F
1E6A:  MOVWF  00
1E6C:  SWAPF  x28,W
1E6E:  ANDWF  00,F
1E70:  MOVLW  0A
1E72:  SUBWF  00,W
1E74:  BC    1E7C
1E76:  MOVLW  30
1E78:  ADDWF  00,F
1E7A:  BRA    1E80
1E7C:  MOVF   x29,W
1E7E:  ADDWF  00,F
1E80:  MOVFF  00,22E
1E84:  MOVLB  0
1E86:  RCALL  1E44
1E88:  MOVLB  2
1E8A:  MOVLW  0F
1E8C:  ANDWF  x28,F
1E8E:  MOVLW  0A
1E90:  SUBWF  x28,W
1E92:  BC    1E98
1E94:  MOVLW  30
1E96:  BRA    1E9C
1E98:  BCF    x29.7
1E9A:  MOVF   x29,W
1E9C:  ADDWF  x28,F
1E9E:  MOVFF  228,22E
1EA2:  MOVLB  0
1EA4:  RCALL  1E44
1EA6:  GOTO   2038 (RETURN)
1EAA:  MOVLB  2
1EAC:  MOVF   x2F,W
1EAE:  CLRF   01
1EB0:  SUBWF  x2E,W
1EB2:  BC    1EBA
1EB4:  MOVFF  22E,00
1EB8:  BRA    1ED2
1EBA:  CLRF   00
1EBC:  MOVLW  08
1EBE:  MOVWF  x30
1EC0:  RLCF   x2E,F
1EC2:  RLCF   00,F
1EC4:  MOVF   x2F,W
1EC6:  SUBWF  00,W
1EC8:  BTFSC  FD8.0
1ECA:  MOVWF  00
1ECC:  RLCF   01,F
1ECE:  DECFSZ x30,F
1ED0:  BRA    1EC0
1ED2:  MOVLB  0
1ED4:  RETURN 0
1ED6:  MOVLW  20
1ED8:  MOVLB  2
1EDA:  BTFSS  x29.4
1EDC:  MOVLW  30
1EDE:  MOVWF  x2A
1EE0:  MOVFF  228,00
1EE4:  BTFSS  00.7
1EE6:  BRA    1EF8
1EE8:  COMF   00,F
1EEA:  INCF   00,F
1EEC:  MOVFF  00,228
1EF0:  MOVLW  2D
1EF2:  MOVWF  x2A
1EF4:  BSF    x29.7
1EF6:  BSF    x29.0
1EF8:  MOVF   01,W
1EFA:  MOVFF  228,22E
1EFE:  MOVLW  64
1F00:  MOVWF  x2F
1F02:  MOVLB  0
1F04:  RCALL  1EAA
1F06:  MOVFF  00,228
1F0A:  MOVLW  30
1F0C:  ADDWF  01,W
1F0E:  MOVLB  2
1F10:  MOVWF  x2B
1F12:  MOVFF  228,22E
1F16:  MOVLW  0A
1F18:  MOVWF  x2F
1F1A:  MOVLB  0
1F1C:  RCALL  1EAA
1F1E:  MOVLW  30
1F20:  ADDWF  00,W
1F22:  MOVLB  2
1F24:  MOVWF  x2D
1F26:  MOVLW  30
1F28:  ADDWF  01,W
1F2A:  MOVWF  x2C
1F2C:  MOVFF  22A,00
1F30:  MOVLW  30
1F32:  SUBWF  x2B,W
1F34:  BZ    1F3E
1F36:  BSF    x29.1
1F38:  BTFSC  x29.7
1F3A:  BSF    x29.2
1F3C:  BRA    1F62
1F3E:  MOVFF  22A,22B
1F42:  MOVLW  20
1F44:  MOVWF  x2A
1F46:  MOVLW  30
1F48:  SUBWF  x2C,W
1F4A:  BZ    1F54
1F4C:  BSF    x29.0
1F4E:  BTFSC  x29.7
1F50:  BSF    x29.1
1F52:  BRA    1F62
1F54:  BTFSS  FD8.2
1F56:  BSF    x29.0
1F58:  BNZ   1F62
1F5A:  MOVFF  22B,22C
1F5E:  MOVLW  20
1F60:  MOVWF  x2B
1F62:  BTFSC  x29.2
1F64:  BRA    1F70
1F66:  BTFSC  x29.1
1F68:  BRA    1F78
1F6A:  BTFSC  x29.0
1F6C:  BRA    1F80
1F6E:  BRA    1F88
1F70:  MOVFF  22A,22E
1F74:  MOVLB  0
1F76:  RCALL  1E44
1F78:  MOVFF  22B,22E
1F7C:  MOVLB  0
1F7E:  RCALL  1E44
1F80:  MOVFF  22C,22E
1F84:  MOVLB  0
1F86:  RCALL  1E44
1F88:  MOVFF  22D,22E
1F8C:  MOVLB  0
1F8E:  RCALL  1E44
1F90:  RETURN 0
*
2446:  MOVLB  1
2448:  MOVF   xB6,W
244A:  BTFSC  FD8.2
244C:  BRA    2598
244E:  MOVWF  xC2
2450:  MOVF   xBA,W
2452:  BTFSC  FD8.2
2454:  BRA    2598
2456:  SUBWF  xC2,F
2458:  BNC   2464
245A:  MOVLW  7F
245C:  ADDWF  xC2,F
245E:  BTFSC  FD8.0
2460:  BRA    2598
2462:  BRA    2470
2464:  MOVLW  81
2466:  SUBWF  xC2,F
2468:  BTFSS  FD8.0
246A:  BRA    2598
246C:  BTFSC  FD8.2
246E:  BRA    2598
2470:  MOVFF  1C2,00
2474:  CLRF   01
2476:  CLRF   02
2478:  CLRF   03
247A:  CLRF   xC1
247C:  MOVFF  1B7,1C0
2480:  BSF    xC0.7
2482:  MOVFF  1B8,1BF
2486:  MOVFF  1B9,1BE
248A:  MOVLW  19
248C:  MOVWF  xC2
248E:  MOVF   xBD,W
2490:  SUBWF  xBE,F
2492:  BC    24AE
2494:  MOVLW  01
2496:  SUBWF  xBF,F
2498:  BC    24AE
249A:  SUBWF  xC0,F
249C:  BC    24AE
249E:  SUBWF  xC1,F
24A0:  BC    24AE
24A2:  INCF   xC1,F
24A4:  INCF   xC0,F
24A6:  INCF   xBF,F
24A8:  MOVF   xBD,W
24AA:  ADDWF  xBE,F
24AC:  BRA    24FE
24AE:  MOVF   xBC,W
24B0:  SUBWF  xBF,F
24B2:  BC    24D8
24B4:  MOVLW  01
24B6:  SUBWF  xC0,F
24B8:  BC    24D8
24BA:  SUBWF  xC1,F
24BC:  BC    24D8
24BE:  INCF   xC1,F
24C0:  INCF   xC0,F
24C2:  MOVF   xBC,W
24C4:  ADDWF  xBF,F
24C6:  MOVF   xBD,W
24C8:  ADDWF  xBE,F
24CA:  BNC   24FE
24CC:  INCF   xBF,F
24CE:  BNZ   24FE
24D0:  INCF   xC0,F
24D2:  BNZ   24FE
24D4:  INCF   xC1,F
24D6:  BRA    24FE
24D8:  MOVF   xBB,W
24DA:  IORLW  80
24DC:  SUBWF  xC0,F
24DE:  BC    24FC
24E0:  MOVLW  01
24E2:  SUBWF  xC1,F
24E4:  BC    24FC
24E6:  INCF   xC1,F
24E8:  MOVF   xBB,W
24EA:  IORLW  80
24EC:  ADDWF  xC0,F
24EE:  MOVF   xBC,W
24F0:  ADDWF  xBF,F
24F2:  BNC   24C6
24F4:  INCF   xC0,F
24F6:  BNZ   24C6
24F8:  INCF   xC1,F
24FA:  BRA    24C6
24FC:  BSF    03.0
24FE:  DECFSZ xC2,F
2500:  BRA    2504
2502:  BRA    251A
2504:  BCF    FD8.0
2506:  RLCF   xBE,F
2508:  RLCF   xBF,F
250A:  RLCF   xC0,F
250C:  RLCF   xC1,F
250E:  BCF    FD8.0
2510:  RLCF   03,F
2512:  RLCF   02,F
2514:  RLCF   01,F
2516:  RLCF   xC3,F
2518:  BRA    248E
251A:  BTFSS  xC3.0
251C:  BRA    252A
251E:  BCF    FD8.0
2520:  RRCF   01,F
2522:  RRCF   02,F
2524:  RRCF   03,F
2526:  RRCF   xC3,F
2528:  BRA    252E
252A:  DECF   00,F
252C:  BZ    2598
252E:  BTFSC  xC3.7
2530:  BRA    256E
2532:  BCF    FD8.0
2534:  RLCF   xBE,F
2536:  RLCF   xBF,F
2538:  RLCF   xC0,F
253A:  RLCF   xC1,F
253C:  MOVF   xBD,W
253E:  SUBWF  xBE,F
2540:  BC    2550
2542:  MOVLW  01
2544:  SUBWF  xBF,F
2546:  BC    2550
2548:  SUBWF  xC0,F
254A:  BC    2550
254C:  SUBWF  xC1,F
254E:  BNC   2584
2550:  MOVF   xBC,W
2552:  SUBWF  xBF,F
2554:  BC    2560
2556:  MOVLW  01
2558:  SUBWF  xC0,F
255A:  BC    2560
255C:  SUBWF  xC1,F
255E:  BNC   2584
2560:  MOVF   xBB,W
2562:  IORLW  80
2564:  SUBWF  xC0,F
2566:  BC    256E
2568:  MOVLW  01
256A:  SUBWF  xC1,F
256C:  BNC   2584
256E:  INCF   03,F
2570:  BNZ   2584
2572:  INCF   02,F
2574:  BNZ   2584
2576:  INCF   01,F
2578:  BNZ   2584
257A:  INCF   00,F
257C:  BZ    2598
257E:  RRCF   01,F
2580:  RRCF   02,F
2582:  RRCF   03,F
2584:  MOVFF  1B7,1C2
2588:  MOVF   xBB,W
258A:  XORWF  xC2,F
258C:  BTFSS  xC2.7
258E:  BRA    2594
2590:  BSF    01.7
2592:  BRA    25A0
2594:  BCF    01.7
2596:  BRA    25A0
2598:  CLRF   00
259A:  CLRF   01
259C:  CLRF   02
259E:  CLRF   03
25A0:  MOVLB  0
25A2:  RETURN 0
25A4:  MOVLW  8E
25A6:  MOVWF  00
25A8:  MOVLB  1
25AA:  MOVF   xB6,W
25AC:  SUBWF  00,F
25AE:  MOVFF  1B7,02
25B2:  MOVFF  1B8,01
25B6:  BSF    02.7
25B8:  MOVF   00,F
25BA:  BZ    25CE
25BC:  BCF    FD8.0
25BE:  MOVF   02,F
25C0:  BNZ   25C6
25C2:  MOVF   01,F
25C4:  BZ    25CE
25C6:  RRCF   02,F
25C8:  RRCF   01,F
25CA:  DECFSZ 00,F
25CC:  BRA    25BC
25CE:  BTFSS  xB7.7
25D0:  BRA    25DC
25D2:  COMF   01,F
25D4:  COMF   02,F
25D6:  INCF   01,F
25D8:  BTFSC  FD8.2
25DA:  INCF   02,F
25DC:  MOVLB  0
25DE:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #fuses HSPLL, NOWDT, NOPROTECT, NODEBUG, USBDIV, PLL4, CPUDIV1, VREGEN
.................... 
.................... #use delay(clock=48MHz,crystal=16MHz,USB_FULL)
*
15BC:  MOVLW  02
15BE:  MOVWF  FEA
15C0:  MOVLW  14
15C2:  MOVWF  FE9
15C4:  MOVF   FEF,W
15C6:  BZ    15E4
15C8:  MOVLW  0F
15CA:  MOVWF  01
15CC:  CLRF   00
15CE:  DECFSZ 00,F
15D0:  BRA    15CE
15D2:  DECFSZ 01,F
15D4:  BRA    15CC
15D6:  MOVLW  8F
15D8:  MOVWF  00
15DA:  DECFSZ 00,F
15DC:  BRA    15DA
15DE:  NOP   
15E0:  DECFSZ FEF,F
15E2:  BRA    15C8
15E4:  RETURN 0
*
166A:  MOVLW  01
166C:  MOVLB  2
166E:  SUBWF  x1E,F
1670:  BNC   168C
1672:  MOVLW  02
1674:  MOVWF  FEA
1676:  MOVLW  1E
1678:  MOVWF  FE9
167A:  MOVF   FEF,W
167C:  BZ    168C
167E:  MOVLW  02
1680:  MOVWF  00
1682:  DECFSZ 00,F
1684:  BRA    1682
1686:  BRA    1688
1688:  DECFSZ FEF,F
168A:  BRA    167E
168C:  MOVLB  0
168E:  GOTO   16C8 (RETURN)
.................... #use FIXED_IO( E_outputs=PIN_E0 )
.................... #define RF_RESET   PIN_E0
.................... 
.................... 
.................... #define USB_CABLE_IS_ATTACHED()  input(PIN_B2)
.................... #define USB_CONFIG_VID 0x2405
.................... #define USB_CONFIG_PID 0x000B
.................... #define USB_CONFIG_BUS_POWER 500
.................... 
.................... // if USB_CDC_ISR is defined, then this function will be called
.................... // by the USB ISR when there incoming CDC (virtual com port) data.
.................... // this is useful if you want to port old RS232 code that was use
.................... // #int_rda to CDC.
.................... #define USB_CDC_ISR() RDA_isr()
.................... 
.................... // in order for handle_incoming_usb() to be able to transmit the entire
.................... // USB message in one pass, we need to increase the CDC buffer size from
.................... // the normal size and use the USB_CDC_DELAYED_FLUSH option.
.................... // failure to do this would cause some loss of data.
.................... #define USB_CDC_DELAYED_FLUSH
.................... #define USB_CDC_DATA_LOCAL_SIZE  128
.................... 
.................... 
.................... static void RDA_isr(void);
.................... 
.................... #include <usb_cdc.h>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////                            usb_cdc.h                            ////
.................... ////                                                                 ////
.................... //// Library for adding a virtual COM port on your PC over USB using ////
.................... //// the standard Communication Device Class (CDC) specification.    ////
.................... //// Including this file in your code will add all USB code,         ////
.................... //// interrupts, descriptors and handlers required.  No other        ////
.................... //// modifications need to be made.                                  ////
.................... ////                                                                 ////
.................... //// This library creates a virtual RS232 link between the PC and    ////
.................... //// the PIC, therefore the library provided will be familiar to     ////
.................... //// anyone with standard UART stream I/O:                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          ////
.................... ////      character received and waiting in the receive buffer.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  ////
.................... ////      there is no data in the receive buffer it will wait until  ////
.................... ////      there is data in the receive buffer.  If you do not want   ////
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   ////
.................... ////      check if there is data before calling usb_cdc_getc().      ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       ////
.................... ////      buffer.  If the transmit buffer is full it will wait until ////
.................... ////      the transmit buffer is not full before putting the char    ////
.................... ////      into the transmit buffer.  The transmit buffer is read by  ////
.................... ////      the PC very quickly, and therefore the buffer should only  ////
.................... ////      be full for a few milli-seconds.  If you are concerned     ////
.................... ////      and don't want to be stuck in a long or infinite loop,     ////
.................... ////      use usb_cdc_putready() to see if there is space in the     ////
.................... ////      transmit buffer before putting data into the transmit      ////
.................... ////      buffer.                                                    ////
.................... ////                                                                 ////
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    ////
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'ptr' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    ////
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'len' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putready() - Returns the number of bytes available      ////
.................... ////     in the TX buffer for storing characters.  If this returns   ////
.................... ////     0 then the buffer is full and waiting for the host (PC)     ////
.................... ////     to read the buffer.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   ////
.................... ////     empty and fully flushed/transmitted to host (PC).           ////
.................... ////                                                                 ////
.................... //// usb_cdc_connected() - Returns TRUE if we received a             ////
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   ////
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        ////
.................... ////      message when the program starts and it opens the virtual   ////
.................... ////      COM port.  This is a simple way to determine if the PC     ////
.................... ////      is ready to display data on a serial terminal program,     ////
.................... ////      but is not garaunteed to work all the time or on other     ////
.................... ////      terminal programs.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   ////
.................... ////      if the transmit buffer is full it will skip the char.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  ////
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   ////
.................... ////                                                                 ////
.................... //// usb_cdc_break - If the PC has sent a break command, this will   ////
.................... ////       hold the break time (in milli-seconds).  If the PC sends  ////
.................... ////       a value of 0xFFFF the device is supposed to hold the      ////
.................... ////       break until it sends a value of 0                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. ////
.................... ////       Of most relevance is the field dte_present, which is the  ////
.................... ////       DTR setting.                                              ////
.................... ////                                                                 ////
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          ////
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   ////
.................... ////       ring, break and more.  See the documentation above        ////
.................... ////       usb_cdc_serial_state() for more information, including    ////
.................... ////       format of state structure.                                ////
.................... ////                                                                 ////
.................... //// The following functions are also provided, and are ports of the ////
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   ////
.................... //// documentation:                                                  ////
.................... ////   get_float_usb() - Read a float number from the user           ////
.................... ////   get_long_usb() - Read a long number from the user             ////
.................... ////   get_int_usb() - Read an integer number from the user          ////
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. ////
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             ////
.................... ////   gethex1_usb() - Read a HEX character                          ////
.................... ////                                                                 ////
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  ////
.................... //// be called when there is incoming CDC (virtual com port) data.   ////
.................... //// This is useful if you want to update legacy RS232 code that     ////
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    ////
.................... //// However, see the INTERRUPT LIMITATIONS section below.           ////
.................... ////                                                                 ////
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    ////
.................... ////  to flush the data as soon as possible.  However at times       ////
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   ////
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         ////
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     ////
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       ////
.................... ////  also attempt to flush the packet on each call to usb_task().   ////
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     ////
.................... ////  if you have a main loop that periodically calls usb_task().    ////
.................... ////                                                                 ////
.................... //// This driver will load all the rest of the USB code, and a set   ////
.................... //// of descriptors that will properly describe a CDC device for a   ////
.................... //// virtual COM port (usb_desc_cdc.h)                               ////
.................... ////                                                                 ////
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      ////
.................... //// standard CDC drivers for a virtual COM port in Windows          ////
.................... //// NT/2000/XP and above.                                           ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// Encapsuated Messages: (USB_CDC_USE_ENCAPSULATED)                ////
.................... //// -------------------------------------------------------------   ////
.................... ////                                                                 ////
.................... //// If USB_CDC_USE_ENCAPSULATED is defined, then the user must      ////
.................... //// provide the following callbacks in their application to provide ////
.................... //// encapsuated message support (SendEncapsulatedCommand and        ////
.................... ////  GetEncapsulatedResponse):                                      ////
.................... ////                                                                 ////
.................... //// usb_cdc_SendEncapsulatedCommand(byte *ptr, unsigned int16 num)  ////
.................... ////     PIC receives encapsulated command from host (PC), 'num'     ////
.................... ////     bytes of message stored in 'ptr'.                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_GetEncapsulatedResponse(byte *ptr, unsigned int16 num)  ////
.................... ////     Host (PC) is asking for 'num' bytes response from the PIC,  ////
.................... ////     PIC should store up to 'num' bytes to 'ptr' as the          ////
.................... ////     response.                                                   ////
.................... ////                                                                 ////
.................... //// Due to the design of the USB stack, all encapsulated messages   ////
.................... //// must be smaller than one endpoint 0 packet.  They cannot be     ////
.................... //// equal in size or larger than the endpoint 0 size.  See          ////
.................... //// USB_MAX_EP0_PACKET_LENGTH.                                      ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// BUFFER SIZES                                                    ////
.................... //// -------------------------------------------------------------   ////
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     ////
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        ////
.................... ////  Full speed devices limit this value to be 64.  To increase     ////
.................... ////  the size of the local PIC buffer you can also define           ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        ////
.................... ////  defined then the total PIC->PC buffer size would be            ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  ////
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      ////
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      ////
.................... ////  then this option isn't used.                                   ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// INTERRUPT LIMITATIONS                                           ////
.................... //// -------------------------------------------------------------   ////
.................... //// This section is only relevant if you are using USB interrupts   ////
.................... ////  and not the USB_ISR_POLLING option.                            ////
.................... ////                                                                 ////
.................... //// USB handling is complex, often requiring several packet         ////
.................... ////  transmissions to accomplish transfer of one block of data.     ////
.................... ////  Most of this processing is done in the USB ISR.  Because       ////
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the ////
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   ////
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  ////
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  ////
.................... ////  overflow the TX buffer than data will be lost.                 ////
.................... ////                                                                 ////
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB ////
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      ////
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           ////
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    ////
.................... ////                                                                 ////
.................... //// ex_usb_serial3.c shows an example of working around these       ////
.................... ////  ISR limitations.  Failure to follow these limitations can      ////
.................... ////  cause the PIC to lockup.  These limtations only need to be     ////
.................... ////  followed in the conditions listed above (writing code in the   ////
.................... ////  ISR or interrupts are disabled).                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// VERSION HISTORY                                                 ////
.................... ////                                                                 ////
.................... //// Nov 20th, 2014:                                                 ////
.................... ////  While usb_cdc_putc() waits for local buffer to be free, also   ////
.................... ////     check the endpoint buffer in case there was a situation     ////
.................... ////     that the ISR for this event was missed.                     ////
.................... ////                                                                 ////
.................... //// Dec 16th, 2013:                                                 ////
.................... ////  Added encapsulated message support.  See                       ////
.................... ////     USB_CDC_USE_ENCAPSULATED above for documentation.           ////
.................... ////                                                                 ////
.................... //// May 31st, 2013:                                                 ////
.................... ////  usb_cdc_putready() now returns the number of bytes available.  ////
.................... ////                                                                 ////
.................... //// May 23rd, 2013:                                                 ////
.................... ////  Added usb_cdc_putd().                                          ////
.................... ////                                                                 ////
.................... //// February 18th, 2013:                                            ////
.................... ////  Enhanced PIC16 support added.                                  ////
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 ////
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    ////
.................... ////                                                                 ////
.................... //// September 13th, 2012:                                           ////
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     ////
.................... ////     (PIC24, dsPIC33).                                           ////
.................... ////  Added usb_cdc_putempty().                                      ////
.................... ////                                                                 ////
.................... //// December 16th, 2011:                                            ////
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will ////
.................... ////     only include the get string helper functions.  This is      ////
.................... ////     a rarely used option, used only if you already wrote your   ////
.................... ////     own getc() and putc() routines.                             ////
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  ////
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      ////
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  ////
.................... ////                                                                 ////
.................... //// Oct 27th, 2011:                                                 ////
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    ////
.................... ////     documentation.  In order for this to work,                  ////
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   ////
.................... ////                                                                 ////
.................... //// Jan 28, 2010:                                                   ////
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    ////
.................... ////     one packet.                                                 ////
.................... ////                                                                 ////
.................... //// Jan 25, 2010:                                                   ////
.................... ////  Ignore incoming 0 length packets.                              ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// April 7th, 2009:                                                ////
.................... ////   Vista 'code 10' issues resolved.                              ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 26th, 2007:                                                 ////
.................... ////              usb_cdc_put_buffer_free() should be more stable.   ////
.................... ////              Fixed a hang-up that would happen if you sent      ////
.................... ////                 exactly 64 bytes.                               ////
.................... ////                                                                 ////
.................... //// Nov 6th, 2007:                                                  ////
.................... ////              Compatabible with latest pic18_usb.h, which        ////
.................... ////                 reduces RAM footprint of USB driver.            ////
.................... ////              This driver now fits on 18F4450/2450 PICs.         ////
.................... ////                                                                 ////
.................... //// October 27th, 2005: Changed the way incoming packets are        ////
.................... ////               handled in that CDC driver will not flush         ////
.................... ////               endpoint until user has handled all data.  This   ////
.................... ////               will prevent overflows as the USB will NAK        ////
.................... ////               incoming packets until it is ready to receive     ////
.................... ////               more.                                             ////
.................... ////            When using 18F4550 family, the RX buffer is          ////
.................... ////               mapped directly to the endpoint buffer - this     ////
.................... ////               saves a chunk of RAM.                             ////
.................... ////            When using the 18F4550 family, you can increase      ////
.................... ////               the TX and RX size over 64 bytes.                 ////
.................... ////            No longer send 0len packets in the TBE interrupt.    ////
.................... ////            Hopefully fixed bugs that caused random crashes      ////
.................... ////               if you tried sending more than 64 bytes.          ////
.................... ////                                                                 ////
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   ////
.................... ////                   buffer.                                       ////
.................... ////                                                                 ////
.................... //// July 1st, 2005: Initial Release.                                ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... //input.c ported to use CDC:
.................... float get_float_usb();
.................... signed long get_long_usb();
.................... signed int get_int_usb();
.................... void get_string_usb(char* s, unsigned int max);
.................... char gethex_usb();
.................... char gethex1_usb();
.................... 
.................... #if !defined(__USB_CDC_HELPERS_ONLY__)
.................... 
.................... //api for the user:
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got)
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free())
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin)
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding)
.................... void usb_cdc_putc_fast(char c);
.................... char usb_cdc_getc(void);
.................... void usb_cdc_putc(char c);
.................... void usb_cdc_get_discard(void);
.................... 
.................... //functions automatically called by USB handler code
.................... void usb_isr_tkn_cdc(void);
.................... void usb_cdc_init(void);
.................... void usb_isr_tok_out_cdc_control_dne(void);
.................... void usb_isr_tok_in_cdc_data_dne(void);
.................... void usb_isr_tok_out_cdc_data_dne(void);
.................... 
.................... void usb_cdc_flush_tx_buffer(void);
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //
.................... // Include the CCS USB Libraries.  See the comments at the top of these
.................... // files for more information
.................... //
.................... /////////////////////////////////////////////////////////////////////////////
.................... #ifndef __USB_PIC_PERIF__
.................... #define __USB_PIC_PERIF__   1
.................... #endif
.................... 
.................... #if __USB_PIC_PERIF__
....................    #if defined(__PCM__)
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c
....................    #elif defined(__PCH__)
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.h                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  This hardware layer      ////
.................... //// supports the USB peripheral on the PIC18 family chips.  Current ////
.................... //// supported families are:                                         ////
.................... ////     PIC18F2455/2550/4455/4550                                   ////
.................... ////     PIC18F2450/4450                                             ////
.................... ////     PIC18F2458/2553/4458/4553                                   ////
.................... ////     PIC18F13K50/14K50                                           ////
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     ////
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       ////
.................... ////     PIC18FxxK50                                                 ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      ////
.................... //// that are specific to only this HW peripheral that you may       ////
.................... //// find useful to use in your application.                         ////
.................... ////                                                                 ////
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    ////
.................... ////  Due to the limited USB RAM of this family, a limitation of     ////
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   ////
.................... ////  The HW actually supports more endpoints, but to simplify       ////
.................... ////  driver development this driver will only support the first 3   ////
.................... ////  so there is an easier memory block to work with.               ////
.................... ////                                                                 ////
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     ////
.................... ////  of USB speed, to save RAM.                                     ////
.................... ////                                                                 ////
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    ////
.................... ////  If you are not using internal pullups, you will need to put    ////
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    ////
.................... ////  want to use slow speed or full speed.  This code configures    ////
.................... ////  the device to use internal pullups, see usb_init() if you      ////
.................... ////  want to change that.                                           ////
.................... ////                                                                 ////
.................... ////  You need approximately 470nF cap on Vusb, even if you are      ////
.................... ////  using the internal 3.3V USB regulator.                         ////
.................... ////                                                                 ////
.................... ////  To run at full speed, you must use the oscillator              ////
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   ////
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     ////
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      ////
.................... ////  96MHz clock.  See the datasheet for details.                   ////
.................... ////                                                                 ////
.................... ////  To run at slow speed you must configure your MCU to run at     ////
.................... ////  24Mhz.  See the datasheet for details.                         ////
.................... ////                                                                 ////
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   ////
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the ////
.................... //// PIC when an event has happened on the USB Bus.  Therfore        ////
.................... //// this code enables interrupts.  A user modification can be made  ////
.................... //// to poll the USB interrupt flag instead of relying on an         ////
.................... //// interrupt.                                                      ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_H__
.................... #DEFINE __PIC18_USB_H__
.................... 
.................... #DEFINE __USB_HARDWARE__
.................... 
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral
.................... #DEFINE __PIC__   1
.................... 
.................... #ifndef USB_USE_FULL_SPEED
....................  #define USB_USE_FULL_SPEED   1
.................... #endif
.................... 
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................    //due to limited ram, force max packet length to 8 for this chip
....................    #define USB_MAX_EP0_PACKET_LENGTH   8
.................... #else
....................    #if USB_USE_FULL_SPEED==0
....................       //slow speed requires 8byte max packet size for endpoint 0
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8
....................    #else
....................       //for full speed you can still use 8bytes, but 64 will be faster
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64
....................    #endif
.................... #endif
.................... #endif
.................... 
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8))
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8
....................  #error Max Endpoint 0 length can't be less than 8!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64
....................  #error Max Endpoint 0 length can't be greater than 64!
.................... #endif
.................... 
.................... #include <usb_hw_layer.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_hw_layer.h                            ////
.................... ////                                                                   ////
.................... //// HW Layer for the USB Stack.                                       ////
.................... ////                                                                   ////
.................... //// HW drivers for the USB stack must support this API.               ////
.................... ////                                                                   ////
.................... //// The HW driver must also have a token handler that will call       ////
.................... //// usb_token_reset() when the device is init/reset, will call        ////
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          ////
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    ////
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     ////
.................... //// See usb.h for documentation of these functions.                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __USB_HW_LAYER_H__
.................... #define __USB_HW_LAYER_H__
.................... 
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0,
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4};
.................... 
.................... 
.................... // USER LEVEL FUNCTIONS:
.................... 
.................... /*****************************************************************************
.................... /* usb_init()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_init_cs()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_cs(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_task()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_task(void);
.................... 
.................... /******************************************************************************
.................... /* usb_attach()
.................... /*
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral.
.................... /*
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt.
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_attach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_detach()
.................... /*
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB.
.................... /*
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* If the user does call this function while USB is connected, the USB 
.................... /* peripheral will be disabled only momentarily because usb_task() will
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB
.................... /* reset of the device.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_detach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_put_packet()
.................... /*
.................... /* Input: endpoint - endpoint to send packet to (0..15).
.................... /*        ptr - points to data to send.
.................... /*        len - amount of data to send.
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, 
.................... /*                 or toggle from the last DATAx pid.
.................... /*
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only 
.................... /*         reason it will return FALSE is if because the TX buffer is still full 
.................... /*         from the last time it tried to send a packet.
.................... /*
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a 
.................... /*          difference between a packet and a message.  If you wanted to send a 
.................... /*          512 byte message on an endpoint that only supported 64 byte packets,
.................... /*          this would be accomplished this by sending 8 64-byte packets, 
.................... /*          followed by a 0 length packet.  If the last (or only packet) being 
.................... /*          sent is less than the max packet size defined in your descriptor 
.................... /*          then you do not need to send a 0 length packet to identify
.................... /*          an end of message.
.................... /*
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message 
.................... /*          correctly and know if a 0 lenght packet needs to be sent.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl);
.................... 
.................... /*******************************************************************************
.................... /* usb_get_packet(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer and saved to ptr.
.................... /*
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS!
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()!
.................... /*
.................... /* Summary: Gets a packet of data from the USB endpoint buffer.
.................... /*          Until this is called, if there is data in the receive buffer the
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be
.................... /*          allowed to send a new packet.  Only receives one packet, if you need 
.................... /*          to receive multiple packets or handle 0-length terminator packets,
.................... /*          then use usb_gets().
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /********************************************************************************/
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max);
.................... 
.................... /****************************************************************************
.................... /* usb_kbhit(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check (0..15)
.................... /*
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not.
.................... /*
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers.
.................... /*          See API section of USB.H for more information.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_kbhit(unsigned int8 en);
.................... 
.................... /******************************************************************************
.................... /* usb_tbe(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last
.................... /*         transmit or if this endpoint is invalid.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_tbe(unsigned int8 en);
.................... 
.................... //////////////// END USER LEVEL FUNCTIONS /////////////////////////////////////
.................... 
.................... 
.................... ///
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by
.................... ///            the USB stack, and are not meant to be called by the 
.................... ///            user/application.
.................... ///
.................... 
.................... /*****************************************************************************
.................... /* usb_stall_ep()
.................... /*
.................... /* Input: endpoint - endpoint to stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will
.................... /*          send STALL packet if the host tries to access this endpoint's 
.................... /*          buffer.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_stall_ep(unsigned int8 endpoint);
.................... 
.................... 
.................... /*****************************************************************************
.................... /* usb_unstall_ep(endpoint, direction)
.................... /*
.................... /* Input: endpoint - endpoint to un-stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Un-stalls endpoint.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_unstall_ep(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_endpoint_stalled()
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not.
.................... /*
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to
.................... /*          see if endpoint has been issued a STALL, just whether or not it is
.................... /*          configured to STALL on the next packet.  See Set_Feature and 
.................... /*          Clear_Feature Chapter 9 requests.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_set_address(address)
.................... /*
.................... /* Input: address - address the host specified that we use
.................... /*
.................... /* Summary: Configures the USB Peripheral for the specified device address.  
.................... /*          The host will now talk to use with the following address.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_address(unsigned int8 address);
.................... 
.................... /******************************************************************************
.................... /* usb_set_configured()
.................... /*
.................... /* Input: config - Configuration to use.  0 to uncofigure device.
.................... /*
.................... /* Summary: Configures or unconfigures device.  If configuring device it will
.................... /*          enable all the endpoints the user specified for this configuration.
.................... /*          If un-configuring device it will disable all endpoints.
.................... /*
.................... /*          NOTE: CCS only provides code to handle 1 configuration.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_configured(unsigned int8 config);
.................... 
.................... /******************************************************************************
.................... /* usb_disable_endpoints()
.................... /*
.................... /* Summary: Disables endpoints (all endpoints but 0)
.................... /*
.................... /*****************************************************************************/
.................... void usb_disable_endpoints(void);
.................... 
.................... 
.................... /*******************************************************************************
.................... /* usb_disable_endpoint()
.................... /*
.................... /* Input: Endpoint to disable (0..15)
.................... /*
.................... /* Summary: Disables specified endpoint
.................... /*
.................... /********************************************************************************/
.................... void usb_disable_endpoint(unsigned int8 en);
.................... 
.................... /**************************************************************
.................... /* usb_request_send_response(len)
.................... /* usb_request_get_data()
.................... /* usb_request_stall()
.................... /*
.................... /* Input: len - size of packet to send
.................... /*
.................... /* Summary: One of these 3 functions will be called by the USB stack after
.................... /*          handling a SETUP packet.
.................... /*          
.................... /*          After we process a SETUP request, we have 1 of three responses:
.................... /*            1.) send a response IN packet
.................... /*            2.) wait for followup OUT packet(s) with data
.................... /*            3.) stall because we don't support that SETUP request
.................... /*
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold
.................... /*          the response and the USB Request handler code will call
.................... /*          usb_request_send_response() to let us know how big the packet is.
.................... /*
.................... /*          If we are waiting for more data, usb_request_get_data() will
.................... /*          be called by the USB request handler code to configure the EP0 OUT
.................... /*          endpoint to be ready for more data
.................... /*
.................... /*          If we don't support a request, usb_request_stall() will be called
.................... /*          by the USB request handler code to stall the endpoint 0.
.................... /*
.................... /*          The operation of these functions depends on how SETUP packets
.................... /*          are handled in the hardware layer.
.................... /*
.................... /***************************************************************/
.................... void usb_request_send_response(unsigned int8 len);
.................... void usb_request_get_data(void);
.................... void usb_request_stall(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... //////////////////////// EXTRA USER FUNCTIONS /////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_flush_in()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for transfer
.................... /*        len - length of data that is being tramsferred
.................... /*        tgl - Data toggle synchronization for this packet
.................... /*
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint)
.................... /*
.................... /* Summary: Marks the endpoint ready for transmission.  You must
.................... /*          have already loaded the endpoint buffer with data.
.................... /*          (IN is PIC -> PC).
.................... /*          This routine is useful if you want to setup an endpoint by
.................... /*          writing to the buffer directly.
.................... /*          This routine is not necessary if you use usb_put_packet().
.................... /***************************************************************/
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_flush_out()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for release
.................... /*        tgl - Data toggle synchronization to expect in the next packet
.................... /*
.................... /* Output: NONE
.................... /*
.................... /* Summary: Clears the previously received packet, and then marks this
.................... /*          endpoint's receive buffer as ready for more data.
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not
.................... /*          want to use usb_get_packet(), instead you want to handle with
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size().
.................... /*          This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_rx_packet_size()
.................... /*
.................... /* Input: endpoint - which endpoint to mark to check
.................... /*
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer.
.................... /*
.................... /* Summary: Read the number of data stored in the receive buffer.  When you
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint.
.................... /*    This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... int16 usb_rx_packet_size(int8 endpoint);
.................... 
.................... #ENDIF
.................... 
....................    #else
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
....................    #endif
.................... #else
....................    #include <usbn960x.h>
.................... #endif
.................... #ifndef __USB_DESCRIPTORS__
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_desc_cdc.h                            ////
.................... ////                                                                   ////
.................... //// An example set of device / configuration descriptors for use with ////
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// Oct 27th, 2011:                                                   ////
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     ////
.................... ////     send SERIAL_STATE messages in one packet.                     ////
.................... ////                                                                   ////
.................... //// April 7th, 2009:                                                  ////
.................... ////   Vista 'code 10' issues resolved.                                ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// 10/28/05:                                                         ////
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        ////
.................... ////    packets.                                                       ////
.................... ////    Changed device to USB 1.10                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
.................... #DEFINE __USB_DESCRIPTORS__
.................... 
.................... ///////// config options, although it's best to leave alone for this demo /////
.................... #ifndef  USB_CONFIG_PID
....................    #define  USB_CONFIG_PID       0x000b
.................... #endif
.................... #ifndef  USB_CONFIG_VID
....................    #define  USB_CONFIG_VID       0x2405
.................... #endif
.................... #ifndef  USB_CONFIG_BUS_POWER
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500)
.................... #endif
.................... #ifndef  USB_CONFIG_VERSION
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99
.................... #endif
.................... //////// end config ///////////////////////////////////////////////////////////
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #DEFINE USB_HID_DEVICE  false
.................... #DEFINE USB_CDC_DEVICE  true
.................... 
.................... #define USB_CDC_COMM_IN_ENDPOINT       1
.................... #ifndef USB_CDC_COMM_IN_SIZE
.................... #define USB_CDC_COMM_IN_SIZE           11
.................... #endif
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE
.................... 
.................... //pic to pc endpoint config
.................... #define USB_CDC_DATA_IN_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_IN_SIZE
.................... #define USB_CDC_DATA_IN_SIZE           64
.................... #endif
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE
.................... 
.................... //pc to pic endpoint config
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_OUT_SIZE
.................... #define USB_CDC_DATA_OUT_SIZE           64
.................... #endif
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start config descriptor
.................... ///   right now we only support one configuration descriptor.
.................... ///   the config, interface, class, and endpoint goes into this array.
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints)
.................... 
....................    const char USB_CONFIG_DESC[] = {
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE:
....................       //    config(s)
....................       //    interface(s)
....................       //    class(es)
....................       //    endpoint(s)
.................... 
....................    //config_descriptor for config index 1
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3
....................          2, //number of interfaces this device supports       ==4
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5
....................          0x00, //index of string descriptor for this configuration      ==6
....................         #if USB_CONFIG_BUS_POWER
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #else
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #endif
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8
.................... 
.................... 
....................    //interface descriptor 0 (comm class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11
....................          0x00, //alternate setting     ==12
....................          1, //number of endpoints   ==13
....................          0x02, //class code, 02 = Comm Interface Class     ==14
....................          0x02, //subclass code, 2 = Abstract     ==15
....................          0x01, //protocol code, 1 = v.25ter      ==16
....................          0x00, //index of string descriptor for interface      ==17
.................... 
....................    //class descriptor [functional header]
....................          5, //length of descriptor    ==18
....................          0x24, //dscriptor type (0x24 == )      ==19
....................          0, //sub type (0=functional header) ==20
....................          0x10,0x01, //      ==21,22 //cdc version
.................... 
....................    //class descriptor [acm header]
....................          4, //length of descriptor    ==23
....................          0x24, //dscriptor type (0x24 == )      ==24
....................          2, //sub type (2=ACM)   ==25
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State.
.................... 
....................    //class descriptor [union header]
....................          5, //length of descriptor    ==27
....................          0x24, //dscriptor type (0x24 == )      ==28
....................          6, //sub type (6=union)    ==29
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union.
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. *
.................... 
....................    //class descriptor [call mgmt header]
....................          5, //length of descriptor    ==32
....................          0x24, //dscriptor type (0x24 == )      ==33
....................          1, //sub type (1=call mgmt)   ==34
....................          0, //capabilities          ==35  //device does not handle call management itself
....................          1, //data interface        ==36  //interface number of data class interface
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43
.................... 
....................    //interface descriptor 1 (data class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46
....................          0x00, //alternate setting     ==47
....................          2, //number of endpoints   ==48
....................          0x0A, //class code, 0A = Data Interface Class     ==49
....................          0x00, //subclass code      ==50
....................          0x00, //protocol code      ==51
....................          0x00, //index of string descriptor for interface      ==52
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55
....................          0x02, //transfer type supported (0x02 is bulk)         ==56
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58
....................          1,  //polling interval, in ms.   ==59
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62
....................          0x02, //transfer type supported (0x02 is bulk)         ==63
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67
....................          1  //polling interval, in ms.   ==68
....................    };
.................... 
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ********
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find
....................    //  a specific descriptor in the above table.
.................... 
....................    //the maximum number of interfaces seen on any config
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2
....................    #define USB_MAX_NUM_INTERFACES   2
.................... 
....................    //define how many interfaces there are per config.  [0] is the first config, etc.
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2};
.................... 
....................    //define where to find class descriptors
....................    //first dimension is the config number
....................    //second dimension specifies which interface
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface
....................    //if a class descriptor is not valid, set the value to 0xFFFF
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]=
....................    {
....................    //config 1
....................       //interface 0
....................          //class 1-4
....................          18,23,27,32,
....................       //interface 1
....................          //no classes for this interface
....................          0xFF,0xFF,0xFF,0xFF
....................    };
.................... 
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN)
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly
....................    #endif
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start device descriptors
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={
....................       //starts of with device configuration. only one possible
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1
....................          0x10,0x01, //usb version in bcd  ==2,3
....................          0x02, //class code. 0x02=Communication Device Class ==4
....................          0x00, //subclass code ==5
....................          0x00, //protocol code ==6
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14
....................          0x02, //index of string descriptor of the product  ==15
....................          0x00, //index of string descriptor of serial number  ==16
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17
....................    };
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start string descriptors
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone.
.................... ///
.................... ///   You must define the length else get_next_string_character() will not see the string
.................... ///   Current code only supports 10 strings (0 thru 9)
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
.................... #if !defined(USB_STRINGS_OVERWRITTEN)
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored.
.................... // Strings are saved as unicode.
.................... // These strings are mostly only displayed during the add hardware wizard.
.................... // Once the operating system drivers have been installed it will usually display
.................... // the name from the drivers .INF.
.................... char const USB_STRING_DESC[]={
....................    //string 0
....................          4, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          0x09,0x04,   //Microsoft Defined for US-English
....................    //string 1  - manufacturer
....................          8, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................    //string 2 - product
....................          32, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................          ' ',0,
....................          'U',0,
....................          'S',0,
....................          'B',0,
....................          ' ',0,
....................          't',0,
....................          'o',0,
....................          ' ',0,
....................          'U',0,
....................          'A',0,
....................          'R',0,
....................          'T',0
.................... };
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN)
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... struct {
....................    int1 got;
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100
....................    unsigned int16 len;
....................    unsigned int16 index;
....................   #else
....................    unsigned int8 len;
....................    unsigned int8 index;
....................   #endif
.................... } usb_cdc_get_buffer_status;
.................... 
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             usb.c                                 ////
.................... ////                                                                   ////
.................... //// Standard USB request and token handler code.                      ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... //// The majority of this code is called and used by the interrupt     ////
.................... //// generated by the hardware level, and therefore it is not meant    ////
.................... //// to be called by the user.  The functions that are meant to be     ////
.................... //// called by the user (init, put packet, get packet, etc) are        ////
.................... //// documented in USB.H.                                              ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////    This code will not create a multiple configuration device.     ////
.................... ////    If you wish to create a multiple configuration device then you ////
.................... ////    will have to modify these drivers.                             ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    ////
.................... ////   requests.  These requests are optional.  If you want to support ////
.................... ////   these requests you must provide the code yourself.  See         ////
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      ////
.................... ////   support.                                                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// If you wish to provide your own USB peripheral hardware layer, it ////
.................... //// must must provide the API as described in usb_hw_layer.h.         ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 20, 2015                                                    ////
.................... ////     USB_STRING_DESC_OFFSET no longer used.                        ////
.................... ////                                                                   ////
.................... //// Feb 6th, 2015                                                     ////
.................... ////     Fixed 'len' not being intiailized in usb_gets()               ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// June 8th, 2011:                                                   ////
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  ////
.................... ////     (for no timeout) resolved.                                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// November 13th, 2009:                                              ////
.................... ////  usb_endpoint_is_valid() has an extra check.                      ////
.................... ////                                                                   ////
.................... //// June 9th, 2009:                                                   ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// Dec 14, 2007:                                                     ////
.................... ////  usb_kbhit() moved to device driver.                              ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    ////
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release.                                         ////
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     ////
.................... ////    layer.                                                         ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////  TODO: alot of indexing and length handling for descriptors is    ////
.................... ////   only 8bit, so make sure all descriptor tables are less than     ////
.................... ////   256 bytes long.                                                 ////
.................... ////                                                                   ////
.................... //// Apr 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     ////
.................... ////   usb_ep_tx_size[] defined in usb.h                               ////
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             ////
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  ////
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     ////
.................... ////   the endpoint buffer until you usb_get_packet(), which will      ////
.................... ////   then free the endpoint buffer for more data.  This affects      ////
.................... ////   routines such as usb_gets() and usb_kbhit().                    ////
.................... ////  usb_gets() no longer reads buffered data (see above note),       ////
.................... ////   now it reads multiple packets in the same way usb_puts()        ////
.................... ////   writes multiple packets                                         ////
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  ////
.................... ////   layer.                                                          ////
.................... ////                                                                   ////
.................... //// Nov 11th, 2004:                                                   ////
.................... ////  No longer includes wrong descriptor header.                      ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   ////
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    ////
.................... ////                     although it didn't cause any serious problems ////
.................... ////                                                                   ////
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  ////
.................... ////                     problems with multiple packet messages        ////
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   ////
.................... ////                     descriptors that require a 0 len packet to    ////
.................... ////                     end message.                                  ////
.................... ////                                                                   ////
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DRIVER__
.................... #DEFINE __USB_DRIVER__
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #else
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) 
....................    {
....................       while(len--)
....................       {
....................          debug_usb_packet(debug_putc, "%02X", *ptr++);
....................       }
....................    }
.................... #endif
.................... 
.................... // legacy
.................... #ifndef debug_usb
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l)
.................... #endif
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if defined(__PIC16F_USB_H__)
....................  #include <pic16f_usb.c>
.................... #endif
.................... 
.................... #if defined(__PIC18_USB_H__)
....................  #include <pic18_usb.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.c                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     ////
.................... //// documentation about the PIC18 hardware layer.                   ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Dec 12, 2016:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Mar 20, 2015:                                                   ////
.................... ////  When TXing a packet, set UOWN bit as a different instruction   ////
.................... ////     as the rest of the BDSTAT flags.  Doing it this way         ////
.................... ////     prevents PIC18F45K50 family USB from locking up.            ////
.................... ////                                                                 ////
.................... //// Mar 1, 2015:                                                    ////
.................... ////  Added __STALL_ON_UEP_ERRATA__ and __UIDLE_JAM_ERRATA__ from    ////
.................... ////     PIC24 USB library, in case those erratas found              ////
.................... ////     their way on the PIC18 USB parts.                           ////
.................... ////                                                                 ////
.................... //// Dec 17, 2013:                                                   ////
.................... ////  Added 18FxxJ9x family support.                                 ////
.................... ////                                                                 ////
.................... //// Dec 11, 2013:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// July 9th, 2012:                                                 ////
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     ////
.................... ////     for non-setup packets on endpoint 0 or all other            ////
.................... ////     endpoints.  This really only affects people using           ////
.................... ////     usb_put_packet() or usb_get_packet() inside of other        ////
.................... ////     interrupts.                                                 ////
.................... ////                                                                 ////
.................... //// Sep 22, 2011:                                                   ////
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   ////
.................... ////     primarily developed for users developing code where         ////
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Added initial 18F47J53 family support.                         ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work.                          ////
.................... ////                                                                 ////
.................... //// Nov 13th, 2009:                                                 ////
.................... ////  usb_disable_endpoint() won't touch BD status registers for     ////
.................... ////     endpoints that aren't allocated.                            ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_C__
.................... #DEFINE __PIC18_USB_C__
.................... 
.................... // i got these from PIC24 library, but maybe these bugs made their way
.................... // into PIC18 usb peripherals.
.................... // __STALL_ON_UEP_ERRATA__ looked wrong on the PIC24 library.
.................... #define __STALL_ON_UEP_ERRATA__
.................... #define __UIDLE_JAM_ERRATA__
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #endif
.................... 
.................... #bit USBIE=getenv("BIT:USBIE")
.................... 
.................... //if you are worried that the PIC is not receiving packets because a bug in the
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on
.................... //receiving.
.................... #ifndef USB_IGNORE_RX_DTS
....................  #define USB_IGNORE_RX_DTS false
.................... #endif
.................... 
.................... #ifndef USB_IGNORE_TX_DTS
....................  #define USB_IGNORE_TX_DTS false
.................... #endif
.................... 
.................... // if only USB_BDT_START is defined, then BDT has a fixed location in RAM
.................... //    but endpoint memory can be anywhere on the PIC.
.................... // if only USB_RAM_START is defined, then both BDT and endpoint have a fixed
.................... //    location in RAM (BDT first, endpoint second).
.................... // if USB_BDT_START and USB_RAM_START are both defined, then BDT has a fixed
.................... //    location in RAM and the endpoint buffers have a different location
.................... //    in RAM.
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50"))
....................  #define __USB_87J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \
....................        (getenv("DEVICE")=="PIC18F24K50") || \
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF24K50"))
....................  #define __USB_45K50__
....................  #define USB_TOTAL_RAM_SPACE  1024
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50"))
....................  #define __USB_46J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || \
....................        (getenv("DEVICE")=="PIC18LF2450") || (getenv("DEVICE")=="PIC18LF4450"))
....................  #define __USB_4450__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................  #define __USB_K50__ //backwards compatability
....................  #define __USB_14K50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x200
....................  #define USB_NUM_UEP 8
....................  //technically this device supports 8 endpoints, but for RAM reasons you should
....................  //attempt to only use the first 3 endpoints.
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") || \
....................        (getenv("DEVICE")=="PIC18LF2455") || (getenv("DEVICE")=="PIC18LF2550") || \
....................        (getenv("DEVICE")=="PIC18LF4455") || (getenv("DEVICE")=="PIC18LF4550") || \
....................        (getenv("DEVICE")=="PIC18LF2458") || (getenv("DEVICE")=="PIC18LF2553") || \
....................        (getenv("DEVICE")=="PIC18LF4458") || (getenv("DEVICE")=="PIC18LF4553") \
....................        )
....................  #define __USB_4550__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") || \
....................        (getenv("DEVICE")=="PIC18LF26J53") || (getenv("DEVICE")=="PIC18LF27J53") || \ 
....................        (getenv("DEVICE")=="PIC18LF46J53") || (getenv("DEVICE")=="PIC18LF47J53") \       
....................        )
....................  #define __USB_18FJ53__
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use
....................  #define USB_BDT_START  0xD00
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F97J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F87J94") ||  \
....................        (getenv("DEVICE")=="PIC18F67J94") ||  \
....................        (getenv("DEVICE")=="PIC18F96J99") ||  \
....................        (getenv("DEVICE")=="PIC18F86J99") ||  \
....................        (getenv("DEVICE")=="PIC18F66J99") ||  \
....................        (getenv("DEVICE")=="PIC18F96J94") ||  \
....................        (getenv("DEVICE")=="PIC18F86J94") ||  \
....................        (getenv("DEVICE")=="PIC18F66J94") ||  \
....................        (getenv("DEVICE")=="PIC18F95J94") ||  \
....................        (getenv("DEVICE")=="PIC18F85J94") ||  \
....................        (getenv("DEVICE")=="PIC18F65J94"))
....................  #define __USB_18FJ94__
....................  #define USB_BDT_START  0x100
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library.
.................... #endif
.................... 
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  15
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  14
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  13
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  12
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  11
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  10
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  9
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  8
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  7
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  6
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  5
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  4
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  3
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  2
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  1
.................... #else
....................  #define USB_LAST_DEFINED_ENDPOINT  0
.................... #endif
.................... 
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8)
.................... 
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)
.................... 
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT)
....................  #error You are trying to use an invalid endpoint for this hardware!
.................... #endif
.................... 
.................... typedef struct
.................... {
....................    unsigned int8 stat;
....................    unsigned int8 cnt;
....................    unsigned int16 addr;
.................... } STRUCT_BD;
.................... 
.................... #if defined(USB_RAM_START) && !defined(USB_BDT_START)
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       struct
....................       {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................       } bd[USB_LAST_DEFINED_ENDPOINT+1];
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM.buffer)
....................    
....................    #locate g_USBRAM=USB_RAM_START
....................    
....................    #define g_USBBDT g_USBRAM.bd
.................... #else
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #if defined(USB_RAM_START)
....................       #locate g_USBRAM=USB_RAM_START
....................    #endif
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM)
....................    
....................    struct
....................    {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................    } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1];
....................    
....................    #locate g_USBBDT=USB_BDT_START
.................... #endif
.................... 
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer
.................... 
.................... //these buffer definitions needed for CDC library
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer
.................... 
.................... //if you enable this it will keep a counter of the 6 possible errors the
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time.
.................... #if !defined(USB_USE_ERROR_COUNTER)
....................    #define USB_USE_ERROR_COUNTER false
.................... #endif
.................... 
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints
.................... 
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS!
.................... #if !defined(USB_PING_PONG_MODE)
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF
.................... #endif
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................    unsigned int ERROR_COUNTER[6];
.................... #endif
.................... 
.................... //---pic18fxx5x memory locations
.................... #if defined(__USB_4550__) || defined(__USB_4450__)
....................    #byte UFRML   =  0xF66
....................    #byte UFRMH   =  0xF67
....................    #byte UIR     =  0xF68
....................    #byte UIE     =  0xF69
....................    #byte UEIR    =  0xF6A
....................    #byte UEIE    =  0xF6B
....................    #byte U1STAT   =  0xF6C
....................    #byte UCON    =  0xF6D
....................    #byte UADDR   =  0xF6E
....................    #byte UCFG    =  0xF6F
....................    #define  UEP0_LOC 0xF70
.................... #elif defined(__USB_46J50__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #elif defined(__USB_14K50__)
....................    #byte UFRML   =  0xF5D
....................    #byte UFRMH   =  0xF5E
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF60
....................    #byte UEIR    =  0xF5F
....................    #byte UEIE    =  0xF5B
....................    #byte U1STAT   =  0xF63
....................    #byte UCON    =  0xF64
....................    #byte UADDR   =  0xF5C
....................    #byte UCFG    =  0xF61
....................    #define  UEP0_LOC 0xF53
.................... #elif defined(__USB_18FJ53__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #else
....................    #byte UFRML = getenv("SFR:UFRML")
....................    #byte UFRMH = getenv("SFR:UFRMH")
....................    #byte UIR = getenv("SFR:UIR")
....................    #byte UIE = getenv("SFR:UIE")
....................    #byte UEIR = getenv("SFR:UEIR")
....................    #byte UEIE = getenv("SFR:UEIE")
....................    #byte U1STAT = getenv("SFR:USTAT")
....................    #byte UCON = getenv("SFR:UCON")
....................    #byte UADDR = getenv("SFR:UADDR")
....................    #byte UCFG = getenv("SFR:UCFG")
.................... #endif
.................... 
.................... unsigned int8 USTATCopy;
.................... 
.................... unsigned int8 g_UEP[USB_NUM_UEP];
.................... #if defined(UEP0_LOC)
.................... #locate g_UEP=UEP0_LOC
.................... #else
.................... #locate g_UEP=getenv("SFR:UEP0")
.................... #endif
.................... #define UEP(x) g_UEP[x]
.................... 
.................... #define BIT_SOF   6
.................... #define BIT_STALL 5
.................... #define BIT_IDLE  4
.................... #define BIT_TRN   3
.................... #define BIT_ACTV  2
.................... #define BIT_UERR  1
.................... #define BIT_URST  0
.................... 
.................... #BIT UIR_SOF = UIR.BIT_SOF
.................... #BIT UIR_STALL = UIR.BIT_STALL
.................... #BIT UIR_IDLE = UIR.BIT_IDLE
.................... #BIT UIR_TRN = UIR.BIT_TRN
.................... #BIT UIR_ACTV = UIR.BIT_ACTV
.................... #BIT UIR_UERR = UIR.BIT_UERR
.................... #BIT UIR_URST = UIR.BIT_URST
.................... 
.................... #BIT UIE_SOF = UIE.BIT_SOF
.................... #BIT UIE_STALL = UIE.BIT_STALL
.................... #BIT UIE_IDLE = UIE.BIT_IDLE
.................... #BIT UIE_TRN = UIE.BIT_TRN
.................... #BIT UIE_ACTV = UIE.BIT_ACTV
.................... #BIT UIE_UERR = UIE.BIT_UERR
.................... #BIT UIE_URST = UIE.BIT_URST
.................... 
.................... #if getenv("BIT_VALID:PPBRST")
....................    #bit UCON_PPBRST = getenv("BIT:PPBRST")
.................... #endif
.................... #bit UCON_SE0=UCON.5
.................... #bit UCON_PKTDIS=UCON.4
.................... #bit UCON_USBEN=UCON.3
.................... #bit UCON_RESUME=UCON.2
.................... #bit UCON_SUSPND=UCON.1
.................... 
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF)
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr
.................... #else
.................... #error Right now this driver only supports no ping pong
.................... #endif
.................... 
.................... //See UEPn (0xF70-0xF7F)
.................... #define ENDPT_DISABLED   0x00   //endpoint not used
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions
.................... 
.................... //Define the states that the USB interface can be in
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3,
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state;
.................... 
.................... //--BDendST has their PIDs upshifed 2
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction
.................... 
.................... #define USTAT_IN_E0        4
.................... #define USTAT_OUT_SETUP_E0 0
.................... 
.................... #define __USB_UIF_RESET    0x01
.................... #define __USB_UIF_ERROR    0x02
.................... #define __USB_UIF_ACTIVE   0x04
.................... #define __USB_UIF_TOKEN    0x08
.................... #define __USB_UIF_IDLE     0x10
.................... #define __USB_UIF_STALL    0x20
.................... #define __USB_UIF_SOF      0x40
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET
.................... #else
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET
.................... #endif
.................... 
.................... #define __USB_UCFG_UTEYE   0x80
.................... #if defined(__USB_4550__)
....................  #define __USB_UCFG_UOEMON  0x40
.................... #endif
.................... #define __USB_UCFG_UPUEN   0x10
.................... #if !defined(__USB_14K50__)
....................  #define __USB_UCFG_UTRDIS  0x08
.................... #endif
.................... #define __USB_UCFG_FSEN    0x04
.................... 
.................... #if defined(USB_EXTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  0
.................... #endif
.................... 
.................... #if defined(USB_INTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if !defined(__USB_UCFG_MY_UPUEN)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if USB_USE_FULL_SPEED
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE)
.................... #else
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE);
.................... #endif
.................... 
.................... #if defined(__USB_UCFG_UTRDIS)
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS
.................... #else
....................  #define __UCFG_VAL_DISABLED__   0
.................... #endif
.................... 
.................... 
.................... unsigned int8 __setup_0_tx_size;
.................... 
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only
.................... void usb_handle_interrupt();
.................... void usb_isr_rst();
.................... void usb_isr_uerr();
.................... void usb_isr_sof(void);
.................... void usb_isr_activity();
.................... void usb_isr_uidle();
.................... void usb_isr_tok_dne();
.................... void usb_isr_stall(void);
.................... void usb_init_ep0_setup(void);
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... void usb_isr(void);
.................... #endif
.................... 
.................... //// BEGIN User Functions:
.................... 
.................... // see usb_hw_layer.h for more documentation
.................... int1 usb_kbhit(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7)));
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_tbe(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7)));
*
0E30:  CLRF   03
0E32:  MOVLB  2
0E34:  MOVF   x56,W
0E36:  ADDLW  70
0E38:  MOVWF  FE9
0E3A:  MOVLW  0F
0E3C:  ADDWFC 03,W
0E3E:  MOVWF  FEA
0E40:  MOVF   FEF,F
0E42:  BZ    0E7A
0E44:  CLRF   x58
0E46:  MOVFF  256,257
0E4A:  CLRF   x5A
0E4C:  MOVLW  08
0E4E:  MOVWF  x59
0E50:  MOVLB  0
0E52:  CALL   04A2
0E56:  MOVFF  02,258
0E5A:  MOVFF  01,257
0E5E:  MOVLW  04
0E60:  MOVLB  2
0E62:  ADDWF  x57,F
0E64:  MOVLW  00
0E66:  ADDWFC x58,F
0E68:  MOVFF  257,FE9
0E6C:  MOVLW  04
0E6E:  ADDWF  x58,W
0E70:  MOVWF  FEA
0E72:  MOVFF  FEF,259
0E76:  BTFSS  x59.7
0E78:  BRA    0E7E
0E7A:  MOVLW  00
0E7C:  BRA    0E80
0E7E:  MOVLW  01
0E80:  MOVWF  01
0E82:  MOVLB  0
0E84:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_detach(void)
.................... {
....................    UCON_SUSPND = 0;
*
1508:  BCF    F6D.1
....................    UCON = 0;  //disable USB hardware
150A:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts
150C:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__;
150E:  MOVLW  08
1510:  MOVWF  F6F
.................... 
....................    // set D+/D- to inputs
....................   #if defined(__USB_87J50__)
....................    set_tris_f(get_tris_f() | 0x18);
....................   #elif defined(__USB_14K50__)
....................    set_tris_a(get_tris_a() | 0x3);
....................   #elif defined(__USB_18FJ94__)
....................    output_float(PIN_F4);
....................    output_float(PIN_F3);
....................   #elif !defined(USB_PIC_NO_USB_GPIO)
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5
1512:  MOVF   F94,W
1514:  IORLW  30
1516:  MOVLB  2
1518:  MOVWF  F94
....................   #endif
....................   
....................    usb_state = USB_STATE_DETACHED;
151A:  CLRF   22
151C:  CLRF   19
151E:  BTFSC  FF2.7
1520:  BSF    19.7
1522:  BCF    FF2.7
....................    
....................    usb_token_reset();              //clear the chapter9 stack
1524:  MOVLB  0
1526:  CALL   0592
152A:  BTFSC  19.7
152C:  BSF    FF2.7
152E:  RETURN 0
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_attach(void) 
*
153C:  CLRF   19
153E:  BTFSC  FF2.7
1540:  BSF    19.7
1542:  BCF    FF2.7
.................... {
....................    usb_token_reset();
1544:  CALL   0592
1548:  BTFSC  19.7
154A:  BSF    FF2.7
....................    UCON_SUSPND = 0;
154C:  BCF    F6D.1
....................    UCON = 0;
154E:  CLRF   F6D
....................   #if getenv("BIT_VALID:PPBRST")
....................    UCON_PPBRST = 1;
1550:  BSF    F6D.6
....................    delay_cycles(5);
1552:  BRA    1554
1554:  BRA    1556
1556:  NOP   
....................    UCON_PPBRST = 0;
1558:  BCF    F6D.6
....................   #endif
....................    UCFG = __UCFG_VAL_ENABLED__;
155A:  MOVLW  14
155C:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts
155E:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus
1560:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h
1562:  MOVLW  01
1564:  MOVWF  22
1566:  GOTO   158A (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init_cs(void)
.................... {
....................    usb_detach();
*
1530:  RCALL  1508
1532:  GOTO   15B0 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_task(void) 
.................... {
....................   #if defined(USB_ISR_POLLING)
....................    if (interrupt_active(INT_USB))
....................    {
....................       usb_isr();
....................    }
....................   #endif
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_enumerated())
*
156A:  RCALL  1536
156C:  MOVF   01,F
156E:  BZ    157E
1570:  CLRF   19
1572:  BTFSC  FF2.7
1574:  BSF    19.7
1576:  BCF    FF2.7
....................    {
....................       usb_cdc_flush_tx_buffer();
1578:  RCALL  1248
157A:  BTFSC  19.7
157C:  BSF    FF2.7
....................    }
....................   #endif
.................... 
....................    if (usb_attached()) 
157E:  BSF    F93.2
1580:  BTFSS  F81.2
1582:  BRA    158C
....................    {
....................       if (UCON_USBEN==0) 
1584:  BTFSC  F6D.3
1586:  BRA    158A
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: ATTACH");
....................          usb_attach();
1588:  BRA    153C
....................       }
....................    }
158A:  BRA    1592
....................    else 
....................    {
....................       if (UCON_USBEN==1)  
158C:  BTFSS  F6D.3
158E:  BRA    1592
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: DE-ATTACH");
....................          usb_detach();
1590:  RCALL  1508
....................       }
....................    }
.................... 
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) 
1592:  DECFSZ 22,W
1594:  BRA    15AC
1596:  BTFSC  F6D.5
1598:  BRA    15AC
....................    {
....................       UIR = 0;
159A:  CLRF   F68
....................       UIE = 0;
159C:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING)
....................       enable_interrupts(INT_USB);
159E:  BSF    FA0.5
....................       enable_interrupts(GLOBAL);
15A0:  MOVLW  C0
15A2:  IORWF  FF2,F
....................      #endif
....................       UIE = __USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR
15A4:  MOVLW  11
15A6:  MOVWF  F69
....................      #if USB_USE_ERROR_COUNTER
....................       UIE |= __USB_UIF_ERROR;
....................      #endif
....................       usb_state=USB_STATE_POWERED;
15A8:  MOVLW  02
15AA:  MOVWF  22
....................       debug_usb_control(debug_putc, "\r\n\nUSB TASK: POWERED");
....................    }
15AC:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init(void) 
.................... {
....................    usb_init_cs();
15AE:  BRA    1530
.................... 
....................    do 
....................    {
....................       usb_task();
15B0:  RCALL  156A
....................    } while (usb_state != USB_STATE_POWERED);
15B2:  MOVF   22,W
15B4:  SUBLW  02
15B6:  BNZ   15B0
15B8:  GOTO   3C4E (RETURN)
.................... }
.................... 
.................... 
.................... // see pic18_usb.h for documentation
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
.................... 
....................    debug_usb_packet(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len);
.................... 
....................    if (usb_tbe(endpoint)) 
*
0E86:  MOVFF  251,256
0E8A:  RCALL  0E30
0E8C:  MOVF   01,F
0E8E:  BTFSC  FD8.2
0E90:  BRA    0FC8
....................    {
....................       EP_BDxCNT_I(endpoint)=len;
0E92:  MOVLB  2
0E94:  CLRF   x58
0E96:  MOVFF  251,257
0E9A:  CLRF   x5A
0E9C:  MOVLW  08
0E9E:  MOVWF  x59
0EA0:  MOVLB  0
0EA2:  CALL   04A2
0EA6:  MOVFF  02,257
0EAA:  MOVFF  01,256
0EAE:  MOVLW  04
0EB0:  MOVLB  2
0EB2:  ADDWF  x56,F
0EB4:  MOVLW  00
0EB6:  ADDWFC x57,F
0EB8:  MOVLW  01
0EBA:  ADDWF  x56,W
0EBC:  MOVWF  01
0EBE:  MOVLW  00
0EC0:  ADDWFC x57,W
0EC2:  MOVWF  03
0EC4:  MOVFF  01,FE9
0EC8:  MOVLW  04
0ECA:  ADDWF  03,W
0ECC:  MOVWF  FEA
0ECE:  MOVFF  252,FEF
.................... 
....................       debug_display_ram(len, EP_BDxADR_I(endpoint));
.................... 
....................      #if USB_IGNORE_TX_DTS
....................       i=0x80;
....................      #else
....................       if (tgl == USB_DTS_TOGGLE) 
0ED2:  MOVF   x54,W
0ED4:  SUBLW  02
0ED6:  BNZ   0F18
....................       {
....................          i = EP_BDxST_I(endpoint);
0ED8:  CLRF   x58
0EDA:  MOVFF  251,257
0EDE:  CLRF   x5A
0EE0:  MOVLW  08
0EE2:  MOVWF  x59
0EE4:  MOVLB  0
0EE6:  CALL   04A2
0EEA:  MOVFF  02,257
0EEE:  MOVFF  01,256
0EF2:  MOVLW  04
0EF4:  MOVLB  2
0EF6:  ADDWF  x56,F
0EF8:  MOVLW  00
0EFA:  ADDWFC x57,F
0EFC:  MOVFF  256,FE9
0F00:  MOVLW  04
0F02:  ADDWF  x57,W
0F04:  MOVWF  FEA
0F06:  MOVFF  FEF,255
....................          if (bit_test(i,6))
0F0A:  BTFSS  x55.6
0F0C:  BRA    0F12
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0F0E:  CLRF   x54
0F10:  BRA    0F16
....................          else
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0F12:  MOVLW  01
0F14:  MOVWF  x54
....................       }
0F16:  BRA    0F4C
....................       else if (tgl == USB_DTS_USERX) 
0F18:  MOVF   x54,W
0F1A:  SUBLW  04
0F1C:  BNZ   0F4C
....................       {
....................          i = EP_BDxST_O(endpoint);
0F1E:  CLRF   x58
0F20:  MOVFF  251,257
0F24:  CLRF   x5A
0F26:  MOVLW  08
0F28:  MOVWF  x59
0F2A:  MOVLB  0
0F2C:  CALL   04A2
0F30:  MOVLB  2
0F32:  MOVFF  01,FE9
0F36:  MOVLW  04
0F38:  ADDWF  02,W
0F3A:  MOVWF  FEA
0F3C:  MOVFF  FEF,255
....................          if (bit_test(i,6))
0F40:  BTFSS  x55.6
0F42:  BRA    0F4A
....................             tgl = USB_DTS_DATA1;
0F44:  MOVLW  01
0F46:  MOVWF  x54
0F48:  BRA    0F4C
....................          else
....................             tgl = USB_DTS_DATA0;
0F4A:  CLRF   x54
....................       }
....................       if (tgl == USB_DTS_DATA1) 
0F4C:  DECFSZ x54,W
0F4E:  BRA    0F56
....................          i=0x48;  //DATA1, UOWN  //change mar2015
0F50:  MOVLW  48
0F52:  MOVWF  x55
0F54:  BRA    0F5A
....................       else //if (tgl == USB_DTS_DATA0) 
....................          i=0x08; //DATA0, UOWN   //change mar2015
0F56:  MOVLW  08
0F58:  MOVWF  x55
....................      #endif
.................... 
....................       //set BC8 and BC9
....................       //if (bit_test(len,8)) {bit_set(i,0);}
....................       //if (bit_test(len,9)) {bit_set(i,1);}
.................... 
....................       debug_usb_packet(debug_putc, " %X", i);
.................... 
....................       EP_BDxST_I(endpoint) = i;  //save changes
0F5A:  CLRF   x58
0F5C:  MOVFF  251,257
0F60:  CLRF   x5A
0F62:  MOVLW  08
0F64:  MOVWF  x59
0F66:  MOVLB  0
0F68:  CALL   04A2
0F6C:  MOVFF  02,257
0F70:  MOVFF  01,256
0F74:  MOVLW  04
0F76:  MOVLB  2
0F78:  ADDWF  x56,F
0F7A:  MOVLW  00
0F7C:  ADDWFC x57,F
0F7E:  MOVFF  256,FE9
0F82:  MOVLW  04
0F84:  ADDWF  x57,W
0F86:  MOVWF  FEA
0F88:  MOVFF  255,FEF
....................       
....................       EP_BDxST_I(endpoint) |= 0x80; //change mar2015
0F8C:  CLRF   x58
0F8E:  MOVFF  251,257
0F92:  CLRF   x5A
0F94:  MOVLW  08
0F96:  MOVWF  x59
0F98:  MOVLB  0
0F9A:  CALL   04A2
0F9E:  MOVFF  02,257
0FA2:  MOVFF  01,256
0FA6:  MOVLW  04
0FA8:  MOVLB  2
0FAA:  ADDWF  x56,F
0FAC:  MOVLW  00
0FAE:  ADDWFC x57,F
0FB0:  MOVFF  256,FE9
0FB4:  MOVLW  04
0FB6:  ADDWF  x57,W
0FB8:  MOVWF  FEA
0FBA:  MOVF   FEF,W
0FBC:  IORLW  80
0FBE:  MOVWF  FEF
....................       
....................       //putc('!');
....................       
....................       return(1);
0FC0:  MOVLW  01
0FC2:  MOVWF  01
0FC4:  BRA    0FCE
....................    }
0FC6:  MOVLB  0
....................    else 
....................    {
....................       //putc('_');
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
....................    return(0);
0FC8:  MOVLW  00
0FCA:  MOVWF  01
0FCC:  MOVLB  2
0FCE:  MOVLB  0
0FD0:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 * buff_add;    
.................... 
....................    if (usb_tbe(endpoint)) 
*
10CE:  MOVFF  249,256
10D2:  RCALL  0E30
10D4:  MOVF   01,F
10D6:  BZ    1166
....................    {
....................       buff_add = EP_BDxADR_I(endpoint);
10D8:  MOVLB  2
10DA:  CLRF   x58
10DC:  MOVFF  249,257
10E0:  CLRF   x5A
10E2:  MOVLW  08
10E4:  MOVWF  x59
10E6:  MOVLB  0
10E8:  CALL   04A2
10EC:  MOVFF  02,252
10F0:  MOVFF  01,251
10F4:  MOVLW  04
10F6:  MOVLB  2
10F8:  ADDWF  x51,F
10FA:  MOVLW  00
10FC:  ADDWFC x52,F
10FE:  MOVLW  02
1100:  ADDWF  x51,W
1102:  MOVWF  01
1104:  MOVLW  00
1106:  ADDWFC x52,W
1108:  MOVWF  03
110A:  MOVFF  01,FE9
110E:  MOVLW  04
1110:  ADDWF  03,W
1112:  MOVWF  FEA
1114:  MOVFF  FEC,250
1118:  MOVF   FED,F
111A:  MOVFF  FEF,24F
....................       memcpy(buff_add, ptr, len);     
111E:  MOVFF  250,FEA
1122:  MOVFF  24F,FE9
1126:  MOVFF  24B,FE2
112A:  MOVFF  24A,FE1
112E:  MOVFF  24D,02
1132:  MOVFF  24C,01
1136:  MOVF   01,F
1138:  BZ    113E
113A:  INCF   02,F
113C:  BRA    1142
113E:  MOVF   02,F
1140:  BZ    114E
1142:  MOVFF  FE6,FEE
1146:  DECFSZ 01,F
1148:  BRA    1142
114A:  DECFSZ 02,F
114C:  BRA    1142
....................       
....................       return(usb_flush_in(endpoint, len, tgl));
114E:  MOVFF  249,251
1152:  MOVFF  24D,253
1156:  MOVFF  24C,252
115A:  MOVFF  24E,254
115E:  MOVLB  0
1160:  RCALL  0E86
1162:  MOVF   01,W
1164:  BRA    116A
....................    }
....................    else 
....................    {
....................       //putc('-');
....................       //printf("%X", EP_BDxST_I(endpoint));
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
.................... 
....................    return(0);
1166:  MOVLW  00
1168:  MOVWF  01
116A:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
....................    unsigned int16 len;
.................... 
....................   #if USB_IGNORE_RX_DTS
....................    if (tgl == USB_DTS_STALL) 
....................    {
....................       debug_usb_token(debug_putc, '*');
....................       EP_BDxCNT_O(endpoint) = 0x84;
....................       EP_BDxST_I(endpoint) = 0x84;
....................       return;
....................    }
....................    else
....................       i=0x80;
....................   #else
....................    i = EP_BDxST_O(endpoint);
*
0D30:  MOVLB  2
0D32:  CLRF   x58
0D34:  MOVFF  248,257
0D38:  CLRF   x5A
0D3A:  MOVLW  08
0D3C:  MOVWF  x59
0D3E:  MOVLB  0
0D40:  CALL   04A2
0D44:  MOVLB  2
0D46:  MOVFF  01,FE9
0D4A:  MOVLW  04
0D4C:  ADDWF  02,W
0D4E:  MOVWF  FEA
0D50:  MOVFF  FEF,24A
....................    if (tgl == USB_DTS_TOGGLE) 
0D54:  MOVF   x49,W
0D56:  SUBLW  02
0D58:  BNZ   0D66
....................    {
....................       if (bit_test(i,6))
0D5A:  BTFSS  x4A.6
0D5C:  BRA    0D62
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0D5E:  CLRF   x49
0D60:  BRA    0D66
....................       else
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0D62:  MOVLW  01
0D64:  MOVWF  x49
....................    }
....................    if (tgl == USB_DTS_STALL) 
0D66:  MOVF   x49,W
0D68:  SUBLW  03
0D6A:  BNZ   0DA4
....................    {
....................       i = 0x84;
0D6C:  MOVLW  84
0D6E:  MOVWF  x4A
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints
0D70:  CLRF   x58
0D72:  MOVFF  248,257
0D76:  CLRF   x5A
0D78:  MOVLW  08
0D7A:  MOVWF  x59
0D7C:  MOVLB  0
0D7E:  CALL   04A2
0D82:  MOVFF  02,24E
0D86:  MOVFF  01,24D
0D8A:  MOVLW  04
0D8C:  MOVLB  2
0D8E:  ADDWF  x4D,F
0D90:  MOVLW  00
0D92:  ADDWFC x4E,F
0D94:  MOVFF  24D,FE9
0D98:  MOVLW  04
0D9A:  ADDWF  x4E,W
0D9C:  MOVWF  FEA
0D9E:  MOVLW  84
0DA0:  MOVWF  FEF
....................    }
0DA2:  BRA    0DB2
....................    else if (tgl == USB_DTS_DATA1)
0DA4:  DECFSZ x49,W
0DA6:  BRA    0DAE
....................       i = 0xC8;  //DATA1, UOWN
0DA8:  MOVLW  C8
0DAA:  MOVWF  x4A
0DAC:  BRA    0DB2
....................    else //if (tgl == USB_DTS_DATA0) 
....................       i = 0x88; //DATA0, UOWN
0DAE:  MOVLW  88
0DB0:  MOVWF  x4A
....................   #endif
.................... 
....................    //bit_clear(__usb_kbhit_status,endpoint);
.................... 
....................    len = usb_ep_rx_size[endpoint];
0DB2:  BCF    FD8.0
0DB4:  RLCF   x48,W
0DB6:  CLRF   03
0DB8:  MOVLB  0
0DBA:  CALL   012A
0DBE:  TBLRD*+
0DC0:  MOVFF  FF5,03
0DC4:  MOVLB  2
0DC6:  MOVWF  x4B
0DC8:  MOVFF  03,24C
....................    EP_BDxCNT_O(endpoint) = len;
0DCC:  CLRF   x58
0DCE:  MOVFF  248,257
0DD2:  CLRF   x5A
0DD4:  MOVLW  08
0DD6:  MOVWF  x59
0DD8:  MOVLB  0
0DDA:  CALL   04A2
0DDE:  MOVFF  01,24D
0DE2:  MOVLW  01
0DE4:  MOVLB  2
0DE6:  ADDWF  01,W
0DE8:  MOVWF  01
0DEA:  MOVLW  00
0DEC:  ADDWFC 02,W
0DEE:  MOVWF  03
0DF0:  MOVFF  01,FE9
0DF4:  MOVLW  04
0DF6:  ADDWF  03,W
0DF8:  MOVWF  FEA
0DFA:  MOVFF  24B,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);}
0DFE:  BTFSS  x4C.0
0E00:  BRA    0E04
0E02:  BSF    x4A.0
....................    if (bit_test(len,9)) {bit_set(i,1);}
0E04:  BTFSS  x4C.1
0E06:  BRA    0E0A
0E08:  BSF    x4A.1
.................... 
....................    EP_BDxST_O(endpoint) = i;
0E0A:  CLRF   x58
0E0C:  MOVFF  248,257
0E10:  CLRF   x5A
0E12:  MOVLW  08
0E14:  MOVWF  x59
0E16:  MOVLB  0
0E18:  CALL   04A2
0E1C:  MOVLB  2
0E1E:  MOVFF  01,FE9
0E22:  MOVLW  04
0E24:  ADDWF  02,W
0E26:  MOVWF  FEA
0E28:  MOVFF  24A,FEF
0E2C:  MOVLB  0
0E2E:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint) 
.................... {
....................    return(EP_BDxCNT_O(endpoint));
*
101A:  MOVLB  2
101C:  CLRF   x58
101E:  MOVFF  248,257
1022:  CLRF   x5A
1024:  MOVLW  08
1026:  MOVWF  x59
1028:  MOVLB  0
102A:  CALL   04A2
102E:  MOVFF  02,24A
1032:  MOVFF  01,249
1036:  MOVLW  01
1038:  MOVLB  2
103A:  ADDWF  01,W
103C:  MOVWF  01
103E:  MOVLW  00
1040:  ADDWFC 02,W
1042:  MOVWF  03
1044:  MOVFF  01,FE9
1048:  MOVLW  04
104A:  ADDWF  03,W
104C:  MOVWF  FEA
104E:  MOVFF  FEF,01
1052:  CLRF   02
1054:  MOVLB  0
1056:  GOTO   107A (RETURN)
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN Hardware layer functions required by USB.
.................... 
.................... /*****************************************************************************
.................... /* usb_get_packet_buffer(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer.
.................... /*
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC 
.................... /*          RAM.
.................... /*          Does not mark the endpoint as ready for more data.  Once you are
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready
.................... /*          to receive more data.
.................... /*
.................... /*****************************************************************************/
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) 
.................... {
....................    unsigned int8 * al;
....................    unsigned int8 st;
....................    unsigned int16 i;
.................... 
....................    al = EP_BDxADR_O(endpoint);
....................    i = EP_BDxCNT_O(endpoint);
....................    st = EP_BDxST_O(endpoint);
.................... 
....................    //read BC8 and BC9
....................    if (bit_test(st,0)) {bit_set(i,8);}
....................    if (bit_test(st,1)) {bit_set(i,9);}
.................... 
....................    if (i < max) {max = i;}
....................    
....................    memcpy(ptr, al ,max);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max)
.................... {
....................    max = usb_get_packet_buffer(endpoint, ptr, max);
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_stall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=s%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0B16:  MOVLB  2
0B18:  BCF    x48.0
0B1A:  BTFSC  x47.7
0B1C:  BSF    x48.0
....................    endpoint &= 0x7F;
0B1E:  BCF    x47.7
....................    
....................    if (direction) 
0B20:  BTFSS  x48.0
0B22:  BRA    0B56
....................    {
....................       EP_BDxST_I(endpoint) = 0x84;
0B24:  CLRF   x58
0B26:  MOVFF  247,257
0B2A:  CLRF   x5A
0B2C:  MOVLW  08
0B2E:  MOVWF  x59
0B30:  MOVLB  0
0B32:  RCALL  04A2
0B34:  MOVFF  02,24A
0B38:  MOVFF  01,249
0B3C:  MOVLW  04
0B3E:  MOVLB  2
0B40:  ADDWF  x49,F
0B42:  MOVLW  00
0B44:  ADDWFC x4A,F
0B46:  MOVFF  249,FE9
0B4A:  MOVLW  04
0B4C:  ADDWF  x4A,W
0B4E:  MOVWF  FEA
0B50:  MOVLW  84
0B52:  MOVWF  FEF
....................    }
0B54:  BRA    0B76
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x84;
0B56:  CLRF   x58
0B58:  MOVFF  247,257
0B5C:  CLRF   x5A
0B5E:  MOVLW  08
0B60:  MOVWF  x59
0B62:  MOVLB  0
0B64:  RCALL  04A2
0B66:  MOVLB  2
0B68:  MOVFF  01,FE9
0B6C:  MOVLW  04
0B6E:  ADDWF  02,W
0B70:  MOVWF  FEA
0B72:  MOVLW  84
0B74:  MOVWF  FEF
....................    }
0B76:  MOVLB  0
0B78:  GOTO   0C26 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_unstall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=u%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0A9C:  MOVLB  2
0A9E:  BCF    x48.0
0AA0:  BTFSC  x47.7
0AA2:  BSF    x48.0
....................    endpoint &= 0x7F;
0AA4:  BCF    x47.7
....................    
....................    if (direction) 
0AA6:  BTFSS  x48.0
0AA8:  BRA    0ADC
....................    {
....................      #if USB_IGNORE_RX_DTS
....................       EP_BDxST_I(endpoint) = 0x80;
....................      #else
....................       EP_BDxST_I(endpoint) = 0x88;
0AAA:  CLRF   x58
0AAC:  MOVFF  247,257
0AB0:  CLRF   x5A
0AB2:  MOVLW  08
0AB4:  MOVWF  x59
0AB6:  MOVLB  0
0AB8:  RCALL  04A2
0ABA:  MOVFF  02,24A
0ABE:  MOVFF  01,249
0AC2:  MOVLW  04
0AC4:  MOVLB  2
0AC6:  ADDWF  x49,F
0AC8:  MOVLW  00
0ACA:  ADDWFC x4A,F
0ACC:  MOVFF  249,FE9
0AD0:  MOVLW  04
0AD2:  ADDWF  x4A,W
0AD4:  MOVWF  FEA
0AD6:  MOVLW  88
0AD8:  MOVWF  FEF
....................      #endif
....................    }
0ADA:  BRA    0AFA
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x00;
0ADC:  CLRF   x58
0ADE:  MOVFF  247,257
0AE2:  CLRF   x5A
0AE4:  MOVLW  08
0AE6:  MOVWF  x59
0AE8:  MOVLB  0
0AEA:  RCALL  04A2
0AEC:  MOVLB  2
0AEE:  MOVFF  01,FE9
0AF2:  MOVLW  04
0AF4:  ADDWF  02,W
0AF6:  MOVWF  FEA
0AF8:  CLRF   FEF
....................    }
....................    
....................   #if defined(__STALL_ON_UEP_ERRATA__)
....................    bit_clear(UEP(endpoint), 0);
0AFA:  CLRF   03
0AFC:  MOVF   x47,W
0AFE:  ADDLW  70
0B00:  MOVWF  01
0B02:  MOVLW  0F
0B04:  ADDWFC 03,F
0B06:  MOVFF  01,FE9
0B0A:  MOVFF  03,FEA
0B0E:  BCF    FEF.0
....................   #endif
0B10:  MOVLB  0
0B12:  GOTO   0C16 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    unsigned int8 st;
....................    
....................    direction = bit_test(endpoint,7);
*
0B7C:  MOVLB  2
0B7E:  BCF    x48.0
0B80:  BTFSC  x47.7
0B82:  BSF    x48.0
....................    endpoint &= 0x7F;
0B84:  BCF    x47.7
....................    
....................    if (direction) 
0B86:  BTFSS  x48.0
0B88:  BRA    0BBC
....................    {
....................       st=EP_BDxST_I(endpoint);
0B8A:  CLRF   x58
0B8C:  MOVFF  247,257
0B90:  CLRF   x5A
0B92:  MOVLW  08
0B94:  MOVWF  x59
0B96:  MOVLB  0
0B98:  RCALL  04A2
0B9A:  MOVFF  02,24B
0B9E:  MOVFF  01,24A
0BA2:  MOVLW  04
0BA4:  MOVLB  2
0BA6:  ADDWF  x4A,F
0BA8:  MOVLW  00
0BAA:  ADDWFC x4B,F
0BAC:  MOVFF  24A,FE9
0BB0:  MOVLW  04
0BB2:  ADDWF  x4B,W
0BB4:  MOVWF  FEA
0BB6:  MOVFF  FEF,249
....................    }
0BBA:  BRA    0BDC
....................    else 
....................    {
....................       st=EP_BDxST_O(endpoint);
0BBC:  CLRF   x58
0BBE:  MOVFF  247,257
0BC2:  CLRF   x5A
0BC4:  MOVLW  08
0BC6:  MOVWF  x59
0BC8:  MOVLB  0
0BCA:  RCALL  04A2
0BCC:  MOVLB  2
0BCE:  MOVFF  01,FE9
0BD2:  MOVLW  04
0BD4:  ADDWF  02,W
0BD6:  MOVWF  FEA
0BD8:  MOVFF  FEF,249
....................    }
....................    
....................    return(bit_test(st,7) && bit_test(st,2));
0BDC:  BTFSS  x49.7
0BDE:  BRA    0BE4
0BE0:  BTFSC  x49.2
0BE2:  BRA    0BE8
0BE4:  MOVLW  00
0BE6:  BRA    0BEA
0BE8:  MOVLW  01
0BEA:  MOVWF  01
0BEC:  MOVLB  0
0BEE:  GOTO   0C3E (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_address(unsigned int8 address) 
.................... {
....................    UADDR = address;
*
10A6:  MOVFF  248,F6E
....................    
....................    if (address) 
10AA:  MOVLB  2
10AC:  MOVF   x48,F
10AE:  BZ    10B6
....................    {
....................       usb_state = USB_STATE_ADDRESS;
10B0:  MOVLW  04
10B2:  MOVWF  22
....................    }
10B4:  BRA    10BA
....................    else 
....................    {
....................       usb_state = USB_STATE_POWERED;
10B6:  MOVLW  02
10B8:  MOVWF  22
....................    }
10BA:  MOVLB  0
10BC:  GOTO   10CA (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_configured(unsigned int8 config) 
.................... {
....................    unsigned int8 en;
....................    unsigned int16 addy;
....................    unsigned int8 new_uep;
....................    unsigned int16 len;
....................    unsigned int8 i;
....................    
....................    if (config == 0)
*
0752:  MOVLB  2
0754:  MOVF   x47,F
0756:  BNZ   0764
....................    {
....................       // if config=0 then set addressed state
....................       usb_state = USB_STATE_ADDRESS;
0758:  MOVLW  04
075A:  MOVWF  22
....................       usb_disable_endpoints();
075C:  MOVLB  0
075E:  RCALL  0534
....................    }
0760:  BRA    0938
0762:  MOVLB  2
....................    else 
....................    {
....................       // else set configed state
....................       usb_state = USB_STATE_CONFIGURED; 
0764:  MOVLW  05
0766:  MOVWF  22
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH);
0768:  MOVLW  04
076A:  MOVWF  x4A
076C:  MOVLW  98
076E:  MOVWF  x49
....................       for (en=1; en<USB_NUM_UEP; en++) 
0770:  MOVLW  01
0772:  MOVWF  x48
0774:  MOVF   x48,W
0776:  SUBLW  0F
0778:  BTFSS  FD8.0
077A:  BRA    0938
....................       {
....................          // enable and config endpoints based upon user configuration
....................          usb_disable_endpoint(en);
077C:  MOVFF  248,250
0780:  MOVLB  0
0782:  RCALL  04C4
....................          new_uep = 0;
0784:  MOVLB  2
0786:  CLRF   x4B
....................          if (usb_ep_rx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
0788:  CLRF   03
078A:  MOVF   x48,W
078C:  MOVLB  0
078E:  RCALL  00DA
0790:  SUBLW  FF
0792:  BZ    0862
....................          {
....................             new_uep = 0x04;
0794:  MOVLW  04
0796:  MOVLB  2
0798:  MOVWF  x4B
....................             len = usb_ep_rx_size[en];
079A:  BCF    FD8.0
079C:  RLCF   x48,W
079E:  CLRF   03
07A0:  MOVLB  0
07A2:  RCALL  012A
07A4:  TBLRD*+
07A6:  MOVFF  FF5,03
07AA:  MOVLB  2
07AC:  MOVWF  x4C
07AE:  MOVFF  03,24D
....................             EP_BDxCNT_O(en) = len;
07B2:  CLRF   x58
07B4:  MOVFF  248,257
07B8:  CLRF   x5A
07BA:  MOVLW  08
07BC:  MOVWF  x59
07BE:  MOVLB  0
07C0:  RCALL  04A2
07C2:  MOVFF  01,24F
07C6:  MOVLW  01
07C8:  MOVLB  2
07CA:  ADDWF  01,W
07CC:  MOVWF  01
07CE:  MOVLW  00
07D0:  ADDWFC 02,W
07D2:  MOVWF  03
07D4:  MOVFF  01,FE9
07D8:  MOVLW  04
07DA:  ADDWF  03,W
07DC:  MOVWF  FEA
07DE:  MOVFF  24C,FEF
....................             EP_BDxADR_O(en) = addy;
07E2:  CLRF   x58
07E4:  MOVFF  248,257
07E8:  CLRF   x5A
07EA:  MOVLW  08
07EC:  MOVWF  x59
07EE:  MOVLB  0
07F0:  RCALL  04A2
07F2:  MOVFF  01,24F
07F6:  MOVLW  02
07F8:  MOVLB  2
07FA:  ADDWF  01,W
07FC:  MOVWF  01
07FE:  MOVLW  00
0800:  ADDWFC 02,W
0802:  MOVWF  03
0804:  MOVFF  01,FE9
0808:  MOVLW  04
080A:  ADDWF  03,W
080C:  MOVWF  FEA
080E:  MOVFF  24A,FEC
0812:  MOVF   FED,F
0814:  MOVFF  249,FEF
....................             addy += usb_ep_rx_size[en];
0818:  BCF    FD8.0
081A:  RLCF   x48,W
081C:  CLRF   03
081E:  MOVLB  0
0820:  RCALL  012A
0822:  TBLRD*+
0824:  MOVFF  FF5,03
0828:  MOVLB  2
082A:  ADDWF  x49,F
082C:  MOVF   03,W
082E:  ADDWFC x4A,F
....................            #if USB_IGNORE_RX_DTS
....................             i = 0x80;
....................            #else
....................             i = 0x88;
0830:  MOVLW  88
0832:  MOVWF  x4E
....................            #endif
....................             if (bit_test(len,8)) {bit_set(i,0);}
0834:  BTFSS  x4D.0
0836:  BRA    083A
0838:  BSF    x4E.0
....................             if (bit_test(len,9)) {bit_set(i,1);}
083A:  BTFSS  x4D.1
083C:  BRA    0840
083E:  BSF    x4E.1
....................             EP_BDxST_O(en) = i;
0840:  CLRF   x58
0842:  MOVFF  248,257
0846:  CLRF   x5A
0848:  MOVLW  08
084A:  MOVWF  x59
084C:  MOVLB  0
084E:  RCALL  04A2
0850:  MOVLB  2
0852:  MOVFF  01,FE9
0856:  MOVLW  04
0858:  ADDWF  02,W
085A:  MOVWF  FEA
085C:  MOVFF  24E,FEF
0860:  MOVLB  0
....................          }
....................          if (usb_ep_tx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
0862:  CLRF   03
0864:  MOVLB  2
0866:  MOVF   x48,W
0868:  MOVLB  0
086A:  RCALL  00BA
086C:  SUBLW  FF
086E:  BZ    0900
....................          {
....................             new_uep |= 0x02;
0870:  MOVLB  2
0872:  BSF    x4B.1
....................             EP_BDxADR_I(en) = addy;
0874:  CLRF   x58
0876:  MOVFF  248,257
087A:  CLRF   x5A
087C:  MOVLW  08
087E:  MOVWF  x59
0880:  MOVLB  0
0882:  RCALL  04A2
0884:  MOVFF  02,250
0888:  MOVFF  01,24F
088C:  MOVLW  04
088E:  MOVLB  2
0890:  ADDWF  x4F,F
0892:  MOVLW  00
0894:  ADDWFC x50,F
0896:  MOVLW  02
0898:  ADDWF  x4F,W
089A:  MOVWF  01
089C:  MOVLW  00
089E:  ADDWFC x50,W
08A0:  MOVWF  03
08A2:  MOVFF  01,FE9
08A6:  MOVLW  04
08A8:  ADDWF  03,W
08AA:  MOVWF  FEA
08AC:  MOVFF  24A,FEC
08B0:  MOVF   FED,F
08B2:  MOVFF  249,FEF
....................             addy += usb_ep_tx_size[en];
08B6:  BCF    FD8.0
08B8:  RLCF   x48,W
08BA:  CLRF   03
08BC:  MOVLB  0
08BE:  RCALL  00FA
08C0:  TBLRD*+
08C2:  MOVFF  FF5,03
08C6:  MOVLB  2
08C8:  ADDWF  x49,F
08CA:  MOVF   03,W
08CC:  ADDWFC x4A,F
....................             EP_BDxST_I(en) = 0x40;
08CE:  CLRF   x58
08D0:  MOVFF  248,257
08D4:  CLRF   x5A
08D6:  MOVLW  08
08D8:  MOVWF  x59
08DA:  MOVLB  0
08DC:  RCALL  04A2
08DE:  MOVFF  02,250
08E2:  MOVFF  01,24F
08E6:  MOVLW  04
08E8:  MOVLB  2
08EA:  ADDWF  x4F,F
08EC:  MOVLW  00
08EE:  ADDWFC x50,F
08F0:  MOVFF  24F,FE9
08F4:  MOVLW  04
08F6:  ADDWF  x50,W
08F8:  MOVWF  FEA
08FA:  MOVLW  40
08FC:  MOVWF  FEF
08FE:  MOVLB  0
....................          }
....................          if (new_uep == 0x06) {new_uep = 0x0E;}
0900:  MOVLB  2
0902:  MOVF   x4B,W
0904:  SUBLW  06
0906:  BNZ   090C
0908:  MOVLW  0E
090A:  MOVWF  x4B
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;}
090C:  CLRF   03
090E:  MOVF   x48,W
0910:  MOVLB  0
0912:  CALL   00BA
0916:  SUBLW  01
0918:  BZ    0920
091A:  MOVLB  2
091C:  BSF    x4B.4
091E:  MOVLB  0
....................          
....................          UEP(en) = new_uep;
0920:  CLRF   03
0922:  MOVLB  2
0924:  MOVF   x48,W
0926:  ADDLW  70
0928:  MOVWF  FE9
092A:  MOVLW  0F
092C:  ADDWFC 03,W
092E:  MOVWF  FEA
0930:  MOVFF  24B,FEF
0934:  INCF   x48,F
0936:  BRA    0774
0938:  MOVLB  0
....................       }
....................    }
093A:  GOTO   09E6 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoint(unsigned int8 en) 
.................... {
....................    UEP(en) = ENDPT_DISABLED;
*
04C4:  CLRF   03
04C6:  MOVLB  2
04C8:  MOVF   x50,W
04CA:  ADDLW  70
04CC:  MOVWF  FE9
04CE:  MOVLW  0F
04D0:  ADDWFC 03,W
04D2:  MOVWF  FEA
04D4:  CLRF   FEF
....................    
....................    if (usb_endpoint_is_valid(en))
04D6:  MOVFF  250,251
04DA:  MOVLB  0
04DC:  RCALL  0454
04DE:  MOVF   01,F
04E0:  BZ    0532
....................    {
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary      
04E2:  MOVLB  2
04E4:  CLRF   x58
04E6:  MOVFF  250,257
04EA:  CLRF   x5A
04EC:  MOVLW  08
04EE:  MOVWF  x59
04F0:  MOVLB  0
04F2:  RCALL  04A2
04F4:  MOVLB  2
04F6:  MOVFF  01,FE9
04FA:  MOVLW  04
04FC:  ADDWF  02,W
04FE:  MOVWF  FEA
0500:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary
0502:  CLRF   x58
0504:  MOVFF  250,257
0508:  CLRF   x5A
050A:  MOVLW  08
050C:  MOVWF  x59
050E:  MOVLB  0
0510:  RCALL  04A2
0512:  MOVFF  02,252
0516:  MOVFF  01,251
051A:  MOVLW  04
051C:  MOVLB  2
051E:  ADDWF  x51,F
0520:  MOVLW  00
0522:  ADDWFC x52,F
0524:  MOVFF  251,FE9
0528:  MOVLW  04
052A:  ADDWF  x52,W
052C:  MOVWF  FEA
052E:  CLRF   FEF
0530:  MOVLB  0
....................    }
0532:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoints(void) 
.................... {
....................    unsigned int8 i;
....................    
....................    for (i=1; i<USB_NUM_UEP; i++)
0534:  MOVLW  01
0536:  MOVLB  2
0538:  MOVWF  x4F
053A:  MOVF   x4F,W
053C:  SUBLW  0F
053E:  BNC   054E
....................       usb_disable_endpoint(i);
0540:  MOVFF  24F,250
0544:  MOVLB  0
0546:  RCALL  04C4
0548:  MOVLB  2
054A:  INCF   x4F,F
054C:  BRA    053A
054E:  MOVLB  0
0550:  RETURN 0
....................       
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... /// END Hardware layer functions required by USB.C
.................... 
.................... 
.................... /// BEGIN USB Interrupt Service Routine
.................... 
.................... static void usb_clear_trn(void)
.................... {
....................    //UIR_TRN = 0;
....................    //delay_cycles(6);
....................    UIR &= ~(1 << BIT_TRN);
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_handle_interrupt()
.................... /*
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished
.................... /*          tokens is the majority of this code, and is handled by usb.c
.................... /*
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt 
.................... /*       method), then you must call this function rapidly.  If there is more 
.................... /*       than 10ms latency the PC may think the USB device is stalled and
.................... /*       disable it.
.................... /*       To switch to a polling method, remove the #int_usb line above this 
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the 
.................... /*       USB interrupt.
.................... /******************************************************************************/
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR)
.................... #int_usb NOCLEAR
.................... #endif
.................... void usb_isr(void)
.................... {
....................    unsigned int8 TRNAttempts;
....................    
....................    clear_interrupt(INT_USB);
*
13EE:  BCF    FA1.5
....................    
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though
13F0:  MOVF   22,F
13F2:  BTFSC  FD8.2
13F4:  BRA    146E
....................    if (UIR) 
13F6:  MOVF   F68,F
13F8:  BTFSC  FD8.2
13FA:  BRA    146E
....................    {
....................       //debug_usb(debug_putc,"\r\n\n[%X] ",UIR);
.................... 
....................       //activity detected.  (only enable after sleep)
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}
13FC:  BTFSS  F68.2
13FE:  BRA    1406
1400:  BTFSC  F69.2
1402:  GOTO   0402
.................... 
....................       if (UCON_SUSPND) return;
1406:  BTFSC  F6D.1
1408:  BRA    146E
.................... 
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent
140A:  BTFSS  F68.5
140C:  BRA    1414
140E:  BTFSC  F69.5
1410:  GOTO   043E
.................... 
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected
1414:  BTFSS  F68.1
1416:  BRA    141E
1418:  BTFSC  F69.1
141A:  GOTO   044C
.................... 
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected
141E:  BTFSS  F68.0
1420:  BRA    1428
1422:  BTFSC  F69.0
1424:  GOTO   05C2
.................... 
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep
1428:  BTFSS  F68.4
142A:  BRA    1432
142C:  BTFSC  F69.4
142E:  GOTO   05F2
....................       
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();}
1432:  BTFSS  F68.6
1434:  BRA    143C
1436:  BTFSC  F69.6
1438:  GOTO   05FC
.................... 
....................       TRNAttempts = 0;
143C:  MOVLB  2
143E:  CLRF   x44
....................       do
....................       {
....................          if (UIR_TRN && UIE_TRN) 
1440:  BTFSS  F68.3
1442:  BRA    1458
1444:  BTFSS  F69.3
1446:  BRA    1458
....................          {
....................             USTATCopy = U1STAT;
1448:  MOVFF  F6C,21
....................             usb_clear_trn();
144C:  MOVLB  0
144E:  CALL   0004
....................             usb_isr_tok_dne();
1452:  BRA    12F2
....................          }
1454:  BRA    145C
1456:  MOVLB  2
....................          else
....................             break;
1458:  BRA    1466
145A:  MOVLB  0
....................       } while (TRNAttempts++ < 4);
145C:  MOVLB  2
145E:  MOVF   x44,W
1460:  INCF   x44,F
1462:  SUBLW  03
1464:  BC    1440
.................... 
....................      #if defined(USB_CDC_ISR)
....................       //has to be done here, can't be done until TRN is empty.
....................       if (usb_cdc_kbhit())
1466:  BTFSS  1E.0
1468:  BRA    1470
....................       {
....................          USB_CDC_ISR();
146A:  MOVLB  0
146C:  BRA    13EA
146E:  MOVLB  2
....................       }
....................      #endif
....................    }
1470:  MOVLB  0
1472:  GOTO   006C
.................... }
.................... 
.................... // SOF interrupt not handled.  user must add this depending on application
.................... void usb_isr_sof(void) 
.................... {
....................    //debug_usb(debug_putc, "\r\nSOF");
....................    
....................    //UIR_SOF = 0;
....................    UIR &= ~(1 << BIT_SOF);
*
05FC:  BCF    F68.6
05FE:  GOTO   143C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_rst()
.................... /*
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device
.................... /*          and token handler code to initial state.
.................... /*
.................... /******************************************************************************/
.................... void usb_isr_rst(void) 
.................... {
....................    debug_usb_control(debug_putc,"-R-");
.................... 
....................    UEIE = 0;
*
05C2:  CLRF   F6B
....................    UIE = 0;
05C4:  CLRF   F69
....................    UEIR = 0;
05C6:  CLRF   F6A
....................    UIR = 0;
05C8:  CLRF   F68
.................... 
....................    UADDR = 0;
05CA:  CLRF   F6E
....................    
....................    UEP(0) = ENDPT_DISABLED;
05CC:  CLRF   F70
.................... 
....................    usb_disable_endpoints();
05CE:  RCALL  0534
....................    
....................    usb_token_reset();
05D0:  RCALL  0592
.................... 
....................    UEP(0) = ENDPT_CONTROL | 0x10;
05D2:  MOVLW  16
05D4:  MOVWF  F70
.................... 
....................    while (UIR_TRN) 
05D6:  BTFSS  F68.3
05D8:  BRA    05DE
....................    {
....................       usb_clear_trn();
05DA:  RCALL  0004
05DC:  BRA    05D6
....................    }
.................... 
.................... 
....................    UEIE = 0x9F;
05DE:  MOVLW  9F
05E0:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE;
05E2:  MOVLW  3D
05E4:  MOVWF  F69
.................... 
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled
05E6:  BCF    F6D.4
.................... 
....................    usb_init_ep0_setup();
05E8:  RCALL  0414
.................... 
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state
05EA:  MOVLW  03
05EC:  MOVWF  22
05EE:  GOTO   1428 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_init_ep0_setup()
.................... /*
.................... /* Summary: Configure EP0 to receive setup packets
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_ep0_setup(void) 
.................... {
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH;
*
0414:  MOVLW  40
0416:  MOVLB  4
0418:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION;
041A:  MOVLW  04
041C:  MOVLB  2
041E:  MOVWF  x46
0420:  MOVLW  18
0422:  MOVFF  246,403
0426:  MOVFF  FE8,402
....................    #if USB_IGNORE_RX_DTS
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off
....................    #else
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on
042A:  MOVLW  88
042C:  MOVLB  4
042E:  MOVWF  x00
....................    #endif
.................... 
....................     EP_BDxST_I(0) = 0;
0430:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH;
0432:  MOVLW  04
0434:  MOVWF  x07
0436:  MOVLW  58
0438:  MOVWF  x06
043A:  MOVLB  0
043C:  RETURN 0
.................... }
.................... 
.................... /*******************************************************************************
.................... /* usb_isr_uerr()
.................... /*
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter
.................... /*          will incerement.  If having problems check the status of these 8 bytes.
.................... /*
.................... /* NOTE: This code is not enabled by default.
.................... /********************************************************************************/
.................... void usb_isr_uerr(void)
.................... {
....................   #if USB_USE_ERROR_COUNTER
....................    int ints;
....................   #endif
.................... 
....................    debug_usb_control(debug_putc,"-E%X-",UEIR);
.................... 
....................   #if USB_USE_ERROR_COUNTER
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled
.................... 
....................    if ( bit_test(ints,0) ) 
....................    { 
....................       //increment pid_error counter
....................       //debug_usb(debug_putc,"PID ");
....................       ERROR_COUNTER[0]++;
....................    }
.................... 
....................    if ( bit_test(ints,1) ) 
....................    {  
....................       //increment crc5 error counter
....................       //debug_usb(debug_putc,"CRC5 ");
....................       ERROR_COUNTER[1]++;
....................    }
.................... 
....................    if ( bit_test(ints,2) ) 
....................    {
....................       //increment crc16 error counter
....................       //debug_usb(debug_putc,"CRC16 ");
....................       ERROR_COUNTER[2]++;
....................    }
.................... 
....................    if ( bit_test(ints,3) ) 
....................    {  
....................       //increment dfn8 error counter
....................       //debug_usb(debug_putc,"DFN8 ");
....................       ERROR_COUNTER[3]++;
....................    }
.................... 
....................    if ( bit_test(ints,4) ) 
....................    {  
....................       //increment bto error counter
....................       //debug_usb(debug_putc,"BTO ");
....................       ERROR_COUNTER[4]++;
....................    }
.................... 
....................    if ( bit_test(ints,7) ) 
....................    { 
....................       //increment bts error counter
....................       //debug_usb(debug_putc,"BTS ");
....................       ERROR_COUNTER[5]++;
....................    }
....................   #endif
.................... 
....................    UEIR = 0;
*
044C:  CLRF   F6A
....................    
....................    //UIR_UERR = 0;
....................    UIR &= ~(1 << BIT_UERR);
044E:  BCF    F68.1
0450:  GOTO   141E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_uidle()
.................... /*
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_uidle(void)
.................... {
....................    debug_usb_control(debug_putc, "-I-");
.................... 
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice)
*
05F2:  BSF    F69.2
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
....................    // turn off isr instead of clearing flag
....................    UIE &= ~(unsigned int16)__USB_UIF_IDLE;
05F4:  BCF    F69.4
....................   #else
....................    UIR &= ~(1 << BIT_IDLE);
....................   #endif
....................    
....................    UCON_SUSPND = 1; //set suspend. we are now suspended
05F6:  BSF    F6D.1
05F8:  GOTO   1432 (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
.................... /* usb_isr_activity()
.................... /*
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB
.................... /*          peripheral.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_activity(void)
.................... {
....................    debug_usb_control(debug_putc, "-A-");
.................... 
....................    UCON_SUSPND = 0; //turn off low power suspending
*
0402:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling
0404:  BCF    F69.2
....................    
....................    while(UIR_ACTV)
0406:  BTFSS  F68.2
0408:  BRA    040E
....................    {
....................       //UIR_ACTV = 0;
....................       UIR &= ~(1 << BIT_ACTV);
040A:  BCF    F68.2
....................    }
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
040C:  BRA    0406
....................    // now it's safe to clear the flag
....................    UIR &= ~(1 << BIT_IDLE);
040E:  BCF    F68.4
....................   #endif   
0410:  GOTO   1406 (RETURN)
.................... }
.................... 
.................... /******************************************************************************
.................... /* usb_isr_stall()
.................... /*
.................... /* Summary: Stall handshake detected.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_stall(void) 
.................... {
....................    debug_usb_control(debug_putc, "-S-");
....................    
....................    
....................    if (bit_test(UEP(0),0)) 
*
043E:  BTFSS  F70.0
0440:  BRA    0446
....................    {
....................       usb_init_ep0_setup();
0442:  RCALL  0414
....................       bit_clear(UEP(0), 0);
0444:  BCF    F70.0
....................    }
....................    
....................    //UIR_STALL = 0;
....................    UIR &= ~(1 << BIT_STALL);
0446:  BCF    F68.5
0448:  GOTO   1414 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;}
*
0602:  MOVFF  24A,23
0606:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;}
*
0C5C:  MOVLW  FE
0C5E:  MOVWF  23
0C60:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;}
*
0608:  SETF   23
060A:  RETURN 0
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_tok_dne()
.................... /*
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral.
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and
.................... /*          handle the request.
.................... /*          If an IN token on EP0 was received, continue transmitting any
.................... /*          unfinished requests that may take more than one packet to transmit
.................... /*          (if necessary).
.................... /*          If an OUT token on any other EP was received, mark that EP as ready
.................... /*          for a usb_get_packet().
.................... /*          Does not handle any IN or OUT tokens on EP0.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_tok_dne(void) 
.................... {
....................    unsigned int8 en;
.................... 
....................    en = USTATCopy>>3;
*
12F2:  RRCF   21,W
12F4:  MOVLB  2
12F6:  MOVWF  x45
12F8:  RRCF   x45,F
12FA:  RRCF   x45,F
12FC:  MOVLW  1F
12FE:  ANDWF  x45,F
.................... 
....................    debug_usb_control(debug_putc, "-T%X-", USTATCopy);
.................... 
....................    if (USTATCopy == USTAT_OUT_SETUP_E0) 
1300:  MOVF   21,F
1302:  BNZ   13A0
....................    {
....................       //new out or setup token in the buffer
....................       int8 pidKey;
....................       
....................       //debug_usb(debug_putc,"%X ", EP_BDxST_O(0));
....................       
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID
1304:  MOVLB  4
1306:  MOVF   x00,W
1308:  ANDLW  3C
130A:  MOVLB  2
130C:  MOVWF  x46
....................       
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion
130E:  MOVLW  43
1310:  MOVLB  4
1312:  ANDWF  x00,F
....................       
....................       if (pidKey == USB_PIC_PID_SETUP) 
1314:  MOVLB  2
1316:  MOVF   x46,W
1318:  SUBLW  34
131A:  BNZ   1366
....................       {
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00)
131C:  MOVLB  4
131E:  MOVF   x04,W
1320:  ANDLW  80
1322:  BZ    1326
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests)
1324:  CLRF   x04
.................... 
....................          //debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0));
....................          //debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer);
.................... 
....................          usb_isr_tok_setup_dne();
1326:  MOVLB  0
1328:  BRA    0CFE
.................... 
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
132A:  BCF    F6D.4
.................... 
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall())
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data())
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response())
....................          if (__setup_0_tx_size == 0xFF)
132C:  INCFSZ 23,W
132E:  BRA    133E
....................             usb_flush_out(0, USB_DTS_STALL);
1330:  MOVLB  2
1332:  CLRF   x48
1334:  MOVLW  03
1336:  MOVWF  x49
1338:  MOVLB  0
133A:  RCALL  0D30
133C:  BRA    1362
....................          else 
....................          {
....................             usb_flush_out(0, USB_DTS_TOGGLE);
133E:  MOVLB  2
1340:  CLRF   x48
1342:  MOVLW  02
1344:  MOVWF  x49
1346:  MOVLB  0
1348:  RCALL  0D30
....................             if (__setup_0_tx_size != 0xFE)
134A:  MOVF   23,W
134C:  SUBLW  FE
134E:  BZ    1362
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX);
1350:  MOVLB  2
1352:  CLRF   x51
1354:  CLRF   x53
1356:  MOVFF  23,252
135A:  MOVLW  04
135C:  MOVWF  x54
135E:  MOVLB  0
1360:  RCALL  0E86
....................          }
....................          //why was this here?
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
....................       }
1362:  BRA    139C
1364:  MOVLB  2
....................       else if (pidKey == USB_PIC_PID_OUT) 
1366:  MOVF   x46,W
1368:  SUBLW  04
136A:  BNZ   139E
....................       {
....................          usb_isr_tok_out_dne(0);
136C:  CLRF   x47
136E:  MOVLB  0
1370:  RCALL  1088
....................          usb_flush_out(0, USB_DTS_TOGGLE);
1372:  MOVLB  2
1374:  CLRF   x48
1376:  MOVLW  02
1378:  MOVWF  x49
137A:  MOVLB  0
137C:  RCALL  0D30
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF))
137E:  MOVF   23,W
1380:  SUBLW  FE
1382:  BZ    139C
1384:  INCFSZ 23,W
1386:  BRA    138A
1388:  BRA    139C
....................          {
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len)
138A:  MOVLB  2
138C:  CLRF   x51
138E:  CLRF   x53
1390:  MOVFF  23,252
1394:  MOVLW  01
1396:  MOVWF  x54
1398:  MOVLB  0
139A:  RCALL  0E86
139C:  MOVLB  2
....................          }
....................       }
....................       //else
....................       //{
....................       //   debug_usb(debug_putc, "!!! ");
....................       //}
....................    }
139E:  BRA    13E4
....................    else if (USTATCopy == USTAT_IN_E0) 
13A0:  MOVF   21,W
13A2:  SUBLW  04
13A4:  BNZ   13CA
....................    {   
....................       //pic -> host transfer completed
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion
....................       __setup_0_tx_size = 0xFF;
13A6:  SETF   23
....................       usb_isr_tok_in_dne(0);
13A8:  CLRF   x47
13AA:  MOVLB  0
13AC:  RCALL  12C0
....................       if (__setup_0_tx_size!=0xFF)
13AE:  INCFSZ 23,W
13B0:  BRA    13B4
13B2:  BRA    13C6
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE);
13B4:  MOVLB  2
13B6:  CLRF   x51
13B8:  CLRF   x53
13BA:  MOVFF  23,252
13BE:  MOVLW  02
13C0:  MOVWF  x54
13C2:  MOVLB  0
13C4:  RCALL  0E86
....................       else
....................       {
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................       }  
....................    }
13C6:  BRA    13E2
13C8:  MOVLB  2
....................    else 
....................    {
....................       if (!bit_test(USTATCopy, 2)) 
13CA:  BTFSC  21.2
13CC:  BRA    13DA
....................       {
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_out_dne(en);
13CE:  MOVFF  245,247
13D2:  MOVLB  0
13D4:  RCALL  1088
....................       }
13D6:  BRA    13E2
13D8:  MOVLB  2
....................       else 
....................       {
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_in_dne(en);
13DA:  MOVFF  245,247
13DE:  MOVLB  0
13E0:  RCALL  12C0
13E2:  MOVLB  2
....................       }
....................    }
13E4:  MOVLB  0
13E6:  GOTO   1454 (RETURN)
.................... }
.................... 
.................... /// END USB Interrupt Service Routine
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... #if defined(__PIC24_USB_H__)
....................  #include <pic24_usb.c>
.................... #endif
.................... 
.................... #if defined(__USBN960X_H__)
....................  #include <usbn960x.c>
.................... #endif
.................... 
.................... 
.................... #IFNDEF __USB_HARDWARE__
....................    #ERROR You must include USB hardware driver.
.................... #ENDIF
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
....................    #ERROR You must include USB descriptors.
.................... #ENDIF
.................... 
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1))
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  64
.................... #else
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  8
.................... #endif
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors
.................... 
.................... #IF USB_HID_BOOT_PROTOCOL
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES];
.................... #ENDIF
.................... 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size);
.................... 
.................... void usb_isr_tkn_setup_StandardEndpoint(void);
.................... void usb_isr_tkn_setup_StandardDevice(void);
.................... void usb_isr_tkn_setup_StandardInterface(void);
.................... #IF USB_HID_DEVICE
....................    void usb_isr_tkn_setup_ClassInterface(void);
.................... #ENDIF
.................... void usb_Get_Descriptor(void);
.................... void usb_copy_desc_seg_to_ep(void);
.................... void usb_finish_set_address(void);
.................... 
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors
.................... 
.................... /// BEGIN User Functions
.................... 
.................... // see usb.h for documentation
.................... int1 usb_enumerated(void)
.................... {
....................    return(USB_stack_status.curr_config);
*
1536:  MOVF   1B,W
1538:  MOVWF  01
153A:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_wait_for_enumeration(void) 
.................... {
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();}
.................... }
.................... 
.................... // see USB.H for documentation
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) {
....................    unsigned int16 i=0;
....................    int1 res;
....................    unsigned int16 this_packet_len;
....................    unsigned int16 packet_size;
....................    unsigned int32 timeout_1us;
.................... 
....................    packet_size = usb_ep_tx_size[endpoint];
....................    
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size);
.................... 
....................    //send data packets until timeout or no more packets to send
....................    while (i < len) 
....................    {
....................       timeout_1us = (int32)timeout*1000;
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;}
....................       else {this_packet_len = len-i;}
....................       //putc('*');
....................       do 
....................       {
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets
....................          //putc('.');
....................          if (!res)
....................          {
....................             delay_us(1);
....................             //delay_ms(500);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................       i += packet_size;
....................    }
.................... 
.................... 
....................    //send 0len packet if needed
....................    if (i==len) {
....................       timeout_1us=(int32)timeout*1000;
....................       do {
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message
....................          if (!res) {
....................             delay_us(1);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................    }
.................... 
....................    return(res);
.................... }
.................... 
.................... // see usb.h for documentation
.................... unsigned int16 usb_gets(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max, unsigned int16 timeout) {
....................    unsigned int16 ret=0;
....................    unsigned int16 to;
....................    unsigned int16 len;
....................    unsigned int16 packet_size;
....................    unsigned int16 this_packet_max;
.................... 
....................    packet_size=usb_ep_rx_size[endpoint];
.................... 
....................    do {
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;}
....................       to=0;
....................       do {
....................          len = packet_size;
....................          if (usb_kbhit(endpoint)) {
....................             len=usb_get_packet(endpoint,ptr,this_packet_max);
....................             ptr+=len;
....................             max-=len;
....................             ret+=len;
....................             break;
....................          }
....................          else {
....................             to++;
....................             delay_ms(1);
....................          }
....................       } while (to!=timeout);
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max);
.................... 
....................    return(ret);
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR)
.................... 
.................... // see usb.h for documentation
.................... void usb_token_reset(void) 
.................... {
....................    unsigned int i;
.................... 
....................    usb_getdesc_len = 0;
*
0592:  CLRF   28
0594:  CLRF   27
....................    
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++) 
0596:  MOVLB  2
0598:  CLRF   x45
059A:  MOVF   x45,W
059C:  SUBLW  01
059E:  BNC   05B4
....................       USB_Interface[i] = 0;   //reset each interface to default
05A0:  CLRF   03
05A2:  MOVF   x45,W
05A4:  ADDLW  29
05A6:  MOVWF  FE9
05A8:  MOVLW  00
05AA:  ADDWFC 03,W
05AC:  MOVWF  FEA
05AE:  CLRF   FEF
.................... 
....................   #IF USB_HID_BOOT_PROTOCOL
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++)
....................       hid_protocol[i] = 1;
....................   #endif
.................... 
....................   #if USB_CDC_DEVICE
05B0:  INCF   x45,F
05B2:  BRA    059A
....................    usb_cdc_init();
05B4:  MOVLB  0
05B6:  RCALL  0552
....................   #endif
.................... 
....................    USB_stack_status.curr_config = 0;      //unconfigured device
05B8:  CLRF   1B
.................... 
....................    USB_stack_status.status_device = 1;    //previous state.  init at none
05BA:  MOVLW  01
05BC:  MOVWF  1C
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none
05BE:  CLRF   1A
05C0:  RETURN 0
.................... }
.................... 
.................... //send a 0len packet to endpoint 0 (optimization)
.................... //notice that this doesnt return the status
.................... #define usb_put_0len_0() usb_request_send_response(0)
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    direction = bit_test(endpoint,7);
*
0454:  MOVLB  2
0456:  BCF    x52.0
0458:  BTFSC  x51.7
045A:  BSF    x52.0
....................    
....................    endpoint &= 0x7F;
045C:  BCF    x51.7
....................    
....................    if (endpoint > 16)
045E:  MOVF   x51,W
0460:  SUBLW  10
0462:  BC    046A
....................       return(false);
0464:  MOVLW  00
0466:  MOVWF  01
0468:  BRA    049E
....................    
....................    if (direction) { //IN
046A:  BTFSS  x52.0
046C:  BRA    0488
....................       return(usb_ep_tx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
046E:  CLRF   03
0470:  MOVF   x51,W
0472:  MOVLB  0
0474:  RCALL  00BA
0476:  SUBLW  FF
0478:  BNZ   047E
047A:  MOVLW  00
047C:  BRA    0480
047E:  MOVLW  01
0480:  MOVWF  01
0482:  MOVLB  2
0484:  BRA    049E
....................    }
0486:  BRA    049E
....................    else {   //OUT
....................       return(usb_ep_rx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
0488:  CLRF   03
048A:  MOVF   x51,W
048C:  MOVLB  0
048E:  RCALL  00DA
0490:  SUBLW  FF
0492:  BNZ   0498
0494:  MOVLW  00
0496:  BRA    049A
0498:  MOVLW  01
049A:  MOVWF  01
049C:  MOVLB  2
....................    }
049E:  MOVLB  0
04A0:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) {
....................    if (endpoint==0) {
*
12C0:  MOVLB  2
12C2:  MOVF   x47,F
12C4:  BNZ   12E2
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor?
12C6:  DECFSZ 1A,W
12C8:  BRA    12D4
12CA:  MOVLB  0
12CC:  CALL   060C
12D0:  BRA    12DE
12D2:  MOVLB  2
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();}
12D4:  MOVF   1A,W
12D6:  SUBLW  02
12D8:  BNZ   12E0
12DA:  MOVLB  0
12DC:  BRA    10C0
12DE:  MOVLB  2
....................    }
....................   #if USB_CDC_DEVICE
12E0:  BRA    12EE
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
12E2:  MOVF   x47,W
12E4:  SUBLW  02
12E6:  BNZ   12EE
....................       usb_isr_tok_in_cdc_data_dne();
12E8:  MOVLB  0
12EA:  BRA    12BA
12EC:  MOVLB  2
....................   }
....................   #endif
12EE:  MOVLB  0
12F0:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint)
.................... {
....................    //TODO:
....................    if (endpoint==0) {
*
1088:  MOVLB  2
108A:  MOVF   x47,F
108C:  BNZ   1096
....................      debug_usb(debug_putc,"TOUT 0 ");
....................      #if USB_CDC_DEVICE
....................       usb_isr_tok_out_cdc_control_dne();
108E:  MOVLB  0
1090:  BRA    0FD2
....................      //#else   //REMOVED JUN/9/2009
....................      //usb_init_ep0_setup();
....................      #endif
....................    }
....................   #if USB_CDC_DEVICE
1092:  BRA    10A0
1094:  MOVLB  2
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
1096:  MOVF   x47,W
1098:  SUBLW  02
109A:  BNZ   10A2
....................       usb_isr_tok_out_cdc_data_dne();
109C:  MOVLB  0
109E:  BRA    106C
10A0:  MOVLB  2
....................    }
....................   #endif
10A2:  MOVLB  0
10A4:  RETURN 0
....................    //else {
....................    //   bit_set(__usb_kbhit_status,endpoint);
....................    //}
.................... }
.................... 
.................... 
.................... //---- process setup message stage -----------//
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_setup_dne(void) 
.................... {
....................    USB_stack_status.dev_req=NONE; // clear the device request..
*
0CFE:  CLRF   1A
.................... 
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) {
0D00:  MOVLB  4
0D02:  MOVF   x18,W
0D04:  ANDLW  7F
0D06:  XORLW  00
0D08:  MOVLB  0
0D0A:  BZ    0D1A
0D0C:  XORLW  01
0D0E:  BZ    0D1E
0D10:  XORLW  03
0D12:  BZ    0D22
0D14:  XORLW  23
0D16:  BZ    0D26
0D18:  BRA    0D2A
.................... 
....................       case 0x00:  //standard to device
....................          debug_usb_token(debug_putc," d");
....................          usb_isr_tkn_setup_StandardDevice();
0D1A:  BRA    093E
....................          break;
0D1C:  BRA    0D2C
.................... 
....................       case 0x01:  //standard to interface
....................          debug_usb_token(debug_putc," i");
....................          usb_isr_tkn_setup_StandardInterface();
0D1E:  BRA    09FA
....................          break;
0D20:  BRA    0D2C
.................... 
....................       case 0x02:  //standard to endpoint
....................          debug_usb_token(debug_putc," e");
....................          usb_isr_tkn_setup_StandardEndpoint();
0D22:  BRA    0BF2
....................          break;
0D24:  BRA    0D2C
....................          
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case 0x21:  //class specific request.  the only class this driver supports is HID
....................          debug_usb_token(debug_putc, " class");
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE)
....................          {
....................             usb_isr_tkn_setup_ClassInterface();
....................          }
....................          else
....................          {
....................             usb_isr_tkn_cdc();
....................          }
....................         #elif USB_HID_DEVICE
....................          usb_isr_tkn_setup_ClassInterface();
....................         #else
....................          usb_isr_tkn_cdc();
0D26:  BRA    0C62
....................         #endif
....................          break;
0D28:  BRA    0D2C
.................... #endif
.................... 
.................... 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE
.................... 
....................       default:
....................          usb_request_stall();
0D2A:  RCALL  0608
....................          break;
....................    }
0D2C:  GOTO   132A (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardDevice()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Device request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardDevice(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
*
093E:  MOVLB  4
0940:  MOVF   x19,W
0942:  XORLW  00
0944:  MOVLB  0
0946:  BZ    0962
0948:  XORLW  01
094A:  BZ    0976
094C:  XORLW  02
094E:  BZ    0992
0950:  XORLW  06
0952:  BZ    09AC
0954:  XORLW  03
0956:  BZ    09BE
0958:  XORLW  0E
095A:  BZ    09C2
095C:  XORLW  01
095E:  BZ    09D2
0960:  BRA    09F4
.................... 
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device;
0962:  MOVFF  1C,458
....................             usb_ep0_tx_buffer[1]=0;
0966:  MOVLB  4
0968:  CLRF   x59
....................             usb_request_send_response(2);
096A:  MOVLW  02
096C:  MOVLB  2
096E:  MOVWF  x4A
0970:  MOVLB  0
0972:  RCALL  0602
....................             break;
0974:  BRA    09F6
.................... 
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1
....................             if (usb_ep0_rx_buffer[2] == 1) {
0976:  MOVLB  4
0978:  DECFSZ x1A,W
097A:  BRA    098C
....................                debug_usb_token(debug_putc,"CF");
....................                USB_stack_status.status_device &= 1;
097C:  MOVLW  01
097E:  ANDWF  1C,F
....................                usb_put_0len_0();
0980:  MOVLB  2
0982:  CLRF   x4A
0984:  MOVLB  0
0986:  RCALL  0602
....................             }
0988:  BRA    0990
098A:  MOVLB  4
....................             else
....................                usb_request_stall();
098C:  MOVLB  0
098E:  RCALL  0608
....................             break;
0990:  BRA    09F6
.................... 
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3
....................             if (usb_ep0_rx_buffer[2] == 1) {
0992:  MOVLB  4
0994:  DECFSZ x1A,W
0996:  BRA    09A6
....................                debug_usb_token(debug_putc,"SF");
....................                USB_stack_status.status_device |= 2;
0998:  BSF    1C.1
....................                usb_put_0len_0();
099A:  MOVLB  2
099C:  CLRF   x4A
099E:  MOVLB  0
09A0:  RCALL  0602
....................             }
09A2:  BRA    09AA
09A4:  MOVLB  4
....................             else
....................                usb_request_stall();
09A6:  MOVLB  0
09A8:  RCALL  0608
....................             break;
09AA:  BRA    09F6
.................... 
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5
....................             debug_usb_token(debug_putc,"SA");
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request
09AC:  MOVLW  02
09AE:  MOVWF  1A
....................             USB_address_pending=usb_ep0_rx_buffer[2];
09B0:  MOVFF  41A,24
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request
....................             usb_set_address(USB_address_pending);
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0
....................             #endif
....................             usb_put_0len_0();
09B4:  MOVLB  2
09B6:  CLRF   x4A
09B8:  MOVLB  0
09BA:  RCALL  0602
....................             break;
09BC:  BRA    09F6
.................... 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6
....................             debug_usb_token(debug_putc,"GD");
....................             usb_Get_Descriptor();
09BE:  BRA    0694
....................             break;
09C0:  BRA    09F6
.................... 
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8
....................             debug_usb_token(debug_putc,"GC");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config;
09C2:  MOVFF  1B,458
....................             usb_request_send_response(1);
09C6:  MOVLW  01
09C8:  MOVLB  2
09CA:  MOVWF  x4A
09CC:  MOVLB  0
09CE:  RCALL  0602
....................             break;
09D0:  BRA    09F6
.................... 
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) {
09D2:  MOVLB  4
09D4:  MOVF   x1A,W
09D6:  SUBLW  01
09D8:  BNC   09F0
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2];
09DA:  MOVFF  41A,1B
....................                usb_set_configured(usb_ep0_rx_buffer[2]);
09DE:  MOVFF  41A,247
09E2:  MOVLB  0
09E4:  BRA    0752
....................                debug_usb_token(debug_putc,"SC%U", USB_stack_status.curr_config);               
....................                usb_put_0len_0();
09E6:  MOVLB  2
09E8:  CLRF   x4A
09EA:  MOVLB  0
09EC:  RCALL  0602
09EE:  MOVLB  4
....................             }
....................             break;
09F0:  MOVLB  0
09F2:  BRA    09F6
.................... 
....................       default:
....................             usb_request_stall();
09F4:  RCALL  0608
....................             break;
....................    }
09F6:  GOTO   0D2C (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Interface request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardInterface(void) {
....................    unsigned int8 curr_config;
.................... 
....................    curr_config=USB_stack_status.curr_config;
09FA:  MOVFF  1B,247
.................... 
....................    switch (usb_ep0_rx_buffer[1]) {
09FE:  MOVLB  4
0A00:  MOVF   x19,W
0A02:  XORLW  00
0A04:  MOVLB  0
0A06:  BZ    0A12
0A08:  XORLW  0A
0A0A:  BZ    0A24
0A0C:  XORLW  01
0A0E:  BZ    0A6A
0A10:  BRA    0A96
....................       case USB_STANDARD_REQUEST_GET_STATUS:
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=0;
0A12:  MOVLB  4
0A14:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0;
0A16:  CLRF   x59
....................             usb_request_send_response(2);
0A18:  MOVLW  02
0A1A:  MOVLB  2
0A1C:  MOVWF  x4A
0A1E:  MOVLB  0
0A20:  RCALL  0602
....................             break;
0A22:  BRA    0A98
.................... 
....................       case USB_STANDARD_REQUEST_GET_INTERFACE:
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state
0A24:  MOVLB  2
0A26:  MOVF   x47,F
0A28:  BZ    0A64
0A2A:  MOVLW  01
0A2C:  SUBWF  x47,W
0A2E:  CLRF   03
0A30:  MOVLB  0
0A32:  CALL   01AE
0A36:  MOVWF  01
0A38:  MOVLB  4
0A3A:  SUBWF  x1C,W
0A3C:  BTFSS  FD8.0
0A3E:  BRA    0A44
0A40:  MOVLB  2
0A42:  BRA    0A64
....................                debug_usb_token(debug_putc,"GI");
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte
0A44:  CLRF   03
0A46:  MOVF   x1C,W
0A48:  ADDLW  29
0A4A:  MOVWF  FE9
0A4C:  MOVLW  00
0A4E:  ADDWFC 03,W
0A50:  MOVWF  FEA
0A52:  MOVFF  FEF,458
....................                usb_request_send_response(1); //send byte back
0A56:  MOVLW  01
0A58:  MOVLB  2
0A5A:  MOVWF  x4A
0A5C:  MOVLB  0
0A5E:  RCALL  0602
....................             }
0A60:  BRA    0A68
0A62:  MOVLB  2
....................             else
....................                usb_request_stall();
0A64:  MOVLB  0
0A66:  RCALL  0608
....................             break;
0A68:  BRA    0A98
.................... 
....................       case USB_STANDARD_REQUEST_SET_INTERFACE:
....................             if (curr_config) { //if configured state
0A6A:  MOVLB  2
0A6C:  MOVF   x47,F
0A6E:  BZ    0A90
....................                debug_usb_token(debug_putc,"SI");
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
0A70:  CLRF   03
0A72:  MOVLB  4
0A74:  MOVF   x1C,W
0A76:  ADDLW  29
0A78:  MOVWF  FE9
0A7A:  MOVLW  00
0A7C:  ADDWFC 03,W
0A7E:  MOVWF  FEA
0A80:  MOVFF  41A,FEF
....................                usb_put_0len_0();
0A84:  MOVLB  2
0A86:  CLRF   x4A
0A88:  MOVLB  0
0A8A:  RCALL  0602
....................             }
0A8C:  BRA    0A94
0A8E:  MOVLB  2
....................             else
....................                usb_request_stall();
0A90:  MOVLB  0
0A92:  RCALL  0608
....................             break;
0A94:  BRA    0A98
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR:
....................             debug_usb_token(debug_putc,"GDh");
....................             usb_Get_Descriptor();
....................             break;
.................... #endif
.................... 
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE:
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE:
.................... //                let default take care of these, goto wrongstate
....................       default:
....................             usb_request_stall();
0A96:  RCALL  0608
....................             break;
....................    }
0A98:  GOTO   0D2C (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardEndpoint()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardEndpoint(void) {
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) {
*
0BF2:  MOVFF  41C,251
0BF6:  RCALL  0454
0BF8:  MOVF   01,F
0BFA:  BZ    0C58
....................       switch(usb_ep0_rx_buffer[1]) {
0BFC:  MOVLB  4
0BFE:  MOVF   x19,W
0C00:  XORLW  01
0C02:  MOVLB  0
0C04:  BZ    0C10
0C06:  XORLW  02
0C08:  BZ    0C20
0C0A:  XORLW  03
0C0C:  BZ    0C30
0C0E:  BRA    0C56
.................... 
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE:
....................                debug_usb_token(debug_putc,"CF");
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]);
0C10:  MOVFF  41C,247
0C14:  BRA    0A9C
....................                usb_put_0len_0();
0C16:  MOVLB  2
0C18:  CLRF   x4A
0C1A:  MOVLB  0
0C1C:  RCALL  0602
....................                break;
0C1E:  BRA    0C58
.................... 
....................          case USB_STANDARD_REQUEST_SET_FEATURE:
....................                      debug_usb_token(debug_putc,"SF");
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]);
0C20:  MOVFF  41C,247
0C24:  BRA    0B16
....................                      usb_put_0len_0();
0C26:  MOVLB  2
0C28:  CLRF   x4A
0C2A:  MOVLB  0
0C2C:  RCALL  0602
....................                      break;
0C2E:  BRA    0C58
.................... 
....................          case USB_STANDARD_REQUEST_GET_STATUS:
....................                debug_usb_token(debug_putc,"GS");
....................                usb_ep0_tx_buffer[0]=0;
0C30:  MOVLB  4
0C32:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0;
0C34:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) {
0C36:  MOVFF  41C,247
0C3A:  MOVLB  0
0C3C:  BRA    0B7C
0C3E:  MOVF   01,F
0C40:  BZ    0C4A
....................                   usb_ep0_tx_buffer[0]=1;
0C42:  MOVLW  01
0C44:  MOVLB  4
0C46:  MOVWF  x58
0C48:  MOVLB  0
....................                }
....................                usb_request_send_response(2);
0C4A:  MOVLW  02
0C4C:  MOVLB  2
0C4E:  MOVWF  x4A
0C50:  MOVLB  0
0C52:  RCALL  0602
....................                break;
0C54:  BRA    0C58
.................... 
....................          default:
....................             usb_request_stall();
0C56:  RCALL  0608
....................             break;
....................       }
....................    }
0C58:  GOTO   0D2C (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_ClassInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /* Only compiled if HID_DEVICE is TRUE
.................... /***************************************************************/
.................... #IF USB_HID_DEVICE
.................... void usb_isr_tkn_setup_ClassInterface(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03
....................             debug_usb_token(debug_putc,"GP");
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]];
....................             usb_request_send_response(1);
....................             break;
....................     #ENDIF
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b
....................             debug_usb_token(debug_putc,"SP");
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
....................             usb_put_0len_0(); //send 0len packet69
....................             break;
....................     #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_SET_IDLE:   //0a
....................          #error TODO: if you want to support SET_IDLE, add code here
....................    #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_GET_IDLE:   //02
....................          #error TODO: if you want to support GET_IDLE, add code here
....................    #ENDIF
.................... 
....................       default:
....................             usb_request_stall();
....................             break;
....................    }
.................... }
.................... #ENDIF
.................... 
.................... /**************************************************************
.................... /* usb_Get_Descriptor()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept
.................... /*
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.),
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have
.................... /*          pointers to constants we must simulate or own by setting up global registers that say
.................... /*          which constant array to deal with, which position to start in this array, and the length.
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne()
.................... /*          which will send the rest of the data.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_Get_Descriptor() {
*
0694:  MOVLB  2
0696:  CLRF   x47
....................    unsigned int8 i = 0;
....................    usb_getdesc_ptr=0;
0698:  CLRF   26
069A:  CLRF   25
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE;
069C:  CLRF   1D
.................... 
....................    switch(usb_ep0_rx_buffer[3]) {
069E:  MOVLB  4
06A0:  MOVF   x1B,W
06A2:  XORLW  01
06A4:  MOVLB  0
06A6:  BZ    06B6
06A8:  XORLW  03
06AA:  BZ    06C2
06AC:  XORLW  01
06AE:  BZ    06CA
06B0:  XORLW  22
06B2:  BZ    0702
06B4:  BRA    072C
....................       case USB_DESC_DEVICE_TYPE:    //1
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN;
06B6:  CLRF   28
06B8:  MOVLW  12
06BA:  MOVWF  27
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE;
06BC:  MOVLW  03
06BE:  MOVWF  1D
....................             break;
06C0:  BRA    0730
.................... 
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually.
....................       case USB_DESC_CONFIG_TYPE:   //2
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN;
06C2:  CLRF   28
06C4:  MOVLW  43
06C6:  MOVWF  27
....................             break;
06C8:  BRA    0730
.................... 
....................       case USB_DESC_STRING_TYPE: //3
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE;
06CA:  MOVLW  02
06CC:  MOVWF  1D
....................             //usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]];
....................             for(i=0; i<usb_ep0_rx_buffer[2]; i++)
06CE:  MOVLB  2
06D0:  CLRF   x47
06D2:  MOVLB  4
06D4:  MOVF   x1A,W
06D6:  MOVLB  2
06D8:  SUBWF  x47,W
06DA:  BC    06F2
....................             {
....................                usb_getdesc_ptr += USB_STRING_DESC[usb_getdesc_ptr];
06DC:  MOVFF  26,03
06E0:  MOVF   25,W
06E2:  MOVLB  0
06E4:  RCALL  01FA
06E6:  ADDWF  25,F
06E8:  MOVLW  00
06EA:  ADDWFC 26,F
06EC:  MOVLB  2
06EE:  INCF   x47,F
06F0:  BRA    06D2
....................             }
....................             usb_getdesc_len = USB_STRING_DESC[usb_getdesc_ptr];
06F2:  MOVFF  26,03
06F6:  MOVF   25,W
06F8:  MOVLB  0
06FA:  RCALL  01FA
06FC:  MOVWF  27
06FE:  CLRF   28
....................             break;
0700:  BRA    0730
.................... 
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06
....................       // this is needed so host can find out about differences about this
....................       // devices ability to handle full speed verses fast speed.
....................       // since we don't support fast speed then we ignore this.
....................       //      break;
.................... 
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case USB_DESC_CLASS_TYPE:  //0x21
....................             //TODO does this work for multiple interfaces or multiple languages?
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]];
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]];
0702:  CLRF   03
0704:  MOVLB  4
0706:  MOVF   x1A,W
0708:  MOVLB  0
070A:  RCALL  01C0
070C:  MOVWF  25
070E:  CLRF   26
....................             if (usb_getdesc_ptr!=0xFF) {
0710:  INCFSZ 25,W
0712:  BRA    0718
0714:  MOVF   26,F
0716:  BZ    0728
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr];
0718:  MOVFF  26,03
071C:  MOVF   25,W
071E:  RCALL  015A
0720:  MOVWF  27
0722:  CLRF   28
....................                break;
0724:  BRA    0730
....................             }
0726:  BRA    072C
....................             else {
....................                usb_request_stall();
0728:  RCALL  0608
....................                return;
072A:  BRA    074E
....................             }
.................... #endif
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_DESC_HIDREPORT_TYPE: //0x22
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]];
....................             if (usb_getdesc_ptr !=0xFF) {
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE;
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]];
....................                break;
....................             }
....................             else {
....................                usb_request_stall();
....................                return;
....................             }
.................... #endif
.................... 
....................       default:
....................             usb_request_stall();
072C:  RCALL  0608
....................             return;
072E:  BRA    074E
....................    }
....................    if (usb_ep0_rx_buffer[7]==0) {
0730:  MOVLB  4
0732:  MOVF   x1F,F
0734:  BNZ   0746
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6])
0736:  MOVF   28,F
0738:  BNZ   0740
073A:  MOVF   27,W
073C:  SUBWF  x1E,W
073E:  BC    0746
....................          usb_getdesc_len = usb_ep0_rx_buffer[6];
0740:  CLRF   28
0742:  MOVFF  41E,27
....................    }
....................    USB_stack_status.dev_req=GET_DESCRIPTOR;
0746:  MOVLW  01
0748:  MOVWF  1A
....................    usb_copy_desc_seg_to_ep();
074A:  MOVLB  0
074C:  RCALL  060C
074E:  GOTO   09F6 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_finish_set_address()
.................... /*
.................... /* Input: USB_address_pending holds the address we were asked to set to.
.................... /*
.................... /* Summary: Sets the address.
.................... /*
.................... /* This code should only be run on the PIC USB peripheral, and not the
.................... /* National peripheral.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
....................  void usb_finish_set_address() {
....................    debug_usb_token(debug_putc," FSA ");
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0
*
10C0:  CLRF   1B
.................... 
....................    #ifdef __PIC__
....................    USB_stack_status.dev_req=NONE;  // no request pending
10C2:  CLRF   1A
....................    usb_set_address(USB_address_pending);
10C4:  MOVFF  24,248
10C8:  BRA    10A6
....................    #endif
10CA:  GOTO   12DE (RETURN)
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// The following function retrieve data from constant arrays.  This may
.................... /// look un-optimized, but remember that you can't create a pointer to
.................... /// a constant array.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... void usb_copy_desc_seg_to_ep(void) {
*
060C:  MOVLB  2
060E:  CLRF   x48
....................    unsigned int i=0;
....................    char c;
....................    
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]);
.................... 
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH))
0610:  MOVF   27,W
0612:  IORWF  28,W
0614:  BZ    067C
0616:  MOVF   x48,W
0618:  SUBLW  3F
061A:  BNC   067C
....................    {
....................       switch(USB_stack_status.getdesc_type) {
061C:  MOVF   1D,W
061E:  XORLW  00
0620:  MOVLB  0
0622:  BZ    062E
0624:  XORLW  02
0626:  BZ    063C
0628:  XORLW  01
062A:  BZ    064A
062C:  BRA    0656
....................          case USB_GETDESC_CONFIG_TYPE:
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr];
062E:  MOVFF  26,03
0632:  MOVF   25,W
0634:  RCALL  015A
0636:  MOVFF  FE8,249
....................             break;
063A:  BRA    0656
.................... 
....................         #IF USB_HID_DEVICE
....................          case USB_GETDESC_HIDREPORT_TYPE:
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr];
....................             break;
....................         #endif
.................... 
....................          case USB_GETDESC_STRING_TYPE:
....................             c=USB_STRING_DESC[usb_getdesc_ptr];
063C:  MOVFF  26,03
0640:  MOVF   25,W
0642:  RCALL  01FA
0644:  MOVFF  FE8,249
....................             break;
0648:  BRA    0656
.................... 
....................          case USB_GETDESC_DEVICE_TYPE:
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr];
064A:  MOVFF  26,03
064E:  MOVF   25,W
0650:  RCALL  01D8
0652:  MOVFF  FE8,249
....................             //debug_usb(debug_putc, "-%X- ", c);
....................             break;
....................       }
....................       usb_getdesc_ptr++;
0656:  INCF   25,F
0658:  BTFSC  FD8.2
065A:  INCF   26,F
....................       usb_getdesc_len--;
065C:  MOVF   27,W
065E:  BTFSC  FD8.2
0660:  DECF   28,F
0662:  DECF   27,F
....................       usb_ep0_tx_buffer[i++]=c;
0664:  MOVLB  2
0666:  MOVF   x48,W
0668:  INCF   x48,F
066A:  ADDLW  58
066C:  MOVWF  FE9
066E:  MOVLW  04
0670:  MOVWF  FEA
0672:  BTFSC  FD8.0
0674:  INCF   FEA,F
0676:  MOVFF  249,FEF
067A:  BRA    0610
....................    }
.................... 
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) {
067C:  MOVF   27,W
067E:  IORWF  28,W
0680:  BNZ   068A
0682:  MOVF   x48,W
0684:  SUBLW  40
0686:  BZ    068A
....................          USB_stack_status.dev_req = NONE;
0688:  CLRF   1A
....................    }
.................... 
....................    usb_request_send_response(i);
068A:  MOVFF  248,24A
068E:  MOVLB  0
0690:  RCALL  0602
0692:  RETURN 0
.................... }
.................... 
.................... #ENDIF
.................... 
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk
....................    transfer endpoints is not supported on slow speed devices per the USB
....................    specification.  You may be able to find unofficial drivers for your
....................    operating system that allows CDC to operate on a slow speed device,
....................    but CCS doesn't have any that they can recommend to you.
.................... */
.................... #if (USB_USE_FULL_SPEED==0)
....................    #error CDC and slow speed is not supported.  See comments above.
.................... #endif
.................... 
.................... struct {
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2)
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space)
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16)
.................... } __attribute__((__packed__)) usb_cdc_line_coding;
.................... 
.................... //length of time, in ms, of break signal as we received in a SendBreak message.
.................... //if ==0xFFFF, send break signal until we receive a 0x0000.
.................... unsigned int16 usb_cdc_break;
.................... 
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1];
.................... #else
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE];
.................... #endif
.................... 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT)
.................... #if sizeof(usb_cdc_put_buffer)>=0x100
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this.
....................  typedef unsigned int16 usb_cdc_tx_t;
.................... #else
....................  typedef unsigned int8 usb_cdc_tx_t;
.................... #endif
.................... 
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin;
.................... //#locate usb_cdc_put_buffer_nextin=0x1800
.................... 
.................... 
.................... #if defined(__PIC__)
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer
.................... #else
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE];
.................... #endif
.................... 
.................... int1 usb_cdc_got_set_line_coding;
.................... 
.................... struct  {
....................    int1 dte_present; //1=DTE present, 0=DTE not present
....................    int1 active;      //1=activate carrier, 0=deactivate carrier
....................    unsigned int reserved:6;
.................... } usb_cdc_carrier;
.................... 
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state;
.................... 
.................... /*
.................... #if defined(__PCH__)
....................  #byte INTCON=0xFF2
....................  #bit INT_GIE=INTCON.7
.................... #else
....................  #word SR=0x42
.................... #endif
.................... */
.................... 
.................... #if defined(USB_CDC_USE_ENCAPSULATED)
.................... unsigned int16 g_UsbCdcSendEncapsSize;
.................... #endif
.................... 
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data]
.................... void usb_isr_tok_out_cdc_control_dne(void) 
.................... {
....................    switch (__usb_cdc_state) {
*
0FD2:  MOVF   xB7,W
0FD4:  XORLW  01
0FD6:  BZ    0FDE
0FD8:  XORLW  03
0FDA:  BZ    0FEC
0FDC:  BRA    1014
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state);
....................       case USB_CDC_OUT_COMMAND:
....................         #if defined(USB_CDC_USE_ENCAPSULATED)
....................          usb_cdc_SendEncapsulatedCommand(usb_ep0_rx_buffer, g_UsbCdcSendEncapsSize);
....................         #endif
....................          usb_put_0len_0();
0FDE:  MOVLB  2
0FE0:  CLRF   x4A
0FE2:  MOVLB  0
0FE4:  CALL   0602
....................          __usb_cdc_state=0;
0FE8:  CLRF   xB7
....................          break;
0FEA:  BRA    1016
.................... 
....................     #if USB_MAX_EP0_PACKET_LENGTH==8
....................       case USB_CDC_WAIT_0LEN:
....................          usb_put_0len_0();
....................          __usb_cdc_state=0;
....................          break;
....................     #endif
.................... 
....................       case USB_CDC_OUT_LINECODING:
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7);
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n");
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7);
0FEC:  CLRF   FEA
0FEE:  MOVLW  2B
0FF0:  MOVWF  FE9
0FF2:  MOVLW  04
0FF4:  MOVWF  FE2
0FF6:  MOVLW  18
0FF8:  MOVWF  FE1
0FFA:  MOVLW  07
0FFC:  MOVWF  01
0FFE:  MOVFF  FE6,FEE
1002:  DECFSZ 01,F
1004:  BRA    0FFE
....................          __usb_cdc_state=0;
1006:  CLRF   xB7
....................          usb_put_0len_0();
1008:  MOVLB  2
100A:  CLRF   x4A
100C:  MOVLB  0
100E:  CALL   0602
....................          break;
1012:  BRA    1016
.................... 
....................       default:
....................          __usb_cdc_state=0;
1014:  CLRF   xB7
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................          break;
....................    }
1016:  GOTO   1092 (RETURN)
.................... }
.................... 
.................... //handle IN token on 0 (setup packet)
.................... void usb_isr_tkn_cdc(void) {
....................    unsigned int16 wLen;
....................    //make sure the request goes to a CDC interface
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) {
*
0C62:  MOVLB  4
0C64:  DECFSZ x1C,W
0C66:  BRA    0C6A
0C68:  BRA    0C6E
0C6A:  MOVF   x1C,F
0C6C:  BNZ   0CF8
....................       wLen = make16(usb_ep0_rx_buffer[7], usb_ep0_rx_buffer[6]);
0C6E:  MOVFF  41F,248
0C72:  MOVFF  41E,247
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]);
....................       switch(usb_ep0_rx_buffer[1]) {
0C76:  MOVF   x19,W
0C78:  XORLW  00
0C7A:  MOVLB  0
0C7C:  BZ    0C94
0C7E:  XORLW  01
0C80:  BZ    0C9C
0C82:  XORLW  21
0C84:  BZ    0CA4
0C86:  XORLW  01
0C88:  BZ    0CAE
0C8A:  XORLW  03
0C8C:  BZ    0CD4
0C8E:  XORLW  01
0C90:  BZ    0CE2
0C92:  BRA    0CF4
....................          case 0x00:  //send_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             g_UsbCdcSendEncapsSize = wLen;
....................            #endif
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND;
0C94:  MOVLW  01
0C96:  MOVWF  xB7
....................             usb_request_get_data();
0C98:  RCALL  0C5C
....................             break;
0C9A:  BRA    0CF6
.................... 
....................          case 0x01:  //get_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             usb_cdc_GetEncapsulatedResponse(usb_ep0_tx_buffer, wLen);
....................            #endif
....................             usb_request_send_response(wLen);
0C9C:  MOVFF  247,24A
0CA0:  RCALL  0602
....................             break;
0CA2:  BRA    0CF6
.................... 
....................          case 0x20:  //set_line_coding
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING;
0CA4:  MOVLW  02
0CA6:  MOVWF  xB7
....................             usb_cdc_got_set_line_coding=true;
0CA8:  BSF    xB5.0
....................             usb_request_get_data();
0CAA:  RCALL  0C5C
....................             break;
0CAC:  BRA    0CF6
.................... 
....................          case 0x21:  //get_line_coding
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding));
0CAE:  MOVLW  04
0CB0:  MOVWF  FEA
0CB2:  MOVLW  58
0CB4:  MOVWF  FE9
0CB6:  CLRF   FE2
0CB8:  MOVLW  2B
0CBA:  MOVWF  FE1
0CBC:  MOVLW  07
0CBE:  MOVWF  01
0CC0:  MOVFF  FE6,FEE
0CC4:  DECFSZ 01,F
0CC6:  BRA    0CC0
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes
0CC8:  MOVLW  07
0CCA:  MOVLB  2
0CCC:  MOVWF  x4A
0CCE:  MOVLB  0
0CD0:  RCALL  0602
....................             break;
0CD2:  BRA    0CF6
.................... 
....................          case 0x22:  //set_control_line_state
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2];
0CD4:  MOVFF  41A,B6
....................             usb_put_0len_0();
0CD8:  MOVLB  2
0CDA:  CLRF   x4A
0CDC:  MOVLB  0
0CDE:  RCALL  0602
....................             break;
0CE0:  BRA    0CF6
.................... 
....................          case 0x23:  //send_break
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]);
0CE2:  MOVFF  41A,33
0CE6:  MOVFF  41B,32
....................             usb_put_0len_0();
0CEA:  MOVLB  2
0CEC:  CLRF   x4A
0CEE:  MOVLB  0
0CF0:  RCALL  0602
....................             break;
0CF2:  BRA    0CF6
.................... 
....................          default:
....................             usb_request_stall();
0CF4:  RCALL  0608
....................             break;
0CF6:  MOVLB  4
....................       }
....................    }
0CF8:  MOVLB  0
0CFA:  GOTO   0D2C (RETURN)
.................... }
.................... 
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars]
.................... void usb_isr_tok_out_cdc_data_dne(void) {
....................    usb_cdc_get_buffer_status.got=true;
*
106C:  BSF    1E.0
....................    usb_cdc_get_buffer_status.index=0;
106E:  CLRF   20
.................... #if (defined(__PIC__) && __PIC__)
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT);
1070:  MOVLW  02
1072:  MOVLB  2
1074:  MOVWF  x48
1076:  MOVLB  0
1078:  BRA    101A
107A:  MOVFF  01,1F
.................... #else
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer(
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE);
.................... #endif
....................    if (!usb_cdc_get_buffer_status.len)
107E:  MOVF   1F,F
1080:  BNZ   1084
....................    {
....................       usb_cdc_get_discard();
1082:  BRA    105A
....................    }
1084:  GOTO   10A0 (RETURN)
....................    /*
....................   #if defined(USB_CDC_ISR)
....................    else
....................    {
....................       USB_CDC_ISR();
....................    }
....................   #endif
....................   */
.................... }
.................... 
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters]
.................... void usb_isr_tok_in_cdc_data_dne(void) 
.................... {
....................    usb_cdc_flush_tx_buffer();
*
12BA:  RCALL  1248
12BC:  GOTO   12EC (RETURN)
.................... }
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
*
116C:  MOVFF  24D,253
1170:  MOVFF  24C,252
....................    sc2=s2;
1174:  MOVFF  24F,255
1178:  MOVFF  24E,254
....................    if(sc2<sc1 && sc1 <sc2 +n)
117C:  MOVLB  2
117E:  MOVF   x55,W
1180:  SUBWF  x53,W
1182:  BNC   11FC
1184:  BNZ   118C
1186:  MOVF   x52,W
1188:  SUBWF  x54,W
118A:  BC    11FC
118C:  MOVF   x50,W
118E:  ADDWF  x54,W
1190:  MOVWF  01
1192:  MOVF   x51,W
1194:  ADDWFC x55,W
1196:  MOVWF  03
1198:  MOVF   x53,W
119A:  SUBWF  03,W
119C:  BNC   11FC
119E:  BNZ   11A6
11A0:  MOVF   01,W
11A2:  SUBWF  x52,W
11A4:  BC    11FC
....................       for(sc1+=n,sc2+=n;0<n;--n)
11A6:  MOVF   x50,W
11A8:  ADDWF  x52,F
11AA:  MOVF   x51,W
11AC:  ADDWFC x53,F
11AE:  MOVF   x50,W
11B0:  ADDWF  x54,F
11B2:  MOVF   x51,W
11B4:  ADDWFC x55,F
11B6:  MOVF   x51,F
11B8:  BNZ   11C0
11BA:  MOVF   x50,W
11BC:  SUBLW  00
11BE:  BC    11FA
....................          *--sc1=*--sc2;
11C0:  MOVF   x52,W
11C2:  BTFSC  FD8.2
11C4:  DECF   x53,F
11C6:  DECF   x52,F
11C8:  MOVFF  253,257
11CC:  MOVFF  252,256
11D0:  MOVF   x54,W
11D2:  BTFSC  FD8.2
11D4:  DECF   x55,F
11D6:  DECF   x54,F
11D8:  MOVFF  255,FEA
11DC:  MOVFF  254,FE9
11E0:  MOVFF  FEF,258
11E4:  MOVFF  253,FEA
11E8:  MOVFF  252,FE9
11EC:  MOVFF  258,FEF
11F0:  MOVF   x50,W
11F2:  BTFSC  FD8.2
11F4:  DECF   x51,F
11F6:  DECF   x50,F
11F8:  BRA    11B6
11FA:  BRA    123C
....................    else
....................       for(;0<n;--n)
11FC:  MOVF   x51,F
11FE:  BNZ   1206
1200:  MOVF   x50,W
1202:  SUBLW  00
1204:  BC    123C
....................          *sc1++=*sc2++;
1206:  MOVFF  253,257
120A:  MOVF   x52,W
120C:  INCF   x52,F
120E:  BTFSC  FD8.2
1210:  INCF   x53,F
1212:  MOVWF  x56
1214:  MOVFF  255,FEA
1218:  MOVF   x54,W
121A:  INCF   x54,F
121C:  BTFSC  FD8.2
121E:  INCF   x55,F
1220:  MOVWF  FE9
1222:  MOVFF  FEF,258
1226:  MOVFF  257,FEA
122A:  MOVFF  256,FE9
122E:  MOVFF  258,FEF
1232:  MOVF   x50,W
1234:  BTFSC  FD8.2
1236:  DECF   x51,F
1238:  DECF   x50,F
123A:  BRA    11FC
....................   return s1;
123C:  MOVFF  24C,01
1240:  MOVFF  24D,02
1244:  MOVLB  0
1246:  RETURN 0
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... void usb_cdc_flush_tx_buffer(void) 
.................... {
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE
....................    usb_cdc_tx_t n;
....................   #endif
....................   
....................    if (usb_cdc_put_buffer_nextin != 0)
1248:  MOVF   xB4,F
124A:  BZ    12B8
....................    {
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE))
....................       {
....................          usb_cdc_put_buffer_nextin = 0;
....................       }
....................      #else
....................       n = usb_cdc_put_buffer_nextin;
124C:  MOVFF  B4,248
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets
1250:  MOVLB  2
1252:  MOVF   x48,W
1254:  SUBLW  3F
1256:  BC    125C
....................          n = USB_CDC_DATA_IN_SIZE-1;
1258:  MOVLW  3F
125A:  MOVWF  x48
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE))
125C:  MOVLW  02
125E:  MOVWF  x49
1260:  CLRF   x4B
1262:  MOVLW  34
1264:  MOVWF  x4A
1266:  CLRF   x4D
1268:  MOVFF  248,24C
126C:  MOVLW  02
126E:  MOVWF  x4E
1270:  MOVLB  0
1272:  RCALL  10CE
1274:  MOVF   01,F
1276:  BZ    12B8
....................       {
....................          //pull the buffer back
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n);
1278:  CLRF   03
127A:  MOVLB  2
127C:  MOVF   x48,W
127E:  ADDLW  34
1280:  MOVWF  01
1282:  MOVLW  00
1284:  ADDWFC 03,F
1286:  MOVFF  01,249
128A:  MOVFF  03,24A
128E:  MOVF   x48,W
1290:  MOVLB  0
1292:  SUBWF  xB4,W
1294:  MOVLB  2
1296:  MOVWF  x4B
1298:  CLRF   x4D
129A:  MOVLW  34
129C:  MOVWF  x4C
129E:  MOVFF  03,24F
12A2:  MOVFF  01,24E
12A6:  CLRF   x51
12A8:  MOVFF  24B,250
12AC:  MOVLB  0
12AE:  RCALL  116C
....................          usb_cdc_put_buffer_nextin -= n;
12B0:  MOVLB  2
12B2:  MOVF   x48,W
12B4:  MOVLB  0
12B6:  SUBWF  xB4,F
....................       }      
....................      #endif
....................    }
12B8:  RETURN 0
.................... }
.................... 
.................... void usb_cdc_init(void) 
.................... {
....................    usb_cdc_line_coding.dwDTERrate = 9600;
*
0552:  MOVLB  2
0554:  CLRF   x49
0556:  CLRF   x48
0558:  MOVLW  25
055A:  MOVWF  x47
055C:  MOVLW  80
055E:  MOVWF  x46
0560:  MOVFF  246,2B
0564:  MOVFF  247,2C
0568:  CLRF   2D
056A:  CLRF   2E
....................    usb_cdc_line_coding.bCharFormat = 0;
056C:  CLRF   x46
056E:  MOVFF  246,2F
....................    usb_cdc_line_coding.bParityType = 0;
0572:  CLRF   x46
0574:  MOVFF  246,30
....................    usb_cdc_line_coding.bDataBits = 8;
0578:  MOVLW  08
057A:  MOVWF  x46
057C:  MOVFF  246,31
....................    (int8)usb_cdc_carrier = 0;
0580:  MOVLB  0
0582:  CLRF   xB6
....................    usb_cdc_got_set_line_coding = false;
0584:  BCF    xB5.0
....................    usb_cdc_break = 0;
0586:  CLRF   33
0588:  CLRF   32
....................    usb_cdc_put_buffer_nextin = 0;
058A:  CLRF   xB4
....................    usb_cdc_get_buffer_status.got = 0;
058C:  BCF    1E.0
....................    __usb_cdc_state = 0;
058E:  CLRF   xB7
0590:  RETURN 0
.................... }
.................... 
.................... ////////////////// END USB CONTROL HANDLING //////////////////////////////////
.................... 
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY /////////////////////////////
.................... 
.................... typedef struct
.................... {
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD.
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device.
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device. 
....................    unsigned int bFraming:1;   //A framing error has occurred.
....................    unsigned int bParity:1;    //A parity error has occurred.
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device.
....................    unsigned int reserved0:1;   //future use
....................    unsigned int reserved1:8;   //future use
.................... } cdc_serial_state_t;
.................... 
.................... /*
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring, 
....................    break signal and more (see cdc_serial_state_t).
....................    Some of these values are held by the host (meaning it's value only needs
....................    to be sent on change), but some values are one shot (meaning you continously
....................    need to send value to host while being held).
.................... */
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state)
.................... {
....................   #if __USB_PIC_PERIF__
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer
....................   #else
....................    unsigned int8 payload[10];
....................    #define CDC_EP1_NOTIFY_BUFFER payload
....................   #endif
.................... 
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT))
....................       return(false);
.................... 
....................    //bmRequestType
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001
....................    //bNotification
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE
....................    //wValue
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0;
....................    //wIndex
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0;
....................    //wLength
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t)
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0;
....................    //data
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state;
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8;
.................... 
....................   #if __USB_PIC_PERIF__
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE);
....................   #else
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE);
....................   #endif
....................    
....................    return(true);
.................... }
.................... 
.................... void usb_cdc_get_discard(void)
.................... {
....................    usb_cdc_get_buffer_status.got = false;
*
105A:  BCF    1E.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE);
105C:  MOVLW  02
105E:  MOVLB  2
1060:  MOVWF  x48
1062:  MOVWF  x49
1064:  MOVLB  0
1066:  RCALL  0D30
1068:  GOTO   1084 (RETURN)
.................... }
.................... 
.................... char usb_cdc_getc(void) 
.................... {
....................    char c;
.................... 
....................    while (!usb_cdc_kbhit()) 
....................    {
....................      #if defined(USB_ISR_POLLING)
....................       usb_task();
....................      #endif
....................    }
.................... 
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++];
.................... 
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len) 
....................    {
....................       usb_cdc_get_discard();
....................    }
.................... 
....................    return(c);
.................... }
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... #define __USB_PAUSE_ISR()
.................... #define __USB_RESTORE_ISR()
.................... #else
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1
.................... #endif
.................... 
.................... static void _usb_cdc_putc_fast_noflush(char c)
.................... {
....................    __USB_PAUSE_ISR();
*
1732:  MOVLB  2
1734:  BCF    x2F.0
1736:  BTFSC  FA0.5
1738:  BSF    x2F.0
173A:  BCF    FA0.5
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) 
173C:  MOVLB  0
173E:  MOVF   xB4,W
1740:  SUBLW  7F
1742:  BC    1752
1744:  CLRF   19
1746:  BTFSC  FF2.7
1748:  BSF    19.7
174A:  BCF    FF2.7
....................    {
....................       usb_cdc_flush_tx_buffer();
174C:  RCALL  1248
174E:  BTFSC  19.7
1750:  BSF    FF2.7
....................    }
....................   #endif
.................... 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) {
1752:  MOVF   xB4,W
1754:  SUBLW  7F
1756:  BC    175C
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer!
1758:  MOVLW  7F
175A:  MOVWF  xB4
....................    }
....................    
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c;
175C:  MOVF   xB4,W
175E:  INCF   xB4,F
1760:  CLRF   03
1762:  ADDLW  34
1764:  MOVWF  FE9
1766:  MOVLW  00
1768:  ADDWFC 03,W
176A:  MOVWF  FEA
176C:  MOVFF  22E,FEF
.................... 
....................    __USB_RESTORE_ISR();
1770:  MOVLB  2
1772:  BTFSS  x2F.0
1774:  BRA    1778
1776:  BSF    FA0.5
1778:  MOVLB  0
177A:  GOTO   1784 (RETURN)
.................... }
.................... 
.................... void usb_cdc_putc_fast(char c)
.................... {
....................    _usb_cdc_putc_fast_noflush(c);
177E:  MOVFF  22D,22E
1782:  BRA    1732
.................... 
....................   #if defined(USB_ISR_POLLING)
....................    // if interrupts are disabled, we should clear all activity isrs
....................    // before we attempt to put any data onto an endpoint.
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT))
....................       return;
....................    usb_task();
....................   #endif
....................   
....................   #if !defined(USB_CDC_DELAYED_FLUSH)
1784:  GOTO   17C2 (RETURN)
....................    //if (usb_cdc_put_buffer_free()) 
....................    {
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin);
....................       usb_cdc_flush_tx_buffer();
....................    }
....................   #endif
.................... 
....................    //putc('*');
.................... }
.................... 
.................... void usb_cdc_putc(char c)
.................... {
....................    while (!usb_cdc_putready()) 
1788:  MOVLW  80
178A:  BSF    FD8.0
178C:  SUBFWB xB4,W
178E:  BNZ   17BC
1790:  CLRF   19
1792:  BTFSC  FF2.7
1794:  BSF    19.7
1796:  BCF    FF2.7
....................    {
....................      #if 1
....................       if (usb_cdc_put_buffer_free()) 
1798:  MOVLW  02
179A:  MOVLB  2
179C:  MOVWF  x56
179E:  MOVLB  0
17A0:  CALL   0E30
17A4:  BTFSC  19.7
17A6:  BSF    FF2.7
17A8:  MOVF   01,F
17AA:  BZ    17BA
17AC:  CLRF   19
17AE:  BTFSC  FF2.7
17B0:  BSF    19.7
17B2:  BCF    FF2.7
....................       {
....................          usb_cdc_flush_tx_buffer();
17B4:  RCALL  1248
17B6:  BTFSC  19.7
17B8:  BSF    FF2.7
....................       }
....................      #endif
.................... 
....................      #if defined(USB_ISR_POLLING)
17BA:  BRA    1788
....................       usb_task();
....................      #endif
....................    }
....................    usb_cdc_putc_fast(c);
17BC:  MOVFF  22C,22D
17C0:  BRA    177E
17C2:  GOTO   17D8 (RETURN)
.................... }
.................... 
.................... int1 usb_cdc_putd(char *ptr, unsigned int8 len)
.................... {
....................  #if USB_EP2_TX_SIZE>=0x100
....................    unsigned int16 i;
....................  #else
....................    unsigned int8 i;
....................  #endif
....................    char c;
....................    
....................    i = 0;
....................    
....................    if (!usb_cdc_put_buffer_free())
....................       return(false);
....................    
....................    while(len--)
....................    {
....................       c = *ptr++;
....................       _usb_cdc_putc_fast_noflush(c);
....................       if (++i >= USB_EP2_TX_SIZE)
....................          break;
....................    }
....................    
....................    usb_cdc_flush_tx_buffer();
....................    
....................    return(true);
.................... }
.................... 
.................... int1 usb_cdc_puts(char *ptr)
.................... {   
....................    unsigned int8 len;
.................... 
....................    len = strlen(ptr);
....................   
....................    return(usb_cdc_putd(ptr, len));
.................... }
.................... 
.................... #endif //__USB_CDC_HELPERS_ONLY__
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... char gethex1_usb() 
.................... {
....................    char digit;
.................... 
....................    digit = usb_cdc_getc();
.................... 
....................    usb_cdc_putc(digit);
.................... 
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((toupper(digit)-'A')+10);
.................... }
.................... 
.................... char gethex_usb() {
....................    unsigned int8 lo,hi;
.................... 
....................    hi = gethex1_usb();
....................    lo = gethex1_usb();
....................    if(lo==0xdd)
....................      return(hi);
....................    else
....................      return( hi*16+lo );
.................... }
.................... 
.................... void get_string_usb(char* s, unsigned int max) {
....................    unsigned int len;
....................    char c;
.................... 
....................    --max;
....................    len=0;
....................    do {
....................      c=usb_cdc_getc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           usb_cdc_putc(c);
....................           usb_cdc_putc(' ');
....................           usb_cdc_putc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<max) {
....................          s[len++]=c;
....................          usb_cdc_putc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... 
.................... 
.................... // stdlib.h is required for the ato_ conversions
.................... // in the following functions
.................... #ifdef _STDLIB
.................... 
.................... signed int get_int_usb() {
....................   char s[7];
....................   signed int i;
.................... 
....................   get_string_usb(s, 7);
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... 
.................... signed long get_long_usb() {
....................   char s[13];
....................   signed long l;
.................... 
....................   get_string_usb(s, 13);
....................   l=atol(s);
....................   return(l);
.................... }
.................... 
.................... float get_float_usb() {
....................   char s[20];
....................   float f;
.................... 
....................   get_string_usb(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... uint16_t globalMs;
.................... uint8_t globalSec;
.................... uint16_t globalMin;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #use spi (MASTER, SPI1, ENABLE=PIN_A5, BAUD=10000, MODE=0, BITS=8, STREAM=SPI_1)
.................... 
.................... #byte porta = 0xf80 // Identificador para el puerto A. 
.................... #byte portb = 0xf81 // Identificador para el puerto B. 
.................... #byte portc = 0xf82 // Identificador para el puerto C. 
.................... #byte portd = 0xf83 // Identificador para el puerto D. 
.................... #byte porte = 0xf84 // Identificador para el puerto E.
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlibm.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /*********************************************************************/
.................... #ifndef _STDLIBM
.................... #define _STDLIBM
.................... 
.................... /* Memory Management Functions*/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #if defined(__PCB__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int8 next; }node_t;
.................... #elif defined(__PCM__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCH__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCD__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #endif
.................... 
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY)
....................    #USE DYNAMIC_MEMORY
.................... #endif
.................... 
.................... #ifndef debug_stdlibm
....................    #define debug_stdlibm(s)
.................... #else
....................    #define __DO_DEBUG_STDLIBM
....................    
....................    char g_DebugStdlibmStr[50];
....................    
....................    #if defined(__PCD__)
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__))
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0))
....................       #else
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0))
....................       #endif
....................    #else
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM"))
....................    #endif
.................... #endif
.................... 
.................... #if defined(STDLIBM_TRACK_WORST_CASE)
....................    static size_t _g_StdlibmCurrentBytesUsed = 0;
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0;
....................    
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \
....................       _g_StdlibmCurrentBytesUsed += _x;   \
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed
....................    
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x
.................... #else
....................    #define _STDLIBM_TRACK_WORST_INC(_x)
....................    #define _STDLIBM_TRACK_WORST_DEC(_x)
.................... #endif
.................... 
.................... #include <memmgmt.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__PCH__)
....................  #define _MEMMGMT_CSIZE 32768
....................  #define _MEMMGMT_POS 15
.................... #elif defined(__PCD__)
....................    #define _MEMMGMT_CSIZE 32768
....................    #define _MEMMGMT_POS 15
.................... #else
....................    #define _MEMMGMT_CSIZE 127
....................    #define _MEMMGMT_POS 7
.................... #endif
.................... 
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location
.................... {
....................    node_t *result;
....................    result =ptr;
*
2C66:  MOVFF  1E1,1E3
2C6A:  MOVFF  1E0,1E2
....................    result->size=size;
2C6E:  MOVLB  1
2C70:  MOVFF  1E2,FE9
2C74:  MOVFF  1E3,FEA
2C78:  MOVFF  1DF,FEC
2C7C:  MOVF   FED,F
2C7E:  MOVFF  1DE,FEF
....................    result->next = NULL;
2C82:  MOVLW  02
2C84:  ADDWF  xE2,W
2C86:  MOVWF  FE9
2C88:  MOVLW  00
2C8A:  ADDWFC xE3,W
2C8C:  MOVWF  FEA
2C8E:  CLRF   FEC
2C90:  MOVF   FED,F
2C92:  CLRF   FEF
....................    return result;
2C94:  MOVFF  1E2,01
2C98:  MOVFF  1E3,02
2C9C:  MOVLB  0
2C9E:  GOTO   2DF2 (RETURN)
.................... }
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node
.................... {
....................    node->size=size;
*
2D28:  MOVLB  1
2D2A:  MOVFF  1DF,FE9
2D2E:  MOVFF  1E0,FEA
2D32:  MOVFF  1E2,FEC
2D36:  MOVF   FED,F
2D38:  MOVFF  1E1,FEF
2D3C:  MOVLB  0
2D3E:  RETURN 0
.................... }
.................... 
.................... /* Insert node immediately after place */ //old,new
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node
.................... {
....................     if (place->next==NULL)
*
2CA2:  MOVLW  02
2CA4:  MOVLB  1
2CA6:  ADDWF  xDA,W
2CA8:  MOVWF  FE9
2CAA:  MOVLW  00
2CAC:  ADDWFC xDB,W
2CAE:  MOVWF  FEA
2CB0:  MOVFF  FEC,1DF
2CB4:  MOVF   FED,F
2CB6:  MOVFF  FEF,1DE
2CBA:  MOVF   xDE,F
2CBC:  BNZ   2CD6
2CBE:  MOVF   xDF,F
2CC0:  BNZ   2CD6
....................        node->next= NULL;
2CC2:  MOVLW  02
2CC4:  ADDWF  xDC,W
2CC6:  MOVWF  FE9
2CC8:  MOVLW  00
2CCA:  ADDWFC xDD,W
2CCC:  MOVWF  FEA
2CCE:  CLRF   FEC
2CD0:  MOVF   FED,F
2CD2:  CLRF   FEF
2CD4:  BRA    2D0C
....................     else
....................        node->next=place->next;
2CD6:  MOVLW  02
2CD8:  ADDWF  xDC,W
2CDA:  MOVWF  01
2CDC:  MOVLW  00
2CDE:  ADDWFC xDD,W
2CE0:  MOVWF  03
2CE2:  MOVWF  xDF
2CE4:  MOVLW  02
2CE6:  ADDWF  xDA,W
2CE8:  MOVWF  FE9
2CEA:  MOVLW  00
2CEC:  ADDWFC xDB,W
2CEE:  MOVWF  FEA
2CF0:  MOVFF  FEC,03
2CF4:  MOVF   FED,F
2CF6:  MOVFF  FEF,1E0
2CFA:  MOVFF  1DF,FEA
2CFE:  MOVFF  01,FE9
2D02:  MOVFF  03,FEC
2D06:  MOVF   FED,F
2D08:  MOVFF  1E0,FEF
....................     place->next=node;
2D0C:  MOVLW  02
2D0E:  ADDWF  xDA,W
2D10:  MOVWF  FE9
2D12:  MOVLW  00
2D14:  ADDWFC xDB,W
2D16:  MOVWF  FEA
2D18:  MOVFF  1DD,FEC
2D1C:  MOVF   FED,F
2D1E:  MOVFF  1DC,FEF
2D22:  MOVLB  0
2D24:  GOTO   2E0C (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void remove_node(node_t *node) {// remove the given node from the memlist
....................    node_t *ptr;
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next);
*
2E82:  MOVFF  C0,1E2
2E86:  MOVFF  BF,1E1
2E8A:  MOVLW  02
2E8C:  MOVLB  1
2E8E:  ADDWF  xE1,W
2E90:  MOVWF  FE9
2E92:  MOVLW  00
2E94:  ADDWFC xE2,W
2E96:  MOVWF  FEA
2E98:  MOVFF  FEC,1E4
2E9C:  MOVF   FED,F
2E9E:  MOVFF  FEF,1E3
2EA2:  MOVF   xDF,W
2EA4:  SUBWF  xE3,W
2EA6:  BNZ   2EAE
2EA8:  MOVF   xE0,W
2EAA:  SUBWF  xE4,W
2EAC:  BZ    2ECA
2EAE:  MOVLW  02
2EB0:  ADDWF  xE1,W
2EB2:  MOVWF  FE9
2EB4:  MOVLW  00
2EB6:  ADDWFC xE2,W
2EB8:  MOVWF  FEA
2EBA:  MOVFF  FEC,1E2
2EBE:  MOVF   FED,F
2EC0:  MOVFF  FEF,1E1
2EC4:  MOVLB  0
2EC6:  BRA    2E8A
2EC8:  MOVLB  1
....................    ptr->next=node->next;
2ECA:  MOVLW  02
2ECC:  ADDWF  xE1,W
2ECE:  MOVWF  01
2ED0:  MOVLW  00
2ED2:  ADDWFC xE2,W
2ED4:  MOVWF  03
2ED6:  MOVWF  xE4
2ED8:  MOVLW  02
2EDA:  ADDWF  xDF,W
2EDC:  MOVWF  FE9
2EDE:  MOVLW  00
2EE0:  ADDWFC xE0,W
2EE2:  MOVWF  FEA
2EE4:  MOVFF  FEC,03
2EE8:  MOVF   FED,F
2EEA:  MOVFF  FEF,1E5
2EEE:  MOVFF  1E4,FEA
2EF2:  MOVFF  01,FE9
2EF6:  MOVFF  03,FEC
2EFA:  MOVF   FED,F
2EFC:  MOVFF  1E5,FEF
....................    node=NULL;
2F00:  CLRF   xE0
2F02:  CLRF   xDF
2F04:  MOVLB  0
2F06:  GOTO   2FC8 (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__DO_DEBUG_STDLIBM)
.................... void print_list() { // print the current memlist
....................     node_t *node;
....................     debug_stdlibm("\r\nThe list is \n\r");
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next)
....................     {
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next);
....................         debug_stdlibm(g_DebugStdlibmStr);
....................         if (INVALID_MEMORY_LOCATION(node->next))
....................         {
....................            debug_stdlibm("Breaking because of invalid next node\r\n");
....................            break;
....................         }   
....................     }
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t));
....................     debug_stdlibm(g_DebugStdlibmStr);
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void traverse()
.................... {
....................    node_t *node,*temp;
....................    unsigned int16 nsize,nextsize;
....................    node=__DYNAMIC_HEAD;
2F0A:  MOVFF  C0,1D8
2F0E:  MOVFF  BF,1D7
....................    while(node!=NULL)
2F12:  MOVLB  1
2F14:  MOVF   xD7,F
2F16:  BNZ   2F1E
2F18:  MOVF   xD8,F
2F1A:  BTFSC  FD8.2
2F1C:  BRA    3016
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          break;
....................       }   
....................      #endif
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free
2F1E:  MOVFF  1D7,FE9
2F22:  MOVFF  1D8,FEA
2F26:  MOVFF  FEC,1E0
2F2A:  MOVF   FED,F
2F2C:  MOVFF  FEF,1DF
2F30:  BTFSC  xE0.7
2F32:  BRA    2FFA
....................       {
....................          nsize=node->size;
2F34:  MOVFF  1D7,FE9
2F38:  MOVFF  1D8,FEA
2F3C:  MOVFF  FEC,1DC
2F40:  MOVF   FED,F
2F42:  MOVFF  FEF,1DB
....................          temp=(unsigned int16)node->next;
2F46:  MOVLW  02
2F48:  ADDWF  xD7,W
2F4A:  MOVWF  FE9
2F4C:  MOVLW  00
2F4E:  ADDWFC xD8,W
2F50:  MOVWF  FEA
2F52:  MOVFF  FEC,1DA
2F56:  MOVF   FED,F
2F58:  MOVFF  FEF,1D9
....................         #if defined(__DO_DEBUG_STDLIBM)
....................          if (INVALID_MEMORY_LOCATION(temp))
....................          {
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node);
....................             debug_stdlibm(g_DebugStdlibmStr);
....................             break;
....................          }
....................         #endif
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine
2F5C:  MOVFF  1D9,FE9
2F60:  MOVFF  1DA,FEA
2F64:  MOVFF  FEC,1E0
2F68:  MOVF   FED,F
2F6A:  MOVFF  FEF,1DF
2F6E:  BTFSC  xE0.7
2F70:  BRA    2FDE
2F72:  MOVF   xDB,W
2F74:  ADDWF  xD7,W
2F76:  MOVWF  xE1
2F78:  MOVF   xDC,W
2F7A:  ADDWFC xD8,W
2F7C:  MOVWF  xE2
2F7E:  MOVLW  04
2F80:  ADDWF  xE1,W
2F82:  MOVWF  01
2F84:  MOVLW  00
2F86:  ADDWFC xE2,W
2F88:  MOVWF  03
2F8A:  MOVF   01,W
2F8C:  SUBWF  xD9,W
2F8E:  BNZ   2FDE
2F90:  MOVF   03,W
2F92:  SUBWF  xDA,W
2F94:  BNZ   2FDE
....................          {
....................             nextsize=temp->size;
2F96:  MOVFF  1D9,FE9
2F9A:  MOVFF  1DA,FEA
2F9E:  MOVFF  FEC,1DE
2FA2:  MOVF   FED,F
2FA4:  MOVFF  FEF,1DD
....................             nsize+=nextsize+sizeof(node_t);
2FA8:  MOVLW  04
2FAA:  ADDWF  xDD,W
2FAC:  MOVWF  01
2FAE:  MOVLW  00
2FB0:  ADDWFC xDE,W
2FB2:  MOVWF  03
2FB4:  MOVF   01,W
2FB6:  ADDWF  xDB,F
2FB8:  MOVF   03,W
2FBA:  ADDWFC xDC,F
....................             remove_node(temp);
2FBC:  MOVFF  1DA,1E0
2FC0:  MOVFF  1D9,1DF
2FC4:  MOVLB  0
2FC6:  BRA    2E82
....................             update_node(node,nsize);
2FC8:  MOVFF  1D8,1E0
2FCC:  MOVFF  1D7,1DF
2FD0:  MOVFF  1DC,1E2
2FD4:  MOVFF  1DB,1E1
2FD8:  RCALL  2D28
....................          }
2FDA:  BRA    2FF6
2FDC:  MOVLB  1
....................          else
....................          node=node->next;
2FDE:  MOVLW  02
2FE0:  ADDWF  xD7,W
2FE2:  MOVWF  FE9
2FE4:  MOVLW  00
2FE6:  ADDWFC xD8,W
2FE8:  MOVWF  FEA
2FEA:  MOVFF  FEC,1D8
2FEE:  MOVF   FED,F
2FF0:  MOVFF  FEF,1D7
2FF4:  MOVLB  0
....................       }
2FF6:  BRA    3012
2FF8:  MOVLB  1
....................       else
....................       node=node->next;
2FFA:  MOVLW  02
2FFC:  ADDWF  xD7,W
2FFE:  MOVWF  FE9
3000:  MOVLW  00
3002:  ADDWFC xD8,W
3004:  MOVWF  FEA
3006:  MOVFF  FEC,1D8
300A:  MOVF   FED,F
300C:  MOVFF  FEF,1D7
3010:  MOVLB  0
3012:  BRA    2F12
3014:  MOVLB  1
....................    }
3016:  MOVLB  0
3018:  GOTO   3090 (RETURN)
.................... }
.................... 
.................... char *malloc(size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize;
....................    #if defined(__PCD__)
....................    if (size % 2)
....................       size++;
....................    #endif
....................    node=__DYNAMIC_HEAD;
*
2D40:  MOVFF  C0,1D5
2D44:  MOVFF  BF,1D4
....................    
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
....................         
....................    while(node!=NULL) // chk until end of memlist
2D48:  MOVLB  1
2D4A:  MOVF   xD4,F
2D4C:  BNZ   2D54
2D4E:  MOVF   xD5,F
2D50:  BTFSC  FD8.2
2D52:  BRA    2E5E
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size
2D54:  MOVFF  1D4,FE9
2D58:  MOVFF  1D5,FEA
2D5C:  MOVFF  FEC,1DB
2D60:  MOVF   FED,F
2D62:  MOVFF  FEF,1DA
2D66:  BTFSC  xDB.7
2D68:  BRA    2E46
2D6A:  MOVFF  1D4,FE9
2D6E:  MOVFF  1D5,FEA
2D72:  MOVFF  FEC,1DD
2D76:  MOVF   FED,F
2D78:  MOVFF  FEF,1DC
2D7C:  MOVF   xD3,W
2D7E:  SUBWF  xDD,W
2D80:  BNC   2E46
2D82:  BNZ   2D8A
2D84:  MOVF   xD2,W
2D86:  SUBWF  xDC,W
2D88:  BNC   2E46
....................       {
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at
2D8A:  MOVFF  1D4,FE9
2D8E:  MOVFF  1D5,FEA
2D92:  MOVFF  FEC,1D9
2D96:  MOVF   FED,F
2D98:  MOVFF  FEF,1D8
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist
2D9C:  MOVLW  04
2D9E:  ADDWF  xD2,W
2DA0:  MOVWF  01
2DA2:  MOVLW  00
2DA4:  ADDWFC xD3,W
2DA6:  MOVWF  03
2DA8:  MOVF   03,W
2DAA:  SUBWF  xD9,W
2DAC:  BNC   2E2A
2DAE:  BNZ   2DB6
2DB0:  MOVF   xD8,W
2DB2:  SUBWF  01,W
2DB4:  BC    2E2A
....................          {
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
2DB6:  MOVF   xD2,W
2DB8:  SUBWF  xD8,W
2DBA:  MOVWF  xDA
2DBC:  MOVF   xD3,W
2DBE:  SUBWFB xD9,W
2DC0:  MOVWF  xDB
2DC2:  MOVLW  04
2DC4:  SUBWF  xDA,F
2DC6:  MOVLW  00
2DC8:  SUBWFB xDB,F
2DCA:  MOVLW  04
2DCC:  ADDWF  xD4,W
2DCE:  MOVWF  xDC
2DD0:  MOVLW  00
2DD2:  ADDWFC xD5,W
2DD4:  MOVWF  xDD
2DD6:  MOVF   xD2,W
2DD8:  ADDWF  xDC,F
2DDA:  MOVF   xD3,W
2DDC:  ADDWFC xDD,F
2DDE:  MOVFF  1DB,1DF
2DE2:  MOVFF  1DA,1DE
2DE6:  MOVFF  1DD,1E1
2DEA:  MOVFF  1DC,1E0
2DEE:  MOVLB  0
2DF0:  BRA    2C66
2DF2:  MOVFF  02,1D7
2DF6:  MOVFF  01,1D6
....................             insert_node_after(node,new);
2DFA:  MOVFF  1D5,1DB
2DFE:  MOVFF  1D4,1DA
2E02:  MOVFF  1D7,1DD
2E06:  MOVFF  1D6,1DC
2E0A:  BRA    2CA2
....................             update_node(node,size+_MEMMGMT_CSIZE);
2E0C:  MOVLB  1
2E0E:  MOVLW  80
2E10:  ADDWF  xD3,W
2E12:  MOVWF  xDB
2E14:  MOVFF  1D5,1E0
2E18:  MOVFF  1D4,1DF
2E1C:  MOVWF  xE2
2E1E:  MOVFF  1D2,1E1
2E22:  MOVLB  0
2E24:  RCALL  2D28
....................          }
2E26:  BRA    2E42
2E28:  MOVLB  1
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
2E2A:  MOVLW  80
2E2C:  ADDWF  xD9,W
2E2E:  MOVWF  xDB
2E30:  MOVFF  1D5,1E0
2E34:  MOVFF  1D4,1DF
2E38:  MOVWF  xE2
2E3A:  MOVFF  1D8,1E1
2E3E:  MOVLB  0
2E40:  RCALL  2D28
....................          //end if
....................          break;
2E42:  MOVLB  1
2E44:  BRA    2E5E
....................       }//end if
....................       node=node->next;
2E46:  MOVLW  02
2E48:  ADDWF  xD4,W
2E4A:  MOVWF  FE9
2E4C:  MOVLW  00
2E4E:  ADDWFC xD5,W
2E50:  MOVWF  FEA
2E52:  MOVFF  FEC,1D5
2E56:  MOVF   FED,F
2E58:  MOVFF  FEF,1D4
2E5C:  BRA    2D4A
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
2E5E:  MOVF   xD4,F
2E60:  BNZ   2E70
2E62:  MOVF   xD5,F
2E64:  BNZ   2E70
....................    {
....................       debug_stdlibm("Not enough memory for mallocation\r\n");
....................       return NULL;
2E66:  MOVLW  00
2E68:  MOVWF  01
2E6A:  MOVWF  02
2E6C:  BRA    2E7E
....................    }
2E6E:  BRA    2E7E
....................    else
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t));
....................       debug_stdlibm(g_DebugStdlibmStr);
....................      #endif
....................       _STDLIBM_TRACK_WORST_INC(size);
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space
2E70:  MOVLW  04
2E72:  ADDWF  xD4,W
2E74:  MOVWF  01
2E76:  MOVLW  00
2E78:  ADDWFC xD5,W
2E7A:  MOVWF  03
2E7C:  MOVWF  02
....................    }
2E7E:  MOVLB  0
2E80:  RETURN 0
.................... }
.................... 
.................... char *calloc(size_t nmemb,size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize,resize;
....................    node=__DYNAMIC_HEAD;
....................    resize=nmemb*size;
....................    #if defined(__PCD__)
....................    if(resize%2)
....................       resize++;
....................    #endif
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size
....................       {
....................          nsize=node->size;
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize);
....................             insert_node_after(node,new);
....................             update_node(node,resize+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for callocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0
....................       _STDLIBM_TRACK_WORST_INC(resize);
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space
....................    }
.................... }
.................... void free( void * ptr)
.................... {
....................    node_t *node;
....................    unsigned int16 nsize;
.................... 
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
.................... 
....................    if(ptr==NULL) // not a valid pounsigned int8er
*
301C:  MOVLB  1
301E:  MOVF   xD1,F
3020:  BNZ   302A
3022:  MOVF   xD2,F
3024:  BNZ   302A
....................       return;
3026:  BRA    3092
3028:  BRA    308C
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
302A:  MOVLW  04
302C:  SUBWF  xD1,W
302E:  MOVWF  xD3
3030:  MOVLW  00
3032:  SUBWFB xD2,W
3034:  MOVWF  xD4
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied
3036:  MOVFF  1D3,FE9
303A:  MOVFF  1D4,FEA
303E:  MOVFF  FEC,1D8
3042:  MOVF   FED,F
3044:  MOVFF  FEF,1D7
3048:  BTFSS  xD8.7
304A:  BRA    3086
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
304C:  MOVFF  1D3,FE9
3050:  MOVFF  1D4,FEA
3054:  MOVFF  FEC,1D8
3058:  MOVF   FED,F
305A:  MOVFF  FEF,1D7
305E:  MOVLW  00
3060:  SUBWF  xD7,W
3062:  MOVWF  xD5
3064:  MOVLW  80
3066:  SUBWFB xD8,W
3068:  MOVWF  xD6
....................          update_node(node,nsize);
306A:  MOVFF  1D4,1E0
306E:  MOVFF  1D3,1DF
3072:  MOVFF  1D6,1E2
3076:  MOVFF  1D5,1E1
307A:  MOVLB  0
307C:  RCALL  2D28
....................          ptr=NULL;
307E:  MOVLB  1
3080:  CLRF   xD2
3082:  CLRF   xD1
....................          _STDLIBM_TRACK_WORST_DEC(nsize);
....................       }
3084:  BRA    308C
....................       else // wrong input, return
....................       {
....................          ptr=NULL;
3086:  CLRF   xD2
3088:  CLRF   xD1
....................          return;
308A:  BRA    3092
....................       }
....................    }
....................    traverse();
308C:  MOVLB  0
308E:  BRA    2F0A
3090:  MOVLB  1
3092:  MOVLB  0
3094:  RETURN 0
.................... }
.................... 
.................... char *realloc(void *ptr,size_t size)
.................... {
....................    node_t *node,*new,*temp;
....................    unsigned int16 nsize,nextsize;
....................    char *newptr;
....................    #if defined(__PCD__)
....................    if(size %2)
....................       size++;
....................    #endif
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory
....................       return(malloc(size));
....................    else if(size==0)
....................    {
....................       free(ptr);
....................       return(NULL);
....................    }
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          temp=(unsigned int16)node->next;
....................          if(nsize>size)// block > req size
....................          {
....................        
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   nextsize=temp->size;
....................                   remove_node(temp);
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t));
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else//not enough space for new node so use original size
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block
.................... 
....................          }
....................          else // block < req size
....................          {
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................             {
....................                nextsize=temp->size;
....................                if(nextsize>=size-nsize) // next block >=difference
....................                {
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist
....................                   {
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t));
....................                       insert_node_after(node,new);
....................                      _STDLIBM_TRACK_WORST_DEC(nsize);
....................                      _STDLIBM_TRACK_WORST_INC(size);
....................                   }
....................                   else//not enough space for new node in next node, so use original size
....................                   {
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                   }
....................                }
....................                else  //next block free but too small for new size
....................                {
....................                   newptr = malloc(size);  //use malloc to find new block
....................                   if(newptr == NULL)
....................                      return(NULL);        //return NULL if malloc was unable to find new block
....................                    
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                   free(ptr);                    //free original block
....................                   return(newptr);               //return new pointer
....................                }
....................             }
....................             else  //next block not free
....................             {
....................                newptr = malloc(size);  //use malloc to find new block
....................                if(newptr == NULL)      
....................                   return(NULL);        //return NULL if malloc was unable to find new block
....................                
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                free(ptr);                    //free original block
....................                return(newptr);               //return new pointer
....................             }
....................          }
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block
....................       }
....................       else // not allocated use malloc
....................       {
....................          return(malloc(size));
....................       }
....................    }
....................  }
....................  
.................... typedef struct
.................... {
....................    size_t bytesUsed;
....................    size_t largestUsedSeg;
....................    int segmentsUsed;
....................    size_t bytesFree;
....................    size_t largestFreeSeg;
....................    int segmentsFree;
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    size_t worstCaseBytesUsed;
....................   #endif
.................... } heap_status_t;
.................... 
.................... void GetHeapStatus(heap_status_t *pHeapStatus)
.................... {
....................    heap_status_t status;
....................    node_t *node;
....................    unsigned int16 nsize;
....................    
....................    node=__DYNAMIC_HEAD;
....................    
....................    memset(&status, 0, sizeof(status));
.................... 
....................    while(node!=NULL)
....................    {
....................       nsize = node->size;
....................       node = node->next;
....................       
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free
....................       {
....................          status.bytesFree += nsize;
....................          
....................          status.segmentsFree++;
....................          
....................          if (nsize > status.largestFreeSeg)
....................          {
....................             status.largestFreeSeg = nsize;
....................          }
....................       }
....................       else
....................       {
....................          bit_clear(nsize, _MEMMGMT_POS);
....................          
....................          status.bytesUsed += nsize;
....................          
....................          status.segmentsUsed++;
....................          
....................          if (nsize > status.largestUsedSeg)
....................          {
....................             status.largestUsedSeg = nsize;
....................          }
....................       }
....................    }
.................... 
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed;
....................   #endif
.................... 
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t));
.................... }
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include <adafruit_rfm69_registers.h>
.................... 
.................... //Internal constants:
.................... #define _REG_FIFO 0x00
.................... #define _REG_OP_MODE 0x01
.................... #define _REG_DATA_MOD 0x02
.................... #define _REG_BITRATE_MSB 0x03
.................... #define _REG_BITRATE_LSB 0x04
.................... #define _REG_FDEV_MSB 0x05
.................... #define _REG_FDEV_LSB 0x06
.................... #define _REG_FRF_MSB 0x07
.................... #define _REG_FRF_MID 0x08
.................... #define _REG_FRF_LSB 0x09
.................... #define _REG_VERSION 0x10
.................... #define _REG_PA_LEVEL 0x11
.................... #define _REG_RX_BW 0x19
.................... #define _REG_AFC_BW 0x1A
.................... #define _REG_RSSI_VALUE 0x24
.................... #define _REG_DIO_MAPPING1 0x25
.................... #define _REG_IRQ_FLAGS1 0x27
.................... #define _REG_IRQ_FLAGS2 0x28
.................... #define _REG_PREAMBLE_MSB 0x2C
.................... #define _REG_PREAMBLE_LSB 0x2D
.................... #define _REG_SYNC_CONFIG 0x2E
.................... #define _REG_SYNC_VALUE1 0x2F
.................... #define _REG_PACKET_CONFIG1 0x37
.................... #define _REG_FIFO_THRESH 0x3C
.................... #define _REG_PACKET_CONFIG2 0x3D
.................... #define _REG_AES_KEY1 0x3E
.................... #define _REG_TEMP1 0x4E
.................... #define _REG_TEMP2 0x4F
.................... #define _REG_TEST_PA1 0x5A
.................... #define _REG_TEST_PA2 0x5C
.................... #define _REG_TEST_DAGC 0x6F
.................... 
.................... #define _TEST_PA1_NORMAL 0x55
.................... #define _TEST_PA1_BOOST 0x5D
.................... #define _TEST_PA2_NORMAL 0x70
.................... #define _TEST_PA2_BOOST 0x7C
.................... 
.................... //The crystal oscillator frequency and frequency synthesizer step size.
.................... //See the datasheet for details of this calculation.
.................... 
.................... //        #define _FXOSC = 32000000.0
.................... //        #define _FSTEP = _FXOSC / 524288
.................... 
.................... //RadioHead specific compatibility constants.
.................... #define _RH_BROADCAST_ADDRESS 0xFF
.................... //The acknowledgement bit in the FLAGS
.................... //The top 4 bits of the flags are reserved for RadioHead. The lower 4 bits are reserved
.................... //for application layer use.
.................... #define _RH_FLAGS_ACK 0x80
.................... #define _RH_FLAGS_RETRY 0x40
.................... 
.................... //User facing constants:
.................... #define SLEEP_MODE 0b000
.................... #define STANDBY_MODE 0b001
.................... #define FS_MODE 0b010
.................... #define TX_MODE 0b011
.................... #define RX_MODE 0b100
.................... //supervisor.ticks_ms() contants
.................... //          #define _TICKS_PERIOD = const(1 << 29)
.................... //          #define _TICKS_MAX = const(_TICKS_PERIOD - 1)
.................... //          #define _TICKS_HALFPERIOD = const(_TICKS_PERIOD // 2)
.................... 
.................... #include <utils.h>
.................... //Global buffer for SPI commands
.................... uint8_t _BUFFER[4];
.................... 
.................... void setOutput(int pin, int value){
....................     output_bit(pin,value);
*
1628:  MOVLB  2
162A:  MOVF   x1F,F
162C:  BNZ   1632
162E:  MOVLW  00
1630:  BRA    1634
1632:  MOVLW  01
1634:  MOVFF  21E,220
1638:  MOVWF  x21
163A:  MOVLW  0F
163C:  MOVWF  x23
163E:  MOVLW  89
1640:  MOVWF  x22
1642:  MOVLB  0
1644:  RCALL  15E6
1646:  MOVFF  21E,220
164A:  MOVLB  2
164C:  CLRF   x21
164E:  MOVLW  0F
1650:  MOVWF  x23
1652:  MOVLW  92
1654:  MOVWF  x22
1656:  MOVLB  0
1658:  RCALL  15E6
165A:  RETURN 0
.................... }
.................... void usbPrint(char* str){
....................       usb_task();  //Verifica la comunicacin USB
*
17EC:  RCALL  156A
....................       if(usb_enumerated()) {
17EE:  RCALL  1536
17F0:  MOVF   01,F
17F2:  BZ    17FE
....................          printf(usb_cdc_putc,str); 
17F4:  MOVFF  229,FEA
17F8:  MOVFF  228,FE9
17FC:  BRA    17C6
....................       }
17FE:  RETURN 0
.................... }
.................... 
.................... void spiBegin(){
.................... //SPI.beginTransaction(SPISettings(SPIBAUD, MSBFIRST, SPI_MODE0));
.................... setOutput(SSPin, 0);
*
165C:  MOVLW  05
165E:  MOVLB  2
1660:  MOVWF  x1E
1662:  CLRF   x1F
1664:  MOVLB  0
1666:  RCALL  1628
1668:  RETURN 0
.................... 
.................... }
.................... void spiEnd(){
.................... setOutput(SSPin, 1);    
*
1692:  MOVLW  05
1694:  MOVLB  2
1696:  MOVWF  x1E
1698:  MOVLW  01
169A:  MOVWF  x1F
169C:  MOVLB  0
169E:  RCALL  1628
16A0:  RETURN 0
.................... //SPI.endTransaction();
.................... }
.................... 
.................... void print(char* str){
....................     //Serial.print(str);
....................     usbPrint(str);
*
185A:  MOVFF  217,229
185E:  MOVFF  216,228
1862:  RCALL  17EC
1864:  RETURN 0
.................... }
.................... 
.................... void print(int str, int format){
....................     char converted[11];
....................     int i;
....................     if (format == HEX) sprintf(converted,"0x%02X",str);
*
1F92:  MOVLB  2
1F94:  MOVF   x1B,W
1F96:  SUBLW  10
1F98:  BNZ   1FCC
1F9A:  MOVLW  02
1F9C:  MOVLB  0
1F9E:  MOVWF  xC6
1FA0:  MOVLW  1C
1FA2:  MOVWF  xC5
1FA4:  MOVLW  30
1FA6:  MOVLB  2
1FA8:  MOVWF  x2E
1FAA:  MOVLB  0
1FAC:  RCALL  1E44
1FAE:  MOVLW  78
1FB0:  MOVLB  2
1FB2:  MOVWF  x2E
1FB4:  MOVLB  0
1FB6:  RCALL  1E44
1FB8:  MOVFF  21A,228
1FBC:  MOVLW  37
1FBE:  MOVLB  2
1FC0:  MOVWF  x29
1FC2:  MOVLB  0
1FC4:  BRA    1E62
1FC6:  MOVLB  0
1FC8:  BRA    2038
1FCA:  MOVLB  2
....................     else if (format == BIN){
1FCC:  MOVF   x1B,W
1FCE:  SUBLW  02
1FD0:  BNZ   201A
....................     //Conversion manual
....................     converted[0] = '0';
1FD2:  MOVLW  30
1FD4:  MOVWF  x1C
....................     converted[1] = 'b';
1FD6:  MOVLW  62
1FD8:  MOVWF  x1D
....................     for (i=0;i<8;i++){
1FDA:  CLRF   x27
1FDC:  MOVF   x27,W
1FDE:  SUBLW  07
1FE0:  BNC   2016
....................     converted[i+2] = ((str >> (7-i)) & 0x01) + '0';
1FE2:  MOVLW  02
1FE4:  ADDWF  x27,W
1FE6:  CLRF   03
1FE8:  ADDLW  1C
1FEA:  MOVWF  FE9
1FEC:  MOVLW  02
1FEE:  ADDWFC 03,W
1FF0:  MOVWF  FEA
1FF2:  MOVLW  07
1FF4:  BSF    FD8.0
1FF6:  SUBFWB x27,W
1FF8:  MOVWF  01
1FFA:  MOVFF  21A,00
1FFE:  MOVF   01,F
2000:  BZ    200A
2002:  BCF    FD8.0
2004:  RRCF   00,F
2006:  DECFSZ 01,F
2008:  BRA    2002
200A:  MOVF   00,W
200C:  ANDLW  01
200E:  ADDLW  30
2010:  MOVWF  FEF
2012:  INCF   x27,F
2014:  BRA    1FDC
....................     }
....................     converted[10] = '\0';
2016:  CLRF   x26
....................     }
2018:  BRA    203A
....................     else if (format == DEC){
201A:  MOVF   x1B,W
201C:  SUBLW  0A
201E:  BNZ   203A
....................       sprintf(converted,"%d",str);
2020:  MOVLW  02
2022:  MOVLB  0
2024:  MOVWF  xC6
2026:  MOVLW  1C
2028:  MOVWF  xC5
202A:  MOVFF  21A,228
202E:  MOVLW  18
2030:  MOVLB  2
2032:  MOVWF  x29
2034:  MOVLB  0
2036:  RCALL  1ED6
2038:  MOVLB  2
....................     }
....................     usbPrint(converted);
203A:  MOVLW  02
203C:  MOVWF  x29
203E:  MOVLW  1C
2040:  MOVWF  x28
2042:  MOVLB  0
2044:  CALL   17EC
2048:  GOTO   2056 (RETURN)
....................     //Serial.print(str,format);
.................... }
.................... void println(char* str){
....................     usbPrint(str);
*
1800:  MOVFF  217,229
1804:  MOVFF  216,228
1808:  RCALL  17EC
....................     usbPrint((char*)"\n");
180A:  MOVLW  0A
180C:  MOVLB  2
180E:  MOVWF  x18
1810:  CLRF   x19
1812:  MOVLW  02
1814:  MOVWF  x29
1816:  MOVLW  18
1818:  MOVWF  x28
181A:  MOVLB  0
181C:  RCALL  17EC
181E:  RETURN 0
....................     //Serial.println(str);
.................... }
.................... void println(int str, int format){
....................     print(str,format);
*
204C:  MOVFF  215,21A
2050:  MOVFF  216,21B
2054:  BRA    1F92
....................     usbPrint((char*)"\n");
2056:  MOVLW  0A
2058:  MOVLB  2
205A:  MOVWF  x17
205C:  CLRF   x18
205E:  MOVLW  02
2060:  MOVWF  x29
2062:  MOVLW  17
2064:  MOVWF  x28
2066:  MOVLB  0
2068:  CALL   17EC
206C:  RETURN 0
....................     //Serial.println(str,format);
.................... }
.................... void print(float str){
....................  char converted[11];
....................  sprintf(converted,"%03f",str);
....................  usbPrint(converted);
.................... }
.................... void println(float str){
....................     print(str);
....................     usbPrint((char*)"\n");
.................... }
.................... float timeSec(){
*
1C9E:  CLRF   19
1CA0:  BTFSC  FF2.7
1CA2:  BSF    19.7
1CA4:  BCF    FF2.7
....................    float t;
....................    t = (float)(60*globalMin);
1CA6:  MOVLB  2
1CA8:  CLRF   x58
1CAA:  MOVLW  3C
1CAC:  MOVWF  x57
1CAE:  MOVFF  BE,25A
1CB2:  MOVFF  BD,259
1CB6:  MOVLB  0
1CB8:  CALL   04A2
1CBC:  BTFSC  19.7
1CBE:  BSF    FF2.7
1CC0:  MOVFF  02,219
1CC4:  MOVFF  01,218
1CC8:  MOVLB  0
1CCA:  RCALL  18F8
1CCC:  MOVFF  03,217
1CD0:  MOVFF  02,216
1CD4:  MOVFF  01,215
1CD8:  MOVFF  00,214
....................    t += (float)globalSec;
1CDC:  MOVLB  2
1CDE:  CLRF   x19
1CE0:  MOVFF  BC,218
1CE4:  MOVLB  0
1CE6:  RCALL  18F8
1CE8:  BCF    FD8.1
1CEA:  MOVFF  217,21D
1CEE:  MOVFF  216,21C
1CF2:  MOVFF  215,21B
1CF6:  MOVFF  214,21A
1CFA:  MOVFF  03,221
1CFE:  MOVFF  02,220
1D02:  MOVFF  01,21F
1D06:  MOVFF  00,21E
1D0A:  RCALL  192E
1D0C:  MOVFF  03,217
1D10:  MOVFF  02,216
1D14:  MOVFF  01,215
1D18:  MOVFF  00,214
....................    t += (float)((float)globalMs*0.001);
1D1C:  MOVFF  BB,219
1D20:  MOVFF  BA,218
1D24:  RCALL  18F8
1D26:  MOVFF  03,21B
1D2A:  MOVFF  02,21A
1D2E:  MOVFF  01,219
1D32:  MOVFF  00,218
1D36:  MOVFF  03,21F
1D3A:  MOVFF  02,21E
1D3E:  MOVFF  01,21D
1D42:  MOVFF  00,21C
1D46:  MOVLW  6F
1D48:  MOVLB  2
1D4A:  MOVWF  x23
1D4C:  MOVLW  12
1D4E:  MOVWF  x22
1D50:  MOVLW  03
1D52:  MOVWF  x21
1D54:  MOVLW  75
1D56:  MOVWF  x20
1D58:  MOVLB  0
1D5A:  BRA    1BA6
1D5C:  BCF    FD8.1
1D5E:  MOVFF  217,21D
1D62:  MOVFF  216,21C
1D66:  MOVFF  215,21B
1D6A:  MOVFF  214,21A
1D6E:  MOVFF  03,221
1D72:  MOVFF  02,220
1D76:  MOVFF  01,21F
1D7A:  MOVFF  00,21E
1D7E:  RCALL  192E
1D80:  MOVFF  03,217
1D84:  MOVFF  02,216
1D88:  MOVFF  01,215
1D8C:  MOVFF  00,214
....................    //println(t);
....................    return t;
1D90:  MOVFF  214,00
1D94:  MOVFF  215,01
1D98:  MOVFF  216,02
1D9C:  MOVFF  217,03
1DA0:  RETURN 0
.................... }
.................... void spi_read_into(uint8_t address,uint8_t* array, uint8_t length){
*
16A2:  MOVLB  2
16A4:  CLRF   x1D
....................     int i=0;
....................     //Select
....................     spiBegin();
16A6:  MOVLB  0
16A8:  RCALL  165C
....................     _BUFFER[0] = address & 0x7F; //Strip MSB byte to read
16AA:  MOVLB  2
16AC:  MOVF   x19,W
16AE:  ANDLW  7F
16B0:  MOVLB  0
16B2:  MOVWF  xC1
....................     //Write address
....................     spi_write(_BUFFER[0]);
16B4:  MOVF   FC9,W
16B6:  MOVFF  C1,FC9
16BA:  RRCF   FC7,W
16BC:  BNC   16BA
....................     delay_us(100);  // Tiempo para que el esclavo responda
16BE:  MOVLW  64
16C0:  MOVLB  2
16C2:  MOVWF  x1E
16C4:  MOVLB  0
16C6:  BRA    166A
....................     for (i=0;i<length;i++)
16C8:  MOVLB  2
16CA:  CLRF   x1D
16CC:  MOVF   x1C,W
16CE:  SUBWF  x1D,W
16D0:  BC    16EE
....................         array[i] = spi_read(0xFF);
16D2:  MOVF   x1D,W
16D4:  ADDWF  x1A,W
16D6:  MOVWF  FE9
16D8:  MOVLW  00
16DA:  ADDWFC x1B,W
16DC:  MOVWF  FEA
16DE:  MOVF   FC9,W
16E0:  SETF   FC9
16E2:  RRCF   FC7,W
16E4:  BNC   16E2
16E6:  MOVFF  FC9,FEF
16EA:  INCF   x1D,F
16EC:  BRA    16CC
....................     spiEnd();
16EE:  MOVLB  0
16F0:  RCALL  1692
16F2:  RETURN 0
.................... 
.................... }
.................... void spi_write_from(uint8_t address,uint8_t* array, uint8_t length){
*
1866:  MOVLB  2
1868:  CLRF   x1A
....................     int i=0;
....................     spiBegin();
186A:  MOVLB  0
186C:  RCALL  165C
....................     spi_write(address | 0b10000000);
186E:  MOVLB  2
1870:  MOVF   x16,W
1872:  IORLW  80
1874:  MOVWF  x1B
1876:  MOVF   FC9,W
1878:  MOVFF  21B,FC9
187C:  RRCF   FC7,W
187E:  BNC   187C
....................     //El address se aumenta en 1 automaticamente
....................    //Serial.println("Writing SPI");
....................     for (i=0;i<length;i++){
1880:  CLRF   x1A
1882:  MOVF   x19,W
1884:  SUBWF  x1A,W
1886:  BC    18A6
....................       // Serial.println((char)array[i]);
....................       spi_write(array[i]);}
1888:  MOVF   x1A,W
188A:  ADDWF  x17,W
188C:  MOVWF  FE9
188E:  MOVLW  00
1890:  ADDWFC x18,W
1892:  MOVWF  FEA
1894:  MOVFF  FEF,21B
1898:  MOVF   FC9,W
189A:  MOVFF  21B,FC9
189E:  RRCF   FC7,W
18A0:  BNC   189E
18A2:  INCF   x1A,F
18A4:  BRA    1882
....................     spiEnd();    
18A6:  MOVLB  0
18A8:  RCALL  1692
18AA:  RETURN 0
.................... }
.................... uint8_t spi_read_u8(uint8_t address){
....................     spi_read_into(address,_BUFFER,1);
*
16F4:  MOVFF  218,219
16F8:  MOVLB  2
16FA:  CLRF   x1B
16FC:  MOVLW  C1
16FE:  MOVWF  x1A
1700:  MOVLW  01
1702:  MOVWF  x1C
1704:  MOVLB  0
1706:  RCALL  16A2
....................     return _BUFFER[0];
1708:  MOVFF  C1,01
170C:  RETURN 0
.................... }
.................... uint8_t spi_write_u8(uint8_t address,uint8_t val){
....................     _BUFFER[0] = val;
*
18AC:  MOVFF  215,C1
....................     spi_write_from(address,_BUFFER,1);
18B0:  MOVFF  214,216
18B4:  MOVLB  2
18B6:  CLRF   x18
18B8:  MOVLW  C1
18BA:  MOVWF  x17
18BC:  MOVLW  01
18BE:  MOVWF  x19
18C0:  MOVLB  0
18C2:  RCALL  1866
....................     return _BUFFER[0];
18C4:  MOVFF  C1,01
18C8:  RETURN 0
.................... }
.................... void sleep_ms(int ms){
....................     delay_ms(ms);
*
1820:  MOVFF  1AE,214
1824:  RCALL  15BC
1826:  RETURN 0
.................... }
.................... 
.................... #include <afadruit_rfm69.h>
.................... 
.................... // # The crystal oscillator frequency and frequency synthesizer step size.
.................... // # See the datasheet for details of this calculation.
.................... const float _FXOSC = 32000000.0;
.................... const float _FSTEP = _FXOSC / 524288;
.................... 
.................... void readAllRegs();
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL);
.................... void reset();
.................... void set_boost(uint8_t setting);
.................... void idle();
.................... void rfm_sleep();
.................... void listen();
.................... void transmit();
.................... float temperature_get();
.................... uint8_t operation_mode_get();
.................... void operation_mode_set(uint8_t val);
.................... uint8_t* sync_word_get();
.................... void sync_word_set(uint8_t* wrd);
.................... uint16_t preamble_length_get();
.................... void preamble_length_set(uint16_t val);
.................... float frequency_mhz_get();
.................... void frequency_mhz_set();
.................... uint8_t* encryption_key_get();
.................... void encryption_key_set(uint8_t* val);
.................... int8_t tx_power_get();
.................... void tx_power_set(int8_t val);
.................... float rssi_get();
.................... float bitrate_get();
.................... void bitrate_set(float val);
.................... float frequency_deviation_get();
.................... void frequency_deviation_set(float val);
.................... bool packet_sent();
.................... bool payload_ready();
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256);
.................... bool send_with_ack(uint8_t* data,uint8_t len);
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false);
.................... 
.................... struct _RegisterBits{
.................... uint8_t address;
.................... uint8_t mask;
.................... uint8_t offset;
.................... };
.................... 
.................... void set(uint8_t val,struct _RegisterBits obj){
*
2322:  MOVFF  1D2,218
2326:  CALL   16F4
232A:  MOVFF  01,1D5
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         regVal &= ~obj.mask;
232E:  MOVLB  1
2330:  MOVF   xD3,W
2332:  XORLW  FF
2334:  ANDWF  xD5,F
....................         regVal |= (val & 0xFF) << obj.offset;
2336:  MOVFF  1D1,00
233A:  MOVF   xD4,W
233C:  MOVWF  01
233E:  BZ    2348
2340:  BCF    FD8.0
2342:  RLCF   00,F
2344:  DECFSZ 01,F
2346:  BRA    2340
2348:  MOVF   00,W
234A:  IORWF  xD5,F
....................         spi_write_u8(obj.address,regVal);
234C:  MOVFF  1D2,214
2350:  MOVFF  1D5,215
2354:  MOVLB  0
2356:  CALL   18AC
235A:  RETURN 0
.................... }
.................... uint8_t get(struct _RegisterBits obj){
*
1DA2:  MOVFF  214,218
1DA6:  RCALL  16F4
1DA8:  MOVFF  01,217
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         return ((regVal & obj.mask) >> obj.offset);
1DAC:  MOVLB  2
1DAE:  MOVF   x17,W
1DB0:  ANDWF  x15,W
1DB2:  MOVWF  00
1DB4:  MOVF   x16,W
1DB6:  MOVWF  01
1DB8:  BZ    1DC2
1DBA:  BCF    FD8.0
1DBC:  RRCF   00,F
1DBE:  DECFSZ 01,F
1DC0:  BRA    1DBA
1DC2:  MOVF   00,W
1DC4:  MOVWF  01
1DC6:  MOVLB  0
1DC8:  RETURN 0
....................     }
.................... uint8_t _debug_(struct _RegisterBits obj){
....................       print ((char*)"Mask: ");
....................       println(obj.mask,BIN);
....................       return obj.mask; 
.................... }
.................... 
.................... struct _RegisterBits _RegisterBits_(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
*
14CA:  MOVLB  1
14CC:  CLRF   x88
.................... 
....................         uint8_t i=0;
....................         struct _RegisterBits ret;
....................         ret.mask=0;
14CE:  CLRF   x8A
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         ret.address = _address;
14D0:  MOVFF  185,189
....................         for (i=0;i<bits;i++){
14D4:  CLRF   x88
14D6:  MOVF   x87,W
14D8:  SUBWF  x88,W
14DA:  BC    14E6
....................             ret.mask<<=1;
14DC:  BCF    FD8.0
14DE:  RLCF   x8A,F
....................             ret.mask|=1;
14E0:  BSF    x8A.0
14E2:  INCF   x88,F
14E4:  BRA    14D6
....................         }
....................         ret.mask <<= _offset;
14E6:  MOVF   x86,W
14E8:  MOVWF  01
14EA:  BZ    14F4
14EC:  BCF    FD8.0
14EE:  RLCF   x8A,F
14F0:  DECFSZ 01,F
14F2:  BRA    14EC
....................         ret.offset = _offset;
14F4:  MOVFF  186,18B
....................         return ret;
14F8:  MOVFF  189,01
14FC:  MOVFF  18A,02
1500:  MOVFF  18B,03
1504:  MOVLB  0
1506:  RETURN 0
....................  }
....................  
.................... /*
.................... class _RegisterBits{
....................     public:
....................     uint8_t address;
....................     uint8_t mask;
....................     uint8_t offset;
....................     _RegisterBits(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
....................         uint8_t i=0;
....................         mask=0;
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         address = _address;
....................         for (i=0;i<bits;i++){
....................             mask<<=1;
....................             mask|=1;
....................         }
....................         mask <<= _offset;
....................         offset = _offset;
....................         }
....................     void set(uint8_t val){
....................         uint8_t regVal = spi_read_u8(address);
....................         regVal &= ~mask;
....................         regVal |= (val & 0xFF) << offset;
....................         spi_write_u8(address,regVal);
....................     }
....................     uint8_t get(){
....................         uint8_t regVal = spi_read_u8(address);
....................         return ((regVal & mask) >> offset);
....................     }
....................    
....................   
....................     }
.................... };
.................... */
.................... 
....................     
.................... //Configuraciones que solo utilizan ciertos bits   
.................... struct _RegisterBits data_mode = _RegisterBits_(_REG_DATA_MOD, 5, 2);
.................... struct _RegisterBits modulation_type = _RegisterBits_(_REG_DATA_MOD, 3, 2);
.................... struct _RegisterBits modulation_shaping = _RegisterBits_(_REG_DATA_MOD, 0, 2);
.................... struct _RegisterBits temp_start = _RegisterBits_(_REG_TEMP1, 3);
.................... struct _RegisterBits temp_running = _RegisterBits_(_REG_TEMP1, 2);
.................... struct _RegisterBits sync_on = _RegisterBits_(_REG_SYNC_CONFIG, 7);
.................... struct _RegisterBits sync_size = _RegisterBits_(_REG_SYNC_CONFIG, 3, 3);
.................... struct _RegisterBits aes_on = _RegisterBits_(_REG_PACKET_CONFIG2, 0);
.................... struct _RegisterBits pa_0_on = _RegisterBits_(_REG_PA_LEVEL, 7);
.................... struct _RegisterBits pa_1_on = _RegisterBits_(_REG_PA_LEVEL, 6);
.................... struct _RegisterBits pa_2_on = _RegisterBits_(_REG_PA_LEVEL, 5);
.................... struct _RegisterBits output_power = _RegisterBits_(_REG_PA_LEVEL, 0, 5);
.................... struct _RegisterBits rx_bw_dcc_freq = _RegisterBits_(_REG_RX_BW, 5, 3);
.................... struct _RegisterBits rx_bw_mantissa = _RegisterBits_(_REG_RX_BW, 3, 2);
.................... struct _RegisterBits rx_bw_exponent = _RegisterBits_(_REG_RX_BW, 0, 3);
.................... struct _RegisterBits afc_bw_dcc_freq = _RegisterBits_(_REG_AFC_BW, 5, 3);
.................... struct _RegisterBits afc_bw_mantissa = _RegisterBits_(_REG_AFC_BW, 3, 2);
.................... struct _RegisterBits afc_bw_exponent = _RegisterBits_(_REG_AFC_BW, 0, 3);
.................... struct _RegisterBits packet_format = _RegisterBits_(_REG_PACKET_CONFIG1, 7, 1);
.................... struct _RegisterBits dc_free = _RegisterBits_(_REG_PACKET_CONFIG1, 5, 2);
.................... struct _RegisterBits crc_on = _RegisterBits_(_REG_PACKET_CONFIG1, 4, 1);
.................... struct _RegisterBits crc_auto_clear_off = _RegisterBits_(_REG_PACKET_CONFIG1, 3, 1);
.................... struct _RegisterBits address_filter = _RegisterBits_(_REG_PACKET_CONFIG1, 1, 2);
.................... struct _RegisterBits mode_ready = _RegisterBits_(_REG_IRQ_FLAGS1, 7);
.................... struct _RegisterBits dio_0_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 6, 2);
.................... struct _RegisterBits dio_1_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 4, 2);
.................... struct _RegisterBits dio_2_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 2, 2);
.................... struct _RegisterBits dio_3_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 0, 2);
.................... struct _RegisterBits dio_4_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 6, 2);
.................... struct _RegisterBits dio_5_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 4, 2);
.................... 
.................... //Extras
.................... int8_t _tx_power;
.................... int8_t tx_power;
.................... bool high_power;
.................... uint8_t* sync_word;
.................... uint16_t preamble_length;
.................... uint32_t frequency_mhz;
.................... float bitrate;
.................... float rssi;
.................... float last_rssi;
.................... float ack_wait;
.................... float receive_timeout;
.................... float xmit_timeout;
.................... uint8_t ack_retries;
.................... float ack_delay;
.................... uint8_t sequence_number;
.................... uint8_t seen_ids[8];
.................... uint8_t node;
.................... uint8_t destination;
.................... uint8_t identifier;
.................... uint8_t flags;
.................... uint8_t operation_mode;
.................... float temperature;
.................... uint8_t encryption_key[16];
.................... float frequency_deviation;
.................... int _reset_pin;
.................... 
.................... 
.................... void readAllRegs()
.................... {
....................   uint8_t regVal;
....................   
....................   println((char*)"Address - HEX - BIN");
....................   for (uint8_t regAddr = 1; regAddr <= 0x4F; regAddr++)
....................   {
....................     /*
....................     spiBegin();
....................     SPI.transfer(regAddr & 0x7F); // send address + r/w bit
....................     regVal = SPI.transfer(0);
....................     spiEnd();*/
....................     regVal = spi_read_u8(regAddr);
....................     print(regAddr, HEX);
....................     print((char*)" - ");
....................     print(regVal,HEX);
....................     print((char*)" - ");
....................     println(regVal,BIN);
....................   }
....................   spiEnd();
.................... }    
.................... 
.................... bool checkId(){
.................... uint8_t version;
.................... version = spi_read_u8(_REG_VERSION);
*
170E:  MOVLW  10
1710:  MOVLB  2
1712:  MOVWF  x18
1714:  MOVLB  0
1716:  RCALL  16F4
1718:  MOVFF  01,185
.................... return version==0x24;
171C:  MOVLB  1
171E:  MOVF   x85,W
1720:  SUBLW  24
1722:  BZ    1728
1724:  MOVLW  00
1726:  BRA    172A
1728:  MOVLW  01
172A:  MOVWF  01
172C:  MOVLB  0
172E:  GOTO   3C6C (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL){
*
27DC:  MOVLB  1
27DE:  CLRF   x90
....................     uint8_t version=0;
....................     println((char*)"Initial conf starts");
27E0:  MOVLW  01
27E2:  MOVWF  FEA
27E4:  MOVLW  91
27E6:  MOVWF  FE9
27E8:  MOVLW  14
27EA:  MOVWF  01
27EC:  CLRF   FF7
27EE:  MOVLW  00
27F0:  MOVLB  0
27F2:  CALL   0236
27F6:  TBLRD*-
27F8:  TBLRD*+
27FA:  MOVFF  FF5,FEE
27FE:  DECFSZ 01,F
2800:  BRA    27F8
2802:  MOVLW  01
2804:  MOVLB  2
2806:  MOVWF  x17
2808:  MOVLW  91
280A:  MOVWF  x16
280C:  MOVLB  0
280E:  CALL   1800
....................     //Serial.println("HOLA 2");
....................     _tx_power = 13;
2812:  MOVLW  0D
2814:  MOVLB  1
2816:  MOVWF  x21
....................     _reset_pin = resetPin;
2818:  MOVFF  187,16E
....................     high_power = _high_power;
281C:  MOVLB  0
281E:  BCF    xB5.1
2820:  MOVLB  1
2822:  BTFSS  x89.0
2824:  BRA    282C
2826:  MOVLB  0
2828:  BSF    xB5.1
282A:  MOVLB  1
....................     reset();
282C:  MOVLB  0
282E:  GOTO   1828
....................     //readAllRegs();
....................     
....................     version = spi_read_u8(_REG_VERSION);
2832:  MOVLW  10
2834:  MOVLB  2
2836:  MOVWF  x18
2838:  MOVLB  0
283A:  CALL   16F4
283E:  MOVFF  01,190
....................     if (version != 0x24){
2842:  MOVLB  1
2844:  MOVF   x90,W
2846:  SUBLW  24
2848:  BZ    28B4
....................         println((char*)"Error: ID del RFM incorrecta");
284A:  MOVLW  01
284C:  MOVWF  FEA
284E:  MOVLW  91
2850:  MOVWF  FE9
2852:  MOVLW  1D
2854:  MOVWF  01
2856:  CLRF   FF7
2858:  MOVLW  00
285A:  MOVLB  0
285C:  CALL   025A
2860:  TBLRD*-
2862:  TBLRD*+
2864:  MOVFF  FF5,FEE
2868:  DECFSZ 01,F
286A:  BRA    2862
286C:  MOVLW  01
286E:  MOVLB  2
2870:  MOVWF  x17
2872:  MOVLW  91
2874:  MOVWF  x16
2876:  MOVLB  0
2878:  CALL   1800
....................         while(1){
....................         println((char*)"ID Loop");
287C:  MOVLW  01
287E:  MOVWF  FEA
2880:  MOVLW  91
2882:  MOVWF  FE9
2884:  MOVLW  08
2886:  MOVWF  01
2888:  CLRF   FF7
288A:  MOVLW  00
288C:  CALL   0288
2890:  TBLRD*-
2892:  TBLRD*+
2894:  MOVFF  FF5,FEE
2898:  DECFSZ 01,F
289A:  BRA    2892
289C:  MOVLW  01
289E:  MOVLB  2
28A0:  MOVWF  x17
28A2:  MOVLW  91
28A4:  MOVWF  x16
28A6:  MOVLB  0
28A8:  CALL   1800
....................         usb_task();
28AC:  CALL   156A
28B0:  BRA    287C
28B2:  MOVLB  1
....................         }
....................         //exit(-1);
....................     }
....................     print((char*)"Idle");
28B4:  MOVLW  49
28B6:  MOVWF  x91
28B8:  MOVLW  64
28BA:  MOVWF  x92
28BC:  MOVLW  6C
28BE:  MOVWF  x93
28C0:  MOVLW  65
28C2:  MOVWF  x94
28C4:  CLRF   x95
28C6:  MOVLW  01
28C8:  MOVLB  2
28CA:  MOVWF  x17
28CC:  MOVLW  91
28CE:  MOVWF  x16
28D0:  MOVLB  0
28D2:  CALL   185A
....................     idle();
28D6:  RCALL  230A
....................     println((char*)"Ready");
28D8:  MOVLW  52
28DA:  MOVLB  1
28DC:  MOVWF  x91
28DE:  MOVLW  65
28E0:  MOVWF  x92
28E2:  MOVLW  61
28E4:  MOVWF  x93
28E6:  MOVLW  64
28E8:  MOVWF  x94
28EA:  MOVLW  79
28EC:  MOVWF  x95
28EE:  CLRF   x96
28F0:  MOVLW  01
28F2:  MOVLB  2
28F4:  MOVWF  x17
28F6:  MOVLW  91
28F8:  MOVWF  x16
28FA:  MOVLB  0
28FC:  CALL   1800
....................     //Chip setup
....................     //Set FIFO TX condition to not empty and the default FIFO threshold to 15.
....................     spi_write_u8(_REG_FIFO_THRESH, 0b10001111);
2900:  MOVLW  3C
2902:  MOVLB  2
2904:  MOVWF  x14
2906:  MOVLW  8F
2908:  MOVWF  x15
290A:  MOVLB  0
290C:  CALL   18AC
....................     //Configure low beta off.
....................     spi_write_u8(_REG_TEST_DAGC, 0x30);
2910:  MOVLW  6F
2912:  MOVLB  2
2914:  MOVWF  x14
2916:  MOVLW  30
2918:  MOVWF  x15
291A:  MOVLB  0
291C:  CALL   18AC
....................     //Disable boost.
....................     spi_write_u8(_REG_TEST_PA1, _TEST_PA1_NORMAL);
2920:  MOVLW  5A
2922:  MOVLB  2
2924:  MOVWF  x14
2926:  MOVLW  55
2928:  MOVWF  x15
292A:  MOVLB  0
292C:  CALL   18AC
....................     spi_write_u8(_REG_TEST_PA2, _TEST_PA2_NORMAL);
2930:  MOVLW  5C
2932:  MOVLB  2
2934:  MOVWF  x14
2936:  MOVLW  70
2938:  MOVWF  x15
293A:  MOVLB  0
293C:  CALL   18AC
....................     //set sync word
....................     //IMPORTANTE: Recuerda alocar el espacio para que no se sobreescriba
....................     print((char*)"Freq");
2940:  MOVLW  46
2942:  MOVLB  1
2944:  MOVWF  x91
2946:  MOVLW  72
2948:  MOVWF  x92
294A:  MOVLW  65
294C:  MOVWF  x93
294E:  MOVLW  71
2950:  MOVWF  x94
2952:  CLRF   x95
2954:  MOVLW  01
2956:  MOVLB  2
2958:  MOVWF  x17
295A:  MOVLW  91
295C:  MOVWF  x16
295E:  MOVLB  0
2960:  CALL   185A
....................     sync_word_set( _sync_word); 
2964:  MOVFF  186,1AF
2968:  MOVFF  185,1AE
296C:  BRA    235C
....................     preamble_length_set(_preamble_length);
296E:  MOVLB  1
2970:  CLRF   xAF
2972:  MOVFF  188,1AE
2976:  MOVLB  0
2978:  BRA    23E4
....................     frequency_mhz_set(); 
297A:  BRA    2412
....................     println((char*)"Ready");
297C:  MOVLW  52
297E:  MOVLB  1
2980:  MOVWF  x91
2982:  MOVLW  65
2984:  MOVWF  x92
2986:  MOVLW  61
2988:  MOVWF  x93
298A:  MOVLW  64
298C:  MOVWF  x94
298E:  MOVLW  79
2990:  MOVWF  x95
2992:  CLRF   x96
2994:  MOVLW  01
2996:  MOVLB  2
2998:  MOVWF  x17
299A:  MOVLW  91
299C:  MOVWF  x16
299E:  MOVLB  0
29A0:  CALL   1800
....................     //TODO: set encryption key
....................     //encryption_key = encrypt;
....................     //encryption_key_set(encrypt);
....................     
....................     //PARA USUARIOS AVANZADOS ----------------------------------------------------------------------------------------------
....................     // Configure modulation for RadioHead library GFSK_Rb250Fd250 mode
....................     // by default.  Users with advanced knowledge can manually reconfigure
....................     // for any other mode (consulting the datasheet is absolutely
....................     // necessary!).
....................     bitrate_set(250000);  // 250kbs
29A4:  MOVLB  1
29A6:  CLRF   xB1
29A8:  MOVLW  24
29AA:  MOVWF  xB0
29AC:  MOVLW  74
29AE:  MOVWF  xAF
29B0:  MOVLW  90
29B2:  MOVWF  xAE
29B4:  MOVLB  0
29B6:  BRA    25E0
....................     frequency_deviation_set(250000);  // 250khz
29B8:  MOVLB  1
29BA:  CLRF   xB1
29BC:  MOVLW  24
29BE:  MOVWF  xB0
29C0:  MOVLW  74
29C2:  MOVWF  xAF
29C4:  MOVLW  90
29C6:  MOVWF  xAE
29C8:  MOVLB  0
29CA:  BRA    2684
....................     set(0b01,modulation_shaping);  // Gaussian filter, BT=1.0
29CC:  MOVLW  01
29CE:  MOVLB  1
29D0:  MOVWF  xD1
29D2:  MOVFF  CF,1D4
29D6:  MOVFF  CE,1D3
29DA:  MOVFF  CD,1D2
29DE:  MOVLB  0
29E0:  RCALL  2322
....................     set(0b111,rx_bw_dcc_freq);  // RxBw register = 0xE0
29E2:  MOVLW  07
29E4:  MOVLB  1
29E6:  MOVWF  xD1
29E8:  MOVFF  ED,1D4
29EC:  MOVFF  EC,1D3
29F0:  MOVFF  EB,1D2
29F4:  MOVLB  0
29F6:  RCALL  2322
....................     set(0b00,rx_bw_mantissa);
29F8:  MOVLB  1
29FA:  CLRF   xD1
29FC:  MOVFF  F0,1D4
2A00:  MOVFF  EF,1D3
2A04:  MOVFF  EE,1D2
2A08:  MOVLB  0
2A0A:  RCALL  2322
....................     set(0b000,rx_bw_exponent);
2A0C:  MOVLB  1
2A0E:  CLRF   xD1
2A10:  MOVFF  F3,1D4
2A14:  MOVFF  F2,1D3
2A18:  MOVFF  F1,1D2
2A1C:  MOVLB  0
2A1E:  RCALL  2322
....................     set(0b111,afc_bw_dcc_freq); // AfcBw register = 0xE0
2A20:  MOVLW  07
2A22:  MOVLB  1
2A24:  MOVWF  xD1
2A26:  MOVFF  F6,1D4
2A2A:  MOVFF  F5,1D3
2A2E:  MOVFF  F4,1D2
2A32:  MOVLB  0
2A34:  RCALL  2322
....................     set(0b00,afc_bw_mantissa);
2A36:  MOVLB  1
2A38:  CLRF   xD1
2A3A:  MOVFF  F9,1D4
2A3E:  MOVFF  F8,1D3
2A42:  MOVFF  F7,1D2
2A46:  MOVLB  0
2A48:  RCALL  2322
....................     set(0b000,afc_bw_exponent);
2A4A:  MOVLB  1
2A4C:  CLRF   xD1
2A4E:  MOVFF  FC,1D4
2A52:  MOVFF  FB,1D3
2A56:  MOVFF  FA,1D2
2A5A:  MOVLB  0
2A5C:  RCALL  2322
....................     set(1,packet_format);  // Variable length.
2A5E:  MOVLW  01
2A60:  MOVLB  1
2A62:  MOVWF  xD1
2A64:  MOVFF  FF,1D4
2A68:  MOVFF  FE,1D3
2A6C:  MOVFF  FD,1D2
2A70:  MOVLB  0
2A72:  RCALL  2322
....................     set(0b10,dc_free);  // Whitening
2A74:  MOVLW  02
2A76:  MOVLB  1
2A78:  MOVWF  xD1
2A7A:  MOVFF  102,1D4
2A7E:  MOVFF  101,1D3
2A82:  MOVFF  100,1D2
2A86:  MOVLB  0
2A88:  RCALL  2322
....................     //-----------------------------------------------------------------------------------------------------------------------
....................     // Set transmit power to 13 dBm, a safe value any module supports.
....................     tx_power_set(13);
2A8A:  MOVLW  0D
2A8C:  MOVLB  1
2A8E:  MOVWF  xAE
2A90:  MOVLB  0
2A92:  BRA    2728
....................     //
....................     // initialize last RSSI reading
....................     last_rssi = 0.0;
2A94:  MOVLB  1
2A96:  CLRF   x36
2A98:  CLRF   x35
2A9A:  CLRF   x34
2A9C:  CLRF   x33
....................     // """The RSSI of the last received packet. Stored when the packet was received.
....................     //    This instantaneous RSSI value may not be accurate once the
....................     //    operating mode has been changed.
....................     // """
....................     // initialize timeouts and delays delays
....................     ack_wait = 0.5;
2A9E:  CLRF   x3A
2AA0:  CLRF   x39
2AA2:  CLRF   x38
2AA4:  MOVLW  7E
2AA6:  MOVWF  x37
....................     // """The delay time before attempting a retry after not receiving an ACK"""
....................     receive_timeout = 0.5;
2AA8:  CLRF   x3E
2AAA:  CLRF   x3D
2AAC:  CLRF   x3C
2AAE:  MOVWF  x3B
....................     // """The amount of time to poll for a received packet.
....................     //    If no packet is received, the returned packet will be None
....................     // """
....................     xmit_timeout = 2.0;
2AB0:  CLRF   x42
2AB2:  CLRF   x41
2AB4:  CLRF   x40
2AB6:  MOVLW  80
2AB8:  MOVWF  x3F
....................     // """The amount of time to wait for the HW to transmit the packet.
....................     //    This is mainly used to prevent a hang due to a HW issue
....................     // """
....................     ack_retries = 5;
2ABA:  MOVLW  05
2ABC:  MOVWF  x43
....................     // """The number of ACK retries before reporting a failure."""
....................     ack_delay = 0;
2ABE:  CLRF   x47
2AC0:  CLRF   x46
2AC2:  CLRF   x45
2AC4:  CLRF   x44
....................     // """The delay time before attemting to send an ACK.
....................     //    If ACKs are being missed try setting this to .1 or .2.
....................     // """
....................     //print("<------------------------------------------------------------------------------------------------------------------------------------------>")
....................     // initialize sequence number counter for reliabe datagram mode
....................     sequence_number = 0;
2AC6:  CLRF   x48
....................     // create seen Ids list
....................     //seen_ids = {0};
....................     // initialize packet header
....................     // node address - default is broadcast
....................     node = _RH_BROADCAST_ADDRESS;
2AC8:  SETF   x51
....................     // """The default address of this Node. (0-255).
....................     //    If not 255 (0xff) then only packets address to this node will be accepted.
....................     //    First byte of the RadioHead header.
....................     // """
....................     // destination address - default is broadcast
....................     destination = _RH_BROADCAST_ADDRESS;
2ACA:  SETF   x52
....................     // """The default destination address for packet transmissions. (0-255).
....................     //    If 255 (0xff) then any receiving node should accept the packet.
....................     //    Second byte of the RadioHead header.
....................     // """
....................     // ID - contains seq count for reliable datagram mode
....................     identifier = 0;
2ACC:  CLRF   x53
....................     // """Automatically set to the sequence number when send_with_ack() used.
....................     //    Third byte of the RadioHead header.
....................     // """
....................     // flags - identifies ack/reetry packet for reliable datagram mode
....................     flags = 0;
2ACE:  CLRF   x54
....................     // """Upper 4 bits reserved for use by Reliable Datagram Mode.
....................     //    Lower 4 bits may be used to pass information.
....................     //    Fourth byte of the RadioHead header.
....................     // """
....................     //Extras: paara algunos registros que no coinciden con la libreria del micropython
....................     // RSSI_CONFIG: 0x2
....................     spi_write_u8(0x23,0x02);
2AD0:  MOVLW  23
2AD2:  MOVLB  2
2AD4:  MOVWF  x14
2AD6:  MOVLW  02
2AD8:  MOVWF  x15
2ADA:  MOVLB  0
2ADC:  CALL   18AC
....................     //_REG_DIO_MAPPING1
....................     spi_write_u8(_REG_DIO_MAPPING1,0x00);
2AE0:  MOVLW  25
2AE2:  MOVLB  2
2AE4:  MOVWF  x14
2AE6:  CLRF   x15
2AE8:  MOVLB  0
2AEA:  CALL   18AC
....................     //101  FXOSC / 32
....................     spi_write_u8(_REG_DIO_MAPPING1+1,0b101);
2AEE:  MOVLW  26
2AF0:  MOVLB  2
2AF2:  MOVWF  x14
2AF4:  MOVLW  05
2AF6:  MOVWF  x15
2AF8:  MOVLB  0
2AFA:  CALL   18AC
....................     //RSSI_THRESH
....................     spi_write_u8(0x29,0xFF);
2AFE:  MOVLW  29
2B00:  MOVLB  2
2B02:  MOVWF  x14
2B04:  SETF   x15
2B06:  MOVLB  0
2B08:  CALL   18AC
....................     //INIT payload length to 0
....................     spi_write_u8(0x38,0x40);
2B0C:  MOVLW  38
2B0E:  MOVLB  2
2B10:  MOVWF  x14
2B12:  MOVLW  40
2B14:  MOVWF  x15
2B16:  MOVLB  0
2B18:  CALL   18AC
....................     //AutoRxRestartOn
....................     spi_write_u8(_REG_PACKET_CONFIG2,0x02);
2B1C:  MOVLW  3D
2B1E:  MOVLB  2
2B20:  MOVWF  x14
2B22:  MOVLW  02
2B24:  MOVWF  x15
2B26:  MOVLB  0
2B28:  CALL   18AC
....................     //Con esto se puede colocar un LED en DIO2 y ver los datos que se reciben y se envian
....................     set(0b01,dio_2_mapping);
2B2C:  MOVLW  01
2B2E:  MOVLB  1
2B30:  MOVWF  xD1
2B32:  MOVFF  117,1D4
2B36:  MOVFF  116,1D3
2B3A:  MOVFF  115,1D2
2B3E:  MOVLB  0
2B40:  CALL   2322
....................     //Asi se puede saber si el buffer FIFO tiene algun dato
....................     set(0b10,dio_1_mapping);
2B44:  MOVLW  02
2B46:  MOVLB  1
2B48:  MOVWF  xD1
2B4A:  MOVFF  114,1D4
2B4E:  MOVFF  113,1D3
2B52:  MOVFF  112,1D2
2B56:  MOVLB  0
2B58:  CALL   2322
....................     //En modo rx, da informacion acerca del RSSI (Recieved Signal Strength Indicator)
....................     set(0b01,dio_3_mapping);
2B5C:  MOVLW  01
2B5E:  MOVLB  1
2B60:  MOVWF  xD1
2B62:  MOVFF  11A,1D4
2B66:  MOVFF  119,1D3
2B6A:  MOVFF  118,1D2
2B6E:  MOVLB  0
2B70:  CALL   2322
....................     print((char*)"Initial configuration end\n");
2B74:  MOVLW  01
2B76:  MOVWF  FEA
2B78:  MOVLW  91
2B7A:  MOVWF  FE9
2B7C:  MOVLW  1B
2B7E:  MOVWF  01
2B80:  CLRF   FF7
2B82:  MOVLW  00
2B84:  CALL   02A0
2B88:  TBLRD*-
2B8A:  TBLRD*+
2B8C:  MOVFF  FF5,FEE
2B90:  DECFSZ 01,F
2B92:  BRA    2B8A
2B94:  MOVLW  01
2B96:  MOVLB  2
2B98:  MOVWF  x17
2B9A:  MOVLW  91
2B9C:  MOVWF  x16
2B9E:  MOVLB  0
2BA0:  CALL   185A
2BA4:  GOTO   3CD0 (RETURN)
.................... }
.................... void reset(){
....................     setOutput(_reset_pin,1);
*
1828:  MOVFF  16E,21E
182C:  MOVLW  01
182E:  MOVLB  2
1830:  MOVWF  x1F
1832:  MOVLB  0
1834:  RCALL  1628
....................     sleep_ms(1);
1836:  MOVLW  01
1838:  MOVLB  1
183A:  MOVWF  xAE
183C:  MOVLB  0
183E:  RCALL  1820
....................     setOutput(_reset_pin,0);
1840:  MOVFF  16E,21E
1844:  MOVLB  2
1846:  CLRF   x1F
1848:  MOVLB  0
184A:  RCALL  1628
....................     sleep_ms(5);
184C:  MOVLW  05
184E:  MOVLB  1
1850:  MOVWF  xAE
1852:  MOVLB  0
1854:  RCALL  1820
1856:  GOTO   2832 (RETURN)
.................... }
.................... void set_boost(uint8_t setting){
....................     //Set preamp boost if needed.
....................     if (_tx_power >= 18){
*
18CA:  MOVLB  1
18CC:  BTFSC  x21.7
18CE:  BRA    18F4
18D0:  MOVF   x21,W
18D2:  SUBLW  11
18D4:  BC    18F4
....................         spi_write_u8(_REG_TEST_PA1, setting);
18D6:  MOVLW  5A
18D8:  MOVLB  2
18DA:  MOVWF  x14
18DC:  MOVFF  1D1,215
18E0:  MOVLB  0
18E2:  RCALL  18AC
....................         spi_write_u8(_REG_TEST_PA2, setting);
18E4:  MOVLW  5C
18E6:  MOVLB  2
18E8:  MOVWF  x14
18EA:  MOVFF  1D1,215
18EE:  MOVLB  0
18F0:  RCALL  18AC
18F2:  MOVLB  1
....................     }
18F4:  MOVLB  0
18F6:  RETURN 0
.................... }
.................... void idle(){
....................     //Enter idle standby mode (switching off high power amplifiers if necessary).
....................     //Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
*
230A:  MOVLW  55
230C:  MOVLB  1
230E:  MOVWF  xD1
2310:  MOVLB  0
2312:  CALL   18CA
....................     operation_mode_set(STANDBY_MODE);
2316:  MOVLW  01
2318:  MOVLB  1
231A:  MOVWF  xD1
231C:  MOVLB  0
231E:  RCALL  206E
2320:  RETURN 0
....................            
.................... }
.................... void rfm_sleep(){
....................     operation_mode_set(SLEEP_MODE); 
.................... }
.................... void listen(){
....................     //Listen for packets to be received by the chip.  Use :py:func:`receive` to listen, wait
....................     //and retrieve packets as they're available.
....................     
....................     // Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
*
2BA8:  MOVLW  55
2BAA:  MOVLB  1
2BAC:  MOVWF  xD1
2BAE:  MOVLB  0
2BB0:  CALL   18CA
....................     // Enable payload ready interrupt for D0 line.
....................     set(0b01,dio_0_mapping);
2BB4:  MOVLW  01
2BB6:  MOVLB  1
2BB8:  MOVWF  xD1
2BBA:  MOVFF  111,1D4
2BBE:  MOVFF  110,1D3
2BC2:  MOVFF  10F,1D2
2BC6:  MOVLB  0
2BC8:  CALL   2322
....................     // Enter RX mode (will clear FIFO!).
....................           
....................     operation_mode_set(RX_MODE); 
2BCC:  MOVLW  04
2BCE:  MOVLB  1
2BD0:  MOVWF  xD1
2BD2:  MOVLB  0
2BD4:  CALL   206E
2BD8:  RETURN 0
.................... }
.................... void transmit(){
....................     // Transmit a packet which is queued in the FIFO.  This is a low level function for
....................     // entering transmit mode and more.  For generating and transmitting a packet of data use
....................     // :py:func:`send` instead.
....................     
....................     // # Like RadioHead library, turn on high power boost if enabled.
....................     set_boost(_TEST_PA1_BOOST);
*
3096:  MOVLW  5D
3098:  MOVLB  1
309A:  MOVWF  xD1
309C:  MOVLB  0
309E:  CALL   18CA
....................     // # Enable packet sent interrupt for D0 line.
....................     set(0b00,dio_0_mapping);
30A2:  MOVLB  1
30A4:  CLRF   xD1
30A6:  MOVFF  111,1D4
30AA:  MOVFF  110,1D3
30AE:  MOVFF  10F,1D2
30B2:  MOVLB  0
30B4:  CALL   2322
....................     //readAllRegs(); 
....................     // # Enter TX mode (will clear FIFO!).
....................     operation_mode_set(TX_MODE);  
30B8:  MOVLW  03
30BA:  MOVLB  1
30BC:  MOVWF  xD1
30BE:  MOVLB  0
30C0:  CALL   206E
30C4:  GOTO   3276 (RETURN)
.................... }
.................... // .. warning:: Reading this will STOP any receiving/sending that might be happening!
.................... //WARNING:LOOP infinito
.................... float temperature_get(){
....................     // The internal temperature of the chip in degrees Celsius. Be warned this is not
....................     // calibrated or very accurate.
....................     // .. warning:: Reading this will STOP any receiving/sending that might be happening!
....................     // # Start a measurement then poll the measurement finished bit.
....................     set(1,temp_start);
....................     //WARNING:LOOP infinito
....................     while (get(temp_running) > 0){
....................     usb_task();
....................     
....................     }
....................     temperature = 166.0 - (float)spi_read_u8(_REG_TEMP2);
....................     return temperature;
.................... }
.................... uint8_t operation_mode_get(){
....................     // """The operation mode value.  Unless you're manually controlling the chip you shouldn't
....................     // change the operation_mode with this property as other side-effects are required for
....................     // changing logical modes--use :py:func:`idle`, :py:func:`sleep`, :py:func:`transmit`,
....................     // :py:func:`listen` instead to signal intent for explicit logical modes.
....................     // """
....................     operation_mode = (spi_read_u8(_REG_OP_MODE) >> 2) &0b111;
....................     return operation_mode;
.................... }
.................... void operation_mode_set(uint8_t val){
....................     float start;
....................     //TODO: assert 0 <= val <= 4
....................     start = timeSec();
*
206E:  RCALL  1C9E
2070:  MOVFF  03,1D5
2074:  MOVFF  02,1D4
2078:  MOVFF  01,1D3
207C:  MOVFF  00,1D2
....................     while (!get(mode_ready)){
2080:  MOVFF  10E,216
2084:  MOVFF  10D,215
2088:  MOVFF  10C,214
208C:  RCALL  1DA2
208E:  MOVF   01,F
2090:  BTFSS  FD8.2
2092:  BRA    21A6
....................       delay_ms(100);
2094:  MOVLW  64
2096:  MOVLB  2
2098:  MOVWF  x14
209A:  MOVLB  0
209C:  CALL   15BC
....................       usb_task();
20A0:  CALL   156A
....................       println((char*)"OP Loop 1");
20A4:  MOVLW  01
20A6:  MOVWF  FEA
20A8:  MOVLW  D6
20AA:  MOVWF  FE9
20AC:  MOVLW  0A
20AE:  MOVWF  01
20B0:  CLRF   FF7
20B2:  MOVLW  00
20B4:  CALL   02CC
20B8:  TBLRD*-
20BA:  TBLRD*+
20BC:  MOVFF  FF5,FEE
20C0:  DECFSZ 01,F
20C2:  BRA    20BA
20C4:  MOVLW  01
20C6:  MOVLB  2
20C8:  MOVWF  x17
20CA:  MOVLW  D6
20CC:  MOVWF  x16
20CE:  MOVLB  0
20D0:  CALL   1800
....................         if ((timeSec() - start) >= 3){
20D4:  RCALL  1C9E
20D6:  MOVFF  03,217
20DA:  MOVFF  02,216
20DE:  MOVFF  01,215
20E2:  MOVFF  00,214
20E6:  MOVFF  FEA,219
20EA:  MOVFF  FE9,218
20EE:  BSF    FD8.1
20F0:  MOVFF  03,21D
20F4:  MOVFF  02,21C
20F8:  MOVFF  01,21B
20FC:  MOVFF  00,21A
2100:  MOVFF  1D5,221
2104:  MOVFF  1D4,220
2108:  MOVFF  1D3,21F
210C:  MOVFF  1D2,21E
2110:  RCALL  192E
2112:  MOVFF  219,FEA
2116:  MOVFF  218,FE9
211A:  MOVFF  03,217
211E:  MOVFF  02,216
2122:  MOVFF  01,215
2126:  MOVFF  00,214
212A:  MOVLB  2
212C:  CLRF   x1D
212E:  CLRF   x1C
2130:  MOVLW  40
2132:  MOVWF  x1B
2134:  MOVLW  80
2136:  MOVWF  x1A
2138:  MOVFF  03,221
213C:  MOVFF  02,220
2140:  MOVFF  01,21F
2144:  MOVFF  00,21E
2148:  MOVLB  0
214A:  RCALL  1DCA
214C:  BC    2150
214E:  BNZ   21A4
....................                  
....................             print ((char*)"Operation Mode couldnt be set\n");
2150:  MOVLW  01
2152:  MOVWF  FEA
2154:  MOVLW  D6
2156:  MOVWF  FE9
2158:  MOVLW  1F
215A:  MOVWF  01
215C:  CLRF   FF7
215E:  MOVLW  00
2160:  CALL   02E6
2164:  TBLRD*-
2166:  TBLRD*+
2168:  MOVFF  FF5,FEE
216C:  DECFSZ 01,F
216E:  BRA    2166
2170:  MOVLW  01
2172:  MOVLB  2
2174:  MOVWF  x17
2176:  MOVLW  D6
2178:  MOVWF  x16
217A:  MOVLB  0
217C:  CALL   185A
....................             println(spi_read_u8(0x27),BIN);
2180:  MOVLW  27
2182:  MOVLB  2
2184:  MOVWF  x18
2186:  MOVLB  0
2188:  CALL   16F4
218C:  MOVFF  01,214
2190:  MOVFF  01,215
2194:  MOVLW  02
2196:  MOVLB  2
2198:  MOVWF  x16
219A:  MOVLB  0
219C:  RCALL  204C
....................             while (1){ 
....................             usb_task();
219E:  CALL   156A
21A2:  BRA    219E
....................             }
....................             
....................             //exit(-2);
....................         }
21A4:  BRA    2080
....................     }      
....................     // Set the mode bits inside the operation mode register.
....................     operation_mode = spi_read_u8(_REG_OP_MODE);
21A6:  MOVLW  01
21A8:  MOVLB  2
21AA:  MOVWF  x18
21AC:  MOVLB  0
21AE:  CALL   16F4
21B2:  MOVFF  01,155
....................     operation_mode &= 0b11100011;
21B6:  MOVLW  E3
21B8:  MOVLB  1
21BA:  ANDWF  x55,F
....................     operation_mode |= val << 2;
21BC:  RLCF   xD1,W
21BE:  MOVWF  00
21C0:  RLCF   00,F
21C2:  MOVLW  FC
21C4:  ANDWF  00,F
21C6:  MOVF   00,W
21C8:  IORWF  x55,F
....................     //Serial.println(operation_mode,BIN);
....................     spi_write_u8(_REG_OP_MODE,operation_mode);
21CA:  MOVLW  01
21CC:  MOVLB  2
21CE:  MOVWF  x14
21D0:  MOVFF  155,215
21D4:  MOVLB  0
21D6:  CALL   18AC
....................    
....................     // Wait for mode to change by polling interrupt bit.
....................     start = timeSec();
21DA:  RCALL  1C9E
21DC:  MOVFF  03,1D5
21E0:  MOVFF  02,1D4
21E4:  MOVFF  01,1D3
21E8:  MOVFF  00,1D2
....................     while (!get(mode_ready)){
21EC:  MOVFF  10E,216
21F0:  MOVFF  10D,215
21F4:  MOVFF  10C,214
21F8:  RCALL  1DA2
21FA:  MOVF   01,F
21FC:  BTFSS  FD8.2
21FE:  BRA    2308
....................     usb_task();
2200:  CALL   156A
....................     println((char*)"OP Loop 2");
2204:  MOVLW  01
2206:  MOVWF  FEA
2208:  MOVLW  F5
220A:  MOVWF  FE9
220C:  MOVLW  0A
220E:  MOVWF  01
2210:  CLRF   FF7
2212:  MOVLW  00
2214:  CALL   0316
2218:  TBLRD*-
221A:  TBLRD*+
221C:  MOVFF  FF5,FEE
2220:  DECFSZ 01,F
2222:  BRA    221A
2224:  MOVLW  01
2226:  MOVLB  2
2228:  MOVWF  x17
222A:  MOVLW  F5
222C:  MOVWF  x16
222E:  MOVLB  0
2230:  CALL   1800
....................         if ((timeSec() - start) >= 3){
2234:  RCALL  1C9E
2236:  MOVFF  03,217
223A:  MOVFF  02,216
223E:  MOVFF  01,215
2242:  MOVFF  00,214
2246:  MOVFF  FEA,219
224A:  MOVFF  FE9,218
224E:  BSF    FD8.1
2250:  MOVFF  03,21D
2254:  MOVFF  02,21C
2258:  MOVFF  01,21B
225C:  MOVFF  00,21A
2260:  MOVFF  1D5,221
2264:  MOVFF  1D4,220
2268:  MOVFF  1D3,21F
226C:  MOVFF  1D2,21E
2270:  CALL   192E
2274:  MOVFF  219,FEA
2278:  MOVFF  218,FE9
227C:  MOVFF  03,217
2280:  MOVFF  02,216
2284:  MOVFF  01,215
2288:  MOVFF  00,214
228C:  MOVLB  2
228E:  CLRF   x1D
2290:  CLRF   x1C
2292:  MOVLW  40
2294:  MOVWF  x1B
2296:  MOVLW  80
2298:  MOVWF  x1A
229A:  MOVFF  03,221
229E:  MOVFF  02,220
22A2:  MOVFF  01,21F
22A6:  MOVFF  00,21E
22AA:  MOVLB  0
22AC:  RCALL  1DCA
22AE:  BC    22B2
22B0:  BNZ   2306
....................             print ((char*)"Timeout on Operation Mode Set\n");
22B2:  MOVLW  01
22B4:  MOVWF  FEA
22B6:  MOVLW  F5
22B8:  MOVWF  FE9
22BA:  MOVLW  1F
22BC:  MOVWF  01
22BE:  CLRF   FF7
22C0:  MOVLW  00
22C2:  CALL   0330
22C6:  TBLRD*-
22C8:  TBLRD*+
22CA:  MOVFF  FF5,FEE
22CE:  DECFSZ 01,F
22D0:  BRA    22C8
22D2:  MOVLW  01
22D4:  MOVLB  2
22D6:  MOVWF  x17
22D8:  MOVLW  F5
22DA:  MOVWF  x16
22DC:  MOVLB  0
22DE:  CALL   185A
....................             println(spi_read_u8(_REG_OP_MODE),BIN)  ;      
22E2:  MOVLW  01
22E4:  MOVLB  2
22E6:  MOVWF  x18
22E8:  MOVLB  0
22EA:  CALL   16F4
22EE:  MOVFF  01,214
22F2:  MOVFF  01,215
22F6:  MOVLW  02
22F8:  MOVLB  2
22FA:  MOVWF  x16
22FC:  MOVLB  0
22FE:  RCALL  204C
....................             while (1){
....................             usb_task();
2300:  CALL   156A
2304:  BRA    2300
....................             
....................             }
....................             //exit(-2);
....................         }
2306:  BRA    21EC
....................     }
2308:  RETURN 0
.................... }
.................... //WARNING must free allocated memory after using
.................... uint8_t* sync_word_get(){
....................     
....................     // """The synchronization word value.  This is a byte string up to 8 bytes long (64 bits)
....................     // which indicates the synchronization word for transmitted and received packets. Any
....................     // received packet which does not include this sync word will be ignored. The default value
....................     // is 0x2D, 0xD4 which matches the RadioHead RFM69 library. Setting a value of None will
....................     // disable synchronization word matching entirely.
....................     // """
....................     // # Handle when sync word is disabled..
....................     if (!get(sync_on))return NULL;
....................     //WARNING must free allocated memory after using
....................     sync_word = (uint8_t*)malloc(get(sync_size)+2);
....................     sync_word[0] = get(sync_size)+1;
....................     spi_read_into(_REG_SYNC_VALUE1,sync_word+1,get(sync_size)+1);
....................     return sync_word;
.................... }
.................... void sync_word_set(uint8_t* wrd){
*
235C:  MOVLB  1
235E:  MOVFF  1AE,FE9
2362:  MOVFF  1AF,FEA
2366:  MOVFF  FEF,1B0
....................   uint8_t len = wrd[0];
....................     if (len == 0 || wrd == NULL)set(0,sync_on);
236A:  MOVF   xB0,F
236C:  BZ    2376
236E:  MOVF   xAE,F
2370:  BNZ   238C
2372:  MOVF   xAF,F
2374:  BNZ   238C
2376:  CLRF   xD1
2378:  MOVFF  D8,1D4
237C:  MOVFF  D7,1D3
2380:  MOVFF  D6,1D2
2384:  MOVLB  0
2386:  RCALL  2322
2388:  BRA    23E0
238A:  MOVLB  1
....................     
....................     else{
....................         //TODO: assert 1 <= len(val) <= 8
....................         spi_write_from(_REG_SYNC_VALUE1,wrd+1,len);
238C:  MOVLW  01
238E:  ADDWF  xAE,W
2390:  MOVWF  xB1
2392:  MOVLW  00
2394:  ADDWFC xAF,W
2396:  MOVWF  xB2
2398:  MOVLW  2F
239A:  MOVLB  2
239C:  MOVWF  x16
239E:  MOVFF  1B2,218
23A2:  MOVFF  1B1,217
23A6:  MOVFF  1B0,219
23AA:  MOVLB  0
23AC:  CALL   1866
....................         //Sync_size: len(SYNC_WORD) - 1
....................         set(len-1,sync_size);
23B0:  MOVLW  01
23B2:  MOVLB  1
23B4:  SUBWF  xB0,W
23B6:  MOVWF  xB1
23B8:  MOVWF  xD1
23BA:  MOVFF  DB,1D4
23BE:  MOVFF  DA,1D3
23C2:  MOVFF  D9,1D2
23C6:  MOVLB  0
23C8:  RCALL  2322
....................         set(1,sync_on);
23CA:  MOVLW  01
23CC:  MOVLB  1
23CE:  MOVWF  xD1
23D0:  MOVFF  D8,1D4
23D4:  MOVFF  D7,1D3
23D8:  MOVFF  D6,1D2
23DC:  MOVLB  0
23DE:  RCALL  2322
....................     }
23E0:  GOTO   296E (RETURN)
.................... }
.................... uint16_t preamble_length_get(){
....................     // The length of the preamble for sent and received packets, an unsigned 16-bit value.
....................     // Received packets must match this length or they are ignored! Set to 4 to match the
....................     // RadioHead RFM69 library.
....................     uint8_t msb = spi_read_u8(_REG_PREAMBLE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_PREAMBLE_LSB);
....................     return ((msb << 8) | lsb) & 0xFFFF;
.................... }
.................... void preamble_length_set(uint16_t val){
....................     spi_write_u8(_REG_PREAMBLE_MSB, (val >> 8) & 0xFF);
23E4:  MOVLB  1
23E6:  CLRF   xB1
23E8:  CLRF   xB1
23EA:  MOVLW  2C
23EC:  MOVLB  2
23EE:  MOVWF  x14
23F0:  MOVFF  1AF,215
23F4:  MOVLB  0
23F6:  CALL   18AC
....................     spi_write_u8(_REG_PREAMBLE_LSB, val & 0xFF);
23FA:  MOVLB  1
23FC:  CLRF   xB1
23FE:  MOVLW  2D
2400:  MOVLB  2
2402:  MOVWF  x14
2404:  MOVFF  1AE,215
2408:  MOVLB  0
240A:  CALL   18AC
240E:  GOTO   297A (RETURN)
.................... }
.................... float frequency_mhz_get(){
....................     // """The frequency of the radio in Megahertz. Only the allowed values for your radio must be
....................     // specified (i.e. 433 vs. 915 mhz)!
....................     // """
....................     // # FRF register is computed from the frequency following the datasheet.
....................     // # See section 6.2 and FRF register description.
....................     // # Read bytes of FRF register and assemble into a 24-bit unsigned value.
....................     uint8_t msb = spi_read_u8(_REG_FRF_MSB);
....................     uint8_t mid = spi_read_u8(_REG_FRF_MID);
....................     uint8_t lsb = spi_read_u8(_REG_FRF_LSB);
....................     uint32_t frf = ((msb << 16) | (mid << 8) | lsb) & 0xFFFFFF;
....................     float frequency = (frf * _FSTEP) / 1000000.0;
....................     return frequency;
.................... }
.................... //WARNING: No funciona en micros porque requiere de enteros de 32 bits    
.................... void frequency_mhz_set(){
....................     //FRF = int((freq/_FSTEP)*1,000,000) & 0xFFFFFF
....................     uint8_t msb,lsb,mid;
....................     #ifdef FREQ_433
....................     msb = 0x6C;
....................     mid = 0x40;
....................     lsb = 0x00;
....................     #endif
....................     //TODO: aadir soporte para otras frecuencias
....................     
....................     //TODO: assert 290 <= val <= 1020
....................     // Calculate FRF register 24-bit value using section 6.2 of the datasheet.
....................     // unsigned long frf = int((val/_FSTEP)* 1000000.0) ;
....................     // Serial.print("FRF: ");
....................     // Serial.println(frf);
....................     
....................     // frf &=  0xFFFFFF;
....................     // // Extract byte values and update registers.
....................     // uint8_t msb = frf >> 16;
....................     // uint8_t mid = (frf >> 8) & 0xFF;
....................     // uint8_t lsb = frf & 0xFF;
....................     spi_write_u8(_REG_FRF_MSB, msb);
2412:  MOVLW  07
2414:  MOVLB  2
2416:  MOVWF  x14
2418:  MOVFF  1AE,215
241C:  MOVLB  0
241E:  CALL   18AC
....................     spi_write_u8(_REG_FRF_MID, mid);
2422:  MOVLW  08
2424:  MOVLB  2
2426:  MOVWF  x14
2428:  MOVFF  1B0,215
242C:  MOVLB  0
242E:  CALL   18AC
....................     spi_write_u8(_REG_FRF_LSB, lsb);
2432:  MOVLW  09
2434:  MOVLB  2
2436:  MOVWF  x14
2438:  MOVFF  1AF,215
243C:  MOVLB  0
243E:  CALL   18AC
2442:  GOTO   297C (RETURN)
.................... }
.................... uint8_t* encryption_key_get(){
....................     // """The AES encryption key used to encrypt and decrypt packets by the chip. This can be set
....................     // to None to disable encryption (the default), otherwise it must be a 16 byte long byte
....................     // string which defines the key (both the transmitter and receiver must use the same key
....................     // value).
....................     // """
....................     // # Handle if encryption is disabled.
....................     if(get(aes_on)==0)return NULL;
....................     spi_read_into(_REG_AES_KEY1,encryption_key,16);
....................     return encryption_key;
.................... }
.................... void encryption_key_set(uint8_t* val){
....................     if (val==0)set(0,aes_on);
....................     else{
....................         // Set the encryption key and enable encryption.
....................         //TODO: assert len(val) == 16
....................         spi_write_from(_REG_AES_KEY1,val,16);
....................         set(1,aes_on);
....................     }
.................... }
.................... int8_t tx_power_get(){
....................     // The transmit power in dBm. Can be set to a value from -2 to 20 for high power devices
....................     // (RFM69HCW, high_power=True) or -18 to 13 for low power devices. Only integer power
....................     // levels are actually set (i.e. 12.5 will result in a value of 12 dBm).
....................     // """
....................     // # Follow table 10 truth table from the datasheet for determining power
....................     // # level from the individual PA level bits and output power register.
....................     uint8_t pa0 = get(pa_0_on);
....................     uint8_t pa1 = get(pa_1_on);
....................     uint8_t pa2 = get(pa_2_on);
....................     uint8_t current_output_power = get(output_power);
....................     if (pa0 &&  !pa1 &&  !pa2)
....................         //# -18 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && !pa2)
....................         //# -2 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && !high_power)
....................         //# 2 to 17 dBm range
....................         return -14 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && high_power)
....................         //# 5 to 20 dBm range
....................         return -11 + current_output_power;
....................     print((char*)"Tx power power amps state unknown!");
....................     while (1){
....................     usb_task();
....................     }
....................     //exit(-3);
.................... }
.................... void tx_power_set(int8_t val){
*
2728:  MOVLB  1
272A:  CLRF   xAF
272C:  CLRF   xB0
272E:  CLRF   xB1
2730:  CLRF   xB2
....................     // Determine power amplifier and output power values depending on
....................     // high power state and requested power.
....................     uint8_t _pa_0_on = 0;
....................     uint8_t _pa_1_on = 0;
....................     uint8_t _pa_2_on = 0;
....................     uint8_t _output_power = 0;
....................     if (high_power){
2732:  MOVLB  0
2734:  BTFSS  xB5.1
2736:  BRA    277E
....................         // Handle high power mode.
....................         //TODO: assert -2 <= val <= 20
....................         _pa_1_on = 1;
2738:  MOVLW  01
273A:  MOVLB  1
273C:  MOVWF  xB0
....................         if (val <= 13)
273E:  BTFSC  xAE.7
2740:  BRA    2748
2742:  MOVF   xAE,W
2744:  SUBLW  0D
2746:  BNC   2750
....................             _output_power = val + 18;
2748:  MOVLW  12
274A:  ADDWF  xAE,W
274C:  MOVWF  xB2
274E:  BRA    277A
....................         else if (13 < val && val <= 17){
2750:  BTFSC  xAE.7
2752:  BRA    2770
2754:  MOVF   xAE,W
2756:  SUBLW  0D
2758:  BC    2770
275A:  BTFSC  xAE.7
275C:  BRA    2764
275E:  MOVF   xAE,W
2760:  SUBLW  11
2762:  BNC   2770
....................             _pa_2_on = 1;
2764:  MOVLW  01
2766:  MOVWF  xB1
....................             _output_power = val + 14;
2768:  MOVLW  0E
276A:  ADDWF  xAE,W
276C:  MOVWF  xB2
....................             }
276E:  BRA    277A
....................         else{
....................             //  # power >= 18 dBm
....................             //# Note this also needs PA boost enabled separately!
....................             _pa_2_on = 1;
2770:  MOVLW  01
2772:  MOVWF  xB1
....................             _output_power = val + 11;
2774:  MOVLW  0B
2776:  ADDWF  xAE,W
2778:  MOVWF  xB2
....................             }
....................     }
277A:  BRA    278A
277C:  MOVLB  0
....................     else{
....................         //Handle non-high power mode.
....................         //TODO: assert -18 <= val <= 13
....................         // Enable only power amplifier 0 and set output power.
....................         _pa_0_on = 1;
277E:  MOVLW  01
2780:  MOVLB  1
2782:  MOVWF  xAF
....................         _output_power = (val+ 18);
2784:  MOVLW  12
2786:  ADDWF  xAE,W
2788:  MOVWF  xB2
....................     }
....................     //# Set power amplifiers and output power as computed above.
....................     set(_pa_0_on,pa_0_on);
278A:  MOVFF  1AF,1D1
278E:  MOVFF  E1,1D4
2792:  MOVFF  E0,1D3
2796:  MOVFF  DF,1D2
279A:  MOVLB  0
279C:  RCALL  2322
....................     set(_pa_1_on,pa_1_on);
279E:  MOVFF  1B0,1D1
27A2:  MOVFF  E4,1D4
27A6:  MOVFF  E3,1D3
27AA:  MOVFF  E2,1D2
27AE:  RCALL  2322
....................     set(_pa_2_on,pa_2_on);
27B0:  MOVFF  1B1,1D1
27B4:  MOVFF  E7,1D4
27B8:  MOVFF  E6,1D3
27BC:  MOVFF  E5,1D2
27C0:  RCALL  2322
....................     set(_output_power,output_power);
27C2:  MOVFF  1B2,1D1
27C6:  MOVFF  EA,1D4
27CA:  MOVFF  E9,1D3
27CE:  MOVFF  E8,1D2
27D2:  RCALL  2322
....................     _tx_power = val;
27D4:  MOVFF  1AE,121
27D8:  GOTO   2A94 (RETURN)
.................... }
.................... float rssi_get(){
....................     // ""The received strength indicator (in dBm).
....................     // May be inaccuate if not read immediatey. last_rssi contains the value read immediately
....................     // receipt of the last packet.
....................     // """
....................     // # Read RSSI register and convert to value using formula in datasheet.
....................     rssi = -spi_read_u8(_REG_RSSI_VALUE) / 2.0;
*
2C04:  MOVLW  24
2C06:  MOVLB  2
2C08:  MOVWF  x18
2C0A:  MOVLB  0
2C0C:  CALL   16F4
2C10:  MOVLW  00
2C12:  BSF    FD8.0
2C14:  SUBFWB 01,W
2C16:  MOVLB  2
2C18:  CLRF   x19
2C1A:  MOVWF  x18
2C1C:  MOVLB  0
2C1E:  CALL   18F8
2C22:  MOVFF  03,1B9
2C26:  MOVFF  02,1B8
2C2A:  MOVFF  01,1B7
2C2E:  MOVFF  00,1B6
2C32:  MOVLB  1
2C34:  CLRF   xBD
2C36:  CLRF   xBC
2C38:  CLRF   xBB
2C3A:  MOVLW  80
2C3C:  MOVWF  xBA
2C3E:  MOVLB  0
2C40:  RCALL  2446
2C42:  MOVFF  03,132
2C46:  MOVFF  02,131
2C4A:  MOVFF  01,130
2C4E:  MOVFF  00,12F
....................     return rssi;
2C52:  MOVFF  12F,00
2C56:  MOVFF  130,01
2C5A:  MOVFF  131,02
2C5E:  MOVFF  132,03
2C62:  GOTO   34BC (RETURN)
.................... }
.................... float bitrate_get(){
....................     //         """The modulation bitrate in bits/second (or chip rate if Manchester encoding is enabled).
....................     // Can be a value from ~489 to 32mbit/s, but see the datasheet for the exact supported
....................     // values.
....................     // """
....................     uint8_t msb = spi_read_u8(_REG_BITRATE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_BITRATE_LSB);
....................     bitrate = _FXOSC / ((msb << 8) | lsb);
....................     return bitrate;
.................... }
.................... void bitrate_set(float val){
*
25E0:  MOVLB  1
25E2:  CLRF   xB9
25E4:  MOVLW  24
25E6:  MOVWF  xB8
25E8:  MOVLW  74
25EA:  MOVWF  xB7
25EC:  MOVLW  97
25EE:  MOVWF  xB6
25F0:  MOVFF  1B1,1BD
25F4:  MOVFF  1B0,1BC
25F8:  MOVFF  1AF,1BB
25FC:  MOVFF  1AE,1BA
2600:  MOVLB  0
2602:  RCALL  2446
2604:  MOVFF  03,1B9
2608:  MOVFF  02,1B8
260C:  MOVFF  01,1B7
2610:  MOVFF  00,1B6
2614:  BCF    FD8.1
2616:  MOVFF  03,21D
261A:  MOVFF  02,21C
261E:  MOVFF  01,21B
2622:  MOVFF  00,21A
2626:  MOVLB  2
2628:  CLRF   x21
262A:  CLRF   x20
262C:  CLRF   x1F
262E:  MOVLW  7E
2630:  MOVWF  x1E
2632:  MOVLB  0
2634:  CALL   192E
2638:  MOVFF  03,1B9
263C:  MOVFF  02,1B8
2640:  MOVFF  01,1B7
2644:  MOVFF  00,1B6
2648:  RCALL  25A4
264A:  MOVFF  01,1B2
264E:  MOVLB  1
2650:  CLRF   xB3
2652:  CLRF   xB4
2654:  CLRF   xB5
....................     //TODO: assert (_FXOSC / 65535) <= val <= 32000000.0
....................     //# Round up to the next closest bit-rate value with addition of 0.5.
....................     uint32_t _bitrate = (int)((_FXOSC/val)+0.5) & 0xFFF;
....................     spi_write_u8(_REG_BITRATE_MSB, _bitrate >> 8);
2656:  CLRF   xBA
2658:  MOVLW  03
265A:  MOVLB  2
265C:  MOVWF  x14
265E:  MOVFF  1B3,215
2662:  MOVLB  0
2664:  CALL   18AC
....................     spi_write_u8(_REG_BITRATE_LSB, _bitrate & 0xFF);
2668:  MOVLB  1
266A:  CLRF   xB7
266C:  CLRF   xB8
266E:  CLRF   xB9
2670:  MOVLW  04
2672:  MOVLB  2
2674:  MOVWF  x14
2676:  MOVFF  1B2,215
267A:  MOVLB  0
267C:  CALL   18AC
2680:  GOTO   29B8 (RETURN)
.................... }
.................... float frequency_deviation_get(){
....................     //"""The frequency deviation in Hertz."""
....................     uint8_t msb = spi_read_u8(_REG_FDEV_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_FDEV_LSB);
....................     frequency_deviation = _FSTEP * ((msb << 8) | lsb);
....................     return frequency_deviation;
.................... }
.................... void frequency_deviation_set(float val){
2684:  MOVFF  1B1,1B9
2688:  MOVFF  1B0,1B8
268C:  MOVFF  1AF,1B7
2690:  MOVFF  1AE,1B6
2694:  MOVLB  1
2696:  CLRF   xBD
2698:  MOVLW  24
269A:  MOVWF  xBC
269C:  MOVLW  74
269E:  MOVWF  xBB
26A0:  MOVLW  84
26A2:  MOVWF  xBA
26A4:  MOVLB  0
26A6:  RCALL  2446
26A8:  MOVFF  03,1B9
26AC:  MOVFF  02,1B8
26B0:  MOVFF  01,1B7
26B4:  MOVFF  00,1B6
26B8:  BCF    FD8.1
26BA:  MOVFF  03,21D
26BE:  MOVFF  02,21C
26C2:  MOVFF  01,21B
26C6:  MOVFF  00,21A
26CA:  MOVLB  2
26CC:  CLRF   x21
26CE:  CLRF   x20
26D0:  CLRF   x1F
26D2:  MOVLW  7E
26D4:  MOVWF  x1E
26D6:  MOVLB  0
26D8:  CALL   192E
26DC:  MOVFF  03,1B9
26E0:  MOVFF  02,1B8
26E4:  MOVFF  01,1B7
26E8:  MOVFF  00,1B6
26EC:  RCALL  25A4
26EE:  MOVFF  01,1B2
26F2:  MOVLB  1
26F4:  CLRF   xB3
26F6:  CLRF   xB4
26F8:  CLRF   xB5
....................     //TODO: assert 0 <= val <= (_FSTEP * 16383)  # fdev is a 14-bit unsigned value
....................     // # Round up to the next closest integer value with addition of 0.5.
....................     uint32_t fdev = (int)((val / _FSTEP) + 0.5) & 0x3FFF;
....................     spi_write_u8(_REG_FDEV_MSB, fdev >> 8);
26FA:  CLRF   xBA
26FC:  MOVLW  05
26FE:  MOVLB  2
2700:  MOVWF  x14
2702:  MOVFF  1B3,215
2706:  MOVLB  0
2708:  CALL   18AC
....................     spi_write_u8(_REG_FDEV_LSB, fdev & 0xFF);
270C:  MOVLB  1
270E:  CLRF   xB7
2710:  CLRF   xB8
2712:  CLRF   xB9
2714:  MOVLW  06
2716:  MOVLB  2
2718:  MOVWF  x14
271A:  MOVFF  1B2,215
271E:  MOVLB  0
2720:  CALL   18AC
2724:  GOTO   29CC (RETURN)
.................... }
.................... bool packet_sent(){
....................     //Transmit status
....................     return (spi_read_u8(_REG_IRQ_FLAGS2) & 0x8) >> 3;
*
30C8:  MOVLW  28
30CA:  MOVLB  2
30CC:  MOVWF  x18
30CE:  MOVLB  0
30D0:  CALL   16F4
30D4:  MOVF   01,W
30D6:  ANDLW  08
30D8:  MOVWF  00
30DA:  RRCF   00,F
30DC:  RRCF   00,F
30DE:  RRCF   00,F
30E0:  MOVLW  1F
30E2:  ANDWF  00,F
30E4:  MOVFF  00,01
30E8:  GOTO   3296 (RETURN)
.................... }
.................... bool payload_ready(){
*
2BDA:  MOVLW  28
2BDC:  MOVLB  2
2BDE:  MOVWF  x18
2BE0:  MOVLB  0
2BE2:  CALL   16F4
2BE6:  MOVFF  01,1AB
....................             // """Receive status"""
....................     uint8_t p = spi_read_u8(_REG_IRQ_FLAGS2);
....................     //Serial.println(p,BIN);
....................     return (p & 0x4) >> 2;
2BEA:  MOVLB  1
2BEC:  MOVF   xAB,W
2BEE:  ANDLW  04
2BF0:  MOVWF  00
2BF2:  RRCF   00,F
2BF4:  RRCF   00,F
2BF6:  MOVLW  3F
2BF8:  ANDWF  00,F
2BFA:  MOVFF  00,01
2BFE:  MOVLB  0
2C00:  GOTO   33DE (RETURN)
.................... }
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256){
....................     // """Send a string of data using the transmitter.
....................     // You can only send 60 bytes at a time
....................     // (limited by chip's FIFO size and appended headers).
....................     // This appends a 4 byte header to be compatible with the RadioHead library.
....................     // The header defaults to using the initialized attributes:
....................     // (destination,node,identifier,flags)
....................     // It may be temporarily overidden via the kwargs - destination,node,identifier,flags.
....................     // Values passed via kwargs do not alter the attribute settings.
....................     // The keep_listening argument should be set to True if you want to start listening
....................     // automatically after the packet is sent. The default setting is False.
....................     // Returns: True if success or False if the send timed out.
....................     // """
....................     // # Disable pylint warning to not use length as a check for zero.
....................     // # This is a puzzling warning as the below code is clearly the most
....................     // # efficient and proper way to ensure a precondition that the provided
....................     // # buffer be within an expected range of bounds.  Disable this check.
....................     // # pylint: disable=len-as-condition
....................     // TODO: assert 0 < len(data) <= 60
....................     // # pylint: enable=len-as-condition
....................     idle(); //# Stop receiving to clear FIFO and keep it clear.
*
30EC:  CALL   230A
....................     // # Fill the FIFO with a packet to send.
....................     // # Combine header and data to form payload
....................     uint32_t i=0;
....................     char* payload = (char*)malloc(5 + len + 1);
30F0:  MOVLB  1
30F2:  CLRF   xBF
30F4:  CLRF   xBE
30F6:  CLRF   xBD
30F8:  CLRF   xBC
30FA:  MOVLW  05
30FC:  ADDWF  xB2,W
30FE:  ADDLW  01
3100:  MOVWF  xD1
3102:  CLRF   xD3
3104:  MOVWF  xD2
3106:  MOVLB  0
3108:  RCALL  2D40
310A:  MOVFF  02,1C1
310E:  MOVFF  01,1C0
....................     
....................     payload[0] = 4 + len;
3112:  MOVLB  1
3114:  MOVFF  1C0,FE9
3118:  MOVFF  1C1,FEA
311C:  MOVLW  04
311E:  ADDWF  xB2,W
3120:  MOVWF  FEF
....................     if (_destination >=256 )  // use attribute
3122:  MOVF   xB5,W
3124:  SUBLW  00
3126:  BC    313A
....................         payload[1] = destination;
3128:  MOVLW  01
312A:  ADDWF  xC0,W
312C:  MOVWF  FE9
312E:  MOVLW  00
3130:  ADDWFC xC1,W
3132:  MOVWF  FEA
3134:  MOVFF  152,FEF
3138:  BRA    314A
....................     else//  # use kwarg
....................         payload[1] = _destination;
313A:  MOVLW  01
313C:  ADDWF  xC0,W
313E:  MOVWF  FE9
3140:  MOVLW  00
3142:  ADDWFC xC1,W
3144:  MOVWF  FEA
3146:  MOVFF  1B4,FEF
....................     if (_node >= 256) // use attribute
314A:  MOVF   xB7,W
314C:  SUBLW  00
314E:  BC    3162
....................         payload[2] = node;
3150:  MOVLW  02
3152:  ADDWF  xC0,W
3154:  MOVWF  FE9
3156:  MOVLW  00
3158:  ADDWFC xC1,W
315A:  MOVWF  FEA
315C:  MOVFF  151,FEF
3160:  BRA    3172
....................     else  //# use kwarg
....................         payload[2] = _node;
3162:  MOVLW  02
3164:  ADDWF  xC0,W
3166:  MOVWF  FE9
3168:  MOVLW  00
316A:  ADDWFC xC1,W
316C:  MOVWF  FEA
316E:  MOVFF  1B6,FEF
....................     if (identifier >=256)  // use attribute
....................         payload[3] = identifier;
....................     else  //# use kwarg
....................         payload[3] = _identifier;
3172:  MOVLW  03
3174:  ADDWF  xC0,W
3176:  MOVWF  FE9
3178:  MOVLW  00
317A:  ADDWFC xC1,W
317C:  MOVWF  FEA
317E:  MOVFF  1B8,FEF
....................     if (flags >=256)  // use attribute
....................         payload[4] = flags;
....................     else  // use kwarg
....................         payload[4] = _flags;
3182:  MOVLW  04
3184:  ADDWF  xC0,W
3186:  MOVWF  FE9
3188:  MOVLW  00
318A:  ADDWFC xC1,W
318C:  MOVWF  FEA
318E:  MOVFF  1BA,FEF
....................     for (i=0;i<= len;i++)
3192:  CLRF   xBF
3194:  CLRF   xBE
3196:  CLRF   xBD
3198:  CLRF   xBC
319A:  MOVF   xBF,F
319C:  BNZ   3204
319E:  MOVF   xBE,F
31A0:  BNZ   3204
31A2:  MOVF   xBD,F
31A4:  BNZ   3204
31A6:  MOVF   xBC,W
31A8:  SUBWF  xB2,W
31AA:  BNC   3204
....................         payload[5+i] = data[i];
31AC:  MOVLW  05
31AE:  ADDWF  xBC,W
31B0:  MOVWF  xD1
31B2:  MOVLW  00
31B4:  ADDWFC xBD,W
31B6:  MOVWF  xD2
31B8:  MOVLW  00
31BA:  ADDWFC xBE,W
31BC:  MOVWF  xD3
31BE:  MOVLW  00
31C0:  ADDWFC xBF,W
31C2:  MOVWF  xD4
31C4:  MOVF   xC0,W
31C6:  ADDWF  xD1,W
31C8:  MOVWF  01
31CA:  MOVF   xC1,W
31CC:  ADDWFC xD2,W
31CE:  MOVWF  03
31D0:  MOVFF  01,1D5
31D4:  MOVWF  xD6
31D6:  MOVF   xB0,W
31D8:  ADDWF  xBC,W
31DA:  MOVWF  FE9
31DC:  MOVF   xB1,W
31DE:  ADDWFC xBD,W
31E0:  MOVWF  FEA
31E2:  MOVFF  FEF,1D7
31E6:  MOVFF  03,FEA
31EA:  MOVFF  01,FE9
31EE:  MOVFF  1D7,FEF
31F2:  MOVLW  01
31F4:  ADDWF  xBC,F
31F6:  BTFSC  FD8.0
31F8:  INCF   xBD,F
31FA:  BTFSC  FD8.2
31FC:  INCF   xBE,F
31FE:  BTFSC  FD8.2
3200:  INCF   xBF,F
3202:  BRA    319A
....................        
....................     // # Write payload to transmit fifo
....................     spi_write_from(_REG_FIFO, payload,5+len);
3204:  MOVLW  05
3206:  ADDWF  xB2,W
3208:  MOVWF  xD1
320A:  MOVLB  2
320C:  CLRF   x16
320E:  MOVFF  1C1,218
3212:  MOVFF  1C0,217
3216:  MOVWF  x19
3218:  MOVLB  0
321A:  CALL   1866
....................     print((char*)"Payload: ");
321E:  MOVLW  01
3220:  MOVWF  FEA
3222:  MOVLW  C2
3224:  MOVWF  FE9
3226:  MOVLW  0A
3228:  MOVWF  01
322A:  CLRF   FF7
322C:  MOVLW  00
322E:  CALL   0360
3232:  TBLRD*-
3234:  TBLRD*+
3236:  MOVFF  FF5,FEE
323A:  DECFSZ 01,F
323C:  BRA    3234
323E:  MOVLW  01
3240:  MOVLB  2
3242:  MOVWF  x17
3244:  MOVLW  C2
3246:  MOVWF  x16
3248:  MOVLB  0
324A:  CALL   185A
....................     println(payload+5);
324E:  MOVLW  05
3250:  MOVLB  1
3252:  ADDWF  xC0,W
3254:  MOVWF  xD1
3256:  MOVLW  00
3258:  ADDWFC xC1,W
325A:  MOVWF  xD2
325C:  MOVFF  FE8,217
3260:  MOVFF  1D1,216
3264:  MOVLB  0
3266:  CALL   1800
....................     // Serial.println((char)spi_read_u8(_REG_FIFO));              
.................... 
....................     free(payload);
326A:  MOVFF  1C1,1D2
326E:  MOVFF  1C0,1D1
3272:  RCALL  301C
....................     // # Turn on transmit mode to send out the packet.       
....................     transmit();
3274:  BRA    3096
....................    
....................     // # Wait for packet sent interrupt with explicit polling (not ideal but
....................     // # best that can be done right now without interrupts).
....................     
....................     float start = timeSec();
....................     bool timed_out = false;
3276:  CALL   1C9E
327A:  MOVFF  03,1CF
327E:  MOVFF  02,1CE
3282:  MOVFF  01,1CD
3286:  MOVFF  00,1CC
328A:  MOVLB  1
328C:  BCF    xD0.0
....................     while (!timed_out && !packet_sent()){
328E:  BTFSC  xD0.0
3290:  BRA    332E
3292:  MOVLB  0
3294:  BRA    30C8
3296:  MOVF   01,F
3298:  BTFSC  FD8.2
329A:  BRA    32A0
329C:  MOVLB  1
329E:  BRA    332E
....................     usb_task();
32A0:  CALL   156A
....................         if ((timeSec() - start) >= xmit_timeout)
32A4:  CALL   1C9E
32A8:  MOVFF  03,1D4
32AC:  MOVFF  02,1D3
32B0:  MOVFF  01,1D2
32B4:  MOVFF  00,1D1
32B8:  MOVFF  FEA,1D6
32BC:  MOVFF  FE9,1D5
32C0:  BSF    FD8.1
32C2:  MOVFF  03,21D
32C6:  MOVFF  02,21C
32CA:  MOVFF  01,21B
32CE:  MOVFF  00,21A
32D2:  MOVFF  1CF,221
32D6:  MOVFF  1CE,220
32DA:  MOVFF  1CD,21F
32DE:  MOVFF  1CC,21E
32E2:  CALL   192E
32E6:  MOVFF  1D6,FEA
32EA:  MOVFF  1D5,FE9
32EE:  MOVFF  03,1D4
32F2:  MOVFF  02,1D3
32F6:  MOVFF  01,1D2
32FA:  MOVFF  00,1D1
32FE:  MOVFF  142,21D
3302:  MOVFF  141,21C
3306:  MOVFF  140,21B
330A:  MOVFF  13F,21A
330E:  MOVFF  03,221
3312:  MOVFF  02,220
3316:  MOVFF  01,21F
331A:  MOVFF  00,21E
331E:  CALL   1DCA
3322:  BC    3326
3324:  BNZ   332A
....................             timed_out = true;
3326:  MOVLB  1
3328:  BSF    xD0.0
332A:  MOVLB  1
332C:  BRA    328E
....................     }
....................     // # Listen again if requested.
....................     if (keep_listening)
332E:  MOVF   xB3,F
3330:  BZ    333A
....................         listen();
3332:  MOVLB  0
3334:  RCALL  2BA8
3336:  BRA    3340
3338:  MOVLB  1
....................     else  //# Enter idle mode to stop receiving other packets.
....................   
....................         idle();
333A:  MOVLB  0
333C:  CALL   230A
....................     return !timed_out;
3340:  MOVLW  00
3342:  MOVLB  1
3344:  BTFSS  xD0.0
3346:  MOVLW  01
3348:  MOVWF  01
334A:  MOVLB  0
334C:  GOTO   36DE (RETURN)
.................... }
.................... bool send_with_ack(uint8_t* data,uint8_t len){
....................     // Reliable Datagram mode:
....................     // Send a packet with data and wait for an ACK response.
....................     // The packet header is automatically generated.
....................     // If enabled, the packet transmission will be retried on failure
....................     int retries_remaining = 0;
....................     bool got_ack = false;
....................     uint8_t* ack_packet;
....................     if (ack_retries)retries_remaining = ack_retries;
....................     else retries_remaining=1;
....................     sequence_number = (sequence_number+1) & 0xFF;
....................     while (!got_ack && retries_remaining){
....................         identifier = sequence_number;
....................         send(data,len,true);
....................         // Don't look for ACK from Broadcast message
....................         if (destination == _RH_BROADCAST_ADDRESS)got_ack = true;
....................         else{
....................             ack_packet = receive(true,false,ack_wait,true);
....................             if(ack_packet != NULL){
....................                 if (ack_packet[4] & _RH_FLAGS_ACK){
....................                     //Check id:
....................                     if (ack_packet[3] == identifier){
....................                         got_ack = true;
....................                         break;
....................                     }
....................                 }
....................             }
....................             
....................         }
....................         //# pause before next retry -- random delay
....................         if (!got_ack){
....................             sleep_ms(ack_wait * (1.5));
....................         }
....................         retries_remaining -= 1;
....................         //# set retry flag in packet header
....................         flags |= _RH_FLAGS_RETRY;
....................     }
....................     flags = 0;  //# clear flags
....................     return got_ack;
.................... }
.................... //IMPORTANTE: La funcion es igual a la de adafruit, excepto porque retorna un array donde el primer valor es la longitud del array
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false){
3350:  MOVLB  1
3352:  BCF    x8C.0
3354:  CLRF   x8D
3356:  CLRF   x8E
3358:  CLRF   x91
335A:  CLRF   x90
....................     // Wait to receive a packet from the receiver. If a packet is found the payload bytes
....................     // are returned, otherwise None is returned (which indicates the timeout elapsed with no
....................     // reception).
....................     // If keep_listening is True (the default) the chip will immediately enter listening mode
....................     // after reception of a packet, otherwise it will fall back to idle mode and ignore any
....................     // future reception.
....................     // All packets must have a 4 byte header for compatibilty with the
....................     // RadioHead library.
....................     // The header consists of 4 bytes (To,From,ID,Flags). The default setting will  strip
....................     // the header before returning the packet to the caller.
....................     // If with_header is True then the 4 byte header will be returned with the packet.
....................     // The payload then begins at packet[4].
....................     // If with_ack is True, send an ACK after receipt (Reliable Datagram mode)
....................     // """
....................     bool timed_out = false;
....................     int start = 0;
....................     int i=0;
....................     uint8_t fifo_length;
....................     uint8_t* packet= NULL;
....................     char fifo_len_str [4];
....................     if (timeout == 0)timeout = receive_timeout;
335C:  MOVFF  18A,21D
3360:  MOVFF  189,21C
3364:  MOVFF  188,21B
3368:  MOVFF  187,21A
336C:  MOVLB  2
336E:  CLRF   x21
3370:  CLRF   x20
3372:  CLRF   x1F
3374:  CLRF   x1E
3376:  MOVLB  0
3378:  CALL   1DCA
337C:  BNZ   338E
337E:  MOVFF  13E,18A
3382:  MOVFF  13D,189
3386:  MOVFF  13C,188
338A:  MOVFF  13B,187
....................     if (timeout!=0){
338E:  MOVFF  18A,21D
3392:  MOVFF  189,21C
3396:  MOVFF  188,21B
339A:  MOVFF  187,21A
339E:  MOVLB  2
33A0:  CLRF   x21
33A2:  CLRF   x20
33A4:  CLRF   x1F
33A6:  CLRF   x1E
33A8:  MOVLB  0
33AA:  CALL   1DCA
33AE:  BTFSC  FD8.2
33B0:  BRA    34B4
....................         //readAllRegs();
....................         //while(1){}
....................         listen();
33B2:  CALL   2BA8
....................         start = timeSec();
33B6:  CALL   1C9E
33BA:  MOVFF  03,1B9
33BE:  MOVFF  02,1B8
33C2:  MOVFF  01,1B7
33C6:  MOVFF  00,1B6
33CA:  CALL   25A4
33CE:  MOVFF  01,18D
....................         while (!timed_out && !payload_ready()){
33D2:  MOVLB  1
33D4:  BTFSC  x8C.0
33D6:  BRA    34B6
33D8:  MOVLB  0
33DA:  GOTO   2BDA
33DE:  MOVF   01,F
33E0:  BTFSC  FD8.2
33E2:  BRA    33E8
33E4:  MOVLB  1
33E6:  BRA    34B6
....................         usb_task();
33E8:  CALL   156A
....................             //delay(20);
....................             if ((timeSec() - start) >= xmit_timeout){
33EC:  CALL   1C9E
33F0:  MOVFF  03,1AE
33F4:  MOVFF  02,1AD
33F8:  MOVFF  01,1AC
33FC:  MOVFF  00,1AB
3400:  MOVLB  2
3402:  CLRF   x19
3404:  MOVFF  18D,218
3408:  MOVLB  0
340A:  CALL   18F8
340E:  MOVFF  FEA,1B0
3412:  MOVFF  FE9,1AF
3416:  BSF    FD8.1
3418:  MOVFF  1AE,21D
341C:  MOVFF  1AD,21C
3420:  MOVFF  1AC,21B
3424:  MOVFF  1AB,21A
3428:  MOVFF  03,221
342C:  MOVFF  02,220
3430:  MOVFF  01,21F
3434:  MOVFF  00,21E
3438:  CALL   192E
343C:  MOVFF  1B0,FEA
3440:  MOVFF  1AF,FE9
3444:  MOVFF  03,1AE
3448:  MOVFF  02,1AD
344C:  MOVFF  01,1AC
3450:  MOVFF  00,1AB
3454:  MOVFF  142,21D
3458:  MOVFF  141,21C
345C:  MOVFF  140,21B
3460:  MOVFF  13F,21A
3464:  MOVFF  03,221
3468:  MOVFF  02,220
346C:  MOVFF  01,21F
3470:  MOVFF  00,21E
3474:  CALL   1DCA
3478:  BC    347C
347A:  BNZ   34B2
....................                 println((char*)"Timed out");
347C:  MOVLW  01
347E:  MOVWF  FEA
3480:  MOVLW  96
3482:  MOVWF  FE9
3484:  MOVLW  0A
3486:  MOVWF  01
3488:  CLRF   FF7
348A:  MOVLW  00
348C:  CALL   037A
3490:  TBLRD*-
3492:  TBLRD*+
3494:  MOVFF  FF5,FEE
3498:  DECFSZ 01,F
349A:  BRA    3492
349C:  MOVLW  01
349E:  MOVLB  2
34A0:  MOVWF  x17
34A2:  MOVLW  96
34A4:  MOVWF  x16
34A6:  MOVLB  0
34A8:  CALL   1800
....................                 timed_out = true;
34AC:  MOVLB  1
34AE:  BSF    x8C.0
34B0:  MOVLB  0
....................                 }
34B2:  BRA    33D2
34B4:  MOVLB  1
....................         }
....................     }
....................    
....................     last_rssi = rssi_get();
34B6:  MOVLB  0
34B8:  GOTO   2C04
34BC:  MOVFF  03,136
34C0:  MOVFF  02,135
34C4:  MOVFF  01,134
34C8:  MOVFF  00,133
....................     // Enter idle mode to stop receiving other packets.
....................     idle();
34CC:  CALL   230A
....................      
....................     if (!timed_out){
34D0:  MOVLB  1
34D2:  BTFSC  x8C.0
34D4:  BRA    37BC
....................         fifo_length = spi_read_u8(_REG_FIFO);
34D6:  MOVLB  2
34D8:  CLRF   x18
34DA:  MOVLB  0
34DC:  CALL   16F4
34E0:  MOVFF  01,18F
....................         print((char*)"FIFO LEN: ");
34E4:  MOVLW  01
34E6:  MOVWF  FEA
34E8:  MOVLW  A0
34EA:  MOVWF  FE9
34EC:  MOVLW  0B
34EE:  MOVWF  01
34F0:  CLRF   FF7
34F2:  MOVLW  00
34F4:  CALL   0394
34F8:  TBLRD*-
34FA:  TBLRD*+
34FC:  MOVFF  FF5,FEE
3500:  DECFSZ 01,F
3502:  BRA    34FA
3504:  MOVLW  01
3506:  MOVLB  2
3508:  MOVWF  x17
350A:  MOVLW  A0
350C:  MOVWF  x16
350E:  MOVLB  0
3510:  CALL   185A
....................         sprintf(fifo_len_str,"%d",fifo_length);
3514:  MOVLW  01
3516:  MOVWF  xC6
3518:  MOVLW  92
351A:  MOVWF  xC5
351C:  MOVFF  18F,228
3520:  MOVLW  18
3522:  MOVLB  2
3524:  MOVWF  x29
3526:  MOVLB  0
3528:  CALL   1ED6
....................         println(fifo_len_str);
352C:  MOVLW  01
352E:  MOVLB  2
3530:  MOVWF  x17
3532:  MOVLW  92
3534:  MOVWF  x16
3536:  MOVLB  0
3538:  CALL   1800
....................         //  # Handle if the received packet is too small to include the 4 byte
....................         // # RadioHead header and at least one byte of data --reject this packet and ignore it.
....................         if (fifo_length > 0){
353C:  MOVLB  1
353E:  MOVF   x8F,F
3540:  BZ    359A
....................             packet = (uint8_t*)malloc(fifo_length+2);
3542:  MOVLW  02
3544:  ADDWF  x8F,W
3546:  MOVWF  xAB
3548:  CLRF   xD3
354A:  MOVWF  xD2
354C:  MOVLB  0
354E:  CALL   2D40
3552:  MOVFF  02,191
3556:  MOVFF  01,190
....................             packet[0] = fifo_length;
355A:  MOVLB  1
355C:  MOVFF  190,FE9
3560:  MOVFF  191,FEA
3564:  MOVFF  18F,FEF
....................             packet[fifo_length+1] = '\0';
3568:  MOVLW  01
356A:  ADDWF  x8F,W
356C:  ADDWF  x90,W
356E:  MOVWF  FE9
3570:  MOVLW  00
3572:  ADDWFC x91,W
3574:  MOVWF  FEA
3576:  CLRF   FEF
....................             spi_read_into(_REG_FIFO,packet+1,fifo_length);
3578:  MOVLW  01
357A:  ADDWF  x90,W
357C:  MOVWF  xAB
357E:  MOVLW  00
3580:  ADDWFC x91,W
3582:  MOVWF  xAC
3584:  MOVLB  2
3586:  CLRF   x19
3588:  MOVWF  x1B
358A:  MOVFF  1AB,21A
358E:  MOVFF  18F,21C
3592:  MOVLB  0
3594:  CALL   16A2
3598:  MOVLB  1
....................             //print(packet);
....................         }
....................         if (fifo_length < 5){
359A:  MOVF   x8F,W
359C:  SUBLW  04
359E:  BNC   35A6
....................             packet = NULL;
35A0:  CLRF   x91
35A2:  CLRF   x90
....................         }
35A4:  BRA    37BC
....................         else{
....................             if (node != _RH_BROADCAST_ADDRESS && packet[1] != _RH_BROADCAST_ADDRESS && packet[1] != node){
35A6:  INCFSZ x51,W
35A8:  BRA    35AC
35AA:  BRA    35E4
35AC:  MOVLW  01
35AE:  ADDWF  x90,W
35B0:  MOVWF  FE9
35B2:  MOVLW  00
35B4:  ADDWFC x91,W
35B6:  MOVWF  FEA
35B8:  INCFSZ FEF,W
35BA:  BRA    35BE
35BC:  BRA    35E4
35BE:  MOVLW  01
35C0:  ADDWF  x90,W
35C2:  MOVWF  FE9
35C4:  MOVLW  00
35C6:  ADDWFC x91,W
35C8:  MOVWF  FEA
35CA:  MOVF   x51,W
35CC:  SUBWF  FEF,W
35CE:  BZ    35E4
....................                 free(packet);
35D0:  MOVFF  191,1D2
35D4:  MOVFF  190,1D1
35D8:  MOVLB  0
35DA:  RCALL  301C
....................                 packet = NULL;
35DC:  MOVLB  1
35DE:  CLRF   x91
35E0:  CLRF   x90
....................             }
35E2:  BRA    3768
....................             //# send ACK unless this was an ACK or a broadcast
....................             else if (with_ack && (packet[4]&_RH_FLAGS_ACK)==0 && packet[1] != _RH_BROADCAST_ADDRESS){
35E4:  MOVF   x86,F
35E6:  BTFSC  FD8.2
35E8:  BRA    3768
35EA:  MOVLW  04
35EC:  ADDWF  x90,W
35EE:  MOVWF  FE9
35F0:  MOVLW  00
35F2:  ADDWFC x91,W
35F4:  MOVWF  FEA
35F6:  MOVF   FEF,W
35F8:  ANDLW  80
35FA:  BTFSS  FD8.2
35FC:  BRA    3768
35FE:  MOVLW  01
3600:  ADDWF  x90,W
3602:  MOVWF  FE9
3604:  MOVLW  00
3606:  ADDWFC x91,W
3608:  MOVWF  FEA
360A:  INCFSZ FEF,W
360C:  BRA    3610
360E:  BRA    3768
....................                 if (ack_delay != 0)sleep_ms((int)(ack_delay/1000));
3610:  MOVFF  147,21D
3614:  MOVFF  146,21C
3618:  MOVFF  145,21B
361C:  MOVFF  144,21A
3620:  MOVLB  2
3622:  CLRF   x21
3624:  CLRF   x20
3626:  CLRF   x1F
3628:  CLRF   x1E
362A:  MOVLB  0
362C:  CALL   1DCA
3630:  BZ    3676
3632:  MOVFF  147,1B9
3636:  MOVFF  146,1B8
363A:  MOVFF  145,1B7
363E:  MOVFF  144,1B6
3642:  MOVLB  1
3644:  CLRF   xBD
3646:  CLRF   xBC
3648:  MOVLW  7A
364A:  MOVWF  xBB
364C:  MOVLW  88
364E:  MOVWF  xBA
3650:  MOVLB  0
3652:  CALL   2446
3656:  MOVFF  03,1B9
365A:  MOVFF  02,1B8
365E:  MOVFF  01,1B7
3662:  MOVFF  00,1B6
3666:  CALL   25A4
366A:  MOVFF  01,1AB
366E:  MOVFF  01,1AE
3672:  CALL   1820
....................                 //# send ACK packet to sender (data is b'!')
....................                 send((char*)"!",false,packet[2],packet[1],packet[3],packet[4]|_RH_FLAGS_ACK);
3676:  MOVLW  21
3678:  MOVLB  1
367A:  MOVWF  xA0
367C:  CLRF   xA1
367E:  MOVLW  02
3680:  ADDWF  x90,W
3682:  MOVWF  FE9
3684:  MOVLW  00
3686:  ADDWFC x91,W
3688:  MOVWF  FEA
368A:  MOVFF  FEF,1B3
368E:  MOVLW  01
3690:  ADDWF  x90,W
3692:  MOVWF  FE9
3694:  MOVLW  00
3696:  ADDWFC x91,W
3698:  MOVWF  FEA
369A:  MOVFF  FEF,1B4
369E:  MOVLW  03
36A0:  ADDWF  x90,W
36A2:  MOVWF  FE9
36A4:  MOVLW  00
36A6:  ADDWFC x91,W
36A8:  MOVWF  FEA
36AA:  MOVFF  FEF,1B6
36AE:  MOVLW  04
36B0:  ADDWF  x90,W
36B2:  MOVWF  FE9
36B4:  MOVLW  00
36B6:  ADDWFC x91,W
36B8:  MOVWF  FEA
36BA:  MOVF   FEF,W
36BC:  IORLW  80
36BE:  MOVWF  xAF
36C0:  MOVLW  01
36C2:  MOVWF  xB1
36C4:  MOVLW  A0
36C6:  MOVWF  xB0
36C8:  CLRF   xB2
36CA:  CLRF   xB5
36CC:  CLRF   xB7
36CE:  CLRF   xB9
36D0:  MOVFF  1AF,1B8
36D4:  MOVLW  01
36D6:  MOVWF  xBB
36D8:  CLRF   xBA
36DA:  MOVLB  0
36DC:  BRA    30EC
....................                 // # reject Retries if we have seen this idetifier from this source before
....................                 if (seen_ids[packet[2]] == packet[3] && packet[4]&_RH_FLAGS_RETRY){
36DE:  MOVLW  02
36E0:  MOVLB  1
36E2:  ADDWF  x90,W
36E4:  MOVWF  FE9
36E6:  MOVLW  00
36E8:  ADDWFC x91,W
36EA:  MOVWF  FEA
36EC:  CLRF   03
36EE:  MOVF   FEF,W
36F0:  ADDLW  49
36F2:  MOVWF  FE9
36F4:  MOVLW  01
36F6:  ADDWFC 03,W
36F8:  MOVWF  FEA
36FA:  MOVFF  FEF,1AB
36FE:  MOVLW  03
3700:  ADDWF  x90,W
3702:  MOVWF  FE9
3704:  MOVLW  00
3706:  ADDWFC x91,W
3708:  MOVWF  FEA
370A:  MOVF   FEF,W
370C:  SUBWF  xAB,W
370E:  BNZ   3734
3710:  MOVLW  04
3712:  ADDWF  x90,W
3714:  MOVWF  FE9
3716:  MOVLW  00
3718:  ADDWFC x91,W
371A:  MOVWF  FEA
371C:  BTFSS  FEF.6
371E:  BRA    3734
....................                     free(packet);
3720:  MOVFF  191,1D2
3724:  MOVFF  190,1D1
3728:  MOVLB  0
372A:  RCALL  301C
....................                     packet= NULL;
372C:  MOVLB  1
372E:  CLRF   x91
3730:  CLRF   x90
....................                 }
3732:  BRA    3768
....................                 else{ //Save identifier from source
....................                     seen_ids[packet[2]] = packet[3];
3734:  MOVLW  02
3736:  ADDWF  x90,W
3738:  MOVWF  FE9
373A:  MOVLW  00
373C:  ADDWFC x91,W
373E:  MOVWF  FEA
3740:  CLRF   03
3742:  MOVF   FEF,W
3744:  ADDLW  49
3746:  MOVWF  01
3748:  MOVLW  01
374A:  ADDWFC 03,F
374C:  MOVLW  03
374E:  ADDWF  x90,W
3750:  MOVWF  FE9
3752:  MOVLW  00
3754:  ADDWFC x91,W
3756:  MOVWF  FEA
3758:  MOVFF  FEF,1AD
375C:  MOVFF  03,FEA
3760:  MOVFF  01,FE9
3764:  MOVFF  1AD,FEF
....................                 }
....................             }
....................             if (!with_header && packet != NULL){
3768:  MOVF   x8B,F
376A:  BNZ   37BC
376C:  MOVF   x90,F
376E:  BNZ   3774
3770:  MOVF   x91,F
3772:  BZ    37BC
....................                  //skip the header if not wanted
....................                  for (i=1; i< fifo_length-4;i++){
3774:  MOVLW  01
3776:  MOVWF  x8E
3778:  MOVLW  04
377A:  SUBWF  x8F,W
377C:  SUBWF  x8E,W
377E:  BC    37AE
....................                     packet[i] = packet[i+4];
3780:  MOVF   x8E,W
3782:  ADDWF  x90,W
3784:  MOVWF  01
3786:  MOVLW  00
3788:  ADDWFC x91,W
378A:  MOVWF  03
378C:  MOVLW  04
378E:  ADDWF  x8E,W
3790:  ADDWF  x90,W
3792:  MOVWF  FE9
3794:  MOVLW  00
3796:  ADDWFC x91,W
3798:  MOVWF  FEA
379A:  MOVFF  FEF,1AD
379E:  MOVFF  03,FEA
37A2:  MOVFF  01,FE9
37A6:  MOVFF  1AD,FEF
37AA:  INCF   x8E,F
37AC:  BRA    3778
....................                  }
....................                  //reduce indicated length
....................                  packet[0] -= 4;
37AE:  MOVFF  190,FE9
37B2:  MOVFF  191,FEA
37B6:  MOVLW  04
37B8:  SUBWF  FEF,W
37BA:  MOVWF  FEF
....................             }
....................         }
....................     }
....................     
....................     if (keep_listening)listen();        
37BC:  MOVF   x85,F
37BE:  BZ    37C8
37C0:  MOVLB  0
37C2:  CALL   2BA8
37C6:  BRA    37CE
....................     else idle();
37C8:  MOVLB  0
37CA:  CALL   230A
....................     return (char*)packet;
37CE:  MOVLB  1
37D0:  MOVFF  190,01
37D4:  MOVFF  191,02
37D8:  MOVLB  0
37DA:  GOTO   3D18 (RETURN)
.................... }
.................... 
.................... 
.................... #ZERO_RAM
.................... 
.................... 
.................... //Define la interrupcin por recepcin Serial
.................... static void RDA_isr(void)
.................... {  
*
13EA:  GOTO   146E (RETURN)
....................  
.................... }
.................... 
.................... 
.................... /* TODO: Use usb_cdc_putc() to transmit data to the USB
.................... virtual COM port. Use usb_cdc_kbhit() and usb_cdc_getc() to
.................... receive data from the USB virtual COM port. usb_enumerated()
.................... can be used to see if connected to a host and ready to
.................... communicate. */
.................... 
.................... /*
.................... Conexiones
.................... MOSI: RX (23)
.................... MISO: B0 (00) (SDI)
.................... CLK: B1 (01) (SCK)
.................... CS: A5 (13)
.................... Reset: E0
.................... */
.................... 
.................... void main()
*
37DE:  CLRF   FF8
37E0:  BCF    FD0.7
37E2:  BSF    07.7
37E4:  MOVLW  FE
37E6:  MOVWF  00
37E8:  MOVLW  04
37EA:  MOVWF  01
37EC:  MOVLW  02
37EE:  MOVWF  FE9
37F0:  MOVLW  00
37F2:  MOVWF  FEA
37F4:  CLRF   FEE
37F6:  DECFSZ 00,F
37F8:  BRA    37F4
37FA:  DECFSZ 01,F
37FC:  BRA    37F4
37FE:  MOVLW  DD
3800:  MOVWF  00
3802:  MOVLW  03
3804:  MOVWF  01
3806:  MOVLW  23
3808:  MOVWF  FE9
380A:  MOVLW  05
380C:  MOVWF  FEA
380E:  CLRF   FEE
3810:  DECFSZ 00,F
3812:  BRA    380E
3814:  DECFSZ 01,F
3816:  BRA    380E
3818:  BCF    FC6.5
381A:  MOVLW  40
381C:  MOVWF  FC7
381E:  MOVLW  22
3820:  MOVWF  FC6
3822:  BCF    F94.7
3824:  BSF    F93.0
3826:  BSF    F89.5
3828:  BCF    F92.5
382A:  BCF    F93.1
382C:  CLRF   xC6
382E:  CLRF   xC5
3830:  MOVLW  02
3832:  MOVLB  1
3834:  MOVWF  x85
3836:  MOVLW  05
3838:  MOVWF  x86
383A:  MOVLW  02
383C:  MOVWF  x87
383E:  MOVLB  0
3840:  CALL   14CA
3844:  MOVFF  03,C9
3848:  MOVFF  02,C8
384C:  MOVFF  01,C7
3850:  MOVLW  02
3852:  MOVLB  1
3854:  MOVWF  x85
3856:  MOVLW  03
3858:  MOVWF  x86
385A:  MOVLW  02
385C:  MOVWF  x87
385E:  MOVLB  0
3860:  CALL   14CA
3864:  MOVFF  03,CC
3868:  MOVFF  02,CB
386C:  MOVFF  01,CA
3870:  MOVLW  02
3872:  MOVLB  1
3874:  MOVWF  x85
3876:  CLRF   x86
3878:  MOVWF  x87
387A:  MOVLB  0
387C:  CALL   14CA
3880:  MOVFF  03,CF
3884:  MOVFF  02,CE
3888:  MOVFF  01,CD
388C:  MOVLW  4E
388E:  MOVLB  1
3890:  MOVWF  x85
3892:  MOVLW  03
3894:  MOVWF  x86
3896:  MOVLW  01
3898:  MOVWF  x87
389A:  MOVLB  0
389C:  CALL   14CA
38A0:  MOVFF  03,D2
38A4:  MOVFF  02,D1
38A8:  MOVFF  01,D0
38AC:  MOVLW  4E
38AE:  MOVLB  1
38B0:  MOVWF  x85
38B2:  MOVLW  02
38B4:  MOVWF  x86
38B6:  MOVLW  01
38B8:  MOVWF  x87
38BA:  MOVLB  0
38BC:  CALL   14CA
38C0:  MOVFF  03,D5
38C4:  MOVFF  02,D4
38C8:  MOVFF  01,D3
38CC:  MOVLW  2E
38CE:  MOVLB  1
38D0:  MOVWF  x85
38D2:  MOVLW  07
38D4:  MOVWF  x86
38D6:  MOVLW  01
38D8:  MOVWF  x87
38DA:  MOVLB  0
38DC:  CALL   14CA
38E0:  MOVFF  03,D8
38E4:  MOVFF  02,D7
38E8:  MOVFF  01,D6
38EC:  MOVLW  2E
38EE:  MOVLB  1
38F0:  MOVWF  x85
38F2:  MOVLW  03
38F4:  MOVWF  x86
38F6:  MOVWF  x87
38F8:  MOVLB  0
38FA:  CALL   14CA
38FE:  MOVFF  03,DB
3902:  MOVFF  02,DA
3906:  MOVFF  01,D9
390A:  MOVLW  3D
390C:  MOVLB  1
390E:  MOVWF  x85
3910:  CLRF   x86
3912:  MOVLW  01
3914:  MOVWF  x87
3916:  MOVLB  0
3918:  CALL   14CA
391C:  MOVFF  03,DE
3920:  MOVFF  02,DD
3924:  MOVFF  01,DC
3928:  MOVLW  11
392A:  MOVLB  1
392C:  MOVWF  x85
392E:  MOVLW  07
3930:  MOVWF  x86
3932:  MOVLW  01
3934:  MOVWF  x87
3936:  MOVLB  0
3938:  CALL   14CA
393C:  MOVFF  03,E1
3940:  MOVFF  02,E0
3944:  MOVFF  01,DF
3948:  MOVLW  11
394A:  MOVLB  1
394C:  MOVWF  x85
394E:  MOVLW  06
3950:  MOVWF  x86
3952:  MOVLW  01
3954:  MOVWF  x87
3956:  MOVLB  0
3958:  CALL   14CA
395C:  MOVFF  03,E4
3960:  MOVFF  02,E3
3964:  MOVFF  01,E2
3968:  MOVLW  11
396A:  MOVLB  1
396C:  MOVWF  x85
396E:  MOVLW  05
3970:  MOVWF  x86
3972:  MOVLW  01
3974:  MOVWF  x87
3976:  MOVLB  0
3978:  CALL   14CA
397C:  MOVFF  03,E7
3980:  MOVFF  02,E6
3984:  MOVFF  01,E5
3988:  MOVLW  11
398A:  MOVLB  1
398C:  MOVWF  x85
398E:  CLRF   x86
3990:  MOVLW  05
3992:  MOVWF  x87
3994:  MOVLB  0
3996:  CALL   14CA
399A:  MOVFF  03,EA
399E:  MOVFF  02,E9
39A2:  MOVFF  01,E8
39A6:  MOVLW  19
39A8:  MOVLB  1
39AA:  MOVWF  x85
39AC:  MOVLW  05
39AE:  MOVWF  x86
39B0:  MOVLW  03
39B2:  MOVWF  x87
39B4:  MOVLB  0
39B6:  CALL   14CA
39BA:  MOVFF  03,ED
39BE:  MOVFF  02,EC
39C2:  MOVFF  01,EB
39C6:  MOVLW  19
39C8:  MOVLB  1
39CA:  MOVWF  x85
39CC:  MOVLW  03
39CE:  MOVWF  x86
39D0:  MOVLW  02
39D2:  MOVWF  x87
39D4:  MOVLB  0
39D6:  CALL   14CA
39DA:  MOVFF  03,F0
39DE:  MOVFF  02,EF
39E2:  MOVFF  01,EE
39E6:  MOVLW  19
39E8:  MOVLB  1
39EA:  MOVWF  x85
39EC:  CLRF   x86
39EE:  MOVLW  03
39F0:  MOVWF  x87
39F2:  MOVLB  0
39F4:  CALL   14CA
39F8:  MOVFF  03,F3
39FC:  MOVFF  02,F2
3A00:  MOVFF  01,F1
3A04:  MOVLW  1A
3A06:  MOVLB  1
3A08:  MOVWF  x85
3A0A:  MOVLW  05
3A0C:  MOVWF  x86
3A0E:  MOVLW  03
3A10:  MOVWF  x87
3A12:  MOVLB  0
3A14:  CALL   14CA
3A18:  MOVFF  03,F6
3A1C:  MOVFF  02,F5
3A20:  MOVFF  01,F4
3A24:  MOVLW  1A
3A26:  MOVLB  1
3A28:  MOVWF  x85
3A2A:  MOVLW  03
3A2C:  MOVWF  x86
3A2E:  MOVLW  02
3A30:  MOVWF  x87
3A32:  MOVLB  0
3A34:  CALL   14CA
3A38:  MOVFF  03,F9
3A3C:  MOVFF  02,F8
3A40:  MOVFF  01,F7
3A44:  MOVLW  1A
3A46:  MOVLB  1
3A48:  MOVWF  x85
3A4A:  CLRF   x86
3A4C:  MOVLW  03
3A4E:  MOVWF  x87
3A50:  MOVLB  0
3A52:  CALL   14CA
3A56:  MOVFF  03,FC
3A5A:  MOVFF  02,FB
3A5E:  MOVFF  01,FA
3A62:  MOVLW  37
3A64:  MOVLB  1
3A66:  MOVWF  x85
3A68:  MOVLW  07
3A6A:  MOVWF  x86
3A6C:  MOVLW  01
3A6E:  MOVWF  x87
3A70:  MOVLB  0
3A72:  CALL   14CA
3A76:  MOVFF  03,FF
3A7A:  MOVFF  02,FE
3A7E:  MOVFF  01,FD
3A82:  MOVLW  37
3A84:  MOVLB  1
3A86:  MOVWF  x85
3A88:  MOVLW  05
3A8A:  MOVWF  x86
3A8C:  MOVLW  02
3A8E:  MOVWF  x87
3A90:  MOVLB  0
3A92:  CALL   14CA
3A96:  MOVFF  03,102
3A9A:  MOVFF  02,101
3A9E:  MOVFF  01,100
3AA2:  MOVLW  37
3AA4:  MOVLB  1
3AA6:  MOVWF  x85
3AA8:  MOVLW  04
3AAA:  MOVWF  x86
3AAC:  MOVLW  01
3AAE:  MOVWF  x87
3AB0:  MOVLB  0
3AB2:  CALL   14CA
3AB6:  MOVFF  03,105
3ABA:  MOVFF  02,104
3ABE:  MOVFF  01,103
3AC2:  MOVLW  37
3AC4:  MOVLB  1
3AC6:  MOVWF  x85
3AC8:  MOVLW  03
3ACA:  MOVWF  x86
3ACC:  MOVLW  01
3ACE:  MOVWF  x87
3AD0:  MOVLB  0
3AD2:  CALL   14CA
3AD6:  MOVFF  03,108
3ADA:  MOVFF  02,107
3ADE:  MOVFF  01,106
3AE2:  MOVLW  37
3AE4:  MOVLB  1
3AE6:  MOVWF  x85
3AE8:  MOVLW  01
3AEA:  MOVWF  x86
3AEC:  MOVLW  02
3AEE:  MOVWF  x87
3AF0:  MOVLB  0
3AF2:  CALL   14CA
3AF6:  MOVFF  03,10B
3AFA:  MOVFF  02,10A
3AFE:  MOVFF  01,109
3B02:  MOVLW  27
3B04:  MOVLB  1
3B06:  MOVWF  x85
3B08:  MOVLW  07
3B0A:  MOVWF  x86
3B0C:  MOVLW  01
3B0E:  MOVWF  x87
3B10:  MOVLB  0
3B12:  CALL   14CA
3B16:  MOVFF  03,10E
3B1A:  MOVFF  02,10D
3B1E:  MOVFF  01,10C
3B22:  MOVLW  25
3B24:  MOVLB  1
3B26:  MOVWF  x85
3B28:  MOVLW  06
3B2A:  MOVWF  x86
3B2C:  MOVLW  02
3B2E:  MOVWF  x87
3B30:  MOVLB  0
3B32:  CALL   14CA
3B36:  MOVFF  03,111
3B3A:  MOVFF  02,110
3B3E:  MOVFF  01,10F
3B42:  MOVLW  25
3B44:  MOVLB  1
3B46:  MOVWF  x85
3B48:  MOVLW  04
3B4A:  MOVWF  x86
3B4C:  MOVLW  02
3B4E:  MOVWF  x87
3B50:  MOVLB  0
3B52:  CALL   14CA
3B56:  MOVFF  03,114
3B5A:  MOVFF  02,113
3B5E:  MOVFF  01,112
3B62:  MOVLW  25
3B64:  MOVLB  1
3B66:  MOVWF  x85
3B68:  MOVLW  02
3B6A:  MOVWF  x86
3B6C:  MOVWF  x87
3B6E:  MOVLB  0
3B70:  CALL   14CA
3B74:  MOVFF  03,117
3B78:  MOVFF  02,116
3B7C:  MOVFF  01,115
3B80:  MOVLW  25
3B82:  MOVLB  1
3B84:  MOVWF  x85
3B86:  CLRF   x86
3B88:  MOVLW  02
3B8A:  MOVWF  x87
3B8C:  MOVLB  0
3B8E:  CALL   14CA
3B92:  MOVFF  03,11A
3B96:  MOVFF  02,119
3B9A:  MOVFF  01,118
3B9E:  MOVLW  26
3BA0:  MOVLB  1
3BA2:  MOVWF  x85
3BA4:  MOVLW  06
3BA6:  MOVWF  x86
3BA8:  MOVLW  02
3BAA:  MOVWF  x87
3BAC:  MOVLB  0
3BAE:  CALL   14CA
3BB2:  MOVFF  03,11D
3BB6:  MOVFF  02,11C
3BBA:  MOVFF  01,11B
3BBE:  MOVLW  26
3BC0:  MOVLB  1
3BC2:  MOVWF  x85
3BC4:  MOVLW  04
3BC6:  MOVWF  x86
3BC8:  MOVLW  02
3BCA:  MOVWF  x87
3BCC:  MOVLB  0
3BCE:  CALL   14CA
3BD2:  MOVFF  03,120
3BD6:  MOVFF  02,11F
3BDA:  MOVFF  01,11E
3BDE:  MOVF   FC1,W
3BE0:  ANDLW  C0
3BE2:  IORLW  0F
3BE4:  MOVWF  FC1
3BE6:  MOVLW  07
3BE8:  MOVWF  FB4
3BEA:  MOVLW  02
3BEC:  MOVWF  xC0
3BEE:  MOVLW  5C
3BF0:  MOVWF  xBF
3BF2:  MOVLW  01
3BF4:  MOVLB  2
3BF6:  MOVWF  x5D
3BF8:  MOVLW  A0
3BFA:  MOVWF  x5C
3BFC:  MOVLW  05
3BFE:  MOVWF  x5F
3C00:  MOVLW  23
3C02:  MOVWF  x5E
3C04:  MOVLW  02
3C06:  MOVLB  5
3C08:  MOVWF  x24
3C0A:  MOVLW  D9
3C0C:  MOVWF  x23
3C0E:  CLRF   x26
3C10:  CLRF   x25
3C12:  MOVLB  0
3C14:  CLRF   xB8
3C16:  CLRF   xB9
.................... {
....................    //Timer de 8 bits
.................... //timer0 (RTCC_INTERNAL), Preescaler de 256, timer de 8 bits
.................... setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256 | RTCC_8_bit); 
3C18:  MOVLW  C7
3C1A:  MOVWF  FD5
.................... //el timer se va a desbordar dependiendo de la formula:
.................... //tiempo_desbordamiento =  (Valor_maximo_del_timer * (4*Preescaler))/Freq
.................... 
.................... //EJEMPLO, 
.................... //para un divisor de 64, reloj de 48 MHZ y tiempo de 1ms
.................... //Dado que el oscilador funciona a 48 Mhz, la formula es:
.................... //t = 256*4*64 / 48000000 = 1.365 ms (aprox. 1ms),
.................... //Para hacerlo mas preciso, es posible inicializar el timer a un valor mayor a 0, por lo que el desbordamiento ocurriria antes:
.................... //con un valor de inicio de 67 (contando el 0, esto es 68 pasos) (256-68 = 180), el valor da 1.0026ms
.................... 
.................... 
.................... set_rtcc(TIMER_START);
3C1C:  CLRF   FD7
3C1E:  MOVLW  72
3C20:  MOVWF  FD6
3C22:  NOP   
.................... //Interrupciones del timer
.................... enable_interrupts(INT_RTCC);
3C24:  BSF    FF2.5
.................... enable_interrupts(GLOBAL);
3C26:  MOVLW  C0
3C28:  IORWF  FF2,F
.................... 
.................... 
....................    //RFM69 radio;
....................    //PRIMER BYTE es el tamao del array 
....................    uint8_t synch[] = {3,0xAA,0x2D,0xD4};
3C2A:  MOVLW  03
3C2C:  MOVLB  1
3C2E:  MOVWF  x6F
3C30:  MOVLW  AA
3C32:  MOVWF  x70
3C34:  MOVLW  2D
3C36:  MOVWF  x71
3C38:  MOVLW  D4
3C3A:  MOVWF  x72
....................    int ResetPin = RF_Reset;
3C3C:  MOVLW  20
3C3E:  MOVWF  x73
....................    //radio.init(synch,ResetPin);
....................    
....................    setup_adc_ports(NO_ANALOGS, VSS_VDD);
3C40:  MOVF   FC1,W
3C42:  ANDLW  C0
3C44:  IORLW  0F
3C46:  MOVWF  FC1
....................    usb_init();
3C48:  MOVLB  0
3C4A:  GOTO   15AE
....................    //Esperar un segundo antes de iniciar
....................    delay_ms(1000);
3C4E:  MOVLW  04
3C50:  MOVLB  1
3C52:  MOVWF  x85
3C54:  MOVLW  FA
3C56:  MOVLB  2
3C58:  MOVWF  x14
3C5A:  MOVLB  0
3C5C:  CALL   15BC
3C60:  MOVLB  1
3C62:  DECFSZ x85,F
3C64:  BRA    3C54
....................    while (!checkId())println((char*)"Id incorrecto");
3C66:  MOVLB  0
3C68:  GOTO   170E
3C6C:  MOVF   01,F
3C6E:  BNZ   3CA2
3C70:  MOVLW  01
3C72:  MOVWF  FEA
3C74:  MOVLW  74
3C76:  MOVWF  FE9
3C78:  MOVLW  0E
3C7A:  MOVWF  01
3C7C:  CLRF   FF7
3C7E:  MOVLW  00
3C80:  CALL   03B0
3C84:  TBLRD*-
3C86:  TBLRD*+
3C88:  MOVFF  FF5,FEE
3C8C:  DECFSZ 01,F
3C8E:  BRA    3C86
3C90:  MOVLW  01
3C92:  MOVLB  2
3C94:  MOVWF  x17
3C96:  MOVLW  74
3C98:  MOVWF  x16
3C9A:  MOVLB  0
3C9C:  CALL   1800
3CA0:  BRA    3C68
....................    init(synch,ResetPin);
3CA2:  MOVLW  01
3CA4:  MOVLB  1
3CA6:  MOVWF  x86
3CA8:  MOVLW  6F
3CAA:  MOVWF  x85
3CAC:  MOVFF  173,187
3CB0:  MOVLW  04
3CB2:  MOVWF  x88
3CB4:  MOVLW  01
3CB6:  MOVWF  x89
3CB8:  CLRF   x8D
3CBA:  MOVLW  1E
3CBC:  MOVWF  x8C
3CBE:  MOVLW  84
3CC0:  MOVWF  x8B
3CC2:  MOVLW  80
3CC4:  MOVWF  x8A
3CC6:  CLRF   x8F
3CC8:  CLRF   x8E
3CCA:  MOVLB  0
3CCC:  GOTO   27DC
....................    println((char*)"INIT DONE");
3CD0:  MOVLW  01
3CD2:  MOVWF  FEA
3CD4:  MOVLW  74
3CD6:  MOVWF  FE9
3CD8:  MOVLW  0A
3CDA:  MOVWF  01
3CDC:  CLRF   FF7
3CDE:  MOVLW  00
3CE0:  CALL   03CE
3CE4:  TBLRD*-
3CE6:  TBLRD*+
3CE8:  MOVFF  FF5,FEE
3CEC:  DECFSZ 01,F
3CEE:  BRA    3CE6
3CF0:  MOVLW  01
3CF2:  MOVLB  2
3CF4:  MOVWF  x17
3CF6:  MOVLW  74
3CF8:  MOVWF  x16
3CFA:  MOVLB  0
3CFC:  CALL   1800
....................    while(TRUE)
....................    {
....................    char* packet = receive(1,0,0,0);
3D00:  MOVLW  01
3D02:  MOVLB  1
3D04:  MOVWF  x85
3D06:  CLRF   x86
3D08:  CLRF   x8A
3D0A:  CLRF   x89
3D0C:  CLRF   x88
3D0E:  CLRF   x87
3D10:  CLRF   x8B
3D12:  MOVLB  0
3D14:  GOTO   3350
3D18:  MOVFF  02,183
3D1C:  MOVFF  01,182
....................    if (!(packet == NULL || packet[0] == 0)){
3D20:  MOVLB  1
3D22:  MOVF   x82,F
3D24:  BNZ   3D2A
3D26:  MOVF   x83,F
3D28:  BZ    3D84
3D2A:  MOVFF  182,FE9
3D2E:  MOVFF  183,FEA
3D32:  MOVF   FEF,F
3D34:  BZ    3D84
....................     for (int i=0;i<packet[0];i++){
3D36:  CLRF   x84
3D38:  MOVFF  182,FE9
3D3C:  MOVFF  183,FEA
3D40:  MOVF   FEF,W
3D42:  SUBWF  x84,W
3D44:  BC    3D6E
....................       print((char*)packet[i+1]);
3D46:  MOVLW  01
3D48:  ADDWF  x84,W
3D4A:  ADDWF  x82,W
3D4C:  MOVWF  FE9
3D4E:  MOVLW  00
3D50:  ADDWFC x83,W
3D52:  MOVWF  FEA
3D54:  MOVF   FEF,W
3D56:  CLRF   x86
3D58:  MOVWF  x85
3D5A:  MOVLB  2
3D5C:  CLRF   x17
3D5E:  MOVFF  FE8,216
3D62:  MOVLB  0
3D64:  CALL   185A
3D68:  MOVLB  1
3D6A:  INCF   x84,F
3D6C:  BRA    3D38
....................       }
....................   println((char*)"");
3D6E:  CLRF   x74
3D70:  MOVLW  01
3D72:  MOVLB  2
3D74:  MOVWF  x17
3D76:  MOVLW  74
3D78:  MOVWF  x16
3D7A:  MOVLB  0
3D7C:  CALL   1800
....................    }
3D80:  BRA    3DB6
3D82:  MOVLB  1
....................    else println((char*) "Esperando");
3D84:  MOVLW  01
3D86:  MOVWF  FEA
3D88:  MOVLW  74
3D8A:  MOVWF  FE9
3D8C:  MOVLW  0A
3D8E:  MOVWF  01
3D90:  CLRF   FF7
3D92:  MOVLW  00
3D94:  MOVLB  0
3D96:  CALL   03E8
3D9A:  TBLRD*-
3D9C:  TBLRD*+
3D9E:  MOVFF  FF5,FEE
3DA2:  DECFSZ 01,F
3DA4:  BRA    3D9C
3DA6:  MOVLW  01
3DA8:  MOVLB  2
3DAA:  MOVWF  x17
3DAC:  MOVLW  74
3DAE:  MOVWF  x16
3DB0:  MOVLB  0
3DB2:  CALL   1800
....................   //radio.readAllRegs();
....................   free(packet);
3DB6:  MOVFF  183,1D2
3DBA:  MOVFF  182,1D1
3DBE:  CALL   301C
....................    //println(globalSec,DEC);
....................    
....................    //readAllRegs();
....................    //print((char*)"RFM ");
....................    
....................    //if (!checkId())println((char*)"incorrecto");
....................    //else println((char*)"Correcto");
....................    //radio.readAllRegs();
.................... //!   println((char*)"HOLA USB");
.................... //!   println(134,HEX);
.................... //!   println(47,BIN);
....................    delay_ms(100);
3DC2:  MOVLW  64
3DC4:  MOVLB  2
3DC6:  MOVWF  x14
3DC8:  MOVLB  0
3DCA:  CALL   15BC
3DCE:  BRA    3D00
....................       //TODO: User Code
....................    }
.................... 
.................... }
.................... 
.................... //Interrupcion del timer
.................... #INT_RTCC  //TIMER0
.................... void timer0(void){
3DD0:  SLEEP 
....................    set_rtcc(TIMER_START); //Timer0
*
1476:  CLRF   FD7
1478:  MOVLW  72
147A:  MOVWF  FD6
147C:  NOP   
....................    //println((char*)"Timer INT");
....................    globalMs += TIMER_STEP_MS ;       
147E:  MOVLW  03
1480:  ADDWF  xBA,F
1482:  MOVLW  00
1484:  ADDWFC xBB,F
....................    if (globalMs >= 1000){
1486:  MOVF   xBB,W
1488:  SUBLW  02
148A:  BC    14A0
148C:  XORLW  FF
148E:  BNZ   1496
1490:  MOVF   xBA,W
1492:  SUBLW  E7
1494:  BC    14A0
....................    globalSec ++;
1496:  INCF   xBC,F
....................    globalMs -= 1000;
1498:  MOVLW  E8
149A:  SUBWF  xBA,F
149C:  MOVLW  03
149E:  SUBWFB xBB,F
....................    }
....................    if (globalSec >= 60){
14A0:  MOVF   xBC,W
14A2:  SUBLW  3B
14A4:  BC    14B0
....................    globalMin ++;
14A6:  INCF   xBD,F
14A8:  BTFSC  FD8.2
14AA:  INCF   xBE,F
....................    globalSec -= 60;
14AC:  MOVLW  3C
14AE:  SUBWF  xBC,F
....................    }
....................    //Inicializar todo al llegar a 60 minutos
....................    //Puede introducir un bug rarisimo en el que una diferencia entre tiempos de negativa, pero es muy poco probable
....................    //Y aun asi el bug ocurrira cuando gloabalMin desborde
....................    if (globalMin >= 60){
14B0:  MOVF   xBE,F
14B2:  BNZ   14BA
14B4:  MOVF   xBD,W
14B6:  SUBLW  3B
14B8:  BC    14C4
....................    globalMs = 0;
14BA:  CLRF   xBB
14BC:  CLRF   xBA
....................    globalSec= 0;
14BE:  CLRF   xBC
....................    globalMin = 0;
14C0:  CLRF   xBE
14C2:  CLRF   xBD
....................    }
14C4:  BCF    FF2.2
14C6:  GOTO   006C
.................... }

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
