CCS PCH C Compiler, Version 5.112, 29001               04-jun.-23 11:14

               Filename:   I:\CanSat\Cansat\Assets\RFM69\Receptor\ArduPort\Receptor.lst

               ROM used:   14996 bytes (46%)
                           Largest free fragment is 17772
               RAM used:   682 (33%) at main() level
                           880 (43%) worst case
               Stack used: 17 locations (10 in main + 7 for interrupts)
               Stack size: 31

*
0000:  GOTO   34A6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   1414
0060:  BTFSS  FA0.5
0062:  GOTO   006C
0066:  BTFSC  FA1.5
0068:  GOTO   138C
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #define HEX 16
.................... #define BIN 2
.................... #define DEC 10
.................... #define SSPin PIN_A5
.................... #define TIMER_START 114
.................... #define TIMER_STEP_MS 3
.................... #include <Receptor.h>
.................... #include <18LF4550.h>
.................... //////////// Standard Header file for the PIC18LF4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18LF4550
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 00,03
00CC:  DATA 02,FF
00CE:  DATA FF,FF
00D0:  DATA FF,FF
00D2:  DATA FF,FF
00D4:  DATA FF,FF
00D6:  DATA FF,FF
00D8:  DATA FF,FF
00DA:  CLRF   FF7
00DC:  ADDLW  EA
00DE:  MOVWF  FF6
00E0:  MOVLW  00
00E2:  ADDWFC FF7,F
00E4:  TBLRD*+
00E6:  MOVF   FF5,W
00E8:  RETURN 0
00EA:  DATA 00,FF
00EC:  DATA 02,FF
00EE:  DATA FF,FF
00F0:  DATA FF,FF
00F2:  DATA FF,FF
00F4:  DATA FF,FF
00F6:  DATA FF,FF
00F8:  DATA FF,FF
00FA:  CLRF   FF7
00FC:  ADDLW  0A
00FE:  MOVWF  FF6
0100:  MOVLW  01
0102:  ADDWFC FF7,F
0104:  TBLRD*+
0106:  MOVF   FF5,W
0108:  RETURN 0
010A:  DATA 40,00
010C:  DATA 0B,00
010E:  DATA 40,00
0110:  DATA 00,00
0112:  DATA 00,00
0114:  DATA 00,00
0116:  DATA 00,00
0118:  DATA 00,00
011A:  DATA 00,00
011C:  DATA 00,00
011E:  DATA 00,00
0120:  DATA 00,00
0122:  DATA 00,00
0124:  DATA 00,00
0126:  DATA 00,00
0128:  DATA 00,00
012A:  CLRF   FF7
012C:  ADDLW  3A
012E:  MOVWF  FF6
0130:  MOVLW  01
0132:  ADDWFC FF7,F
0134:  TBLRD*+
0136:  MOVF   FF5,W
0138:  RETURN 0
013A:  DATA 40,00
013C:  DATA 00,00
013E:  DATA 40,00
0140:  DATA 00,00
0142:  DATA 00,00
0144:  DATA 00,00
0146:  DATA 00,00
0148:  DATA 00,00
014A:  DATA 00,00
014C:  DATA 00,00
014E:  DATA 00,00
0150:  DATA 00,00
0152:  DATA 00,00
0154:  DATA 00,00
0156:  DATA 00,00
0158:  DATA 00,00
015A:  CLRF   FF7
015C:  ADDLW  6A
015E:  MOVWF  FF6
0160:  MOVLW  01
0162:  ADDWFC FF7,F
0164:  TBLRD*+
0166:  MOVF   FF5,W
0168:  RETURN 0
016A:  DATA 09,02
016C:  DATA 43,00
016E:  DATA 02,01
0170:  DATA 00,80
0172:  DATA FA,09
0174:  DATA 04,00
0176:  DATA 00,01
0178:  DATA 02,02
017A:  DATA 01,00
017C:  DATA 05,24
017E:  DATA 00,10
0180:  DATA 01,04
0182:  DATA 24,02
0184:  DATA 02,05
0186:  DATA 24,06
0188:  DATA 00,01
018A:  DATA 05,24
018C:  DATA 01,00
018E:  DATA 01,07
0190:  DATA 05,81
0192:  DATA 03,0B
0194:  DATA 00,FA
0196:  DATA 09,04
0198:  DATA 01,00
019A:  DATA 02,0A
019C:  DATA 00,00
019E:  DATA 00,07
01A0:  DATA 05,02
01A2:  DATA 02,40
01A4:  DATA 00,01
01A6:  DATA 07,05
01A8:  DATA 82,02
01AA:  DATA 40,00
01AC:  DATA 01,00
01AE:  CLRF   FF7
01B0:  ADDLW  BE
01B2:  MOVWF  FF6
01B4:  MOVLW  01
01B6:  ADDWFC FF7,F
01B8:  TBLRD*+
01BA:  MOVF   FF5,W
01BC:  RETURN 0
01BE:  DATA 02,00
01C0:  CLRF   FF7
01C2:  ADDLW  D0
01C4:  MOVWF  FF6
01C6:  MOVLW  01
01C8:  ADDWFC FF7,F
01CA:  TBLRD*+
01CC:  MOVF   FF5,W
01CE:  RETURN 0
01D0:  DATA 12,17
01D2:  DATA 1B,20
01D4:  DATA FF,FF
01D6:  DATA FF,FF
01D8:  CLRF   FF7
01DA:  ADDLW  E8
01DC:  MOVWF  FF6
01DE:  MOVLW  01
01E0:  ADDWFC FF7,F
01E2:  TBLRD*+
01E4:  MOVF   FF5,W
01E6:  RETURN 0
01E8:  DATA 12,01
01EA:  DATA 10,01
01EC:  DATA 02,00
01EE:  DATA 00,40
01F0:  DATA 05,24
01F2:  DATA 0B,00
01F4:  DATA 00,01
01F6:  DATA 01,02
01F8:  DATA 00,01
01FA:  CLRF   FF7
01FC:  ADDLW  0A
01FE:  MOVWF  FF6
0200:  MOVLW  02
0202:  ADDWFC FF7,F
0204:  TBLRD*+
0206:  MOVF   FF5,W
0208:  RETURN 0
020A:  DATA 04,03
020C:  DATA 09,04
020E:  DATA 08,03
0210:  DATA 43,00
0212:  DATA 43,00
0214:  DATA 53,00
0216:  DATA 20,03
0218:  DATA 43,00
021A:  DATA 43,00
021C:  DATA 53,00
021E:  DATA 20,00
0220:  DATA 55,00
0222:  DATA 53,00
0224:  DATA 42,00
0226:  DATA 20,00
0228:  DATA 74,00
022A:  DATA 6F,00
022C:  DATA 20,00
022E:  DATA 55,00
0230:  DATA 41,00
0232:  DATA 52,00
0234:  DATA 54,00
0236:  CLRF   FF7
0238:  ADDLW  46
023A:  MOVWF  FF6
023C:  MOVLW  02
023E:  ADDWFC FF7,F
0240:  TBLRD*+
0242:  MOVF   FF5,W
0244:  RETURN 0
0246:  DATA 49,6E
0248:  DATA 69,74
024A:  DATA 69,61
024C:  DATA 6C,20
024E:  DATA 63,6F
0250:  DATA 6E,66
0252:  DATA 20,73
0254:  DATA 74,61
0256:  DATA 72,74
0258:  DATA 73,00
025A:  CLRF   FF7
025C:  ADDLW  6A
025E:  MOVWF  FF6
0260:  MOVLW  02
0262:  ADDWFC FF7,F
0264:  TBLRD*+
0266:  MOVF   FF5,W
0268:  RETURN 0
026A:  DATA 45,72
026C:  DATA 72,6F
026E:  DATA 72,3A
0270:  DATA 20,49
0272:  DATA 44,20
0274:  DATA 64,65
0276:  DATA 6C,20
0278:  DATA 52,46
027A:  DATA 4D,20
027C:  DATA 69,6E
027E:  DATA 63,6F
0280:  DATA 72,72
0282:  DATA 65,63
0284:  DATA 74,61
0286:  DATA 00,00
0288:  CLRF   FF7
028A:  ADDLW  98
028C:  MOVWF  FF6
028E:  MOVLW  02
0290:  ADDWFC FF7,F
0292:  TBLRD*+
0294:  MOVF   FF5,W
0296:  RETURN 0
0298:  DATA 49,44
029A:  DATA 20,4C
029C:  DATA 6F,6F
029E:  DATA 70,00
02A0:  CLRF   FF7
02A2:  ADDLW  B0
02A4:  MOVWF  FF6
02A6:  MOVLW  02
02A8:  ADDWFC FF7,F
02AA:  TBLRD*+
02AC:  MOVF   FF5,W
02AE:  RETURN 0
02B0:  DATA 49,6E
02B2:  DATA 69,74
02B4:  DATA 69,61
02B6:  DATA 6C,20
02B8:  DATA 63,6F
02BA:  DATA 6E,66
02BC:  DATA 69,67
02BE:  DATA 75,72
02C0:  DATA 61,74
02C2:  DATA 69,6F
02C4:  DATA 6E,20
02C6:  DATA 65,6E
02C8:  DATA 64,0A
02CA:  DATA 00,00
02CC:  CLRF   FF7
02CE:  ADDLW  DC
02D0:  MOVWF  FF6
02D2:  MOVLW  02
02D4:  ADDWFC FF7,F
02D6:  TBLRD*+
02D8:  MOVF   FF5,W
02DA:  RETURN 0
02DC:  DATA 4F,50
02DE:  DATA 20,4C
02E0:  DATA 6F,6F
02E2:  DATA 70,20
02E4:  DATA 31,00
02E6:  CLRF   FF7
02E8:  ADDLW  F6
02EA:  MOVWF  FF6
02EC:  MOVLW  02
02EE:  ADDWFC FF7,F
02F0:  TBLRD*+
02F2:  MOVF   FF5,W
02F4:  RETURN 0
02F6:  DATA 4F,50
02F8:  DATA 20,4C
02FA:  DATA 6F,6F
02FC:  DATA 70,20
02FE:  DATA 32,00
0300:  CLRF   FF7
0302:  ADDLW  10
0304:  MOVWF  FF6
0306:  MOVLW  03
0308:  ADDWFC FF7,F
030A:  TBLRD*+
030C:  MOVF   FF5,W
030E:  RETURN 0
0310:  DATA 50,61
0312:  DATA 79,6C
0314:  DATA 6F,61
0316:  DATA 64,3A
0318:  DATA 20,00
031A:  CLRF   FF7
031C:  ADDLW  2A
031E:  MOVWF  FF6
0320:  MOVLW  03
0322:  ADDWFC FF7,F
0324:  TBLRD*+
0326:  MOVF   FF5,W
0328:  RETURN 0
032A:  DATA 54,69
032C:  DATA 6D,65
032E:  DATA 64,20
0330:  DATA 6F,75
0332:  DATA 74,00
0334:  CLRF   FF7
0336:  ADDLW  44
0338:  MOVWF  FF6
033A:  MOVLW  03
033C:  ADDWFC FF7,F
033E:  TBLRD*+
0340:  MOVF   FF5,W
0342:  RETURN 0
0344:  DATA 46,49
0346:  DATA 46,4F
0348:  DATA 20,4C
034A:  DATA 45,4E
034C:  DATA 3A,20
034E:  DATA 00,00
0350:  CLRF   FF7
0352:  ADDLW  60
0354:  MOVWF  FF6
0356:  MOVLW  03
0358:  ADDWFC FF7,F
035A:  TBLRD*+
035C:  MOVF   FF5,W
035E:  RETURN 0
0360:  DATA 49,64
0362:  DATA 20,69
0364:  DATA 6E,63
0366:  DATA 6F,72
0368:  DATA 72,65
036A:  DATA 63,74
036C:  DATA 6F,00
036E:  CLRF   FF7
0370:  ADDLW  7E
0372:  MOVWF  FF6
0374:  MOVLW  03
0376:  ADDWFC FF7,F
0378:  TBLRD*+
037A:  MOVF   FF5,W
037C:  RETURN 0
037E:  DATA 49,4E
0380:  DATA 49,54
0382:  DATA 20,44
0384:  DATA 4F,4E
0386:  DATA 45,00
0388:  CLRF   FF7
038A:  ADDLW  98
038C:  MOVWF  FF6
038E:  MOVLW  03
0390:  ADDWFC FF7,F
0392:  TBLRD*+
0394:  MOVF   FF5,W
0396:  RETURN 0
0398:  DATA 45,73
039A:  DATA 70,65
039C:  DATA 72,61
039E:  DATA 6E,64
03A0:  DATA 6F,00
*
0442:  MOVLB  2
0444:  MOVF   x48,W
0446:  MULWF  x4A
0448:  MOVFF  FF3,01
044C:  MOVFF  FF4,00
0450:  MULWF  x4B
0452:  MOVF   FF3,W
0454:  ADDWF  00,F
0456:  MOVF   x49,W
0458:  MULWF  x4A
045A:  MOVF   FF3,W
045C:  ADDWFC 00,W
045E:  MOVWF  02
0460:  MOVLB  0
0462:  RETURN 0
*
1584:  MOVLB  2
1586:  MOVF   x1D,W
1588:  ANDLW  07
158A:  MOVWF  00
158C:  RRCF   x1D,W
158E:  MOVWF  01
1590:  RRCF   01,F
1592:  RRCF   01,F
1594:  MOVLW  1F
1596:  ANDWF  01,F
1598:  MOVF   01,W
159A:  ADDWF  x1F,W
159C:  MOVWF  FE9
159E:  MOVLW  00
15A0:  ADDWFC x20,W
15A2:  MOVWF  FEA
15A4:  CLRF   01
15A6:  INCF   01,F
15A8:  INCF   00,F
15AA:  BRA    15AE
15AC:  RLCF   01,F
15AE:  DECFSZ 00,F
15B0:  BRA    15AC
15B2:  MOVF   x1E,F
15B4:  BZ    15BC
15B6:  MOVF   01,W
15B8:  IORWF  FEF,F
15BA:  BRA    15C2
15BC:  COMF   01,F
15BE:  MOVF   01,W
15C0:  ANDWF  FEF,F
15C2:  MOVLB  0
15C4:  RETURN 0
*
1764:  MOVF   FEF,F
1766:  BZ    1786
1768:  MOVFF  FEA,21C
176C:  MOVFF  FE9,21B
1770:  MOVFF  FEF,21D
1774:  BRA    1726
1776:  MOVFF  21C,FEA
177A:  MOVFF  21B,FE9
177E:  INCF   FE9,F
1780:  BTFSC  FD8.2
1782:  INCF   FEA,F
1784:  BRA    1764
1786:  GOTO   179C (RETURN)
*
1ADA:  MOVLB  1
1ADC:  MOVF   xB6,W
1ADE:  BTFSC  FD8.2
1AE0:  BRA    1C2C
1AE2:  MOVWF  xC2
1AE4:  MOVF   xBA,W
1AE6:  BTFSC  FD8.2
1AE8:  BRA    1C2C
1AEA:  SUBWF  xC2,F
1AEC:  BNC   1AF8
1AEE:  MOVLW  7F
1AF0:  ADDWF  xC2,F
1AF2:  BTFSC  FD8.0
1AF4:  BRA    1C2C
1AF6:  BRA    1B04
1AF8:  MOVLW  81
1AFA:  SUBWF  xC2,F
1AFC:  BTFSS  FD8.0
1AFE:  BRA    1C2C
1B00:  BTFSC  FD8.2
1B02:  BRA    1C2C
1B04:  MOVFF  1C2,00
1B08:  CLRF   01
1B0A:  CLRF   02
1B0C:  CLRF   03
1B0E:  CLRF   xC1
1B10:  MOVFF  1B7,1C0
1B14:  BSF    xC0.7
1B16:  MOVFF  1B8,1BF
1B1A:  MOVFF  1B9,1BE
1B1E:  MOVLW  19
1B20:  MOVWF  xC2
1B22:  MOVF   xBD,W
1B24:  SUBWF  xBE,F
1B26:  BC    1B42
1B28:  MOVLW  01
1B2A:  SUBWF  xBF,F
1B2C:  BC    1B42
1B2E:  SUBWF  xC0,F
1B30:  BC    1B42
1B32:  SUBWF  xC1,F
1B34:  BC    1B42
1B36:  INCF   xC1,F
1B38:  INCF   xC0,F
1B3A:  INCF   xBF,F
1B3C:  MOVF   xBD,W
1B3E:  ADDWF  xBE,F
1B40:  BRA    1B92
1B42:  MOVF   xBC,W
1B44:  SUBWF  xBF,F
1B46:  BC    1B6C
1B48:  MOVLW  01
1B4A:  SUBWF  xC0,F
1B4C:  BC    1B6C
1B4E:  SUBWF  xC1,F
1B50:  BC    1B6C
1B52:  INCF   xC1,F
1B54:  INCF   xC0,F
1B56:  MOVF   xBC,W
1B58:  ADDWF  xBF,F
1B5A:  MOVF   xBD,W
1B5C:  ADDWF  xBE,F
1B5E:  BNC   1B92
1B60:  INCF   xBF,F
1B62:  BNZ   1B92
1B64:  INCF   xC0,F
1B66:  BNZ   1B92
1B68:  INCF   xC1,F
1B6A:  BRA    1B92
1B6C:  MOVF   xBB,W
1B6E:  IORLW  80
1B70:  SUBWF  xC0,F
1B72:  BC    1B90
1B74:  MOVLW  01
1B76:  SUBWF  xC1,F
1B78:  BC    1B90
1B7A:  INCF   xC1,F
1B7C:  MOVF   xBB,W
1B7E:  IORLW  80
1B80:  ADDWF  xC0,F
1B82:  MOVF   xBC,W
1B84:  ADDWF  xBF,F
1B86:  BNC   1B5A
1B88:  INCF   xC0,F
1B8A:  BNZ   1B5A
1B8C:  INCF   xC1,F
1B8E:  BRA    1B5A
1B90:  BSF    03.0
1B92:  DECFSZ xC2,F
1B94:  BRA    1B98
1B96:  BRA    1BAE
1B98:  BCF    FD8.0
1B9A:  RLCF   xBE,F
1B9C:  RLCF   xBF,F
1B9E:  RLCF   xC0,F
1BA0:  RLCF   xC1,F
1BA2:  BCF    FD8.0
1BA4:  RLCF   03,F
1BA6:  RLCF   02,F
1BA8:  RLCF   01,F
1BAA:  RLCF   xC3,F
1BAC:  BRA    1B22
1BAE:  BTFSS  xC3.0
1BB0:  BRA    1BBE
1BB2:  BCF    FD8.0
1BB4:  RRCF   01,F
1BB6:  RRCF   02,F
1BB8:  RRCF   03,F
1BBA:  RRCF   xC3,F
1BBC:  BRA    1BC2
1BBE:  DECF   00,F
1BC0:  BZ    1C2C
1BC2:  BTFSC  xC3.7
1BC4:  BRA    1C02
1BC6:  BCF    FD8.0
1BC8:  RLCF   xBE,F
1BCA:  RLCF   xBF,F
1BCC:  RLCF   xC0,F
1BCE:  RLCF   xC1,F
1BD0:  MOVF   xBD,W
1BD2:  SUBWF  xBE,F
1BD4:  BC    1BE4
1BD6:  MOVLW  01
1BD8:  SUBWF  xBF,F
1BDA:  BC    1BE4
1BDC:  SUBWF  xC0,F
1BDE:  BC    1BE4
1BE0:  SUBWF  xC1,F
1BE2:  BNC   1C18
1BE4:  MOVF   xBC,W
1BE6:  SUBWF  xBF,F
1BE8:  BC    1BF4
1BEA:  MOVLW  01
1BEC:  SUBWF  xC0,F
1BEE:  BC    1BF4
1BF0:  SUBWF  xC1,F
1BF2:  BNC   1C18
1BF4:  MOVF   xBB,W
1BF6:  IORLW  80
1BF8:  SUBWF  xC0,F
1BFA:  BC    1C02
1BFC:  MOVLW  01
1BFE:  SUBWF  xC1,F
1C00:  BNC   1C18
1C02:  INCF   03,F
1C04:  BNZ   1C18
1C06:  INCF   02,F
1C08:  BNZ   1C18
1C0A:  INCF   01,F
1C0C:  BNZ   1C18
1C0E:  INCF   00,F
1C10:  BZ    1C2C
1C12:  RRCF   01,F
1C14:  RRCF   02,F
1C16:  RRCF   03,F
1C18:  MOVFF  1B7,1C2
1C1C:  MOVF   xBB,W
1C1E:  XORWF  xC2,F
1C20:  BTFSS  xC2.7
1C22:  BRA    1C28
1C24:  BSF    01.7
1C26:  BRA    1C34
1C28:  BCF    01.7
1C2A:  BRA    1C34
1C2C:  CLRF   00
1C2E:  CLRF   01
1C30:  CLRF   02
1C32:  CLRF   03
1C34:  MOVLB  0
1C36:  RETURN 0
1C38:  MOVLW  80
1C3A:  BTFSS  FD8.1
1C3C:  BRA    1C42
1C3E:  MOVLB  1
1C40:  XORWF  xDC,F
1C42:  MOVLB  1
1C44:  CLRF   xE1
1C46:  CLRF   xE2
1C48:  MOVFF  1D8,1E0
1C4C:  MOVF   xDC,W
1C4E:  XORWF  xE0,F
1C50:  MOVF   xD7,W
1C52:  BTFSC  FD8.2
1C54:  BRA    1E14
1C56:  MOVWF  xDF
1C58:  MOVWF  00
1C5A:  MOVF   xDB,W
1C5C:  BTFSC  FD8.2
1C5E:  BRA    1E26
1C60:  SUBWF  xDF,F
1C62:  BTFSC  FD8.2
1C64:  BRA    1D6C
1C66:  BNC   1CE4
1C68:  MOVFF  1DC,1E5
1C6C:  BSF    xE5.7
1C6E:  MOVFF  1DD,1E4
1C72:  MOVFF  1DE,1E3
1C76:  CLRF   xE2
1C78:  BCF    FD8.0
1C7A:  RRCF   xE5,F
1C7C:  RRCF   xE4,F
1C7E:  RRCF   xE3,F
1C80:  RRCF   xE2,F
1C82:  DECFSZ xDF,F
1C84:  BRA    1C76
1C86:  BTFSS  xE0.7
1C88:  BRA    1C90
1C8A:  BSF    xE1.0
1C8C:  BRA    1E4E
1C8E:  BCF    xE1.0
1C90:  BCF    xDF.0
1C92:  BSF    xE1.4
1C94:  MOVLW  01
1C96:  MOVWF  FEA
1C98:  MOVLW  DA
1C9A:  MOVWF  FE9
1C9C:  BRA    1E74
1C9E:  BCF    xE1.4
1CA0:  BTFSC  xE0.7
1CA2:  BRA    1CB8
1CA4:  BTFSS  xDF.0
1CA6:  BRA    1CCE
1CA8:  RRCF   xE5,F
1CAA:  RRCF   xE4,F
1CAC:  RRCF   xE3,F
1CAE:  RRCF   xE2,F
1CB0:  INCF   00,F
1CB2:  BTFSC  FD8.2
1CB4:  BRA    1E44
1CB6:  BRA    1CCE
1CB8:  BTFSC  xE5.7
1CBA:  BRA    1CD4
1CBC:  BCF    FD8.0
1CBE:  RLCF   xE2,F
1CC0:  RLCF   xE3,F
1CC2:  RLCF   xE4,F
1CC4:  RLCF   xE5,F
1CC6:  DECF   00,F
1CC8:  BTFSC  FD8.2
1CCA:  BRA    1E44
1CCC:  BRA    1CB8
1CCE:  BSF    xE1.6
1CD0:  BRA    1DAC
1CD2:  BCF    xE1.6
1CD4:  MOVFF  1D8,1E0
1CD8:  BTFSS  xD8.7
1CDA:  BRA    1CE0
1CDC:  BSF    xE5.7
1CDE:  BRA    1E36
1CE0:  BCF    xE5.7
1CE2:  BRA    1E36
1CE4:  MOVFF  1DB,1DF
1CE8:  MOVFF  1DB,00
1CEC:  MOVF   xD7,W
1CEE:  SUBWF  xDF,F
1CF0:  MOVFF  1D8,1E5
1CF4:  BSF    xE5.7
1CF6:  MOVFF  1D9,1E4
1CFA:  MOVFF  1DA,1E3
1CFE:  CLRF   xE2
1D00:  BCF    FD8.0
1D02:  RRCF   xE5,F
1D04:  RRCF   xE4,F
1D06:  RRCF   xE3,F
1D08:  RRCF   xE2,F
1D0A:  DECFSZ xDF,F
1D0C:  BRA    1CFE
1D0E:  BTFSS  xE0.7
1D10:  BRA    1D18
1D12:  BSF    xE1.1
1D14:  BRA    1E4E
1D16:  BCF    xE1.1
1D18:  BCF    xDF.0
1D1A:  BSF    xE1.5
1D1C:  MOVLW  01
1D1E:  MOVWF  FEA
1D20:  MOVLW  DE
1D22:  MOVWF  FE9
1D24:  BRA    1E74
1D26:  BCF    xE1.5
1D28:  BTFSC  xE0.7
1D2A:  BRA    1D40
1D2C:  BTFSS  xDF.0
1D2E:  BRA    1D56
1D30:  RRCF   xE5,F
1D32:  RRCF   xE4,F
1D34:  RRCF   xE3,F
1D36:  RRCF   xE2,F
1D38:  INCF   00,F
1D3A:  BTFSC  FD8.2
1D3C:  BRA    1E44
1D3E:  BRA    1D56
1D40:  BTFSC  xE5.7
1D42:  BRA    1D5C
1D44:  BCF    FD8.0
1D46:  RLCF   xE2,F
1D48:  RLCF   xE3,F
1D4A:  RLCF   xE4,F
1D4C:  RLCF   xE5,F
1D4E:  DECF   00,F
1D50:  BTFSC  FD8.2
1D52:  BRA    1E44
1D54:  BRA    1D40
1D56:  BSF    xE1.7
1D58:  BRA    1DAC
1D5A:  BCF    xE1.7
1D5C:  MOVFF  1DC,1E0
1D60:  BTFSS  xDC.7
1D62:  BRA    1D68
1D64:  BSF    xE5.7
1D66:  BRA    1E36
1D68:  BCF    xE5.7
1D6A:  BRA    1E36
1D6C:  MOVFF  1DC,1E5
1D70:  BSF    xE5.7
1D72:  MOVFF  1DD,1E4
1D76:  MOVFF  1DE,1E3
1D7A:  BTFSS  xE0.7
1D7C:  BRA    1D86
1D7E:  BCF    xE5.7
1D80:  BSF    xE1.2
1D82:  BRA    1E4E
1D84:  BCF    xE1.2
1D86:  CLRF   xE2
1D88:  BCF    xDF.0
1D8A:  MOVLW  01
1D8C:  MOVWF  FEA
1D8E:  MOVLW  DA
1D90:  MOVWF  FE9
1D92:  BRA    1E74
1D94:  BTFSC  xE0.7
1D96:  BRA    1DD0
1D98:  MOVFF  1D8,1E0
1D9C:  BTFSS  xDF.0
1D9E:  BRA    1DAC
1DA0:  RRCF   xE5,F
1DA2:  RRCF   xE4,F
1DA4:  RRCF   xE3,F
1DA6:  RRCF   xE2,F
1DA8:  INCF   00,F
1DAA:  BZ    1E44
1DAC:  BTFSS  xE2.7
1DAE:  BRA    1DC6
1DB0:  INCF   xE3,F
1DB2:  BNZ   1DC6
1DB4:  INCF   xE4,F
1DB6:  BNZ   1DC6
1DB8:  INCF   xE5,F
1DBA:  BNZ   1DC6
1DBC:  RRCF   xE5,F
1DBE:  RRCF   xE4,F
1DC0:  RRCF   xE3,F
1DC2:  INCF   00,F
1DC4:  BZ    1E44
1DC6:  BTFSC  xE1.6
1DC8:  BRA    1CD2
1DCA:  BTFSC  xE1.7
1DCC:  BRA    1D5A
1DCE:  BRA    1E08
1DD0:  MOVLW  80
1DD2:  XORWF  xE5,F
1DD4:  BTFSS  xE5.7
1DD6:  BRA    1DE0
1DD8:  BRA    1E4E
1DDA:  MOVFF  1DC,1E0
1DDE:  BRA    1DF4
1DE0:  MOVFF  1D8,1E0
1DE4:  MOVF   xE5,F
1DE6:  BNZ   1DF4
1DE8:  MOVF   xE4,F
1DEA:  BNZ   1DF4
1DEC:  MOVF   xE3,F
1DEE:  BNZ   1DF4
1DF0:  CLRF   00
1DF2:  BRA    1E36
1DF4:  BTFSC  xE5.7
1DF6:  BRA    1E08
1DF8:  BCF    FD8.0
1DFA:  RLCF   xE2,F
1DFC:  RLCF   xE3,F
1DFE:  RLCF   xE4,F
1E00:  RLCF   xE5,F
1E02:  DECFSZ 00,F
1E04:  BRA    1DF4
1E06:  BRA    1E44
1E08:  BTFSS  xE0.7
1E0A:  BRA    1E10
1E0C:  BSF    xE5.7
1E0E:  BRA    1E36
1E10:  BCF    xE5.7
1E12:  BRA    1E36
1E14:  MOVFF  1DB,00
1E18:  MOVFF  1DC,1E5
1E1C:  MOVFF  1DD,1E4
1E20:  MOVFF  1DE,1E3
1E24:  BRA    1E36
1E26:  MOVFF  1D7,00
1E2A:  MOVFF  1D8,1E5
1E2E:  MOVFF  1D9,1E4
1E32:  MOVFF  1DA,1E3
1E36:  MOVFF  1E5,01
1E3A:  MOVFF  1E4,02
1E3E:  MOVFF  1E3,03
1E42:  BRA    1EAC
1E44:  CLRF   00
1E46:  CLRF   01
1E48:  CLRF   02
1E4A:  CLRF   03
1E4C:  BRA    1EAC
1E4E:  CLRF   xE2
1E50:  COMF   xE3,F
1E52:  COMF   xE4,F
1E54:  COMF   xE5,F
1E56:  COMF   xE2,F
1E58:  INCF   xE2,F
1E5A:  BNZ   1E66
1E5C:  INCF   xE3,F
1E5E:  BNZ   1E66
1E60:  INCF   xE4,F
1E62:  BNZ   1E66
1E64:  INCF   xE5,F
1E66:  BTFSC  xE1.0
1E68:  BRA    1C8E
1E6A:  BTFSC  xE1.1
1E6C:  BRA    1D16
1E6E:  BTFSC  xE1.2
1E70:  BRA    1D84
1E72:  BRA    1DDA
1E74:  MOVF   FEF,W
1E76:  ADDWF  xE3,F
1E78:  BNC   1E84
1E7A:  INCF   xE4,F
1E7C:  BNZ   1E84
1E7E:  INCF   xE5,F
1E80:  BTFSC  FD8.2
1E82:  BSF    xDF.0
1E84:  MOVF   FED,F
1E86:  MOVF   FEF,W
1E88:  ADDWF  xE4,F
1E8A:  BNC   1E92
1E8C:  INCF   xE5,F
1E8E:  BTFSC  FD8.2
1E90:  BSF    xDF.0
1E92:  MOVF   FED,F
1E94:  MOVF   FEF,W
1E96:  BTFSC  FEF.7
1E98:  BRA    1E9C
1E9A:  XORLW  80
1E9C:  ADDWF  xE5,F
1E9E:  BTFSC  FD8.0
1EA0:  BSF    xDF.0
1EA2:  BTFSC  xE1.4
1EA4:  BRA    1C9E
1EA6:  BTFSC  xE1.5
1EA8:  BRA    1D26
1EAA:  BRA    1D94
1EAC:  MOVLB  0
1EAE:  RETURN 0
1EB0:  MOVLW  8E
1EB2:  MOVWF  00
1EB4:  MOVLB  1
1EB6:  MOVF   xB6,W
1EB8:  SUBWF  00,F
1EBA:  MOVFF  1B7,02
1EBE:  MOVFF  1B8,01
1EC2:  BSF    02.7
1EC4:  MOVF   00,F
1EC6:  BZ    1EDA
1EC8:  BCF    FD8.0
1ECA:  MOVF   02,F
1ECC:  BNZ   1ED2
1ECE:  MOVF   01,F
1ED0:  BZ    1EDA
1ED2:  RRCF   02,F
1ED4:  RRCF   01,F
1ED6:  DECFSZ 00,F
1ED8:  BRA    1EC8
1EDA:  BTFSS  xB7.7
1EDC:  BRA    1EE8
1EDE:  COMF   01,F
1EE0:  COMF   02,F
1EE2:  INCF   01,F
1EE4:  BTFSC  FD8.2
1EE6:  INCF   02,F
1EE8:  MOVLB  0
1EEA:  RETURN 0
*
24BA:  MOVFF  1D8,1DF
24BE:  MOVLB  1
24C0:  MOVF   xDC,W
24C2:  XORWF  xDF,F
24C4:  BTFSS  xDF.7
24C6:  BRA    24D2
24C8:  BCF    FD8.2
24CA:  BCF    FD8.0
24CC:  BTFSC  xD8.7
24CE:  BSF    FD8.0
24D0:  BRA    2530
24D2:  MOVFF  1D8,1DF
24D6:  MOVFF  1DB,1E0
24DA:  MOVF   xD7,W
24DC:  SUBWF  xE0,F
24DE:  BZ    24EC
24E0:  BTFSS  xDF.7
24E2:  BRA    2530
24E4:  MOVF   FD8,W
24E6:  XORLW  01
24E8:  MOVWF  FD8
24EA:  BRA    2530
24EC:  MOVFF  1DC,1E0
24F0:  MOVF   xD8,W
24F2:  SUBWF  xE0,F
24F4:  BZ    2502
24F6:  BTFSS  xDF.7
24F8:  BRA    2530
24FA:  MOVF   FD8,W
24FC:  XORLW  01
24FE:  MOVWF  FD8
2500:  BRA    2530
2502:  MOVFF  1DD,1E0
2506:  MOVF   xD9,W
2508:  SUBWF  xE0,F
250A:  BZ    2518
250C:  BTFSS  xDF.7
250E:  BRA    2530
2510:  MOVF   FD8,W
2512:  XORLW  01
2514:  MOVWF  FD8
2516:  BRA    2530
2518:  MOVFF  1DE,1E0
251C:  MOVF   xDA,W
251E:  SUBWF  xE0,F
2520:  BZ    252E
2522:  BTFSS  xDF.7
2524:  BRA    2530
2526:  MOVF   FD8,W
2528:  XORLW  01
252A:  MOVWF  FD8
252C:  BRA    2530
252E:  BCF    FD8.0
2530:  MOVLB  0
2532:  RETURN 0
*
2566:  MOVLW  8E
2568:  MOVWF  00
256A:  MOVFF  1D6,01
256E:  MOVFF  1D5,02
2572:  CLRF   03
2574:  MOVF   01,F
2576:  BNZ   258A
2578:  MOVFF  02,01
257C:  CLRF   02
257E:  MOVLW  08
2580:  SUBWF  00,F
2582:  MOVF   01,F
2584:  BNZ   258A
2586:  CLRF   00
2588:  BRA    259A
258A:  BCF    FD8.0
258C:  BTFSC  01.7
258E:  BRA    2598
2590:  RLCF   02,F
2592:  RLCF   01,F
2594:  DECF   00,F
2596:  BRA    258A
2598:  BCF    01.7
259A:  RETURN 0
259C:  MOVLB  1
259E:  MOVF   xD9,W
25A0:  BTFSC  FD8.2
25A2:  BRA    2686
25A4:  MOVWF  00
25A6:  MOVF   xDD,W
25A8:  BTFSC  FD8.2
25AA:  BRA    2686
25AC:  ADDWF  00,F
25AE:  BNC   25B8
25B0:  MOVLW  81
25B2:  ADDWF  00,F
25B4:  BC    2686
25B6:  BRA    25C0
25B8:  MOVLW  7F
25BA:  SUBWF  00,F
25BC:  BNC   2686
25BE:  BZ    2686
25C0:  MOVFF  1DA,1E1
25C4:  MOVF   xDE,W
25C6:  XORWF  xE1,F
25C8:  BSF    xDA.7
25CA:  BSF    xDE.7
25CC:  MOVF   xDC,W
25CE:  MULWF  xE0
25D0:  MOVFF  FF4,1E3
25D4:  MOVF   xDB,W
25D6:  MULWF  xDF
25D8:  MOVFF  FF4,03
25DC:  MOVFF  FF3,1E2
25E0:  MULWF  xE0
25E2:  MOVF   FF3,W
25E4:  ADDWF  xE3,F
25E6:  MOVF   FF4,W
25E8:  ADDWFC xE2,F
25EA:  MOVLW  00
25EC:  ADDWFC 03,F
25EE:  MOVF   xDC,W
25F0:  MULWF  xDF
25F2:  MOVF   FF3,W
25F4:  ADDWF  xE3,F
25F6:  MOVF   FF4,W
25F8:  ADDWFC xE2,F
25FA:  MOVLW  00
25FC:  CLRF   02
25FE:  ADDWFC 03,F
2600:  ADDWFC 02,F
2602:  MOVF   xDA,W
2604:  MULWF  xE0
2606:  MOVF   FF3,W
2608:  ADDWF  xE2,F
260A:  MOVF   FF4,W
260C:  ADDWFC 03,F
260E:  MOVLW  00
2610:  ADDWFC 02,F
2612:  MOVF   xDA,W
2614:  MULWF  xDF
2616:  MOVF   FF3,W
2618:  ADDWF  03,F
261A:  MOVF   FF4,W
261C:  ADDWFC 02,F
261E:  MOVLW  00
2620:  CLRF   01
2622:  ADDWFC 01,F
2624:  MOVF   xDC,W
2626:  MULWF  xDE
2628:  MOVF   FF3,W
262A:  ADDWF  xE2,F
262C:  MOVF   FF4,W
262E:  ADDWFC 03,F
2630:  MOVLW  00
2632:  ADDWFC 02,F
2634:  ADDWFC 01,F
2636:  MOVF   xDB,W
2638:  MULWF  xDE
263A:  MOVF   FF3,W
263C:  ADDWF  03,F
263E:  MOVF   FF4,W
2640:  ADDWFC 02,F
2642:  MOVLW  00
2644:  ADDWFC 01,F
2646:  MOVF   xDA,W
2648:  MULWF  xDE
264A:  MOVF   FF3,W
264C:  ADDWF  02,F
264E:  MOVF   FF4,W
2650:  ADDWFC 01,F
2652:  INCF   00,F
2654:  BTFSC  01.7
2656:  BRA    2662
2658:  RLCF   xE2,F
265A:  RLCF   03,F
265C:  RLCF   02,F
265E:  RLCF   01,F
2660:  DECF   00,F
2662:  MOVLW  00
2664:  BTFSS  xE2.7
2666:  BRA    267C
2668:  INCF   03,F
266A:  ADDWFC 02,F
266C:  ADDWFC 01,F
266E:  MOVF   01,W
2670:  BNZ   267C
2672:  MOVF   02,W
2674:  BNZ   267C
2676:  MOVF   03,W
2678:  BNZ   267C
267A:  INCF   00,F
267C:  BTFSC  xE1.7
267E:  BSF    01.7
2680:  BTFSS  xE1.7
2682:  BCF    01.7
2684:  BRA    268E
2686:  CLRF   00
2688:  CLRF   01
268A:  CLRF   02
268C:  CLRF   03
268E:  MOVLB  0
2690:  GOTO   2754 (RETURN)
*
2828:  MOVLB  1
282A:  MOVF   xB2,W
282C:  CLRF   01
282E:  SUBWF  xB1,W
2830:  BC    2838
2832:  MOVFF  1B1,00
2836:  BRA    2850
2838:  CLRF   00
283A:  MOVLW  08
283C:  MOVWF  xB3
283E:  RLCF   xB1,F
2840:  RLCF   00,F
2842:  MOVF   xB2,W
2844:  SUBWF  00,W
2846:  BTFSC  FD8.0
2848:  MOVWF  00
284A:  RLCF   01,F
284C:  DECFSZ xB3,F
284E:  BRA    283E
2850:  MOVLB  0
2852:  RETURN 0
2854:  MOVFF  C6,FEA
2858:  MOVFF  C5,FE9
285C:  MOVFF  1B1,FEF
2860:  INCF   FE9,F
2862:  BTFSC  FD8.2
2864:  INCF   FEA,F
2866:  CLRF   FEF
2868:  MOVLB  0
286A:  INCF   xC5,F
286C:  BTFSC  FD8.2
286E:  INCF   xC6,F
2870:  RETURN 0
2872:  MOVLW  20
2874:  MOVLB  1
2876:  BTFSS  xAC.4
2878:  MOVLW  30
287A:  MOVWF  xAD
287C:  MOVFF  1AB,00
2880:  BTFSS  00.7
2882:  BRA    2894
2884:  COMF   00,F
2886:  INCF   00,F
2888:  MOVFF  00,1AB
288C:  MOVLW  2D
288E:  MOVWF  xAD
2890:  BSF    xAC.7
2892:  BSF    xAC.0
2894:  MOVF   01,W
2896:  MOVFF  1AB,1B1
289A:  MOVLW  64
289C:  MOVWF  xB2
289E:  MOVLB  0
28A0:  RCALL  2828
28A2:  MOVFF  00,1AB
28A6:  MOVLW  30
28A8:  ADDWF  01,W
28AA:  MOVLB  1
28AC:  MOVWF  xAE
28AE:  MOVFF  1AB,1B1
28B2:  MOVLW  0A
28B4:  MOVWF  xB2
28B6:  MOVLB  0
28B8:  RCALL  2828
28BA:  MOVLW  30
28BC:  ADDWF  00,W
28BE:  MOVLB  1
28C0:  MOVWF  xB0
28C2:  MOVLW  30
28C4:  ADDWF  01,W
28C6:  MOVWF  xAF
28C8:  MOVFF  1AD,00
28CC:  MOVLW  30
28CE:  SUBWF  xAE,W
28D0:  BZ    28DA
28D2:  BSF    xAC.1
28D4:  BTFSC  xAC.7
28D6:  BSF    xAC.2
28D8:  BRA    28FE
28DA:  MOVFF  1AD,1AE
28DE:  MOVLW  20
28E0:  MOVWF  xAD
28E2:  MOVLW  30
28E4:  SUBWF  xAF,W
28E6:  BZ    28F0
28E8:  BSF    xAC.0
28EA:  BTFSC  xAC.7
28EC:  BSF    xAC.1
28EE:  BRA    28FE
28F0:  BTFSS  FD8.2
28F2:  BSF    xAC.0
28F4:  BNZ   28FE
28F6:  MOVFF  1AE,1AF
28FA:  MOVLW  20
28FC:  MOVWF  xAE
28FE:  BTFSC  xAC.2
2900:  BRA    290C
2902:  BTFSC  xAC.1
2904:  BRA    2914
2906:  BTFSC  xAC.0
2908:  BRA    291C
290A:  BRA    2924
290C:  MOVFF  1AD,1B1
2910:  MOVLB  0
2912:  RCALL  2854
2914:  MOVFF  1AE,1B1
2918:  MOVLB  0
291A:  RCALL  2854
291C:  MOVFF  1AF,1B1
2920:  MOVLB  0
2922:  RCALL  2854
2924:  MOVFF  1B0,1B1
2928:  MOVLB  0
292A:  RCALL  2854
292C:  GOTO   31F6 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #fuses HSPLL, NOWDT, NOPROTECT, NODEBUG, USBDIV, PLL4, CPUDIV1, VREGEN
.................... 
.................... #use delay(clock=48MHz,crystal=16MHz,USB_FULL)
*
155A:  MOVLW  02
155C:  MOVWF  FEA
155E:  MOVLW  11
1560:  MOVWF  FE9
1562:  MOVF   FEF,W
1564:  BZ    1582
1566:  MOVLW  0F
1568:  MOVWF  01
156A:  CLRF   00
156C:  DECFSZ 00,F
156E:  BRA    156C
1570:  DECFSZ 01,F
1572:  BRA    156A
1574:  MOVLW  8F
1576:  MOVWF  00
1578:  DECFSZ 00,F
157A:  BRA    1578
157C:  NOP   
157E:  DECFSZ FEF,F
1580:  BRA    1566
1582:  RETURN 0
*
1608:  MOVLW  01
160A:  MOVLB  2
160C:  SUBWF  x1B,F
160E:  BNC   162A
1610:  MOVLW  02
1612:  MOVWF  FEA
1614:  MOVLW  1B
1616:  MOVWF  FE9
1618:  MOVF   FEF,W
161A:  BZ    162A
161C:  MOVLW  02
161E:  MOVWF  00
1620:  DECFSZ 00,F
1622:  BRA    1620
1624:  BRA    1626
1626:  DECFSZ FEF,F
1628:  BRA    161C
162A:  MOVLB  0
162C:  GOTO   1666 (RETURN)
.................... #use FIXED_IO( E_outputs=PIN_E0 )
.................... #define RF_RESET   PIN_E0
.................... 
.................... 
.................... #define USB_CABLE_IS_ATTACHED()  input(PIN_B2)
.................... #define USB_CONFIG_VID 0x2405
.................... #define USB_CONFIG_PID 0x000B
.................... #define USB_CONFIG_BUS_POWER 500
.................... 
.................... // if USB_CDC_ISR is defined, then this function will be called
.................... // by the USB ISR when there incoming CDC (virtual com port) data.
.................... // this is useful if you want to port old RS232 code that was use
.................... // #int_rda to CDC.
.................... #define USB_CDC_ISR() RDA_isr()
.................... 
.................... // in order for handle_incoming_usb() to be able to transmit the entire
.................... // USB message in one pass, we need to increase the CDC buffer size from
.................... // the normal size and use the USB_CDC_DELAYED_FLUSH option.
.................... // failure to do this would cause some loss of data.
.................... #define USB_CDC_DELAYED_FLUSH
.................... #define USB_CDC_DATA_LOCAL_SIZE  128
.................... 
.................... 
.................... static void RDA_isr(void);
.................... 
.................... #include <usb_cdc.h>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////                            usb_cdc.h                            ////
.................... ////                                                                 ////
.................... //// Library for adding a virtual COM port on your PC over USB using ////
.................... //// the standard Communication Device Class (CDC) specification.    ////
.................... //// Including this file in your code will add all USB code,         ////
.................... //// interrupts, descriptors and handlers required.  No other        ////
.................... //// modifications need to be made.                                  ////
.................... ////                                                                 ////
.................... //// This library creates a virtual RS232 link between the PC and    ////
.................... //// the PIC, therefore the library provided will be familiar to     ////
.................... //// anyone with standard UART stream I/O:                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          ////
.................... ////      character received and waiting in the receive buffer.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  ////
.................... ////      there is no data in the receive buffer it will wait until  ////
.................... ////      there is data in the receive buffer.  If you do not want   ////
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   ////
.................... ////      check if there is data before calling usb_cdc_getc().      ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       ////
.................... ////      buffer.  If the transmit buffer is full it will wait until ////
.................... ////      the transmit buffer is not full before putting the char    ////
.................... ////      into the transmit buffer.  The transmit buffer is read by  ////
.................... ////      the PC very quickly, and therefore the buffer should only  ////
.................... ////      be full for a few milli-seconds.  If you are concerned     ////
.................... ////      and don't want to be stuck in a long or infinite loop,     ////
.................... ////      use usb_cdc_putready() to see if there is space in the     ////
.................... ////      transmit buffer before putting data into the transmit      ////
.................... ////      buffer.                                                    ////
.................... ////                                                                 ////
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    ////
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'ptr' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    ////
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'len' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putready() - Returns the number of bytes available      ////
.................... ////     in the TX buffer for storing characters.  If this returns   ////
.................... ////     0 then the buffer is full and waiting for the host (PC)     ////
.................... ////     to read the buffer.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   ////
.................... ////     empty and fully flushed/transmitted to host (PC).           ////
.................... ////                                                                 ////
.................... //// usb_cdc_connected() - Returns TRUE if we received a             ////
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   ////
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        ////
.................... ////      message when the program starts and it opens the virtual   ////
.................... ////      COM port.  This is a simple way to determine if the PC     ////
.................... ////      is ready to display data on a serial terminal program,     ////
.................... ////      but is not garaunteed to work all the time or on other     ////
.................... ////      terminal programs.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   ////
.................... ////      if the transmit buffer is full it will skip the char.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  ////
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   ////
.................... ////                                                                 ////
.................... //// usb_cdc_break - If the PC has sent a break command, this will   ////
.................... ////       hold the break time (in milli-seconds).  If the PC sends  ////
.................... ////       a value of 0xFFFF the device is supposed to hold the      ////
.................... ////       break until it sends a value of 0                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. ////
.................... ////       Of most relevance is the field dte_present, which is the  ////
.................... ////       DTR setting.                                              ////
.................... ////                                                                 ////
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          ////
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   ////
.................... ////       ring, break and more.  See the documentation above        ////
.................... ////       usb_cdc_serial_state() for more information, including    ////
.................... ////       format of state structure.                                ////
.................... ////                                                                 ////
.................... //// The following functions are also provided, and are ports of the ////
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   ////
.................... //// documentation:                                                  ////
.................... ////   get_float_usb() - Read a float number from the user           ////
.................... ////   get_long_usb() - Read a long number from the user             ////
.................... ////   get_int_usb() - Read an integer number from the user          ////
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. ////
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             ////
.................... ////   gethex1_usb() - Read a HEX character                          ////
.................... ////                                                                 ////
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  ////
.................... //// be called when there is incoming CDC (virtual com port) data.   ////
.................... //// This is useful if you want to update legacy RS232 code that     ////
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    ////
.................... //// However, see the INTERRUPT LIMITATIONS section below.           ////
.................... ////                                                                 ////
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    ////
.................... ////  to flush the data as soon as possible.  However at times       ////
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   ////
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         ////
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     ////
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       ////
.................... ////  also attempt to flush the packet on each call to usb_task().   ////
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     ////
.................... ////  if you have a main loop that periodically calls usb_task().    ////
.................... ////                                                                 ////
.................... //// This driver will load all the rest of the USB code, and a set   ////
.................... //// of descriptors that will properly describe a CDC device for a   ////
.................... //// virtual COM port (usb_desc_cdc.h)                               ////
.................... ////                                                                 ////
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      ////
.................... //// standard CDC drivers for a virtual COM port in Windows          ////
.................... //// NT/2000/XP and above.                                           ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// Encapsuated Messages: (USB_CDC_USE_ENCAPSULATED)                ////
.................... //// -------------------------------------------------------------   ////
.................... ////                                                                 ////
.................... //// If USB_CDC_USE_ENCAPSULATED is defined, then the user must      ////
.................... //// provide the following callbacks in their application to provide ////
.................... //// encapsuated message support (SendEncapsulatedCommand and        ////
.................... ////  GetEncapsulatedResponse):                                      ////
.................... ////                                                                 ////
.................... //// usb_cdc_SendEncapsulatedCommand(byte *ptr, unsigned int16 num)  ////
.................... ////     PIC receives encapsulated command from host (PC), 'num'     ////
.................... ////     bytes of message stored in 'ptr'.                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_GetEncapsulatedResponse(byte *ptr, unsigned int16 num)  ////
.................... ////     Host (PC) is asking for 'num' bytes response from the PIC,  ////
.................... ////     PIC should store up to 'num' bytes to 'ptr' as the          ////
.................... ////     response.                                                   ////
.................... ////                                                                 ////
.................... //// Due to the design of the USB stack, all encapsulated messages   ////
.................... //// must be smaller than one endpoint 0 packet.  They cannot be     ////
.................... //// equal in size or larger than the endpoint 0 size.  See          ////
.................... //// USB_MAX_EP0_PACKET_LENGTH.                                      ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// BUFFER SIZES                                                    ////
.................... //// -------------------------------------------------------------   ////
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     ////
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        ////
.................... ////  Full speed devices limit this value to be 64.  To increase     ////
.................... ////  the size of the local PIC buffer you can also define           ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        ////
.................... ////  defined then the total PIC->PC buffer size would be            ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  ////
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      ////
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      ////
.................... ////  then this option isn't used.                                   ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// INTERRUPT LIMITATIONS                                           ////
.................... //// -------------------------------------------------------------   ////
.................... //// This section is only relevant if you are using USB interrupts   ////
.................... ////  and not the USB_ISR_POLLING option.                            ////
.................... ////                                                                 ////
.................... //// USB handling is complex, often requiring several packet         ////
.................... ////  transmissions to accomplish transfer of one block of data.     ////
.................... ////  Most of this processing is done in the USB ISR.  Because       ////
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the ////
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   ////
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  ////
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  ////
.................... ////  overflow the TX buffer than data will be lost.                 ////
.................... ////                                                                 ////
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB ////
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      ////
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           ////
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    ////
.................... ////                                                                 ////
.................... //// ex_usb_serial3.c shows an example of working around these       ////
.................... ////  ISR limitations.  Failure to follow these limitations can      ////
.................... ////  cause the PIC to lockup.  These limtations only need to be     ////
.................... ////  followed in the conditions listed above (writing code in the   ////
.................... ////  ISR or interrupts are disabled).                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// VERSION HISTORY                                                 ////
.................... ////                                                                 ////
.................... //// Nov 20th, 2014:                                                 ////
.................... ////  While usb_cdc_putc() waits for local buffer to be free, also   ////
.................... ////     check the endpoint buffer in case there was a situation     ////
.................... ////     that the ISR for this event was missed.                     ////
.................... ////                                                                 ////
.................... //// Dec 16th, 2013:                                                 ////
.................... ////  Added encapsulated message support.  See                       ////
.................... ////     USB_CDC_USE_ENCAPSULATED above for documentation.           ////
.................... ////                                                                 ////
.................... //// May 31st, 2013:                                                 ////
.................... ////  usb_cdc_putready() now returns the number of bytes available.  ////
.................... ////                                                                 ////
.................... //// May 23rd, 2013:                                                 ////
.................... ////  Added usb_cdc_putd().                                          ////
.................... ////                                                                 ////
.................... //// February 18th, 2013:                                            ////
.................... ////  Enhanced PIC16 support added.                                  ////
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 ////
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    ////
.................... ////                                                                 ////
.................... //// September 13th, 2012:                                           ////
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     ////
.................... ////     (PIC24, dsPIC33).                                           ////
.................... ////  Added usb_cdc_putempty().                                      ////
.................... ////                                                                 ////
.................... //// December 16th, 2011:                                            ////
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will ////
.................... ////     only include the get string helper functions.  This is      ////
.................... ////     a rarely used option, used only if you already wrote your   ////
.................... ////     own getc() and putc() routines.                             ////
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  ////
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      ////
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  ////
.................... ////                                                                 ////
.................... //// Oct 27th, 2011:                                                 ////
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    ////
.................... ////     documentation.  In order for this to work,                  ////
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   ////
.................... ////                                                                 ////
.................... //// Jan 28, 2010:                                                   ////
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    ////
.................... ////     one packet.                                                 ////
.................... ////                                                                 ////
.................... //// Jan 25, 2010:                                                   ////
.................... ////  Ignore incoming 0 length packets.                              ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// April 7th, 2009:                                                ////
.................... ////   Vista 'code 10' issues resolved.                              ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 26th, 2007:                                                 ////
.................... ////              usb_cdc_put_buffer_free() should be more stable.   ////
.................... ////              Fixed a hang-up that would happen if you sent      ////
.................... ////                 exactly 64 bytes.                               ////
.................... ////                                                                 ////
.................... //// Nov 6th, 2007:                                                  ////
.................... ////              Compatabible with latest pic18_usb.h, which        ////
.................... ////                 reduces RAM footprint of USB driver.            ////
.................... ////              This driver now fits on 18F4450/2450 PICs.         ////
.................... ////                                                                 ////
.................... //// October 27th, 2005: Changed the way incoming packets are        ////
.................... ////               handled in that CDC driver will not flush         ////
.................... ////               endpoint until user has handled all data.  This   ////
.................... ////               will prevent overflows as the USB will NAK        ////
.................... ////               incoming packets until it is ready to receive     ////
.................... ////               more.                                             ////
.................... ////            When using 18F4550 family, the RX buffer is          ////
.................... ////               mapped directly to the endpoint buffer - this     ////
.................... ////               saves a chunk of RAM.                             ////
.................... ////            When using the 18F4550 family, you can increase      ////
.................... ////               the TX and RX size over 64 bytes.                 ////
.................... ////            No longer send 0len packets in the TBE interrupt.    ////
.................... ////            Hopefully fixed bugs that caused random crashes      ////
.................... ////               if you tried sending more than 64 bytes.          ////
.................... ////                                                                 ////
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   ////
.................... ////                   buffer.                                       ////
.................... ////                                                                 ////
.................... //// July 1st, 2005: Initial Release.                                ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... //input.c ported to use CDC:
.................... float get_float_usb();
.................... signed long get_long_usb();
.................... signed int get_int_usb();
.................... void get_string_usb(char* s, unsigned int max);
.................... char gethex_usb();
.................... char gethex1_usb();
.................... 
.................... #if !defined(__USB_CDC_HELPERS_ONLY__)
.................... 
.................... //api for the user:
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got)
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free())
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin)
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding)
.................... void usb_cdc_putc_fast(char c);
.................... char usb_cdc_getc(void);
.................... void usb_cdc_putc(char c);
.................... void usb_cdc_get_discard(void);
.................... 
.................... //functions automatically called by USB handler code
.................... void usb_isr_tkn_cdc(void);
.................... void usb_cdc_init(void);
.................... void usb_isr_tok_out_cdc_control_dne(void);
.................... void usb_isr_tok_in_cdc_data_dne(void);
.................... void usb_isr_tok_out_cdc_data_dne(void);
.................... 
.................... void usb_cdc_flush_tx_buffer(void);
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //
.................... // Include the CCS USB Libraries.  See the comments at the top of these
.................... // files for more information
.................... //
.................... /////////////////////////////////////////////////////////////////////////////
.................... #ifndef __USB_PIC_PERIF__
.................... #define __USB_PIC_PERIF__   1
.................... #endif
.................... 
.................... #if __USB_PIC_PERIF__
....................    #if defined(__PCM__)
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c
....................    #elif defined(__PCH__)
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.h                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  This hardware layer      ////
.................... //// supports the USB peripheral on the PIC18 family chips.  Current ////
.................... //// supported families are:                                         ////
.................... ////     PIC18F2455/2550/4455/4550                                   ////
.................... ////     PIC18F2450/4450                                             ////
.................... ////     PIC18F2458/2553/4458/4553                                   ////
.................... ////     PIC18F13K50/14K50                                           ////
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     ////
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       ////
.................... ////     PIC18FxxK50                                                 ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      ////
.................... //// that are specific to only this HW peripheral that you may       ////
.................... //// find useful to use in your application.                         ////
.................... ////                                                                 ////
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    ////
.................... ////  Due to the limited USB RAM of this family, a limitation of     ////
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   ////
.................... ////  The HW actually supports more endpoints, but to simplify       ////
.................... ////  driver development this driver will only support the first 3   ////
.................... ////  so there is an easier memory block to work with.               ////
.................... ////                                                                 ////
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     ////
.................... ////  of USB speed, to save RAM.                                     ////
.................... ////                                                                 ////
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    ////
.................... ////  If you are not using internal pullups, you will need to put    ////
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    ////
.................... ////  want to use slow speed or full speed.  This code configures    ////
.................... ////  the device to use internal pullups, see usb_init() if you      ////
.................... ////  want to change that.                                           ////
.................... ////                                                                 ////
.................... ////  You need approximately 470nF cap on Vusb, even if you are      ////
.................... ////  using the internal 3.3V USB regulator.                         ////
.................... ////                                                                 ////
.................... ////  To run at full speed, you must use the oscillator              ////
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   ////
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     ////
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      ////
.................... ////  96MHz clock.  See the datasheet for details.                   ////
.................... ////                                                                 ////
.................... ////  To run at slow speed you must configure your MCU to run at     ////
.................... ////  24Mhz.  See the datasheet for details.                         ////
.................... ////                                                                 ////
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   ////
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the ////
.................... //// PIC when an event has happened on the USB Bus.  Therfore        ////
.................... //// this code enables interrupts.  A user modification can be made  ////
.................... //// to poll the USB interrupt flag instead of relying on an         ////
.................... //// interrupt.                                                      ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_H__
.................... #DEFINE __PIC18_USB_H__
.................... 
.................... #DEFINE __USB_HARDWARE__
.................... 
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral
.................... #DEFINE __PIC__   1
.................... 
.................... #ifndef USB_USE_FULL_SPEED
....................  #define USB_USE_FULL_SPEED   1
.................... #endif
.................... 
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................    //due to limited ram, force max packet length to 8 for this chip
....................    #define USB_MAX_EP0_PACKET_LENGTH   8
.................... #else
....................    #if USB_USE_FULL_SPEED==0
....................       //slow speed requires 8byte max packet size for endpoint 0
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8
....................    #else
....................       //for full speed you can still use 8bytes, but 64 will be faster
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64
....................    #endif
.................... #endif
.................... #endif
.................... 
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8))
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8
....................  #error Max Endpoint 0 length can't be less than 8!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64
....................  #error Max Endpoint 0 length can't be greater than 64!
.................... #endif
.................... 
.................... #include <usb_hw_layer.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_hw_layer.h                            ////
.................... ////                                                                   ////
.................... //// HW Layer for the USB Stack.                                       ////
.................... ////                                                                   ////
.................... //// HW drivers for the USB stack must support this API.               ////
.................... ////                                                                   ////
.................... //// The HW driver must also have a token handler that will call       ////
.................... //// usb_token_reset() when the device is init/reset, will call        ////
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          ////
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    ////
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     ////
.................... //// See usb.h for documentation of these functions.                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __USB_HW_LAYER_H__
.................... #define __USB_HW_LAYER_H__
.................... 
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0,
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4};
.................... 
.................... 
.................... // USER LEVEL FUNCTIONS:
.................... 
.................... /*****************************************************************************
.................... /* usb_init()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_init_cs()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_cs(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_task()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_task(void);
.................... 
.................... /******************************************************************************
.................... /* usb_attach()
.................... /*
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral.
.................... /*
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt.
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_attach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_detach()
.................... /*
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB.
.................... /*
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* If the user does call this function while USB is connected, the USB 
.................... /* peripheral will be disabled only momentarily because usb_task() will
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB
.................... /* reset of the device.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_detach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_put_packet()
.................... /*
.................... /* Input: endpoint - endpoint to send packet to (0..15).
.................... /*        ptr - points to data to send.
.................... /*        len - amount of data to send.
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, 
.................... /*                 or toggle from the last DATAx pid.
.................... /*
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only 
.................... /*         reason it will return FALSE is if because the TX buffer is still full 
.................... /*         from the last time it tried to send a packet.
.................... /*
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a 
.................... /*          difference between a packet and a message.  If you wanted to send a 
.................... /*          512 byte message on an endpoint that only supported 64 byte packets,
.................... /*          this would be accomplished this by sending 8 64-byte packets, 
.................... /*          followed by a 0 length packet.  If the last (or only packet) being 
.................... /*          sent is less than the max packet size defined in your descriptor 
.................... /*          then you do not need to send a 0 length packet to identify
.................... /*          an end of message.
.................... /*
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message 
.................... /*          correctly and know if a 0 lenght packet needs to be sent.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl);
.................... 
.................... /*******************************************************************************
.................... /* usb_get_packet(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer and saved to ptr.
.................... /*
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS!
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()!
.................... /*
.................... /* Summary: Gets a packet of data from the USB endpoint buffer.
.................... /*          Until this is called, if there is data in the receive buffer the
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be
.................... /*          allowed to send a new packet.  Only receives one packet, if you need 
.................... /*          to receive multiple packets or handle 0-length terminator packets,
.................... /*          then use usb_gets().
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /********************************************************************************/
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max);
.................... 
.................... /****************************************************************************
.................... /* usb_kbhit(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check (0..15)
.................... /*
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not.
.................... /*
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers.
.................... /*          See API section of USB.H for more information.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_kbhit(unsigned int8 en);
.................... 
.................... /******************************************************************************
.................... /* usb_tbe(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last
.................... /*         transmit or if this endpoint is invalid.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_tbe(unsigned int8 en);
.................... 
.................... //////////////// END USER LEVEL FUNCTIONS /////////////////////////////////////
.................... 
.................... 
.................... ///
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by
.................... ///            the USB stack, and are not meant to be called by the 
.................... ///            user/application.
.................... ///
.................... 
.................... /*****************************************************************************
.................... /* usb_stall_ep()
.................... /*
.................... /* Input: endpoint - endpoint to stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will
.................... /*          send STALL packet if the host tries to access this endpoint's 
.................... /*          buffer.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_stall_ep(unsigned int8 endpoint);
.................... 
.................... 
.................... /*****************************************************************************
.................... /* usb_unstall_ep(endpoint, direction)
.................... /*
.................... /* Input: endpoint - endpoint to un-stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Un-stalls endpoint.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_unstall_ep(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_endpoint_stalled()
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not.
.................... /*
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to
.................... /*          see if endpoint has been issued a STALL, just whether or not it is
.................... /*          configured to STALL on the next packet.  See Set_Feature and 
.................... /*          Clear_Feature Chapter 9 requests.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_set_address(address)
.................... /*
.................... /* Input: address - address the host specified that we use
.................... /*
.................... /* Summary: Configures the USB Peripheral for the specified device address.  
.................... /*          The host will now talk to use with the following address.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_address(unsigned int8 address);
.................... 
.................... /******************************************************************************
.................... /* usb_set_configured()
.................... /*
.................... /* Input: config - Configuration to use.  0 to uncofigure device.
.................... /*
.................... /* Summary: Configures or unconfigures device.  If configuring device it will
.................... /*          enable all the endpoints the user specified for this configuration.
.................... /*          If un-configuring device it will disable all endpoints.
.................... /*
.................... /*          NOTE: CCS only provides code to handle 1 configuration.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_configured(unsigned int8 config);
.................... 
.................... /******************************************************************************
.................... /* usb_disable_endpoints()
.................... /*
.................... /* Summary: Disables endpoints (all endpoints but 0)
.................... /*
.................... /*****************************************************************************/
.................... void usb_disable_endpoints(void);
.................... 
.................... 
.................... /*******************************************************************************
.................... /* usb_disable_endpoint()
.................... /*
.................... /* Input: Endpoint to disable (0..15)
.................... /*
.................... /* Summary: Disables specified endpoint
.................... /*
.................... /********************************************************************************/
.................... void usb_disable_endpoint(unsigned int8 en);
.................... 
.................... /**************************************************************
.................... /* usb_request_send_response(len)
.................... /* usb_request_get_data()
.................... /* usb_request_stall()
.................... /*
.................... /* Input: len - size of packet to send
.................... /*
.................... /* Summary: One of these 3 functions will be called by the USB stack after
.................... /*          handling a SETUP packet.
.................... /*          
.................... /*          After we process a SETUP request, we have 1 of three responses:
.................... /*            1.) send a response IN packet
.................... /*            2.) wait for followup OUT packet(s) with data
.................... /*            3.) stall because we don't support that SETUP request
.................... /*
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold
.................... /*          the response and the USB Request handler code will call
.................... /*          usb_request_send_response() to let us know how big the packet is.
.................... /*
.................... /*          If we are waiting for more data, usb_request_get_data() will
.................... /*          be called by the USB request handler code to configure the EP0 OUT
.................... /*          endpoint to be ready for more data
.................... /*
.................... /*          If we don't support a request, usb_request_stall() will be called
.................... /*          by the USB request handler code to stall the endpoint 0.
.................... /*
.................... /*          The operation of these functions depends on how SETUP packets
.................... /*          are handled in the hardware layer.
.................... /*
.................... /***************************************************************/
.................... void usb_request_send_response(unsigned int8 len);
.................... void usb_request_get_data(void);
.................... void usb_request_stall(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... //////////////////////// EXTRA USER FUNCTIONS /////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_flush_in()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for transfer
.................... /*        len - length of data that is being tramsferred
.................... /*        tgl - Data toggle synchronization for this packet
.................... /*
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint)
.................... /*
.................... /* Summary: Marks the endpoint ready for transmission.  You must
.................... /*          have already loaded the endpoint buffer with data.
.................... /*          (IN is PIC -> PC).
.................... /*          This routine is useful if you want to setup an endpoint by
.................... /*          writing to the buffer directly.
.................... /*          This routine is not necessary if you use usb_put_packet().
.................... /***************************************************************/
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_flush_out()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for release
.................... /*        tgl - Data toggle synchronization to expect in the next packet
.................... /*
.................... /* Output: NONE
.................... /*
.................... /* Summary: Clears the previously received packet, and then marks this
.................... /*          endpoint's receive buffer as ready for more data.
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not
.................... /*          want to use usb_get_packet(), instead you want to handle with
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size().
.................... /*          This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_rx_packet_size()
.................... /*
.................... /* Input: endpoint - which endpoint to mark to check
.................... /*
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer.
.................... /*
.................... /* Summary: Read the number of data stored in the receive buffer.  When you
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint.
.................... /*    This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... int16 usb_rx_packet_size(int8 endpoint);
.................... 
.................... #ENDIF
.................... 
....................    #else
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
....................    #endif
.................... #else
....................    #include <usbn960x.h>
.................... #endif
.................... #ifndef __USB_DESCRIPTORS__
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_desc_cdc.h                            ////
.................... ////                                                                   ////
.................... //// An example set of device / configuration descriptors for use with ////
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// Oct 27th, 2011:                                                   ////
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     ////
.................... ////     send SERIAL_STATE messages in one packet.                     ////
.................... ////                                                                   ////
.................... //// April 7th, 2009:                                                  ////
.................... ////   Vista 'code 10' issues resolved.                                ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// 10/28/05:                                                         ////
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        ////
.................... ////    packets.                                                       ////
.................... ////    Changed device to USB 1.10                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
.................... #DEFINE __USB_DESCRIPTORS__
.................... 
.................... ///////// config options, although it's best to leave alone for this demo /////
.................... #ifndef  USB_CONFIG_PID
....................    #define  USB_CONFIG_PID       0x000b
.................... #endif
.................... #ifndef  USB_CONFIG_VID
....................    #define  USB_CONFIG_VID       0x2405
.................... #endif
.................... #ifndef  USB_CONFIG_BUS_POWER
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500)
.................... #endif
.................... #ifndef  USB_CONFIG_VERSION
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99
.................... #endif
.................... //////// end config ///////////////////////////////////////////////////////////
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #DEFINE USB_HID_DEVICE  false
.................... #DEFINE USB_CDC_DEVICE  true
.................... 
.................... #define USB_CDC_COMM_IN_ENDPOINT       1
.................... #ifndef USB_CDC_COMM_IN_SIZE
.................... #define USB_CDC_COMM_IN_SIZE           11
.................... #endif
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE
.................... 
.................... //pic to pc endpoint config
.................... #define USB_CDC_DATA_IN_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_IN_SIZE
.................... #define USB_CDC_DATA_IN_SIZE           64
.................... #endif
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE
.................... 
.................... //pc to pic endpoint config
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_OUT_SIZE
.................... #define USB_CDC_DATA_OUT_SIZE           64
.................... #endif
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start config descriptor
.................... ///   right now we only support one configuration descriptor.
.................... ///   the config, interface, class, and endpoint goes into this array.
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints)
.................... 
....................    const char USB_CONFIG_DESC[] = {
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE:
....................       //    config(s)
....................       //    interface(s)
....................       //    class(es)
....................       //    endpoint(s)
.................... 
....................    //config_descriptor for config index 1
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3
....................          2, //number of interfaces this device supports       ==4
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5
....................          0x00, //index of string descriptor for this configuration      ==6
....................         #if USB_CONFIG_BUS_POWER
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #else
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #endif
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8
.................... 
.................... 
....................    //interface descriptor 0 (comm class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11
....................          0x00, //alternate setting     ==12
....................          1, //number of endpoints   ==13
....................          0x02, //class code, 02 = Comm Interface Class     ==14
....................          0x02, //subclass code, 2 = Abstract     ==15
....................          0x01, //protocol code, 1 = v.25ter      ==16
....................          0x00, //index of string descriptor for interface      ==17
.................... 
....................    //class descriptor [functional header]
....................          5, //length of descriptor    ==18
....................          0x24, //dscriptor type (0x24 == )      ==19
....................          0, //sub type (0=functional header) ==20
....................          0x10,0x01, //      ==21,22 //cdc version
.................... 
....................    //class descriptor [acm header]
....................          4, //length of descriptor    ==23
....................          0x24, //dscriptor type (0x24 == )      ==24
....................          2, //sub type (2=ACM)   ==25
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State.
.................... 
....................    //class descriptor [union header]
....................          5, //length of descriptor    ==27
....................          0x24, //dscriptor type (0x24 == )      ==28
....................          6, //sub type (6=union)    ==29
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union.
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. *
.................... 
....................    //class descriptor [call mgmt header]
....................          5, //length of descriptor    ==32
....................          0x24, //dscriptor type (0x24 == )      ==33
....................          1, //sub type (1=call mgmt)   ==34
....................          0, //capabilities          ==35  //device does not handle call management itself
....................          1, //data interface        ==36  //interface number of data class interface
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43
.................... 
....................    //interface descriptor 1 (data class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46
....................          0x00, //alternate setting     ==47
....................          2, //number of endpoints   ==48
....................          0x0A, //class code, 0A = Data Interface Class     ==49
....................          0x00, //subclass code      ==50
....................          0x00, //protocol code      ==51
....................          0x00, //index of string descriptor for interface      ==52
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55
....................          0x02, //transfer type supported (0x02 is bulk)         ==56
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58
....................          1,  //polling interval, in ms.   ==59
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62
....................          0x02, //transfer type supported (0x02 is bulk)         ==63
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67
....................          1  //polling interval, in ms.   ==68
....................    };
.................... 
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ********
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find
....................    //  a specific descriptor in the above table.
.................... 
....................    //the maximum number of interfaces seen on any config
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2
....................    #define USB_MAX_NUM_INTERFACES   2
.................... 
....................    //define how many interfaces there are per config.  [0] is the first config, etc.
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2};
.................... 
....................    //define where to find class descriptors
....................    //first dimension is the config number
....................    //second dimension specifies which interface
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface
....................    //if a class descriptor is not valid, set the value to 0xFFFF
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]=
....................    {
....................    //config 1
....................       //interface 0
....................          //class 1-4
....................          18,23,27,32,
....................       //interface 1
....................          //no classes for this interface
....................          0xFF,0xFF,0xFF,0xFF
....................    };
.................... 
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN)
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly
....................    #endif
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start device descriptors
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={
....................       //starts of with device configuration. only one possible
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1
....................          0x10,0x01, //usb version in bcd  ==2,3
....................          0x02, //class code. 0x02=Communication Device Class ==4
....................          0x00, //subclass code ==5
....................          0x00, //protocol code ==6
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14
....................          0x02, //index of string descriptor of the product  ==15
....................          0x00, //index of string descriptor of serial number  ==16
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17
....................    };
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start string descriptors
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone.
.................... ///
.................... ///   You must define the length else get_next_string_character() will not see the string
.................... ///   Current code only supports 10 strings (0 thru 9)
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
.................... #if !defined(USB_STRINGS_OVERWRITTEN)
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored.
.................... // Strings are saved as unicode.
.................... // These strings are mostly only displayed during the add hardware wizard.
.................... // Once the operating system drivers have been installed it will usually display
.................... // the name from the drivers .INF.
.................... char const USB_STRING_DESC[]={
....................    //string 0
....................          4, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          0x09,0x04,   //Microsoft Defined for US-English
....................    //string 1  - manufacturer
....................          8, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................    //string 2 - product
....................          32, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................          ' ',0,
....................          'U',0,
....................          'S',0,
....................          'B',0,
....................          ' ',0,
....................          't',0,
....................          'o',0,
....................          ' ',0,
....................          'U',0,
....................          'A',0,
....................          'R',0,
....................          'T',0
.................... };
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN)
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... struct {
....................    int1 got;
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100
....................    unsigned int16 len;
....................    unsigned int16 index;
....................   #else
....................    unsigned int8 len;
....................    unsigned int8 index;
....................   #endif
.................... } usb_cdc_get_buffer_status;
.................... 
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             usb.c                                 ////
.................... ////                                                                   ////
.................... //// Standard USB request and token handler code.                      ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... //// The majority of this code is called and used by the interrupt     ////
.................... //// generated by the hardware level, and therefore it is not meant    ////
.................... //// to be called by the user.  The functions that are meant to be     ////
.................... //// called by the user (init, put packet, get packet, etc) are        ////
.................... //// documented in USB.H.                                              ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////    This code will not create a multiple configuration device.     ////
.................... ////    If you wish to create a multiple configuration device then you ////
.................... ////    will have to modify these drivers.                             ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    ////
.................... ////   requests.  These requests are optional.  If you want to support ////
.................... ////   these requests you must provide the code yourself.  See         ////
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      ////
.................... ////   support.                                                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// If you wish to provide your own USB peripheral hardware layer, it ////
.................... //// must must provide the API as described in usb_hw_layer.h.         ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 20, 2015                                                    ////
.................... ////     USB_STRING_DESC_OFFSET no longer used.                        ////
.................... ////                                                                   ////
.................... //// Feb 6th, 2015                                                     ////
.................... ////     Fixed 'len' not being intiailized in usb_gets()               ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// June 8th, 2011:                                                   ////
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  ////
.................... ////     (for no timeout) resolved.                                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// November 13th, 2009:                                              ////
.................... ////  usb_endpoint_is_valid() has an extra check.                      ////
.................... ////                                                                   ////
.................... //// June 9th, 2009:                                                   ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// Dec 14, 2007:                                                     ////
.................... ////  usb_kbhit() moved to device driver.                              ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    ////
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release.                                         ////
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     ////
.................... ////    layer.                                                         ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////  TODO: alot of indexing and length handling for descriptors is    ////
.................... ////   only 8bit, so make sure all descriptor tables are less than     ////
.................... ////   256 bytes long.                                                 ////
.................... ////                                                                   ////
.................... //// Apr 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     ////
.................... ////   usb_ep_tx_size[] defined in usb.h                               ////
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             ////
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  ////
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     ////
.................... ////   the endpoint buffer until you usb_get_packet(), which will      ////
.................... ////   then free the endpoint buffer for more data.  This affects      ////
.................... ////   routines such as usb_gets() and usb_kbhit().                    ////
.................... ////  usb_gets() no longer reads buffered data (see above note),       ////
.................... ////   now it reads multiple packets in the same way usb_puts()        ////
.................... ////   writes multiple packets                                         ////
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  ////
.................... ////   layer.                                                          ////
.................... ////                                                                   ////
.................... //// Nov 11th, 2004:                                                   ////
.................... ////  No longer includes wrong descriptor header.                      ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   ////
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    ////
.................... ////                     although it didn't cause any serious problems ////
.................... ////                                                                   ////
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  ////
.................... ////                     problems with multiple packet messages        ////
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   ////
.................... ////                     descriptors that require a 0 len packet to    ////
.................... ////                     end message.                                  ////
.................... ////                                                                   ////
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DRIVER__
.................... #DEFINE __USB_DRIVER__
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #else
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) 
....................    {
....................       while(len--)
....................       {
....................          debug_usb_packet(debug_putc, "%02X", *ptr++);
....................       }
....................    }
.................... #endif
.................... 
.................... // legacy
.................... #ifndef debug_usb
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l)
.................... #endif
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if defined(__PIC16F_USB_H__)
....................  #include <pic16f_usb.c>
.................... #endif
.................... 
.................... #if defined(__PIC18_USB_H__)
....................  #include <pic18_usb.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.c                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     ////
.................... //// documentation about the PIC18 hardware layer.                   ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Dec 12, 2016:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Mar 20, 2015:                                                   ////
.................... ////  When TXing a packet, set UOWN bit as a different instruction   ////
.................... ////     as the rest of the BDSTAT flags.  Doing it this way         ////
.................... ////     prevents PIC18F45K50 family USB from locking up.            ////
.................... ////                                                                 ////
.................... //// Mar 1, 2015:                                                    ////
.................... ////  Added __STALL_ON_UEP_ERRATA__ and __UIDLE_JAM_ERRATA__ from    ////
.................... ////     PIC24 USB library, in case those erratas found              ////
.................... ////     their way on the PIC18 USB parts.                           ////
.................... ////                                                                 ////
.................... //// Dec 17, 2013:                                                   ////
.................... ////  Added 18FxxJ9x family support.                                 ////
.................... ////                                                                 ////
.................... //// Dec 11, 2013:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// July 9th, 2012:                                                 ////
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     ////
.................... ////     for non-setup packets on endpoint 0 or all other            ////
.................... ////     endpoints.  This really only affects people using           ////
.................... ////     usb_put_packet() or usb_get_packet() inside of other        ////
.................... ////     interrupts.                                                 ////
.................... ////                                                                 ////
.................... //// Sep 22, 2011:                                                   ////
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   ////
.................... ////     primarily developed for users developing code where         ////
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Added initial 18F47J53 family support.                         ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work.                          ////
.................... ////                                                                 ////
.................... //// Nov 13th, 2009:                                                 ////
.................... ////  usb_disable_endpoint() won't touch BD status registers for     ////
.................... ////     endpoints that aren't allocated.                            ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_C__
.................... #DEFINE __PIC18_USB_C__
.................... 
.................... // i got these from PIC24 library, but maybe these bugs made their way
.................... // into PIC18 usb peripherals.
.................... // __STALL_ON_UEP_ERRATA__ looked wrong on the PIC24 library.
.................... #define __STALL_ON_UEP_ERRATA__
.................... #define __UIDLE_JAM_ERRATA__
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #endif
.................... 
.................... #bit USBIE=getenv("BIT:USBIE")
.................... 
.................... //if you are worried that the PIC is not receiving packets because a bug in the
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on
.................... //receiving.
.................... #ifndef USB_IGNORE_RX_DTS
....................  #define USB_IGNORE_RX_DTS false
.................... #endif
.................... 
.................... #ifndef USB_IGNORE_TX_DTS
....................  #define USB_IGNORE_TX_DTS false
.................... #endif
.................... 
.................... // if only USB_BDT_START is defined, then BDT has a fixed location in RAM
.................... //    but endpoint memory can be anywhere on the PIC.
.................... // if only USB_RAM_START is defined, then both BDT and endpoint have a fixed
.................... //    location in RAM (BDT first, endpoint second).
.................... // if USB_BDT_START and USB_RAM_START are both defined, then BDT has a fixed
.................... //    location in RAM and the endpoint buffers have a different location
.................... //    in RAM.
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50"))
....................  #define __USB_87J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \
....................        (getenv("DEVICE")=="PIC18F24K50") || \
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF24K50"))
....................  #define __USB_45K50__
....................  #define USB_TOTAL_RAM_SPACE  1024
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50"))
....................  #define __USB_46J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || \
....................        (getenv("DEVICE")=="PIC18LF2450") || (getenv("DEVICE")=="PIC18LF4450"))
....................  #define __USB_4450__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................  #define __USB_K50__ //backwards compatability
....................  #define __USB_14K50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x200
....................  #define USB_NUM_UEP 8
....................  //technically this device supports 8 endpoints, but for RAM reasons you should
....................  //attempt to only use the first 3 endpoints.
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") || \
....................        (getenv("DEVICE")=="PIC18LF2455") || (getenv("DEVICE")=="PIC18LF2550") || \
....................        (getenv("DEVICE")=="PIC18LF4455") || (getenv("DEVICE")=="PIC18LF4550") || \
....................        (getenv("DEVICE")=="PIC18LF2458") || (getenv("DEVICE")=="PIC18LF2553") || \
....................        (getenv("DEVICE")=="PIC18LF4458") || (getenv("DEVICE")=="PIC18LF4553") \
....................        )
....................  #define __USB_4550__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") || \
....................        (getenv("DEVICE")=="PIC18LF26J53") || (getenv("DEVICE")=="PIC18LF27J53") || \ 
....................        (getenv("DEVICE")=="PIC18LF46J53") || (getenv("DEVICE")=="PIC18LF47J53") \       
....................        )
....................  #define __USB_18FJ53__
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use
....................  #define USB_BDT_START  0xD00
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F97J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F87J94") ||  \
....................        (getenv("DEVICE")=="PIC18F67J94") ||  \
....................        (getenv("DEVICE")=="PIC18F96J99") ||  \
....................        (getenv("DEVICE")=="PIC18F86J99") ||  \
....................        (getenv("DEVICE")=="PIC18F66J99") ||  \
....................        (getenv("DEVICE")=="PIC18F96J94") ||  \
....................        (getenv("DEVICE")=="PIC18F86J94") ||  \
....................        (getenv("DEVICE")=="PIC18F66J94") ||  \
....................        (getenv("DEVICE")=="PIC18F95J94") ||  \
....................        (getenv("DEVICE")=="PIC18F85J94") ||  \
....................        (getenv("DEVICE")=="PIC18F65J94"))
....................  #define __USB_18FJ94__
....................  #define USB_BDT_START  0x100
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library.
.................... #endif
.................... 
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  15
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  14
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  13
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  12
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  11
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  10
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  9
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  8
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  7
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  6
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  5
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  4
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  3
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  2
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  1
.................... #else
....................  #define USB_LAST_DEFINED_ENDPOINT  0
.................... #endif
.................... 
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8)
.................... 
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)
.................... 
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT)
....................  #error You are trying to use an invalid endpoint for this hardware!
.................... #endif
.................... 
.................... typedef struct
.................... {
....................    unsigned int8 stat;
....................    unsigned int8 cnt;
....................    unsigned int16 addr;
.................... } STRUCT_BD;
.................... 
.................... #if defined(USB_RAM_START) && !defined(USB_BDT_START)
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       struct
....................       {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................       } bd[USB_LAST_DEFINED_ENDPOINT+1];
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM.buffer)
....................    
....................    #locate g_USBRAM=USB_RAM_START
....................    
....................    #define g_USBBDT g_USBRAM.bd
.................... #else
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #if defined(USB_RAM_START)
....................       #locate g_USBRAM=USB_RAM_START
....................    #endif
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM)
....................    
....................    struct
....................    {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................    } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1];
....................    
....................    #locate g_USBBDT=USB_BDT_START
.................... #endif
.................... 
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer
.................... 
.................... //these buffer definitions needed for CDC library
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer
.................... 
.................... //if you enable this it will keep a counter of the 6 possible errors the
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time.
.................... #if !defined(USB_USE_ERROR_COUNTER)
....................    #define USB_USE_ERROR_COUNTER false
.................... #endif
.................... 
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints
.................... 
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS!
.................... #if !defined(USB_PING_PONG_MODE)
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF
.................... #endif
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................    unsigned int ERROR_COUNTER[6];
.................... #endif
.................... 
.................... //---pic18fxx5x memory locations
.................... #if defined(__USB_4550__) || defined(__USB_4450__)
....................    #byte UFRML   =  0xF66
....................    #byte UFRMH   =  0xF67
....................    #byte UIR     =  0xF68
....................    #byte UIE     =  0xF69
....................    #byte UEIR    =  0xF6A
....................    #byte UEIE    =  0xF6B
....................    #byte U1STAT   =  0xF6C
....................    #byte UCON    =  0xF6D
....................    #byte UADDR   =  0xF6E
....................    #byte UCFG    =  0xF6F
....................    #define  UEP0_LOC 0xF70
.................... #elif defined(__USB_46J50__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #elif defined(__USB_14K50__)
....................    #byte UFRML   =  0xF5D
....................    #byte UFRMH   =  0xF5E
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF60
....................    #byte UEIR    =  0xF5F
....................    #byte UEIE    =  0xF5B
....................    #byte U1STAT   =  0xF63
....................    #byte UCON    =  0xF64
....................    #byte UADDR   =  0xF5C
....................    #byte UCFG    =  0xF61
....................    #define  UEP0_LOC 0xF53
.................... #elif defined(__USB_18FJ53__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #else
....................    #byte UFRML = getenv("SFR:UFRML")
....................    #byte UFRMH = getenv("SFR:UFRMH")
....................    #byte UIR = getenv("SFR:UIR")
....................    #byte UIE = getenv("SFR:UIE")
....................    #byte UEIR = getenv("SFR:UEIR")
....................    #byte UEIE = getenv("SFR:UEIE")
....................    #byte U1STAT = getenv("SFR:USTAT")
....................    #byte UCON = getenv("SFR:UCON")
....................    #byte UADDR = getenv("SFR:UADDR")
....................    #byte UCFG = getenv("SFR:UCFG")
.................... #endif
.................... 
.................... unsigned int8 USTATCopy;
.................... 
.................... unsigned int8 g_UEP[USB_NUM_UEP];
.................... #if defined(UEP0_LOC)
.................... #locate g_UEP=UEP0_LOC
.................... #else
.................... #locate g_UEP=getenv("SFR:UEP0")
.................... #endif
.................... #define UEP(x) g_UEP[x]
.................... 
.................... #define BIT_SOF   6
.................... #define BIT_STALL 5
.................... #define BIT_IDLE  4
.................... #define BIT_TRN   3
.................... #define BIT_ACTV  2
.................... #define BIT_UERR  1
.................... #define BIT_URST  0
.................... 
.................... #BIT UIR_SOF = UIR.BIT_SOF
.................... #BIT UIR_STALL = UIR.BIT_STALL
.................... #BIT UIR_IDLE = UIR.BIT_IDLE
.................... #BIT UIR_TRN = UIR.BIT_TRN
.................... #BIT UIR_ACTV = UIR.BIT_ACTV
.................... #BIT UIR_UERR = UIR.BIT_UERR
.................... #BIT UIR_URST = UIR.BIT_URST
.................... 
.................... #BIT UIE_SOF = UIE.BIT_SOF
.................... #BIT UIE_STALL = UIE.BIT_STALL
.................... #BIT UIE_IDLE = UIE.BIT_IDLE
.................... #BIT UIE_TRN = UIE.BIT_TRN
.................... #BIT UIE_ACTV = UIE.BIT_ACTV
.................... #BIT UIE_UERR = UIE.BIT_UERR
.................... #BIT UIE_URST = UIE.BIT_URST
.................... 
.................... #if getenv("BIT_VALID:PPBRST")
....................    #bit UCON_PPBRST = getenv("BIT:PPBRST")
.................... #endif
.................... #bit UCON_SE0=UCON.5
.................... #bit UCON_PKTDIS=UCON.4
.................... #bit UCON_USBEN=UCON.3
.................... #bit UCON_RESUME=UCON.2
.................... #bit UCON_SUSPND=UCON.1
.................... 
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF)
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr
.................... #else
.................... #error Right now this driver only supports no ping pong
.................... #endif
.................... 
.................... //See UEPn (0xF70-0xF7F)
.................... #define ENDPT_DISABLED   0x00   //endpoint not used
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions
.................... 
.................... //Define the states that the USB interface can be in
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3,
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state;
.................... 
.................... //--BDendST has their PIDs upshifed 2
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction
.................... 
.................... #define USTAT_IN_E0        4
.................... #define USTAT_OUT_SETUP_E0 0
.................... 
.................... #define __USB_UIF_RESET    0x01
.................... #define __USB_UIF_ERROR    0x02
.................... #define __USB_UIF_ACTIVE   0x04
.................... #define __USB_UIF_TOKEN    0x08
.................... #define __USB_UIF_IDLE     0x10
.................... #define __USB_UIF_STALL    0x20
.................... #define __USB_UIF_SOF      0x40
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET
.................... #else
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET
.................... #endif
.................... 
.................... #define __USB_UCFG_UTEYE   0x80
.................... #if defined(__USB_4550__)
....................  #define __USB_UCFG_UOEMON  0x40
.................... #endif
.................... #define __USB_UCFG_UPUEN   0x10
.................... #if !defined(__USB_14K50__)
....................  #define __USB_UCFG_UTRDIS  0x08
.................... #endif
.................... #define __USB_UCFG_FSEN    0x04
.................... 
.................... #if defined(USB_EXTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  0
.................... #endif
.................... 
.................... #if defined(USB_INTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if !defined(__USB_UCFG_MY_UPUEN)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if USB_USE_FULL_SPEED
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE)
.................... #else
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE);
.................... #endif
.................... 
.................... #if defined(__USB_UCFG_UTRDIS)
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS
.................... #else
....................  #define __UCFG_VAL_DISABLED__   0
.................... #endif
.................... 
.................... 
.................... unsigned int8 __setup_0_tx_size;
.................... 
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only
.................... void usb_handle_interrupt();
.................... void usb_isr_rst();
.................... void usb_isr_uerr();
.................... void usb_isr_sof(void);
.................... void usb_isr_activity();
.................... void usb_isr_uidle();
.................... void usb_isr_tok_dne();
.................... void usb_isr_stall(void);
.................... void usb_init_ep0_setup(void);
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... void usb_isr(void);
.................... #endif
.................... 
.................... //// BEGIN User Functions:
.................... 
.................... // see usb_hw_layer.h for more documentation
.................... int1 usb_kbhit(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7)));
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_tbe(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7)));
*
0DCE:  CLRF   03
0DD0:  MOVLB  2
0DD2:  MOVF   x47,W
0DD4:  ADDLW  70
0DD6:  MOVWF  FE9
0DD8:  MOVLW  0F
0DDA:  ADDWFC 03,W
0DDC:  MOVWF  FEA
0DDE:  MOVF   FEF,F
0DE0:  BZ    0E18
0DE2:  CLRF   x49
0DE4:  MOVFF  247,248
0DE8:  CLRF   x4B
0DEA:  MOVLW  08
0DEC:  MOVWF  x4A
0DEE:  MOVLB  0
0DF0:  CALL   0442
0DF4:  MOVFF  02,249
0DF8:  MOVFF  01,248
0DFC:  MOVLW  04
0DFE:  MOVLB  2
0E00:  ADDWF  x48,F
0E02:  MOVLW  00
0E04:  ADDWFC x49,F
0E06:  MOVFF  248,FE9
0E0A:  MOVLW  04
0E0C:  ADDWF  x49,W
0E0E:  MOVWF  FEA
0E10:  MOVFF  FEF,24A
0E14:  BTFSS  x4A.7
0E16:  BRA    0E1C
0E18:  MOVLW  00
0E1A:  BRA    0E1E
0E1C:  MOVLW  01
0E1E:  MOVWF  01
0E20:  MOVLB  0
0E22:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_detach(void)
.................... {
....................    UCON_SUSPND = 0;
*
14A6:  BCF    F6D.1
....................    UCON = 0;  //disable USB hardware
14A8:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts
14AA:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__;
14AC:  MOVLW  08
14AE:  MOVWF  F6F
.................... 
....................    // set D+/D- to inputs
....................   #if defined(__USB_87J50__)
....................    set_tris_f(get_tris_f() | 0x18);
....................   #elif defined(__USB_14K50__)
....................    set_tris_a(get_tris_a() | 0x3);
....................   #elif defined(__USB_18FJ94__)
....................    output_float(PIN_F4);
....................    output_float(PIN_F3);
....................   #elif !defined(USB_PIC_NO_USB_GPIO)
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5
14B0:  MOVF   F94,W
14B2:  IORLW  30
14B4:  MOVLB  2
14B6:  MOVWF  F94
....................   #endif
....................   
....................    usb_state = USB_STATE_DETACHED;
14B8:  CLRF   22
14BA:  CLRF   19
14BC:  BTFSC  FF2.7
14BE:  BSF    19.7
14C0:  BCF    FF2.7
....................    
....................    usb_token_reset();              //clear the chapter9 stack
14C2:  MOVLB  0
14C4:  CALL   0532
14C8:  BTFSC  19.7
14CA:  BSF    FF2.7
14CC:  RETURN 0
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_attach(void) 
*
14DA:  CLRF   19
14DC:  BTFSC  FF2.7
14DE:  BSF    19.7
14E0:  BCF    FF2.7
.................... {
....................    usb_token_reset();
14E2:  CALL   0532
14E6:  BTFSC  19.7
14E8:  BSF    FF2.7
....................    UCON_SUSPND = 0;
14EA:  BCF    F6D.1
....................    UCON = 0;
14EC:  CLRF   F6D
....................   #if getenv("BIT_VALID:PPBRST")
....................    UCON_PPBRST = 1;
14EE:  BSF    F6D.6
....................    delay_cycles(5);
14F0:  BRA    14F2
14F2:  BRA    14F4
14F4:  NOP   
....................    UCON_PPBRST = 0;
14F6:  BCF    F6D.6
....................   #endif
....................    UCFG = __UCFG_VAL_ENABLED__;
14F8:  MOVLW  14
14FA:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts
14FC:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus
14FE:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h
1500:  MOVLW  01
1502:  MOVWF  22
1504:  GOTO   1528 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init_cs(void)
.................... {
....................    usb_detach();
*
14CE:  RCALL  14A6
14D0:  GOTO   154E (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_task(void) 
.................... {
....................   #if defined(USB_ISR_POLLING)
....................    if (interrupt_active(INT_USB))
....................    {
....................       usb_isr();
....................    }
....................   #endif
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_enumerated())
*
1508:  RCALL  14D4
150A:  MOVF   01,F
150C:  BZ    151C
150E:  CLRF   19
1510:  BTFSC  FF2.7
1512:  BSF    19.7
1514:  BCF    FF2.7
....................    {
....................       usb_cdc_flush_tx_buffer();
1516:  RCALL  11E6
1518:  BTFSC  19.7
151A:  BSF    FF2.7
....................    }
....................   #endif
.................... 
....................    if (usb_attached()) 
151C:  BSF    F93.2
151E:  BTFSS  F81.2
1520:  BRA    152A
....................    {
....................       if (UCON_USBEN==0) 
1522:  BTFSC  F6D.3
1524:  BRA    1528
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: ATTACH");
....................          usb_attach();
1526:  BRA    14DA
....................       }
....................    }
1528:  BRA    1530
....................    else 
....................    {
....................       if (UCON_USBEN==1)  
152A:  BTFSS  F6D.3
152C:  BRA    1530
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: DE-ATTACH");
....................          usb_detach();
152E:  RCALL  14A6
....................       }
....................    }
.................... 
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) 
1530:  DECFSZ 22,W
1532:  BRA    154A
1534:  BTFSC  F6D.5
1536:  BRA    154A
....................    {
....................       UIR = 0;
1538:  CLRF   F68
....................       UIE = 0;
153A:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING)
....................       enable_interrupts(INT_USB);
153C:  BSF    FA0.5
....................       enable_interrupts(GLOBAL);
153E:  MOVLW  C0
1540:  IORWF  FF2,F
....................      #endif
....................       UIE = __USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR
1542:  MOVLW  11
1544:  MOVWF  F69
....................      #if USB_USE_ERROR_COUNTER
....................       UIE |= __USB_UIF_ERROR;
....................      #endif
....................       usb_state=USB_STATE_POWERED;
1546:  MOVLW  02
1548:  MOVWF  22
....................       debug_usb_control(debug_putc, "\r\n\nUSB TASK: POWERED");
....................    }
154A:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init(void) 
.................... {
....................    usb_init_cs();
154C:  BRA    14CE
.................... 
....................    do 
....................    {
....................       usb_task();
154E:  RCALL  1508
....................    } while (usb_state != USB_STATE_POWERED);
1550:  MOVF   22,W
1552:  SUBLW  02
1554:  BNZ   154E
1556:  GOTO   3916 (RETURN)
.................... }
.................... 
.................... 
.................... // see pic18_usb.h for documentation
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
.................... 
....................    debug_usb_packet(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len);
.................... 
....................    if (usb_tbe(endpoint)) 
*
0E24:  MOVFF  242,247
0E28:  RCALL  0DCE
0E2A:  MOVF   01,F
0E2C:  BTFSC  FD8.2
0E2E:  BRA    0F66
....................    {
....................       EP_BDxCNT_I(endpoint)=len;
0E30:  MOVLB  2
0E32:  CLRF   x49
0E34:  MOVFF  242,248
0E38:  CLRF   x4B
0E3A:  MOVLW  08
0E3C:  MOVWF  x4A
0E3E:  MOVLB  0
0E40:  CALL   0442
0E44:  MOVFF  02,248
0E48:  MOVFF  01,247
0E4C:  MOVLW  04
0E4E:  MOVLB  2
0E50:  ADDWF  x47,F
0E52:  MOVLW  00
0E54:  ADDWFC x48,F
0E56:  MOVLW  01
0E58:  ADDWF  x47,W
0E5A:  MOVWF  01
0E5C:  MOVLW  00
0E5E:  ADDWFC x48,W
0E60:  MOVWF  03
0E62:  MOVFF  01,FE9
0E66:  MOVLW  04
0E68:  ADDWF  03,W
0E6A:  MOVWF  FEA
0E6C:  MOVFF  243,FEF
.................... 
....................       debug_display_ram(len, EP_BDxADR_I(endpoint));
.................... 
....................      #if USB_IGNORE_TX_DTS
....................       i=0x80;
....................      #else
....................       if (tgl == USB_DTS_TOGGLE) 
0E70:  MOVF   x45,W
0E72:  SUBLW  02
0E74:  BNZ   0EB6
....................       {
....................          i = EP_BDxST_I(endpoint);
0E76:  CLRF   x49
0E78:  MOVFF  242,248
0E7C:  CLRF   x4B
0E7E:  MOVLW  08
0E80:  MOVWF  x4A
0E82:  MOVLB  0
0E84:  CALL   0442
0E88:  MOVFF  02,248
0E8C:  MOVFF  01,247
0E90:  MOVLW  04
0E92:  MOVLB  2
0E94:  ADDWF  x47,F
0E96:  MOVLW  00
0E98:  ADDWFC x48,F
0E9A:  MOVFF  247,FE9
0E9E:  MOVLW  04
0EA0:  ADDWF  x48,W
0EA2:  MOVWF  FEA
0EA4:  MOVFF  FEF,246
....................          if (bit_test(i,6))
0EA8:  BTFSS  x46.6
0EAA:  BRA    0EB0
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0EAC:  CLRF   x45
0EAE:  BRA    0EB4
....................          else
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0EB0:  MOVLW  01
0EB2:  MOVWF  x45
....................       }
0EB4:  BRA    0EEA
....................       else if (tgl == USB_DTS_USERX) 
0EB6:  MOVF   x45,W
0EB8:  SUBLW  04
0EBA:  BNZ   0EEA
....................       {
....................          i = EP_BDxST_O(endpoint);
0EBC:  CLRF   x49
0EBE:  MOVFF  242,248
0EC2:  CLRF   x4B
0EC4:  MOVLW  08
0EC6:  MOVWF  x4A
0EC8:  MOVLB  0
0ECA:  CALL   0442
0ECE:  MOVLB  2
0ED0:  MOVFF  01,FE9
0ED4:  MOVLW  04
0ED6:  ADDWF  02,W
0ED8:  MOVWF  FEA
0EDA:  MOVFF  FEF,246
....................          if (bit_test(i,6))
0EDE:  BTFSS  x46.6
0EE0:  BRA    0EE8
....................             tgl = USB_DTS_DATA1;
0EE2:  MOVLW  01
0EE4:  MOVWF  x45
0EE6:  BRA    0EEA
....................          else
....................             tgl = USB_DTS_DATA0;
0EE8:  CLRF   x45
....................       }
....................       if (tgl == USB_DTS_DATA1) 
0EEA:  DECFSZ x45,W
0EEC:  BRA    0EF4
....................          i=0x48;  //DATA1, UOWN  //change mar2015
0EEE:  MOVLW  48
0EF0:  MOVWF  x46
0EF2:  BRA    0EF8
....................       else //if (tgl == USB_DTS_DATA0) 
....................          i=0x08; //DATA0, UOWN   //change mar2015
0EF4:  MOVLW  08
0EF6:  MOVWF  x46
....................      #endif
.................... 
....................       //set BC8 and BC9
....................       //if (bit_test(len,8)) {bit_set(i,0);}
....................       //if (bit_test(len,9)) {bit_set(i,1);}
.................... 
....................       debug_usb_packet(debug_putc, " %X", i);
.................... 
....................       EP_BDxST_I(endpoint) = i;  //save changes
0EF8:  CLRF   x49
0EFA:  MOVFF  242,248
0EFE:  CLRF   x4B
0F00:  MOVLW  08
0F02:  MOVWF  x4A
0F04:  MOVLB  0
0F06:  CALL   0442
0F0A:  MOVFF  02,248
0F0E:  MOVFF  01,247
0F12:  MOVLW  04
0F14:  MOVLB  2
0F16:  ADDWF  x47,F
0F18:  MOVLW  00
0F1A:  ADDWFC x48,F
0F1C:  MOVFF  247,FE9
0F20:  MOVLW  04
0F22:  ADDWF  x48,W
0F24:  MOVWF  FEA
0F26:  MOVFF  246,FEF
....................       
....................       EP_BDxST_I(endpoint) |= 0x80; //change mar2015
0F2A:  CLRF   x49
0F2C:  MOVFF  242,248
0F30:  CLRF   x4B
0F32:  MOVLW  08
0F34:  MOVWF  x4A
0F36:  MOVLB  0
0F38:  CALL   0442
0F3C:  MOVFF  02,248
0F40:  MOVFF  01,247
0F44:  MOVLW  04
0F46:  MOVLB  2
0F48:  ADDWF  x47,F
0F4A:  MOVLW  00
0F4C:  ADDWFC x48,F
0F4E:  MOVFF  247,FE9
0F52:  MOVLW  04
0F54:  ADDWF  x48,W
0F56:  MOVWF  FEA
0F58:  MOVF   FEF,W
0F5A:  IORLW  80
0F5C:  MOVWF  FEF
....................       
....................       //putc('!');
....................       
....................       return(1);
0F5E:  MOVLW  01
0F60:  MOVWF  01
0F62:  BRA    0F6C
....................    }
0F64:  MOVLB  0
....................    else 
....................    {
....................       //putc('_');
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
....................    return(0);
0F66:  MOVLW  00
0F68:  MOVWF  01
0F6A:  MOVLB  2
0F6C:  MOVLB  0
0F6E:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 * buff_add;    
.................... 
....................    if (usb_tbe(endpoint)) 
*
106C:  MOVFF  23A,247
1070:  RCALL  0DCE
1072:  MOVF   01,F
1074:  BZ    1104
....................    {
....................       buff_add = EP_BDxADR_I(endpoint);
1076:  MOVLB  2
1078:  CLRF   x49
107A:  MOVFF  23A,248
107E:  CLRF   x4B
1080:  MOVLW  08
1082:  MOVWF  x4A
1084:  MOVLB  0
1086:  CALL   0442
108A:  MOVFF  02,243
108E:  MOVFF  01,242
1092:  MOVLW  04
1094:  MOVLB  2
1096:  ADDWF  x42,F
1098:  MOVLW  00
109A:  ADDWFC x43,F
109C:  MOVLW  02
109E:  ADDWF  x42,W
10A0:  MOVWF  01
10A2:  MOVLW  00
10A4:  ADDWFC x43,W
10A6:  MOVWF  03
10A8:  MOVFF  01,FE9
10AC:  MOVLW  04
10AE:  ADDWF  03,W
10B0:  MOVWF  FEA
10B2:  MOVFF  FEC,241
10B6:  MOVF   FED,F
10B8:  MOVFF  FEF,240
....................       memcpy(buff_add, ptr, len);     
10BC:  MOVFF  241,FEA
10C0:  MOVFF  240,FE9
10C4:  MOVFF  23C,FE2
10C8:  MOVFF  23B,FE1
10CC:  MOVFF  23E,02
10D0:  MOVFF  23D,01
10D4:  MOVF   01,F
10D6:  BZ    10DC
10D8:  INCF   02,F
10DA:  BRA    10E0
10DC:  MOVF   02,F
10DE:  BZ    10EC
10E0:  MOVFF  FE6,FEE
10E4:  DECFSZ 01,F
10E6:  BRA    10E0
10E8:  DECFSZ 02,F
10EA:  BRA    10E0
....................       
....................       return(usb_flush_in(endpoint, len, tgl));
10EC:  MOVFF  23A,242
10F0:  MOVFF  23E,244
10F4:  MOVFF  23D,243
10F8:  MOVFF  23F,245
10FC:  MOVLB  0
10FE:  RCALL  0E24
1100:  MOVF   01,W
1102:  BRA    1108
....................    }
....................    else 
....................    {
....................       //putc('-');
....................       //printf("%X", EP_BDxST_I(endpoint));
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
.................... 
....................    return(0);
1104:  MOVLW  00
1106:  MOVWF  01
1108:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
....................    unsigned int16 len;
.................... 
....................   #if USB_IGNORE_RX_DTS
....................    if (tgl == USB_DTS_STALL) 
....................    {
....................       debug_usb_token(debug_putc, '*');
....................       EP_BDxCNT_O(endpoint) = 0x84;
....................       EP_BDxST_I(endpoint) = 0x84;
....................       return;
....................    }
....................    else
....................       i=0x80;
....................   #else
....................    i = EP_BDxST_O(endpoint);
*
0CCE:  MOVLB  2
0CD0:  CLRF   x49
0CD2:  MOVFF  239,248
0CD6:  CLRF   x4B
0CD8:  MOVLW  08
0CDA:  MOVWF  x4A
0CDC:  MOVLB  0
0CDE:  CALL   0442
0CE2:  MOVLB  2
0CE4:  MOVFF  01,FE9
0CE8:  MOVLW  04
0CEA:  ADDWF  02,W
0CEC:  MOVWF  FEA
0CEE:  MOVFF  FEF,23B
....................    if (tgl == USB_DTS_TOGGLE) 
0CF2:  MOVF   x3A,W
0CF4:  SUBLW  02
0CF6:  BNZ   0D04
....................    {
....................       if (bit_test(i,6))
0CF8:  BTFSS  x3B.6
0CFA:  BRA    0D00
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0CFC:  CLRF   x3A
0CFE:  BRA    0D04
....................       else
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0D00:  MOVLW  01
0D02:  MOVWF  x3A
....................    }
....................    if (tgl == USB_DTS_STALL) 
0D04:  MOVF   x3A,W
0D06:  SUBLW  03
0D08:  BNZ   0D42
....................    {
....................       i = 0x84;
0D0A:  MOVLW  84
0D0C:  MOVWF  x3B
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints
0D0E:  CLRF   x49
0D10:  MOVFF  239,248
0D14:  CLRF   x4B
0D16:  MOVLW  08
0D18:  MOVWF  x4A
0D1A:  MOVLB  0
0D1C:  CALL   0442
0D20:  MOVFF  02,23F
0D24:  MOVFF  01,23E
0D28:  MOVLW  04
0D2A:  MOVLB  2
0D2C:  ADDWF  x3E,F
0D2E:  MOVLW  00
0D30:  ADDWFC x3F,F
0D32:  MOVFF  23E,FE9
0D36:  MOVLW  04
0D38:  ADDWF  x3F,W
0D3A:  MOVWF  FEA
0D3C:  MOVLW  84
0D3E:  MOVWF  FEF
....................    }
0D40:  BRA    0D50
....................    else if (tgl == USB_DTS_DATA1)
0D42:  DECFSZ x3A,W
0D44:  BRA    0D4C
....................       i = 0xC8;  //DATA1, UOWN
0D46:  MOVLW  C8
0D48:  MOVWF  x3B
0D4A:  BRA    0D50
....................    else //if (tgl == USB_DTS_DATA0) 
....................       i = 0x88; //DATA0, UOWN
0D4C:  MOVLW  88
0D4E:  MOVWF  x3B
....................   #endif
.................... 
....................    //bit_clear(__usb_kbhit_status,endpoint);
.................... 
....................    len = usb_ep_rx_size[endpoint];
0D50:  BCF    FD8.0
0D52:  RLCF   x39,W
0D54:  CLRF   03
0D56:  MOVLB  0
0D58:  CALL   012A
0D5C:  TBLRD*+
0D5E:  MOVFF  FF5,03
0D62:  MOVLB  2
0D64:  MOVWF  x3C
0D66:  MOVFF  03,23D
....................    EP_BDxCNT_O(endpoint) = len;
0D6A:  CLRF   x49
0D6C:  MOVFF  239,248
0D70:  CLRF   x4B
0D72:  MOVLW  08
0D74:  MOVWF  x4A
0D76:  MOVLB  0
0D78:  CALL   0442
0D7C:  MOVFF  01,23E
0D80:  MOVLW  01
0D82:  MOVLB  2
0D84:  ADDWF  01,W
0D86:  MOVWF  01
0D88:  MOVLW  00
0D8A:  ADDWFC 02,W
0D8C:  MOVWF  03
0D8E:  MOVFF  01,FE9
0D92:  MOVLW  04
0D94:  ADDWF  03,W
0D96:  MOVWF  FEA
0D98:  MOVFF  23C,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);}
0D9C:  BTFSS  x3D.0
0D9E:  BRA    0DA2
0DA0:  BSF    x3B.0
....................    if (bit_test(len,9)) {bit_set(i,1);}
0DA2:  BTFSS  x3D.1
0DA4:  BRA    0DA8
0DA6:  BSF    x3B.1
.................... 
....................    EP_BDxST_O(endpoint) = i;
0DA8:  CLRF   x49
0DAA:  MOVFF  239,248
0DAE:  CLRF   x4B
0DB0:  MOVLW  08
0DB2:  MOVWF  x4A
0DB4:  MOVLB  0
0DB6:  CALL   0442
0DBA:  MOVLB  2
0DBC:  MOVFF  01,FE9
0DC0:  MOVLW  04
0DC2:  ADDWF  02,W
0DC4:  MOVWF  FEA
0DC6:  MOVFF  23B,FEF
0DCA:  MOVLB  0
0DCC:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint) 
.................... {
....................    return(EP_BDxCNT_O(endpoint));
*
0FB8:  MOVLB  2
0FBA:  CLRF   x49
0FBC:  MOVFF  239,248
0FC0:  CLRF   x4B
0FC2:  MOVLW  08
0FC4:  MOVWF  x4A
0FC6:  MOVLB  0
0FC8:  CALL   0442
0FCC:  MOVFF  02,23B
0FD0:  MOVFF  01,23A
0FD4:  MOVLW  01
0FD6:  MOVLB  2
0FD8:  ADDWF  01,W
0FDA:  MOVWF  01
0FDC:  MOVLW  00
0FDE:  ADDWFC 02,W
0FE0:  MOVWF  03
0FE2:  MOVFF  01,FE9
0FE6:  MOVLW  04
0FE8:  ADDWF  03,W
0FEA:  MOVWF  FEA
0FEC:  MOVFF  FEF,01
0FF0:  CLRF   02
0FF2:  MOVLB  0
0FF4:  GOTO   1018 (RETURN)
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN Hardware layer functions required by USB.
.................... 
.................... /*****************************************************************************
.................... /* usb_get_packet_buffer(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer.
.................... /*
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC 
.................... /*          RAM.
.................... /*          Does not mark the endpoint as ready for more data.  Once you are
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready
.................... /*          to receive more data.
.................... /*
.................... /*****************************************************************************/
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) 
.................... {
....................    unsigned int8 * al;
....................    unsigned int8 st;
....................    unsigned int16 i;
.................... 
....................    al = EP_BDxADR_O(endpoint);
....................    i = EP_BDxCNT_O(endpoint);
....................    st = EP_BDxST_O(endpoint);
.................... 
....................    //read BC8 and BC9
....................    if (bit_test(st,0)) {bit_set(i,8);}
....................    if (bit_test(st,1)) {bit_set(i,9);}
.................... 
....................    if (i < max) {max = i;}
....................    
....................    memcpy(ptr, al ,max);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max)
.................... {
....................    max = usb_get_packet_buffer(endpoint, ptr, max);
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_stall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=s%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0AB4:  MOVLB  2
0AB6:  BCF    x39.0
0AB8:  BTFSC  x38.7
0ABA:  BSF    x39.0
....................    endpoint &= 0x7F;
0ABC:  BCF    x38.7
....................    
....................    if (direction) 
0ABE:  BTFSS  x39.0
0AC0:  BRA    0AF4
....................    {
....................       EP_BDxST_I(endpoint) = 0x84;
0AC2:  CLRF   x49
0AC4:  MOVFF  238,248
0AC8:  CLRF   x4B
0ACA:  MOVLW  08
0ACC:  MOVWF  x4A
0ACE:  MOVLB  0
0AD0:  RCALL  0442
0AD2:  MOVFF  02,23B
0AD6:  MOVFF  01,23A
0ADA:  MOVLW  04
0ADC:  MOVLB  2
0ADE:  ADDWF  x3A,F
0AE0:  MOVLW  00
0AE2:  ADDWFC x3B,F
0AE4:  MOVFF  23A,FE9
0AE8:  MOVLW  04
0AEA:  ADDWF  x3B,W
0AEC:  MOVWF  FEA
0AEE:  MOVLW  84
0AF0:  MOVWF  FEF
....................    }
0AF2:  BRA    0B14
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x84;
0AF4:  CLRF   x49
0AF6:  MOVFF  238,248
0AFA:  CLRF   x4B
0AFC:  MOVLW  08
0AFE:  MOVWF  x4A
0B00:  MOVLB  0
0B02:  RCALL  0442
0B04:  MOVLB  2
0B06:  MOVFF  01,FE9
0B0A:  MOVLW  04
0B0C:  ADDWF  02,W
0B0E:  MOVWF  FEA
0B10:  MOVLW  84
0B12:  MOVWF  FEF
....................    }
0B14:  MOVLB  0
0B16:  GOTO   0BC4 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_unstall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=u%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0A3A:  MOVLB  2
0A3C:  BCF    x39.0
0A3E:  BTFSC  x38.7
0A40:  BSF    x39.0
....................    endpoint &= 0x7F;
0A42:  BCF    x38.7
....................    
....................    if (direction) 
0A44:  BTFSS  x39.0
0A46:  BRA    0A7A
....................    {
....................      #if USB_IGNORE_RX_DTS
....................       EP_BDxST_I(endpoint) = 0x80;
....................      #else
....................       EP_BDxST_I(endpoint) = 0x88;
0A48:  CLRF   x49
0A4A:  MOVFF  238,248
0A4E:  CLRF   x4B
0A50:  MOVLW  08
0A52:  MOVWF  x4A
0A54:  MOVLB  0
0A56:  RCALL  0442
0A58:  MOVFF  02,23B
0A5C:  MOVFF  01,23A
0A60:  MOVLW  04
0A62:  MOVLB  2
0A64:  ADDWF  x3A,F
0A66:  MOVLW  00
0A68:  ADDWFC x3B,F
0A6A:  MOVFF  23A,FE9
0A6E:  MOVLW  04
0A70:  ADDWF  x3B,W
0A72:  MOVWF  FEA
0A74:  MOVLW  88
0A76:  MOVWF  FEF
....................      #endif
....................    }
0A78:  BRA    0A98
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x00;
0A7A:  CLRF   x49
0A7C:  MOVFF  238,248
0A80:  CLRF   x4B
0A82:  MOVLW  08
0A84:  MOVWF  x4A
0A86:  MOVLB  0
0A88:  RCALL  0442
0A8A:  MOVLB  2
0A8C:  MOVFF  01,FE9
0A90:  MOVLW  04
0A92:  ADDWF  02,W
0A94:  MOVWF  FEA
0A96:  CLRF   FEF
....................    }
....................    
....................   #if defined(__STALL_ON_UEP_ERRATA__)
....................    bit_clear(UEP(endpoint), 0);
0A98:  CLRF   03
0A9A:  MOVF   x38,W
0A9C:  ADDLW  70
0A9E:  MOVWF  01
0AA0:  MOVLW  0F
0AA2:  ADDWFC 03,F
0AA4:  MOVFF  01,FE9
0AA8:  MOVFF  03,FEA
0AAC:  BCF    FEF.0
....................   #endif
0AAE:  MOVLB  0
0AB0:  GOTO   0BB4 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    unsigned int8 st;
....................    
....................    direction = bit_test(endpoint,7);
*
0B1A:  MOVLB  2
0B1C:  BCF    x39.0
0B1E:  BTFSC  x38.7
0B20:  BSF    x39.0
....................    endpoint &= 0x7F;
0B22:  BCF    x38.7
....................    
....................    if (direction) 
0B24:  BTFSS  x39.0
0B26:  BRA    0B5A
....................    {
....................       st=EP_BDxST_I(endpoint);
0B28:  CLRF   x49
0B2A:  MOVFF  238,248
0B2E:  CLRF   x4B
0B30:  MOVLW  08
0B32:  MOVWF  x4A
0B34:  MOVLB  0
0B36:  RCALL  0442
0B38:  MOVFF  02,23C
0B3C:  MOVFF  01,23B
0B40:  MOVLW  04
0B42:  MOVLB  2
0B44:  ADDWF  x3B,F
0B46:  MOVLW  00
0B48:  ADDWFC x3C,F
0B4A:  MOVFF  23B,FE9
0B4E:  MOVLW  04
0B50:  ADDWF  x3C,W
0B52:  MOVWF  FEA
0B54:  MOVFF  FEF,23A
....................    }
0B58:  BRA    0B7A
....................    else 
....................    {
....................       st=EP_BDxST_O(endpoint);
0B5A:  CLRF   x49
0B5C:  MOVFF  238,248
0B60:  CLRF   x4B
0B62:  MOVLW  08
0B64:  MOVWF  x4A
0B66:  MOVLB  0
0B68:  RCALL  0442
0B6A:  MOVLB  2
0B6C:  MOVFF  01,FE9
0B70:  MOVLW  04
0B72:  ADDWF  02,W
0B74:  MOVWF  FEA
0B76:  MOVFF  FEF,23A
....................    }
....................    
....................    return(bit_test(st,7) && bit_test(st,2));
0B7A:  BTFSS  x3A.7
0B7C:  BRA    0B82
0B7E:  BTFSC  x3A.2
0B80:  BRA    0B86
0B82:  MOVLW  00
0B84:  BRA    0B88
0B86:  MOVLW  01
0B88:  MOVWF  01
0B8A:  MOVLB  0
0B8C:  GOTO   0BDC (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_address(unsigned int8 address) 
.................... {
....................    UADDR = address;
*
1044:  MOVFF  239,F6E
....................    
....................    if (address) 
1048:  MOVLB  2
104A:  MOVF   x39,F
104C:  BZ    1054
....................    {
....................       usb_state = USB_STATE_ADDRESS;
104E:  MOVLW  04
1050:  MOVWF  22
....................    }
1052:  BRA    1058
....................    else 
....................    {
....................       usb_state = USB_STATE_POWERED;
1054:  MOVLW  02
1056:  MOVWF  22
....................    }
1058:  MOVLB  0
105A:  GOTO   1068 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_configured(unsigned int8 config) 
.................... {
....................    unsigned int8 en;
....................    unsigned int16 addy;
....................    unsigned int8 new_uep;
....................    unsigned int16 len;
....................    unsigned int8 i;
....................    
....................    if (config == 0)
*
06F2:  MOVLB  2
06F4:  MOVF   x38,F
06F6:  BNZ   0704
....................    {
....................       // if config=0 then set addressed state
....................       usb_state = USB_STATE_ADDRESS;
06F8:  MOVLW  04
06FA:  MOVWF  22
....................       usb_disable_endpoints();
06FC:  MOVLB  0
06FE:  RCALL  04D4
....................    }
0700:  BRA    08D6
0702:  MOVLB  2
....................    else 
....................    {
....................       // else set configed state
....................       usb_state = USB_STATE_CONFIGURED; 
0704:  MOVLW  05
0706:  MOVWF  22
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH);
0708:  MOVLW  04
070A:  MOVWF  x3B
070C:  MOVLW  98
070E:  MOVWF  x3A
....................       for (en=1; en<USB_NUM_UEP; en++) 
0710:  MOVLW  01
0712:  MOVWF  x39
0714:  MOVF   x39,W
0716:  SUBLW  0F
0718:  BTFSS  FD8.0
071A:  BRA    08D6
....................       {
....................          // enable and config endpoints based upon user configuration
....................          usb_disable_endpoint(en);
071C:  MOVFF  239,241
0720:  MOVLB  0
0722:  RCALL  0464
....................          new_uep = 0;
0724:  MOVLB  2
0726:  CLRF   x3C
....................          if (usb_ep_rx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
0728:  CLRF   03
072A:  MOVF   x39,W
072C:  MOVLB  0
072E:  RCALL  00DA
0730:  SUBLW  FF
0732:  BZ    0802
....................          {
....................             new_uep = 0x04;
0734:  MOVLW  04
0736:  MOVLB  2
0738:  MOVWF  x3C
....................             len = usb_ep_rx_size[en];
073A:  BCF    FD8.0
073C:  RLCF   x39,W
073E:  CLRF   03
0740:  MOVLB  0
0742:  RCALL  012A
0744:  TBLRD*+
0746:  MOVFF  FF5,03
074A:  MOVLB  2
074C:  MOVWF  x3D
074E:  MOVFF  03,23E
....................             EP_BDxCNT_O(en) = len;
0752:  CLRF   x49
0754:  MOVFF  239,248
0758:  CLRF   x4B
075A:  MOVLW  08
075C:  MOVWF  x4A
075E:  MOVLB  0
0760:  RCALL  0442
0762:  MOVFF  01,240
0766:  MOVLW  01
0768:  MOVLB  2
076A:  ADDWF  01,W
076C:  MOVWF  01
076E:  MOVLW  00
0770:  ADDWFC 02,W
0772:  MOVWF  03
0774:  MOVFF  01,FE9
0778:  MOVLW  04
077A:  ADDWF  03,W
077C:  MOVWF  FEA
077E:  MOVFF  23D,FEF
....................             EP_BDxADR_O(en) = addy;
0782:  CLRF   x49
0784:  MOVFF  239,248
0788:  CLRF   x4B
078A:  MOVLW  08
078C:  MOVWF  x4A
078E:  MOVLB  0
0790:  RCALL  0442
0792:  MOVFF  01,240
0796:  MOVLW  02
0798:  MOVLB  2
079A:  ADDWF  01,W
079C:  MOVWF  01
079E:  MOVLW  00
07A0:  ADDWFC 02,W
07A2:  MOVWF  03
07A4:  MOVFF  01,FE9
07A8:  MOVLW  04
07AA:  ADDWF  03,W
07AC:  MOVWF  FEA
07AE:  MOVFF  23B,FEC
07B2:  MOVF   FED,F
07B4:  MOVFF  23A,FEF
....................             addy += usb_ep_rx_size[en];
07B8:  BCF    FD8.0
07BA:  RLCF   x39,W
07BC:  CLRF   03
07BE:  MOVLB  0
07C0:  RCALL  012A
07C2:  TBLRD*+
07C4:  MOVFF  FF5,03
07C8:  MOVLB  2
07CA:  ADDWF  x3A,F
07CC:  MOVF   03,W
07CE:  ADDWFC x3B,F
....................            #if USB_IGNORE_RX_DTS
....................             i = 0x80;
....................            #else
....................             i = 0x88;
07D0:  MOVLW  88
07D2:  MOVWF  x3F
....................            #endif
....................             if (bit_test(len,8)) {bit_set(i,0);}
07D4:  BTFSS  x3E.0
07D6:  BRA    07DA
07D8:  BSF    x3F.0
....................             if (bit_test(len,9)) {bit_set(i,1);}
07DA:  BTFSS  x3E.1
07DC:  BRA    07E0
07DE:  BSF    x3F.1
....................             EP_BDxST_O(en) = i;
07E0:  CLRF   x49
07E2:  MOVFF  239,248
07E6:  CLRF   x4B
07E8:  MOVLW  08
07EA:  MOVWF  x4A
07EC:  MOVLB  0
07EE:  RCALL  0442
07F0:  MOVLB  2
07F2:  MOVFF  01,FE9
07F6:  MOVLW  04
07F8:  ADDWF  02,W
07FA:  MOVWF  FEA
07FC:  MOVFF  23F,FEF
0800:  MOVLB  0
....................          }
....................          if (usb_ep_tx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
0802:  CLRF   03
0804:  MOVLB  2
0806:  MOVF   x39,W
0808:  MOVLB  0
080A:  RCALL  00BA
080C:  SUBLW  FF
080E:  BZ    08A0
....................          {
....................             new_uep |= 0x02;
0810:  MOVLB  2
0812:  BSF    x3C.1
....................             EP_BDxADR_I(en) = addy;
0814:  CLRF   x49
0816:  MOVFF  239,248
081A:  CLRF   x4B
081C:  MOVLW  08
081E:  MOVWF  x4A
0820:  MOVLB  0
0822:  RCALL  0442
0824:  MOVFF  02,241
0828:  MOVFF  01,240
082C:  MOVLW  04
082E:  MOVLB  2
0830:  ADDWF  x40,F
0832:  MOVLW  00
0834:  ADDWFC x41,F
0836:  MOVLW  02
0838:  ADDWF  x40,W
083A:  MOVWF  01
083C:  MOVLW  00
083E:  ADDWFC x41,W
0840:  MOVWF  03
0842:  MOVFF  01,FE9
0846:  MOVLW  04
0848:  ADDWF  03,W
084A:  MOVWF  FEA
084C:  MOVFF  23B,FEC
0850:  MOVF   FED,F
0852:  MOVFF  23A,FEF
....................             addy += usb_ep_tx_size[en];
0856:  BCF    FD8.0
0858:  RLCF   x39,W
085A:  CLRF   03
085C:  MOVLB  0
085E:  RCALL  00FA
0860:  TBLRD*+
0862:  MOVFF  FF5,03
0866:  MOVLB  2
0868:  ADDWF  x3A,F
086A:  MOVF   03,W
086C:  ADDWFC x3B,F
....................             EP_BDxST_I(en) = 0x40;
086E:  CLRF   x49
0870:  MOVFF  239,248
0874:  CLRF   x4B
0876:  MOVLW  08
0878:  MOVWF  x4A
087A:  MOVLB  0
087C:  RCALL  0442
087E:  MOVFF  02,241
0882:  MOVFF  01,240
0886:  MOVLW  04
0888:  MOVLB  2
088A:  ADDWF  x40,F
088C:  MOVLW  00
088E:  ADDWFC x41,F
0890:  MOVFF  240,FE9
0894:  MOVLW  04
0896:  ADDWF  x41,W
0898:  MOVWF  FEA
089A:  MOVLW  40
089C:  MOVWF  FEF
089E:  MOVLB  0
....................          }
....................          if (new_uep == 0x06) {new_uep = 0x0E;}
08A0:  MOVLB  2
08A2:  MOVF   x3C,W
08A4:  SUBLW  06
08A6:  BNZ   08AC
08A8:  MOVLW  0E
08AA:  MOVWF  x3C
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;}
08AC:  CLRF   03
08AE:  MOVF   x39,W
08B0:  MOVLB  0
08B2:  RCALL  00BA
08B4:  SUBLW  01
08B6:  BZ    08BE
08B8:  MOVLB  2
08BA:  BSF    x3C.4
08BC:  MOVLB  0
....................          
....................          UEP(en) = new_uep;
08BE:  CLRF   03
08C0:  MOVLB  2
08C2:  MOVF   x39,W
08C4:  ADDLW  70
08C6:  MOVWF  FE9
08C8:  MOVLW  0F
08CA:  ADDWFC 03,W
08CC:  MOVWF  FEA
08CE:  MOVFF  23C,FEF
08D2:  INCF   x39,F
08D4:  BRA    0714
08D6:  MOVLB  0
....................       }
....................    }
08D8:  GOTO   0984 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoint(unsigned int8 en) 
.................... {
....................    UEP(en) = ENDPT_DISABLED;
*
0464:  CLRF   03
0466:  MOVLB  2
0468:  MOVF   x41,W
046A:  ADDLW  70
046C:  MOVWF  FE9
046E:  MOVLW  0F
0470:  ADDWFC 03,W
0472:  MOVWF  FEA
0474:  CLRF   FEF
....................    
....................    if (usb_endpoint_is_valid(en))
0476:  MOVFF  241,242
047A:  MOVLB  0
047C:  RCALL  03F4
047E:  MOVF   01,F
0480:  BZ    04D2
....................    {
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary      
0482:  MOVLB  2
0484:  CLRF   x49
0486:  MOVFF  241,248
048A:  CLRF   x4B
048C:  MOVLW  08
048E:  MOVWF  x4A
0490:  MOVLB  0
0492:  RCALL  0442
0494:  MOVLB  2
0496:  MOVFF  01,FE9
049A:  MOVLW  04
049C:  ADDWF  02,W
049E:  MOVWF  FEA
04A0:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary
04A2:  CLRF   x49
04A4:  MOVFF  241,248
04A8:  CLRF   x4B
04AA:  MOVLW  08
04AC:  MOVWF  x4A
04AE:  MOVLB  0
04B0:  RCALL  0442
04B2:  MOVFF  02,243
04B6:  MOVFF  01,242
04BA:  MOVLW  04
04BC:  MOVLB  2
04BE:  ADDWF  x42,F
04C0:  MOVLW  00
04C2:  ADDWFC x43,F
04C4:  MOVFF  242,FE9
04C8:  MOVLW  04
04CA:  ADDWF  x43,W
04CC:  MOVWF  FEA
04CE:  CLRF   FEF
04D0:  MOVLB  0
....................    }
04D2:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoints(void) 
.................... {
....................    unsigned int8 i;
....................    
....................    for (i=1; i<USB_NUM_UEP; i++)
04D4:  MOVLW  01
04D6:  MOVLB  2
04D8:  MOVWF  x40
04DA:  MOVF   x40,W
04DC:  SUBLW  0F
04DE:  BNC   04EE
....................       usb_disable_endpoint(i);
04E0:  MOVFF  240,241
04E4:  MOVLB  0
04E6:  RCALL  0464
04E8:  MOVLB  2
04EA:  INCF   x40,F
04EC:  BRA    04DA
04EE:  MOVLB  0
04F0:  RETURN 0
....................       
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... /// END Hardware layer functions required by USB.C
.................... 
.................... 
.................... /// BEGIN USB Interrupt Service Routine
.................... 
.................... static void usb_clear_trn(void)
.................... {
....................    //UIR_TRN = 0;
....................    //delay_cycles(6);
....................    UIR &= ~(1 << BIT_TRN);
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_handle_interrupt()
.................... /*
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished
.................... /*          tokens is the majority of this code, and is handled by usb.c
.................... /*
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt 
.................... /*       method), then you must call this function rapidly.  If there is more 
.................... /*       than 10ms latency the PC may think the USB device is stalled and
.................... /*       disable it.
.................... /*       To switch to a polling method, remove the #int_usb line above this 
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the 
.................... /*       USB interrupt.
.................... /******************************************************************************/
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR)
.................... #int_usb NOCLEAR
.................... #endif
.................... void usb_isr(void)
.................... {
....................    unsigned int8 TRNAttempts;
....................    
....................    clear_interrupt(INT_USB);
*
138C:  BCF    FA1.5
....................    
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though
138E:  MOVF   22,F
1390:  BTFSC  FD8.2
1392:  BRA    140C
....................    if (UIR) 
1394:  MOVF   F68,F
1396:  BTFSC  FD8.2
1398:  BRA    140C
....................    {
....................       //debug_usb(debug_putc,"\r\n\n[%X] ",UIR);
.................... 
....................       //activity detected.  (only enable after sleep)
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}
139A:  BTFSS  F68.2
139C:  BRA    13A4
139E:  BTFSC  F69.2
13A0:  GOTO   03A2
.................... 
....................       if (UCON_SUSPND) return;
13A4:  BTFSC  F6D.1
13A6:  BRA    140C
.................... 
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent
13A8:  BTFSS  F68.5
13AA:  BRA    13B2
13AC:  BTFSC  F69.5
13AE:  GOTO   03DE
.................... 
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected
13B2:  BTFSS  F68.1
13B4:  BRA    13BC
13B6:  BTFSC  F69.1
13B8:  GOTO   03EC
.................... 
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected
13BC:  BTFSS  F68.0
13BE:  BRA    13C6
13C0:  BTFSC  F69.0
13C2:  GOTO   0562
.................... 
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep
13C6:  BTFSS  F68.4
13C8:  BRA    13D0
13CA:  BTFSC  F69.4
13CC:  GOTO   0592
....................       
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();}
13D0:  BTFSS  F68.6
13D2:  BRA    13DA
13D4:  BTFSC  F69.6
13D6:  GOTO   059C
.................... 
....................       TRNAttempts = 0;
13DA:  MOVLB  2
13DC:  CLRF   x35
....................       do
....................       {
....................          if (UIR_TRN && UIE_TRN) 
13DE:  BTFSS  F68.3
13E0:  BRA    13F6
13E2:  BTFSS  F69.3
13E4:  BRA    13F6
....................          {
....................             USTATCopy = U1STAT;
13E6:  MOVFF  F6C,21
....................             usb_clear_trn();
13EA:  MOVLB  0
13EC:  CALL   0004
....................             usb_isr_tok_dne();
13F0:  BRA    1290
....................          }
13F2:  BRA    13FA
13F4:  MOVLB  2
....................          else
....................             break;
13F6:  BRA    1404
13F8:  MOVLB  0
....................       } while (TRNAttempts++ < 4);
13FA:  MOVLB  2
13FC:  MOVF   x35,W
13FE:  INCF   x35,F
1400:  SUBLW  03
1402:  BC    13DE
.................... 
....................      #if defined(USB_CDC_ISR)
....................       //has to be done here, can't be done until TRN is empty.
....................       if (usb_cdc_kbhit())
1404:  BTFSS  1E.0
1406:  BRA    140E
....................       {
....................          USB_CDC_ISR();
1408:  MOVLB  0
140A:  BRA    1388
140C:  MOVLB  2
....................       }
....................      #endif
....................    }
140E:  MOVLB  0
1410:  GOTO   006C
.................... }
.................... 
.................... // SOF interrupt not handled.  user must add this depending on application
.................... void usb_isr_sof(void) 
.................... {
....................    //debug_usb(debug_putc, "\r\nSOF");
....................    
....................    //UIR_SOF = 0;
....................    UIR &= ~(1 << BIT_SOF);
*
059C:  BCF    F68.6
059E:  GOTO   13DA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_rst()
.................... /*
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device
.................... /*          and token handler code to initial state.
.................... /*
.................... /******************************************************************************/
.................... void usb_isr_rst(void) 
.................... {
....................    debug_usb_control(debug_putc,"-R-");
.................... 
....................    UEIE = 0;
*
0562:  CLRF   F6B
....................    UIE = 0;
0564:  CLRF   F69
....................    UEIR = 0;
0566:  CLRF   F6A
....................    UIR = 0;
0568:  CLRF   F68
.................... 
....................    UADDR = 0;
056A:  CLRF   F6E
....................    
....................    UEP(0) = ENDPT_DISABLED;
056C:  CLRF   F70
.................... 
....................    usb_disable_endpoints();
056E:  RCALL  04D4
....................    
....................    usb_token_reset();
0570:  RCALL  0532
.................... 
....................    UEP(0) = ENDPT_CONTROL | 0x10;
0572:  MOVLW  16
0574:  MOVWF  F70
.................... 
....................    while (UIR_TRN) 
0576:  BTFSS  F68.3
0578:  BRA    057E
....................    {
....................       usb_clear_trn();
057A:  RCALL  0004
057C:  BRA    0576
....................    }
.................... 
.................... 
....................    UEIE = 0x9F;
057E:  MOVLW  9F
0580:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE;
0582:  MOVLW  3D
0584:  MOVWF  F69
.................... 
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled
0586:  BCF    F6D.4
.................... 
....................    usb_init_ep0_setup();
0588:  RCALL  03B4
.................... 
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state
058A:  MOVLW  03
058C:  MOVWF  22
058E:  GOTO   13C6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_init_ep0_setup()
.................... /*
.................... /* Summary: Configure EP0 to receive setup packets
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_ep0_setup(void) 
.................... {
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH;
*
03B4:  MOVLW  40
03B6:  MOVLB  4
03B8:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION;
03BA:  MOVLW  04
03BC:  MOVLB  2
03BE:  MOVWF  x37
03C0:  MOVLW  18
03C2:  MOVFF  237,403
03C6:  MOVFF  FE8,402
....................    #if USB_IGNORE_RX_DTS
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off
....................    #else
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on
03CA:  MOVLW  88
03CC:  MOVLB  4
03CE:  MOVWF  x00
....................    #endif
.................... 
....................     EP_BDxST_I(0) = 0;
03D0:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH;
03D2:  MOVLW  04
03D4:  MOVWF  x07
03D6:  MOVLW  58
03D8:  MOVWF  x06
03DA:  MOVLB  0
03DC:  RETURN 0
.................... }
.................... 
.................... /*******************************************************************************
.................... /* usb_isr_uerr()
.................... /*
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter
.................... /*          will incerement.  If having problems check the status of these 8 bytes.
.................... /*
.................... /* NOTE: This code is not enabled by default.
.................... /********************************************************************************/
.................... void usb_isr_uerr(void)
.................... {
....................   #if USB_USE_ERROR_COUNTER
....................    int ints;
....................   #endif
.................... 
....................    debug_usb_control(debug_putc,"-E%X-",UEIR);
.................... 
....................   #if USB_USE_ERROR_COUNTER
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled
.................... 
....................    if ( bit_test(ints,0) ) 
....................    { 
....................       //increment pid_error counter
....................       //debug_usb(debug_putc,"PID ");
....................       ERROR_COUNTER[0]++;
....................    }
.................... 
....................    if ( bit_test(ints,1) ) 
....................    {  
....................       //increment crc5 error counter
....................       //debug_usb(debug_putc,"CRC5 ");
....................       ERROR_COUNTER[1]++;
....................    }
.................... 
....................    if ( bit_test(ints,2) ) 
....................    {
....................       //increment crc16 error counter
....................       //debug_usb(debug_putc,"CRC16 ");
....................       ERROR_COUNTER[2]++;
....................    }
.................... 
....................    if ( bit_test(ints,3) ) 
....................    {  
....................       //increment dfn8 error counter
....................       //debug_usb(debug_putc,"DFN8 ");
....................       ERROR_COUNTER[3]++;
....................    }
.................... 
....................    if ( bit_test(ints,4) ) 
....................    {  
....................       //increment bto error counter
....................       //debug_usb(debug_putc,"BTO ");
....................       ERROR_COUNTER[4]++;
....................    }
.................... 
....................    if ( bit_test(ints,7) ) 
....................    { 
....................       //increment bts error counter
....................       //debug_usb(debug_putc,"BTS ");
....................       ERROR_COUNTER[5]++;
....................    }
....................   #endif
.................... 
....................    UEIR = 0;
*
03EC:  CLRF   F6A
....................    
....................    //UIR_UERR = 0;
....................    UIR &= ~(1 << BIT_UERR);
03EE:  BCF    F68.1
03F0:  GOTO   13BC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_uidle()
.................... /*
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_uidle(void)
.................... {
....................    debug_usb_control(debug_putc, "-I-");
.................... 
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice)
*
0592:  BSF    F69.2
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
....................    // turn off isr instead of clearing flag
....................    UIE &= ~(unsigned int16)__USB_UIF_IDLE;
0594:  BCF    F69.4
....................   #else
....................    UIR &= ~(1 << BIT_IDLE);
....................   #endif
....................    
....................    UCON_SUSPND = 1; //set suspend. we are now suspended
0596:  BSF    F6D.1
0598:  GOTO   13D0 (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
.................... /* usb_isr_activity()
.................... /*
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB
.................... /*          peripheral.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_activity(void)
.................... {
....................    debug_usb_control(debug_putc, "-A-");
.................... 
....................    UCON_SUSPND = 0; //turn off low power suspending
*
03A2:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling
03A4:  BCF    F69.2
....................    
....................    while(UIR_ACTV)
03A6:  BTFSS  F68.2
03A8:  BRA    03AE
....................    {
....................       //UIR_ACTV = 0;
....................       UIR &= ~(1 << BIT_ACTV);
03AA:  BCF    F68.2
....................    }
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
03AC:  BRA    03A6
....................    // now it's safe to clear the flag
....................    UIR &= ~(1 << BIT_IDLE);
03AE:  BCF    F68.4
....................   #endif   
03B0:  GOTO   13A4 (RETURN)
.................... }
.................... 
.................... /******************************************************************************
.................... /* usb_isr_stall()
.................... /*
.................... /* Summary: Stall handshake detected.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_stall(void) 
.................... {
....................    debug_usb_control(debug_putc, "-S-");
....................    
....................    
....................    if (bit_test(UEP(0),0)) 
*
03DE:  BTFSS  F70.0
03E0:  BRA    03E6
....................    {
....................       usb_init_ep0_setup();
03E2:  RCALL  03B4
....................       bit_clear(UEP(0), 0);
03E4:  BCF    F70.0
....................    }
....................    
....................    //UIR_STALL = 0;
....................    UIR &= ~(1 << BIT_STALL);
03E6:  BCF    F68.5
03E8:  GOTO   13B2 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;}
*
05A2:  MOVFF  23B,23
05A6:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;}
*
0BFA:  MOVLW  FE
0BFC:  MOVWF  23
0BFE:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;}
*
05A8:  SETF   23
05AA:  RETURN 0
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_tok_dne()
.................... /*
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral.
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and
.................... /*          handle the request.
.................... /*          If an IN token on EP0 was received, continue transmitting any
.................... /*          unfinished requests that may take more than one packet to transmit
.................... /*          (if necessary).
.................... /*          If an OUT token on any other EP was received, mark that EP as ready
.................... /*          for a usb_get_packet().
.................... /*          Does not handle any IN or OUT tokens on EP0.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_tok_dne(void) 
.................... {
....................    unsigned int8 en;
.................... 
....................    en = USTATCopy>>3;
*
1290:  RRCF   21,W
1292:  MOVLB  2
1294:  MOVWF  x36
1296:  RRCF   x36,F
1298:  RRCF   x36,F
129A:  MOVLW  1F
129C:  ANDWF  x36,F
.................... 
....................    debug_usb_control(debug_putc, "-T%X-", USTATCopy);
.................... 
....................    if (USTATCopy == USTAT_OUT_SETUP_E0) 
129E:  MOVF   21,F
12A0:  BNZ   133E
....................    {
....................       //new out or setup token in the buffer
....................       int8 pidKey;
....................       
....................       //debug_usb(debug_putc,"%X ", EP_BDxST_O(0));
....................       
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID
12A2:  MOVLB  4
12A4:  MOVF   x00,W
12A6:  ANDLW  3C
12A8:  MOVLB  2
12AA:  MOVWF  x37
....................       
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion
12AC:  MOVLW  43
12AE:  MOVLB  4
12B0:  ANDWF  x00,F
....................       
....................       if (pidKey == USB_PIC_PID_SETUP) 
12B2:  MOVLB  2
12B4:  MOVF   x37,W
12B6:  SUBLW  34
12B8:  BNZ   1304
....................       {
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00)
12BA:  MOVLB  4
12BC:  MOVF   x04,W
12BE:  ANDLW  80
12C0:  BZ    12C4
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests)
12C2:  CLRF   x04
.................... 
....................          //debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0));
....................          //debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer);
.................... 
....................          usb_isr_tok_setup_dne();
12C4:  MOVLB  0
12C6:  BRA    0C9C
.................... 
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
12C8:  BCF    F6D.4
.................... 
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall())
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data())
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response())
....................          if (__setup_0_tx_size == 0xFF)
12CA:  INCFSZ 23,W
12CC:  BRA    12DC
....................             usb_flush_out(0, USB_DTS_STALL);
12CE:  MOVLB  2
12D0:  CLRF   x39
12D2:  MOVLW  03
12D4:  MOVWF  x3A
12D6:  MOVLB  0
12D8:  RCALL  0CCE
12DA:  BRA    1300
....................          else 
....................          {
....................             usb_flush_out(0, USB_DTS_TOGGLE);
12DC:  MOVLB  2
12DE:  CLRF   x39
12E0:  MOVLW  02
12E2:  MOVWF  x3A
12E4:  MOVLB  0
12E6:  RCALL  0CCE
....................             if (__setup_0_tx_size != 0xFE)
12E8:  MOVF   23,W
12EA:  SUBLW  FE
12EC:  BZ    1300
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX);
12EE:  MOVLB  2
12F0:  CLRF   x42
12F2:  CLRF   x44
12F4:  MOVFF  23,243
12F8:  MOVLW  04
12FA:  MOVWF  x45
12FC:  MOVLB  0
12FE:  RCALL  0E24
....................          }
....................          //why was this here?
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
....................       }
1300:  BRA    133A
1302:  MOVLB  2
....................       else if (pidKey == USB_PIC_PID_OUT) 
1304:  MOVF   x37,W
1306:  SUBLW  04
1308:  BNZ   133C
....................       {
....................          usb_isr_tok_out_dne(0);
130A:  CLRF   x38
130C:  MOVLB  0
130E:  RCALL  1026
....................          usb_flush_out(0, USB_DTS_TOGGLE);
1310:  MOVLB  2
1312:  CLRF   x39
1314:  MOVLW  02
1316:  MOVWF  x3A
1318:  MOVLB  0
131A:  RCALL  0CCE
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF))
131C:  MOVF   23,W
131E:  SUBLW  FE
1320:  BZ    133A
1322:  INCFSZ 23,W
1324:  BRA    1328
1326:  BRA    133A
....................          {
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len)
1328:  MOVLB  2
132A:  CLRF   x42
132C:  CLRF   x44
132E:  MOVFF  23,243
1332:  MOVLW  01
1334:  MOVWF  x45
1336:  MOVLB  0
1338:  RCALL  0E24
133A:  MOVLB  2
....................          }
....................       }
....................       //else
....................       //{
....................       //   debug_usb(debug_putc, "!!! ");
....................       //}
....................    }
133C:  BRA    1382
....................    else if (USTATCopy == USTAT_IN_E0) 
133E:  MOVF   21,W
1340:  SUBLW  04
1342:  BNZ   1368
....................    {   
....................       //pic -> host transfer completed
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion
....................       __setup_0_tx_size = 0xFF;
1344:  SETF   23
....................       usb_isr_tok_in_dne(0);
1346:  CLRF   x38
1348:  MOVLB  0
134A:  RCALL  125E
....................       if (__setup_0_tx_size!=0xFF)
134C:  INCFSZ 23,W
134E:  BRA    1352
1350:  BRA    1364
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE);
1352:  MOVLB  2
1354:  CLRF   x42
1356:  CLRF   x44
1358:  MOVFF  23,243
135C:  MOVLW  02
135E:  MOVWF  x45
1360:  MOVLB  0
1362:  RCALL  0E24
....................       else
....................       {
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................       }  
....................    }
1364:  BRA    1380
1366:  MOVLB  2
....................    else 
....................    {
....................       if (!bit_test(USTATCopy, 2)) 
1368:  BTFSC  21.2
136A:  BRA    1378
....................       {
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_out_dne(en);
136C:  MOVFF  236,238
1370:  MOVLB  0
1372:  RCALL  1026
....................       }
1374:  BRA    1380
1376:  MOVLB  2
....................       else 
....................       {
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_in_dne(en);
1378:  MOVFF  236,238
137C:  MOVLB  0
137E:  RCALL  125E
1380:  MOVLB  2
....................       }
....................    }
1382:  MOVLB  0
1384:  GOTO   13F2 (RETURN)
.................... }
.................... 
.................... /// END USB Interrupt Service Routine
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... #if defined(__PIC24_USB_H__)
....................  #include <pic24_usb.c>
.................... #endif
.................... 
.................... #if defined(__USBN960X_H__)
....................  #include <usbn960x.c>
.................... #endif
.................... 
.................... 
.................... #IFNDEF __USB_HARDWARE__
....................    #ERROR You must include USB hardware driver.
.................... #ENDIF
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
....................    #ERROR You must include USB descriptors.
.................... #ENDIF
.................... 
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1))
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  64
.................... #else
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  8
.................... #endif
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors
.................... 
.................... #IF USB_HID_BOOT_PROTOCOL
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES];
.................... #ENDIF
.................... 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size);
.................... 
.................... void usb_isr_tkn_setup_StandardEndpoint(void);
.................... void usb_isr_tkn_setup_StandardDevice(void);
.................... void usb_isr_tkn_setup_StandardInterface(void);
.................... #IF USB_HID_DEVICE
....................    void usb_isr_tkn_setup_ClassInterface(void);
.................... #ENDIF
.................... void usb_Get_Descriptor(void);
.................... void usb_copy_desc_seg_to_ep(void);
.................... void usb_finish_set_address(void);
.................... 
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors
.................... 
.................... /// BEGIN User Functions
.................... 
.................... // see usb.h for documentation
.................... int1 usb_enumerated(void)
.................... {
....................    return(USB_stack_status.curr_config);
*
14D4:  MOVF   1B,W
14D6:  MOVWF  01
14D8:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_wait_for_enumeration(void) 
.................... {
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();}
.................... }
.................... 
.................... // see USB.H for documentation
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) {
....................    unsigned int16 i=0;
....................    int1 res;
....................    unsigned int16 this_packet_len;
....................    unsigned int16 packet_size;
....................    unsigned int32 timeout_1us;
.................... 
....................    packet_size = usb_ep_tx_size[endpoint];
....................    
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size);
.................... 
....................    //send data packets until timeout or no more packets to send
....................    while (i < len) 
....................    {
....................       timeout_1us = (int32)timeout*1000;
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;}
....................       else {this_packet_len = len-i;}
....................       //putc('*');
....................       do 
....................       {
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets
....................          //putc('.');
....................          if (!res)
....................          {
....................             delay_us(1);
....................             //delay_ms(500);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................       i += packet_size;
....................    }
.................... 
.................... 
....................    //send 0len packet if needed
....................    if (i==len) {
....................       timeout_1us=(int32)timeout*1000;
....................       do {
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message
....................          if (!res) {
....................             delay_us(1);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................    }
.................... 
....................    return(res);
.................... }
.................... 
.................... // see usb.h for documentation
.................... unsigned int16 usb_gets(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max, unsigned int16 timeout) {
....................    unsigned int16 ret=0;
....................    unsigned int16 to;
....................    unsigned int16 len;
....................    unsigned int16 packet_size;
....................    unsigned int16 this_packet_max;
.................... 
....................    packet_size=usb_ep_rx_size[endpoint];
.................... 
....................    do {
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;}
....................       to=0;
....................       do {
....................          len = packet_size;
....................          if (usb_kbhit(endpoint)) {
....................             len=usb_get_packet(endpoint,ptr,this_packet_max);
....................             ptr+=len;
....................             max-=len;
....................             ret+=len;
....................             break;
....................          }
....................          else {
....................             to++;
....................             delay_ms(1);
....................          }
....................       } while (to!=timeout);
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max);
.................... 
....................    return(ret);
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR)
.................... 
.................... // see usb.h for documentation
.................... void usb_token_reset(void) 
.................... {
....................    unsigned int i;
.................... 
....................    usb_getdesc_len = 0;
*
0532:  CLRF   28
0534:  CLRF   27
....................    
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++) 
0536:  MOVLB  2
0538:  CLRF   x36
053A:  MOVF   x36,W
053C:  SUBLW  01
053E:  BNC   0554
....................       USB_Interface[i] = 0;   //reset each interface to default
0540:  CLRF   03
0542:  MOVF   x36,W
0544:  ADDLW  29
0546:  MOVWF  FE9
0548:  MOVLW  00
054A:  ADDWFC 03,W
054C:  MOVWF  FEA
054E:  CLRF   FEF
.................... 
....................   #IF USB_HID_BOOT_PROTOCOL
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++)
....................       hid_protocol[i] = 1;
....................   #endif
.................... 
....................   #if USB_CDC_DEVICE
0550:  INCF   x36,F
0552:  BRA    053A
....................    usb_cdc_init();
0554:  MOVLB  0
0556:  RCALL  04F2
....................   #endif
.................... 
....................    USB_stack_status.curr_config = 0;      //unconfigured device
0558:  CLRF   1B
.................... 
....................    USB_stack_status.status_device = 1;    //previous state.  init at none
055A:  MOVLW  01
055C:  MOVWF  1C
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none
055E:  CLRF   1A
0560:  RETURN 0
.................... }
.................... 
.................... //send a 0len packet to endpoint 0 (optimization)
.................... //notice that this doesnt return the status
.................... #define usb_put_0len_0() usb_request_send_response(0)
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    direction = bit_test(endpoint,7);
*
03F4:  MOVLB  2
03F6:  BCF    x43.0
03F8:  BTFSC  x42.7
03FA:  BSF    x43.0
....................    
....................    endpoint &= 0x7F;
03FC:  BCF    x42.7
....................    
....................    if (endpoint > 16)
03FE:  MOVF   x42,W
0400:  SUBLW  10
0402:  BC    040A
....................       return(false);
0404:  MOVLW  00
0406:  MOVWF  01
0408:  BRA    043E
....................    
....................    if (direction) { //IN
040A:  BTFSS  x43.0
040C:  BRA    0428
....................       return(usb_ep_tx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
040E:  CLRF   03
0410:  MOVF   x42,W
0412:  MOVLB  0
0414:  RCALL  00BA
0416:  SUBLW  FF
0418:  BNZ   041E
041A:  MOVLW  00
041C:  BRA    0420
041E:  MOVLW  01
0420:  MOVWF  01
0422:  MOVLB  2
0424:  BRA    043E
....................    }
0426:  BRA    043E
....................    else {   //OUT
....................       return(usb_ep_rx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
0428:  CLRF   03
042A:  MOVF   x42,W
042C:  MOVLB  0
042E:  RCALL  00DA
0430:  SUBLW  FF
0432:  BNZ   0438
0434:  MOVLW  00
0436:  BRA    043A
0438:  MOVLW  01
043A:  MOVWF  01
043C:  MOVLB  2
....................    }
043E:  MOVLB  0
0440:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) {
....................    if (endpoint==0) {
*
125E:  MOVLB  2
1260:  MOVF   x38,F
1262:  BNZ   1280
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor?
1264:  DECFSZ 1A,W
1266:  BRA    1272
1268:  MOVLB  0
126A:  CALL   05AC
126E:  BRA    127C
1270:  MOVLB  2
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();}
1272:  MOVF   1A,W
1274:  SUBLW  02
1276:  BNZ   127E
1278:  MOVLB  0
127A:  BRA    105E
127C:  MOVLB  2
....................    }
....................   #if USB_CDC_DEVICE
127E:  BRA    128C
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
1280:  MOVF   x38,W
1282:  SUBLW  02
1284:  BNZ   128C
....................       usb_isr_tok_in_cdc_data_dne();
1286:  MOVLB  0
1288:  BRA    1258
128A:  MOVLB  2
....................   }
....................   #endif
128C:  MOVLB  0
128E:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint)
.................... {
....................    //TODO:
....................    if (endpoint==0) {
*
1026:  MOVLB  2
1028:  MOVF   x38,F
102A:  BNZ   1034
....................      debug_usb(debug_putc,"TOUT 0 ");
....................      #if USB_CDC_DEVICE
....................       usb_isr_tok_out_cdc_control_dne();
102C:  MOVLB  0
102E:  BRA    0F70
....................      //#else   //REMOVED JUN/9/2009
....................      //usb_init_ep0_setup();
....................      #endif
....................    }
....................   #if USB_CDC_DEVICE
1030:  BRA    103E
1032:  MOVLB  2
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
1034:  MOVF   x38,W
1036:  SUBLW  02
1038:  BNZ   1040
....................       usb_isr_tok_out_cdc_data_dne();
103A:  MOVLB  0
103C:  BRA    100A
103E:  MOVLB  2
....................    }
....................   #endif
1040:  MOVLB  0
1042:  RETURN 0
....................    //else {
....................    //   bit_set(__usb_kbhit_status,endpoint);
....................    //}
.................... }
.................... 
.................... 
.................... //---- process setup message stage -----------//
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_setup_dne(void) 
.................... {
....................    USB_stack_status.dev_req=NONE; // clear the device request..
*
0C9C:  CLRF   1A
.................... 
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) {
0C9E:  MOVLB  4
0CA0:  MOVF   x18,W
0CA2:  ANDLW  7F
0CA4:  XORLW  00
0CA6:  MOVLB  0
0CA8:  BZ    0CB8
0CAA:  XORLW  01
0CAC:  BZ    0CBC
0CAE:  XORLW  03
0CB0:  BZ    0CC0
0CB2:  XORLW  23
0CB4:  BZ    0CC4
0CB6:  BRA    0CC8
.................... 
....................       case 0x00:  //standard to device
....................          debug_usb_token(debug_putc," d");
....................          usb_isr_tkn_setup_StandardDevice();
0CB8:  BRA    08DC
....................          break;
0CBA:  BRA    0CCA
.................... 
....................       case 0x01:  //standard to interface
....................          debug_usb_token(debug_putc," i");
....................          usb_isr_tkn_setup_StandardInterface();
0CBC:  BRA    0998
....................          break;
0CBE:  BRA    0CCA
.................... 
....................       case 0x02:  //standard to endpoint
....................          debug_usb_token(debug_putc," e");
....................          usb_isr_tkn_setup_StandardEndpoint();
0CC0:  BRA    0B90
....................          break;
0CC2:  BRA    0CCA
....................          
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case 0x21:  //class specific request.  the only class this driver supports is HID
....................          debug_usb_token(debug_putc, " class");
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE)
....................          {
....................             usb_isr_tkn_setup_ClassInterface();
....................          }
....................          else
....................          {
....................             usb_isr_tkn_cdc();
....................          }
....................         #elif USB_HID_DEVICE
....................          usb_isr_tkn_setup_ClassInterface();
....................         #else
....................          usb_isr_tkn_cdc();
0CC4:  BRA    0C00
....................         #endif
....................          break;
0CC6:  BRA    0CCA
.................... #endif
.................... 
.................... 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE
.................... 
....................       default:
....................          usb_request_stall();
0CC8:  RCALL  05A8
....................          break;
....................    }
0CCA:  GOTO   12C8 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardDevice()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Device request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardDevice(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
*
08DC:  MOVLB  4
08DE:  MOVF   x19,W
08E0:  XORLW  00
08E2:  MOVLB  0
08E4:  BZ    0900
08E6:  XORLW  01
08E8:  BZ    0914
08EA:  XORLW  02
08EC:  BZ    0930
08EE:  XORLW  06
08F0:  BZ    094A
08F2:  XORLW  03
08F4:  BZ    095C
08F6:  XORLW  0E
08F8:  BZ    0960
08FA:  XORLW  01
08FC:  BZ    0970
08FE:  BRA    0992
.................... 
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device;
0900:  MOVFF  1C,458
....................             usb_ep0_tx_buffer[1]=0;
0904:  MOVLB  4
0906:  CLRF   x59
....................             usb_request_send_response(2);
0908:  MOVLW  02
090A:  MOVLB  2
090C:  MOVWF  x3B
090E:  MOVLB  0
0910:  RCALL  05A2
....................             break;
0912:  BRA    0994
.................... 
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1
....................             if (usb_ep0_rx_buffer[2] == 1) {
0914:  MOVLB  4
0916:  DECFSZ x1A,W
0918:  BRA    092A
....................                debug_usb_token(debug_putc,"CF");
....................                USB_stack_status.status_device &= 1;
091A:  MOVLW  01
091C:  ANDWF  1C,F
....................                usb_put_0len_0();
091E:  MOVLB  2
0920:  CLRF   x3B
0922:  MOVLB  0
0924:  RCALL  05A2
....................             }
0926:  BRA    092E
0928:  MOVLB  4
....................             else
....................                usb_request_stall();
092A:  MOVLB  0
092C:  RCALL  05A8
....................             break;
092E:  BRA    0994
.................... 
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3
....................             if (usb_ep0_rx_buffer[2] == 1) {
0930:  MOVLB  4
0932:  DECFSZ x1A,W
0934:  BRA    0944
....................                debug_usb_token(debug_putc,"SF");
....................                USB_stack_status.status_device |= 2;
0936:  BSF    1C.1
....................                usb_put_0len_0();
0938:  MOVLB  2
093A:  CLRF   x3B
093C:  MOVLB  0
093E:  RCALL  05A2
....................             }
0940:  BRA    0948
0942:  MOVLB  4
....................             else
....................                usb_request_stall();
0944:  MOVLB  0
0946:  RCALL  05A8
....................             break;
0948:  BRA    0994
.................... 
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5
....................             debug_usb_token(debug_putc,"SA");
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request
094A:  MOVLW  02
094C:  MOVWF  1A
....................             USB_address_pending=usb_ep0_rx_buffer[2];
094E:  MOVFF  41A,24
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request
....................             usb_set_address(USB_address_pending);
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0
....................             #endif
....................             usb_put_0len_0();
0952:  MOVLB  2
0954:  CLRF   x3B
0956:  MOVLB  0
0958:  RCALL  05A2
....................             break;
095A:  BRA    0994
.................... 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6
....................             debug_usb_token(debug_putc,"GD");
....................             usb_Get_Descriptor();
095C:  BRA    0634
....................             break;
095E:  BRA    0994
.................... 
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8
....................             debug_usb_token(debug_putc,"GC");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config;
0960:  MOVFF  1B,458
....................             usb_request_send_response(1);
0964:  MOVLW  01
0966:  MOVLB  2
0968:  MOVWF  x3B
096A:  MOVLB  0
096C:  RCALL  05A2
....................             break;
096E:  BRA    0994
.................... 
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) {
0970:  MOVLB  4
0972:  MOVF   x1A,W
0974:  SUBLW  01
0976:  BNC   098E
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2];
0978:  MOVFF  41A,1B
....................                usb_set_configured(usb_ep0_rx_buffer[2]);
097C:  MOVFF  41A,238
0980:  MOVLB  0
0982:  BRA    06F2
....................                debug_usb_token(debug_putc,"SC%U", USB_stack_status.curr_config);               
....................                usb_put_0len_0();
0984:  MOVLB  2
0986:  CLRF   x3B
0988:  MOVLB  0
098A:  RCALL  05A2
098C:  MOVLB  4
....................             }
....................             break;
098E:  MOVLB  0
0990:  BRA    0994
.................... 
....................       default:
....................             usb_request_stall();
0992:  RCALL  05A8
....................             break;
....................    }
0994:  GOTO   0CCA (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Interface request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardInterface(void) {
....................    unsigned int8 curr_config;
.................... 
....................    curr_config=USB_stack_status.curr_config;
0998:  MOVFF  1B,238
.................... 
....................    switch (usb_ep0_rx_buffer[1]) {
099C:  MOVLB  4
099E:  MOVF   x19,W
09A0:  XORLW  00
09A2:  MOVLB  0
09A4:  BZ    09B0
09A6:  XORLW  0A
09A8:  BZ    09C2
09AA:  XORLW  01
09AC:  BZ    0A08
09AE:  BRA    0A34
....................       case USB_STANDARD_REQUEST_GET_STATUS:
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=0;
09B0:  MOVLB  4
09B2:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0;
09B4:  CLRF   x59
....................             usb_request_send_response(2);
09B6:  MOVLW  02
09B8:  MOVLB  2
09BA:  MOVWF  x3B
09BC:  MOVLB  0
09BE:  RCALL  05A2
....................             break;
09C0:  BRA    0A36
.................... 
....................       case USB_STANDARD_REQUEST_GET_INTERFACE:
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state
09C2:  MOVLB  2
09C4:  MOVF   x38,F
09C6:  BZ    0A02
09C8:  MOVLW  01
09CA:  SUBWF  x38,W
09CC:  CLRF   03
09CE:  MOVLB  0
09D0:  CALL   01AE
09D4:  MOVWF  01
09D6:  MOVLB  4
09D8:  SUBWF  x1C,W
09DA:  BTFSS  FD8.0
09DC:  BRA    09E2
09DE:  MOVLB  2
09E0:  BRA    0A02
....................                debug_usb_token(debug_putc,"GI");
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte
09E2:  CLRF   03
09E4:  MOVF   x1C,W
09E6:  ADDLW  29
09E8:  MOVWF  FE9
09EA:  MOVLW  00
09EC:  ADDWFC 03,W
09EE:  MOVWF  FEA
09F0:  MOVFF  FEF,458
....................                usb_request_send_response(1); //send byte back
09F4:  MOVLW  01
09F6:  MOVLB  2
09F8:  MOVWF  x3B
09FA:  MOVLB  0
09FC:  RCALL  05A2
....................             }
09FE:  BRA    0A06
0A00:  MOVLB  2
....................             else
....................                usb_request_stall();
0A02:  MOVLB  0
0A04:  RCALL  05A8
....................             break;
0A06:  BRA    0A36
.................... 
....................       case USB_STANDARD_REQUEST_SET_INTERFACE:
....................             if (curr_config) { //if configured state
0A08:  MOVLB  2
0A0A:  MOVF   x38,F
0A0C:  BZ    0A2E
....................                debug_usb_token(debug_putc,"SI");
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
0A0E:  CLRF   03
0A10:  MOVLB  4
0A12:  MOVF   x1C,W
0A14:  ADDLW  29
0A16:  MOVWF  FE9
0A18:  MOVLW  00
0A1A:  ADDWFC 03,W
0A1C:  MOVWF  FEA
0A1E:  MOVFF  41A,FEF
....................                usb_put_0len_0();
0A22:  MOVLB  2
0A24:  CLRF   x3B
0A26:  MOVLB  0
0A28:  RCALL  05A2
....................             }
0A2A:  BRA    0A32
0A2C:  MOVLB  2
....................             else
....................                usb_request_stall();
0A2E:  MOVLB  0
0A30:  RCALL  05A8
....................             break;
0A32:  BRA    0A36
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR:
....................             debug_usb_token(debug_putc,"GDh");
....................             usb_Get_Descriptor();
....................             break;
.................... #endif
.................... 
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE:
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE:
.................... //                let default take care of these, goto wrongstate
....................       default:
....................             usb_request_stall();
0A34:  RCALL  05A8
....................             break;
....................    }
0A36:  GOTO   0CCA (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardEndpoint()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardEndpoint(void) {
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) {
*
0B90:  MOVFF  41C,242
0B94:  RCALL  03F4
0B96:  MOVF   01,F
0B98:  BZ    0BF6
....................       switch(usb_ep0_rx_buffer[1]) {
0B9A:  MOVLB  4
0B9C:  MOVF   x19,W
0B9E:  XORLW  01
0BA0:  MOVLB  0
0BA2:  BZ    0BAE
0BA4:  XORLW  02
0BA6:  BZ    0BBE
0BA8:  XORLW  03
0BAA:  BZ    0BCE
0BAC:  BRA    0BF4
.................... 
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE:
....................                debug_usb_token(debug_putc,"CF");
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]);
0BAE:  MOVFF  41C,238
0BB2:  BRA    0A3A
....................                usb_put_0len_0();
0BB4:  MOVLB  2
0BB6:  CLRF   x3B
0BB8:  MOVLB  0
0BBA:  RCALL  05A2
....................                break;
0BBC:  BRA    0BF6
.................... 
....................          case USB_STANDARD_REQUEST_SET_FEATURE:
....................                      debug_usb_token(debug_putc,"SF");
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]);
0BBE:  MOVFF  41C,238
0BC2:  BRA    0AB4
....................                      usb_put_0len_0();
0BC4:  MOVLB  2
0BC6:  CLRF   x3B
0BC8:  MOVLB  0
0BCA:  RCALL  05A2
....................                      break;
0BCC:  BRA    0BF6
.................... 
....................          case USB_STANDARD_REQUEST_GET_STATUS:
....................                debug_usb_token(debug_putc,"GS");
....................                usb_ep0_tx_buffer[0]=0;
0BCE:  MOVLB  4
0BD0:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0;
0BD2:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) {
0BD4:  MOVFF  41C,238
0BD8:  MOVLB  0
0BDA:  BRA    0B1A
0BDC:  MOVF   01,F
0BDE:  BZ    0BE8
....................                   usb_ep0_tx_buffer[0]=1;
0BE0:  MOVLW  01
0BE2:  MOVLB  4
0BE4:  MOVWF  x58
0BE6:  MOVLB  0
....................                }
....................                usb_request_send_response(2);
0BE8:  MOVLW  02
0BEA:  MOVLB  2
0BEC:  MOVWF  x3B
0BEE:  MOVLB  0
0BF0:  RCALL  05A2
....................                break;
0BF2:  BRA    0BF6
.................... 
....................          default:
....................             usb_request_stall();
0BF4:  RCALL  05A8
....................             break;
....................       }
....................    }
0BF6:  GOTO   0CCA (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_ClassInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /* Only compiled if HID_DEVICE is TRUE
.................... /***************************************************************/
.................... #IF USB_HID_DEVICE
.................... void usb_isr_tkn_setup_ClassInterface(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03
....................             debug_usb_token(debug_putc,"GP");
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]];
....................             usb_request_send_response(1);
....................             break;
....................     #ENDIF
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b
....................             debug_usb_token(debug_putc,"SP");
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
....................             usb_put_0len_0(); //send 0len packet69
....................             break;
....................     #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_SET_IDLE:   //0a
....................          #error TODO: if you want to support SET_IDLE, add code here
....................    #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_GET_IDLE:   //02
....................          #error TODO: if you want to support GET_IDLE, add code here
....................    #ENDIF
.................... 
....................       default:
....................             usb_request_stall();
....................             break;
....................    }
.................... }
.................... #ENDIF
.................... 
.................... /**************************************************************
.................... /* usb_Get_Descriptor()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept
.................... /*
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.),
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have
.................... /*          pointers to constants we must simulate or own by setting up global registers that say
.................... /*          which constant array to deal with, which position to start in this array, and the length.
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne()
.................... /*          which will send the rest of the data.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_Get_Descriptor() {
*
0634:  MOVLB  2
0636:  CLRF   x38
....................    unsigned int8 i = 0;
....................    usb_getdesc_ptr=0;
0638:  CLRF   26
063A:  CLRF   25
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE;
063C:  CLRF   1D
.................... 
....................    switch(usb_ep0_rx_buffer[3]) {
063E:  MOVLB  4
0640:  MOVF   x1B,W
0642:  XORLW  01
0644:  MOVLB  0
0646:  BZ    0656
0648:  XORLW  03
064A:  BZ    0662
064C:  XORLW  01
064E:  BZ    066A
0650:  XORLW  22
0652:  BZ    06A2
0654:  BRA    06CC
....................       case USB_DESC_DEVICE_TYPE:    //1
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN;
0656:  CLRF   28
0658:  MOVLW  12
065A:  MOVWF  27
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE;
065C:  MOVLW  03
065E:  MOVWF  1D
....................             break;
0660:  BRA    06D0
.................... 
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually.
....................       case USB_DESC_CONFIG_TYPE:   //2
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN;
0662:  CLRF   28
0664:  MOVLW  43
0666:  MOVWF  27
....................             break;
0668:  BRA    06D0
.................... 
....................       case USB_DESC_STRING_TYPE: //3
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE;
066A:  MOVLW  02
066C:  MOVWF  1D
....................             //usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]];
....................             for(i=0; i<usb_ep0_rx_buffer[2]; i++)
066E:  MOVLB  2
0670:  CLRF   x38
0672:  MOVLB  4
0674:  MOVF   x1A,W
0676:  MOVLB  2
0678:  SUBWF  x38,W
067A:  BC    0692
....................             {
....................                usb_getdesc_ptr += USB_STRING_DESC[usb_getdesc_ptr];
067C:  MOVFF  26,03
0680:  MOVF   25,W
0682:  MOVLB  0
0684:  RCALL  01FA
0686:  ADDWF  25,F
0688:  MOVLW  00
068A:  ADDWFC 26,F
068C:  MOVLB  2
068E:  INCF   x38,F
0690:  BRA    0672
....................             }
....................             usb_getdesc_len = USB_STRING_DESC[usb_getdesc_ptr];
0692:  MOVFF  26,03
0696:  MOVF   25,W
0698:  MOVLB  0
069A:  RCALL  01FA
069C:  MOVWF  27
069E:  CLRF   28
....................             break;
06A0:  BRA    06D0
.................... 
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06
....................       // this is needed so host can find out about differences about this
....................       // devices ability to handle full speed verses fast speed.
....................       // since we don't support fast speed then we ignore this.
....................       //      break;
.................... 
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case USB_DESC_CLASS_TYPE:  //0x21
....................             //TODO does this work for multiple interfaces or multiple languages?
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]];
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]];
06A2:  CLRF   03
06A4:  MOVLB  4
06A6:  MOVF   x1A,W
06A8:  MOVLB  0
06AA:  RCALL  01C0
06AC:  MOVWF  25
06AE:  CLRF   26
....................             if (usb_getdesc_ptr!=0xFF) {
06B0:  INCFSZ 25,W
06B2:  BRA    06B8
06B4:  MOVF   26,F
06B6:  BZ    06C8
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr];
06B8:  MOVFF  26,03
06BC:  MOVF   25,W
06BE:  RCALL  015A
06C0:  MOVWF  27
06C2:  CLRF   28
....................                break;
06C4:  BRA    06D0
....................             }
06C6:  BRA    06CC
....................             else {
....................                usb_request_stall();
06C8:  RCALL  05A8
....................                return;
06CA:  BRA    06EE
....................             }
.................... #endif
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_DESC_HIDREPORT_TYPE: //0x22
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]];
....................             if (usb_getdesc_ptr !=0xFF) {
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE;
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]];
....................                break;
....................             }
....................             else {
....................                usb_request_stall();
....................                return;
....................             }
.................... #endif
.................... 
....................       default:
....................             usb_request_stall();
06CC:  RCALL  05A8
....................             return;
06CE:  BRA    06EE
....................    }
....................    if (usb_ep0_rx_buffer[7]==0) {
06D0:  MOVLB  4
06D2:  MOVF   x1F,F
06D4:  BNZ   06E6
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6])
06D6:  MOVF   28,F
06D8:  BNZ   06E0
06DA:  MOVF   27,W
06DC:  SUBWF  x1E,W
06DE:  BC    06E6
....................          usb_getdesc_len = usb_ep0_rx_buffer[6];
06E0:  CLRF   28
06E2:  MOVFF  41E,27
....................    }
....................    USB_stack_status.dev_req=GET_DESCRIPTOR;
06E6:  MOVLW  01
06E8:  MOVWF  1A
....................    usb_copy_desc_seg_to_ep();
06EA:  MOVLB  0
06EC:  RCALL  05AC
06EE:  GOTO   0994 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_finish_set_address()
.................... /*
.................... /* Input: USB_address_pending holds the address we were asked to set to.
.................... /*
.................... /* Summary: Sets the address.
.................... /*
.................... /* This code should only be run on the PIC USB peripheral, and not the
.................... /* National peripheral.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
....................  void usb_finish_set_address() {
....................    debug_usb_token(debug_putc," FSA ");
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0
*
105E:  CLRF   1B
.................... 
....................    #ifdef __PIC__
....................    USB_stack_status.dev_req=NONE;  // no request pending
1060:  CLRF   1A
....................    usb_set_address(USB_address_pending);
1062:  MOVFF  24,239
1066:  BRA    1044
....................    #endif
1068:  GOTO   127C (RETURN)
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// The following function retrieve data from constant arrays.  This may
.................... /// look un-optimized, but remember that you can't create a pointer to
.................... /// a constant array.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... void usb_copy_desc_seg_to_ep(void) {
*
05AC:  MOVLB  2
05AE:  CLRF   x39
....................    unsigned int i=0;
....................    char c;
....................    
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]);
.................... 
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH))
05B0:  MOVF   27,W
05B2:  IORWF  28,W
05B4:  BZ    061C
05B6:  MOVF   x39,W
05B8:  SUBLW  3F
05BA:  BNC   061C
....................    {
....................       switch(USB_stack_status.getdesc_type) {
05BC:  MOVF   1D,W
05BE:  XORLW  00
05C0:  MOVLB  0
05C2:  BZ    05CE
05C4:  XORLW  02
05C6:  BZ    05DC
05C8:  XORLW  01
05CA:  BZ    05EA
05CC:  BRA    05F6
....................          case USB_GETDESC_CONFIG_TYPE:
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr];
05CE:  MOVFF  26,03
05D2:  MOVF   25,W
05D4:  RCALL  015A
05D6:  MOVFF  FE8,23A
....................             break;
05DA:  BRA    05F6
.................... 
....................         #IF USB_HID_DEVICE
....................          case USB_GETDESC_HIDREPORT_TYPE:
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr];
....................             break;
....................         #endif
.................... 
....................          case USB_GETDESC_STRING_TYPE:
....................             c=USB_STRING_DESC[usb_getdesc_ptr];
05DC:  MOVFF  26,03
05E0:  MOVF   25,W
05E2:  RCALL  01FA
05E4:  MOVFF  FE8,23A
....................             break;
05E8:  BRA    05F6
.................... 
....................          case USB_GETDESC_DEVICE_TYPE:
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr];
05EA:  MOVFF  26,03
05EE:  MOVF   25,W
05F0:  RCALL  01D8
05F2:  MOVFF  FE8,23A
....................             //debug_usb(debug_putc, "-%X- ", c);
....................             break;
....................       }
....................       usb_getdesc_ptr++;
05F6:  INCF   25,F
05F8:  BTFSC  FD8.2
05FA:  INCF   26,F
....................       usb_getdesc_len--;
05FC:  MOVF   27,W
05FE:  BTFSC  FD8.2
0600:  DECF   28,F
0602:  DECF   27,F
....................       usb_ep0_tx_buffer[i++]=c;
0604:  MOVLB  2
0606:  MOVF   x39,W
0608:  INCF   x39,F
060A:  ADDLW  58
060C:  MOVWF  FE9
060E:  MOVLW  04
0610:  MOVWF  FEA
0612:  BTFSC  FD8.0
0614:  INCF   FEA,F
0616:  MOVFF  23A,FEF
061A:  BRA    05B0
....................    }
.................... 
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) {
061C:  MOVF   27,W
061E:  IORWF  28,W
0620:  BNZ   062A
0622:  MOVF   x39,W
0624:  SUBLW  40
0626:  BZ    062A
....................          USB_stack_status.dev_req = NONE;
0628:  CLRF   1A
....................    }
.................... 
....................    usb_request_send_response(i);
062A:  MOVFF  239,23B
062E:  MOVLB  0
0630:  RCALL  05A2
0632:  RETURN 0
.................... }
.................... 
.................... #ENDIF
.................... 
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk
....................    transfer endpoints is not supported on slow speed devices per the USB
....................    specification.  You may be able to find unofficial drivers for your
....................    operating system that allows CDC to operate on a slow speed device,
....................    but CCS doesn't have any that they can recommend to you.
.................... */
.................... #if (USB_USE_FULL_SPEED==0)
....................    #error CDC and slow speed is not supported.  See comments above.
.................... #endif
.................... 
.................... struct {
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2)
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space)
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16)
.................... } __attribute__((__packed__)) usb_cdc_line_coding;
.................... 
.................... //length of time, in ms, of break signal as we received in a SendBreak message.
.................... //if ==0xFFFF, send break signal until we receive a 0x0000.
.................... unsigned int16 usb_cdc_break;
.................... 
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1];
.................... #else
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE];
.................... #endif
.................... 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT)
.................... #if sizeof(usb_cdc_put_buffer)>=0x100
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this.
....................  typedef unsigned int16 usb_cdc_tx_t;
.................... #else
....................  typedef unsigned int8 usb_cdc_tx_t;
.................... #endif
.................... 
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin;
.................... //#locate usb_cdc_put_buffer_nextin=0x1800
.................... 
.................... 
.................... #if defined(__PIC__)
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer
.................... #else
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE];
.................... #endif
.................... 
.................... int1 usb_cdc_got_set_line_coding;
.................... 
.................... struct  {
....................    int1 dte_present; //1=DTE present, 0=DTE not present
....................    int1 active;      //1=activate carrier, 0=deactivate carrier
....................    unsigned int reserved:6;
.................... } usb_cdc_carrier;
.................... 
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state;
.................... 
.................... /*
.................... #if defined(__PCH__)
....................  #byte INTCON=0xFF2
....................  #bit INT_GIE=INTCON.7
.................... #else
....................  #word SR=0x42
.................... #endif
.................... */
.................... 
.................... #if defined(USB_CDC_USE_ENCAPSULATED)
.................... unsigned int16 g_UsbCdcSendEncapsSize;
.................... #endif
.................... 
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data]
.................... void usb_isr_tok_out_cdc_control_dne(void) 
.................... {
....................    switch (__usb_cdc_state) {
*
0F70:  MOVF   xB7,W
0F72:  XORLW  01
0F74:  BZ    0F7C
0F76:  XORLW  03
0F78:  BZ    0F8A
0F7A:  BRA    0FB2
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state);
....................       case USB_CDC_OUT_COMMAND:
....................         #if defined(USB_CDC_USE_ENCAPSULATED)
....................          usb_cdc_SendEncapsulatedCommand(usb_ep0_rx_buffer, g_UsbCdcSendEncapsSize);
....................         #endif
....................          usb_put_0len_0();
0F7C:  MOVLB  2
0F7E:  CLRF   x3B
0F80:  MOVLB  0
0F82:  CALL   05A2
....................          __usb_cdc_state=0;
0F86:  CLRF   xB7
....................          break;
0F88:  BRA    0FB4
.................... 
....................     #if USB_MAX_EP0_PACKET_LENGTH==8
....................       case USB_CDC_WAIT_0LEN:
....................          usb_put_0len_0();
....................          __usb_cdc_state=0;
....................          break;
....................     #endif
.................... 
....................       case USB_CDC_OUT_LINECODING:
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7);
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n");
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7);
0F8A:  CLRF   FEA
0F8C:  MOVLW  2B
0F8E:  MOVWF  FE9
0F90:  MOVLW  04
0F92:  MOVWF  FE2
0F94:  MOVLW  18
0F96:  MOVWF  FE1
0F98:  MOVLW  07
0F9A:  MOVWF  01
0F9C:  MOVFF  FE6,FEE
0FA0:  DECFSZ 01,F
0FA2:  BRA    0F9C
....................          __usb_cdc_state=0;
0FA4:  CLRF   xB7
....................          usb_put_0len_0();
0FA6:  MOVLB  2
0FA8:  CLRF   x3B
0FAA:  MOVLB  0
0FAC:  CALL   05A2
....................          break;
0FB0:  BRA    0FB4
.................... 
....................       default:
....................          __usb_cdc_state=0;
0FB2:  CLRF   xB7
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................          break;
....................    }
0FB4:  GOTO   1030 (RETURN)
.................... }
.................... 
.................... //handle IN token on 0 (setup packet)
.................... void usb_isr_tkn_cdc(void) {
....................    unsigned int16 wLen;
....................    //make sure the request goes to a CDC interface
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) {
*
0C00:  MOVLB  4
0C02:  DECFSZ x1C,W
0C04:  BRA    0C08
0C06:  BRA    0C0C
0C08:  MOVF   x1C,F
0C0A:  BNZ   0C96
....................       wLen = make16(usb_ep0_rx_buffer[7], usb_ep0_rx_buffer[6]);
0C0C:  MOVFF  41F,239
0C10:  MOVFF  41E,238
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]);
....................       switch(usb_ep0_rx_buffer[1]) {
0C14:  MOVF   x19,W
0C16:  XORLW  00
0C18:  MOVLB  0
0C1A:  BZ    0C32
0C1C:  XORLW  01
0C1E:  BZ    0C3A
0C20:  XORLW  21
0C22:  BZ    0C42
0C24:  XORLW  01
0C26:  BZ    0C4C
0C28:  XORLW  03
0C2A:  BZ    0C72
0C2C:  XORLW  01
0C2E:  BZ    0C80
0C30:  BRA    0C92
....................          case 0x00:  //send_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             g_UsbCdcSendEncapsSize = wLen;
....................            #endif
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND;
0C32:  MOVLW  01
0C34:  MOVWF  xB7
....................             usb_request_get_data();
0C36:  RCALL  0BFA
....................             break;
0C38:  BRA    0C94
.................... 
....................          case 0x01:  //get_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             usb_cdc_GetEncapsulatedResponse(usb_ep0_tx_buffer, wLen);
....................            #endif
....................             usb_request_send_response(wLen);
0C3A:  MOVFF  238,23B
0C3E:  RCALL  05A2
....................             break;
0C40:  BRA    0C94
.................... 
....................          case 0x20:  //set_line_coding
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING;
0C42:  MOVLW  02
0C44:  MOVWF  xB7
....................             usb_cdc_got_set_line_coding=true;
0C46:  BSF    xB5.0
....................             usb_request_get_data();
0C48:  RCALL  0BFA
....................             break;
0C4A:  BRA    0C94
.................... 
....................          case 0x21:  //get_line_coding
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding));
0C4C:  MOVLW  04
0C4E:  MOVWF  FEA
0C50:  MOVLW  58
0C52:  MOVWF  FE9
0C54:  CLRF   FE2
0C56:  MOVLW  2B
0C58:  MOVWF  FE1
0C5A:  MOVLW  07
0C5C:  MOVWF  01
0C5E:  MOVFF  FE6,FEE
0C62:  DECFSZ 01,F
0C64:  BRA    0C5E
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes
0C66:  MOVLW  07
0C68:  MOVLB  2
0C6A:  MOVWF  x3B
0C6C:  MOVLB  0
0C6E:  RCALL  05A2
....................             break;
0C70:  BRA    0C94
.................... 
....................          case 0x22:  //set_control_line_state
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2];
0C72:  MOVFF  41A,B6
....................             usb_put_0len_0();
0C76:  MOVLB  2
0C78:  CLRF   x3B
0C7A:  MOVLB  0
0C7C:  RCALL  05A2
....................             break;
0C7E:  BRA    0C94
.................... 
....................          case 0x23:  //send_break
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]);
0C80:  MOVFF  41A,33
0C84:  MOVFF  41B,32
....................             usb_put_0len_0();
0C88:  MOVLB  2
0C8A:  CLRF   x3B
0C8C:  MOVLB  0
0C8E:  RCALL  05A2
....................             break;
0C90:  BRA    0C94
.................... 
....................          default:
....................             usb_request_stall();
0C92:  RCALL  05A8
....................             break;
0C94:  MOVLB  4
....................       }
....................    }
0C96:  MOVLB  0
0C98:  GOTO   0CCA (RETURN)
.................... }
.................... 
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars]
.................... void usb_isr_tok_out_cdc_data_dne(void) {
....................    usb_cdc_get_buffer_status.got=true;
*
100A:  BSF    1E.0
....................    usb_cdc_get_buffer_status.index=0;
100C:  CLRF   20
.................... #if (defined(__PIC__) && __PIC__)
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT);
100E:  MOVLW  02
1010:  MOVLB  2
1012:  MOVWF  x39
1014:  MOVLB  0
1016:  BRA    0FB8
1018:  MOVFF  01,1F
.................... #else
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer(
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE);
.................... #endif
....................    if (!usb_cdc_get_buffer_status.len)
101C:  MOVF   1F,F
101E:  BNZ   1022
....................    {
....................       usb_cdc_get_discard();
1020:  BRA    0FF8
....................    }
1022:  GOTO   103E (RETURN)
....................    /*
....................   #if defined(USB_CDC_ISR)
....................    else
....................    {
....................       USB_CDC_ISR();
....................    }
....................   #endif
....................   */
.................... }
.................... 
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters]
.................... void usb_isr_tok_in_cdc_data_dne(void) 
.................... {
....................    usb_cdc_flush_tx_buffer();
*
1258:  RCALL  11E6
125A:  GOTO   128A (RETURN)
.................... }
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
*
110A:  MOVFF  23E,244
110E:  MOVFF  23D,243
....................    sc2=s2;
1112:  MOVFF  240,246
1116:  MOVFF  23F,245
....................    if(sc2<sc1 && sc1 <sc2 +n)
111A:  MOVLB  2
111C:  MOVF   x46,W
111E:  SUBWF  x44,W
1120:  BNC   119A
1122:  BNZ   112A
1124:  MOVF   x43,W
1126:  SUBWF  x45,W
1128:  BC    119A
112A:  MOVF   x41,W
112C:  ADDWF  x45,W
112E:  MOVWF  01
1130:  MOVF   x42,W
1132:  ADDWFC x46,W
1134:  MOVWF  03
1136:  MOVF   x44,W
1138:  SUBWF  03,W
113A:  BNC   119A
113C:  BNZ   1144
113E:  MOVF   01,W
1140:  SUBWF  x43,W
1142:  BC    119A
....................       for(sc1+=n,sc2+=n;0<n;--n)
1144:  MOVF   x41,W
1146:  ADDWF  x43,F
1148:  MOVF   x42,W
114A:  ADDWFC x44,F
114C:  MOVF   x41,W
114E:  ADDWF  x45,F
1150:  MOVF   x42,W
1152:  ADDWFC x46,F
1154:  MOVF   x42,F
1156:  BNZ   115E
1158:  MOVF   x41,W
115A:  SUBLW  00
115C:  BC    1198
....................          *--sc1=*--sc2;
115E:  MOVF   x43,W
1160:  BTFSC  FD8.2
1162:  DECF   x44,F
1164:  DECF   x43,F
1166:  MOVFF  244,248
116A:  MOVFF  243,247
116E:  MOVF   x45,W
1170:  BTFSC  FD8.2
1172:  DECF   x46,F
1174:  DECF   x45,F
1176:  MOVFF  246,FEA
117A:  MOVFF  245,FE9
117E:  MOVFF  FEF,249
1182:  MOVFF  244,FEA
1186:  MOVFF  243,FE9
118A:  MOVFF  249,FEF
118E:  MOVF   x41,W
1190:  BTFSC  FD8.2
1192:  DECF   x42,F
1194:  DECF   x41,F
1196:  BRA    1154
1198:  BRA    11DA
....................    else
....................       for(;0<n;--n)
119A:  MOVF   x42,F
119C:  BNZ   11A4
119E:  MOVF   x41,W
11A0:  SUBLW  00
11A2:  BC    11DA
....................          *sc1++=*sc2++;
11A4:  MOVFF  244,248
11A8:  MOVF   x43,W
11AA:  INCF   x43,F
11AC:  BTFSC  FD8.2
11AE:  INCF   x44,F
11B0:  MOVWF  x47
11B2:  MOVFF  246,FEA
11B6:  MOVF   x45,W
11B8:  INCF   x45,F
11BA:  BTFSC  FD8.2
11BC:  INCF   x46,F
11BE:  MOVWF  FE9
11C0:  MOVFF  FEF,249
11C4:  MOVFF  248,FEA
11C8:  MOVFF  247,FE9
11CC:  MOVFF  249,FEF
11D0:  MOVF   x41,W
11D2:  BTFSC  FD8.2
11D4:  DECF   x42,F
11D6:  DECF   x41,F
11D8:  BRA    119A
....................   return s1;
11DA:  MOVFF  23D,01
11DE:  MOVFF  23E,02
11E2:  MOVLB  0
11E4:  RETURN 0
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... void usb_cdc_flush_tx_buffer(void) 
.................... {
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE
....................    usb_cdc_tx_t n;
....................   #endif
....................   
....................    if (usb_cdc_put_buffer_nextin != 0)
11E6:  MOVF   xB4,F
11E8:  BZ    1256
....................    {
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE))
....................       {
....................          usb_cdc_put_buffer_nextin = 0;
....................       }
....................      #else
....................       n = usb_cdc_put_buffer_nextin;
11EA:  MOVFF  B4,239
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets
11EE:  MOVLB  2
11F0:  MOVF   x39,W
11F2:  SUBLW  3F
11F4:  BC    11FA
....................          n = USB_CDC_DATA_IN_SIZE-1;
11F6:  MOVLW  3F
11F8:  MOVWF  x39
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE))
11FA:  MOVLW  02
11FC:  MOVWF  x3A
11FE:  CLRF   x3C
1200:  MOVLW  34
1202:  MOVWF  x3B
1204:  CLRF   x3E
1206:  MOVFF  239,23D
120A:  MOVLW  02
120C:  MOVWF  x3F
120E:  MOVLB  0
1210:  RCALL  106C
1212:  MOVF   01,F
1214:  BZ    1256
....................       {
....................          //pull the buffer back
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n);
1216:  CLRF   03
1218:  MOVLB  2
121A:  MOVF   x39,W
121C:  ADDLW  34
121E:  MOVWF  01
1220:  MOVLW  00
1222:  ADDWFC 03,F
1224:  MOVFF  01,23A
1228:  MOVFF  03,23B
122C:  MOVF   x39,W
122E:  MOVLB  0
1230:  SUBWF  xB4,W
1232:  MOVLB  2
1234:  MOVWF  x3C
1236:  CLRF   x3E
1238:  MOVLW  34
123A:  MOVWF  x3D
123C:  MOVFF  03,240
1240:  MOVFF  01,23F
1244:  CLRF   x42
1246:  MOVFF  23C,241
124A:  MOVLB  0
124C:  RCALL  110A
....................          usb_cdc_put_buffer_nextin -= n;
124E:  MOVLB  2
1250:  MOVF   x39,W
1252:  MOVLB  0
1254:  SUBWF  xB4,F
....................       }      
....................      #endif
....................    }
1256:  RETURN 0
.................... }
.................... 
.................... void usb_cdc_init(void) 
.................... {
....................    usb_cdc_line_coding.dwDTERrate = 9600;
*
04F2:  MOVLB  2
04F4:  CLRF   x3A
04F6:  CLRF   x39
04F8:  MOVLW  25
04FA:  MOVWF  x38
04FC:  MOVLW  80
04FE:  MOVWF  x37
0500:  MOVFF  237,2B
0504:  MOVFF  238,2C
0508:  CLRF   2D
050A:  CLRF   2E
....................    usb_cdc_line_coding.bCharFormat = 0;
050C:  CLRF   x37
050E:  MOVFF  237,2F
....................    usb_cdc_line_coding.bParityType = 0;
0512:  CLRF   x37
0514:  MOVFF  237,30
....................    usb_cdc_line_coding.bDataBits = 8;
0518:  MOVLW  08
051A:  MOVWF  x37
051C:  MOVFF  237,31
....................    (int8)usb_cdc_carrier = 0;
0520:  MOVLB  0
0522:  CLRF   xB6
....................    usb_cdc_got_set_line_coding = false;
0524:  BCF    xB5.0
....................    usb_cdc_break = 0;
0526:  CLRF   33
0528:  CLRF   32
....................    usb_cdc_put_buffer_nextin = 0;
052A:  CLRF   xB4
....................    usb_cdc_get_buffer_status.got = 0;
052C:  BCF    1E.0
....................    __usb_cdc_state = 0;
052E:  CLRF   xB7
0530:  RETURN 0
.................... }
.................... 
.................... ////////////////// END USB CONTROL HANDLING //////////////////////////////////
.................... 
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY /////////////////////////////
.................... 
.................... typedef struct
.................... {
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD.
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device.
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device. 
....................    unsigned int bFraming:1;   //A framing error has occurred.
....................    unsigned int bParity:1;    //A parity error has occurred.
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device.
....................    unsigned int reserved0:1;   //future use
....................    unsigned int reserved1:8;   //future use
.................... } cdc_serial_state_t;
.................... 
.................... /*
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring, 
....................    break signal and more (see cdc_serial_state_t).
....................    Some of these values are held by the host (meaning it's value only needs
....................    to be sent on change), but some values are one shot (meaning you continously
....................    need to send value to host while being held).
.................... */
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state)
.................... {
....................   #if __USB_PIC_PERIF__
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer
....................   #else
....................    unsigned int8 payload[10];
....................    #define CDC_EP1_NOTIFY_BUFFER payload
....................   #endif
.................... 
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT))
....................       return(false);
.................... 
....................    //bmRequestType
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001
....................    //bNotification
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE
....................    //wValue
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0;
....................    //wIndex
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0;
....................    //wLength
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t)
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0;
....................    //data
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state;
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8;
.................... 
....................   #if __USB_PIC_PERIF__
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE);
....................   #else
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE);
....................   #endif
....................    
....................    return(true);
.................... }
.................... 
.................... void usb_cdc_get_discard(void)
.................... {
....................    usb_cdc_get_buffer_status.got = false;
*
0FF8:  BCF    1E.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE);
0FFA:  MOVLW  02
0FFC:  MOVLB  2
0FFE:  MOVWF  x39
1000:  MOVWF  x3A
1002:  MOVLB  0
1004:  RCALL  0CCE
1006:  GOTO   1022 (RETURN)
.................... }
.................... 
.................... char usb_cdc_getc(void) 
.................... {
....................    char c;
.................... 
....................    while (!usb_cdc_kbhit()) 
....................    {
....................      #if defined(USB_ISR_POLLING)
....................       usb_task();
....................      #endif
....................    }
.................... 
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++];
.................... 
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len) 
....................    {
....................       usb_cdc_get_discard();
....................    }
.................... 
....................    return(c);
.................... }
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... #define __USB_PAUSE_ISR()
.................... #define __USB_RESTORE_ISR()
.................... #else
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1
.................... #endif
.................... 
.................... static void _usb_cdc_putc_fast_noflush(char c)
.................... {
....................    __USB_PAUSE_ISR();
*
16D0:  MOVLB  2
16D2:  BCF    x20.0
16D4:  BTFSC  FA0.5
16D6:  BSF    x20.0
16D8:  BCF    FA0.5
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) 
16DA:  MOVLB  0
16DC:  MOVF   xB4,W
16DE:  SUBLW  7F
16E0:  BC    16F0
16E2:  CLRF   19
16E4:  BTFSC  FF2.7
16E6:  BSF    19.7
16E8:  BCF    FF2.7
....................    {
....................       usb_cdc_flush_tx_buffer();
16EA:  RCALL  11E6
16EC:  BTFSC  19.7
16EE:  BSF    FF2.7
....................    }
....................   #endif
.................... 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) {
16F0:  MOVF   xB4,W
16F2:  SUBLW  7F
16F4:  BC    16FA
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer!
16F6:  MOVLW  7F
16F8:  MOVWF  xB4
....................    }
....................    
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c;
16FA:  MOVF   xB4,W
16FC:  INCF   xB4,F
16FE:  CLRF   03
1700:  ADDLW  34
1702:  MOVWF  FE9
1704:  MOVLW  00
1706:  ADDWFC 03,W
1708:  MOVWF  FEA
170A:  MOVFF  21F,FEF
.................... 
....................    __USB_RESTORE_ISR();
170E:  MOVLB  2
1710:  BTFSS  x20.0
1712:  BRA    1716
1714:  BSF    FA0.5
1716:  MOVLB  0
1718:  GOTO   1722 (RETURN)
.................... }
.................... 
.................... void usb_cdc_putc_fast(char c)
.................... {
....................    _usb_cdc_putc_fast_noflush(c);
171C:  MOVFF  21E,21F
1720:  BRA    16D0
.................... 
....................   #if defined(USB_ISR_POLLING)
....................    // if interrupts are disabled, we should clear all activity isrs
....................    // before we attempt to put any data onto an endpoint.
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT))
....................       return;
....................    usb_task();
....................   #endif
....................   
....................   #if !defined(USB_CDC_DELAYED_FLUSH)
1722:  GOTO   1760 (RETURN)
....................    //if (usb_cdc_put_buffer_free()) 
....................    {
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin);
....................       usb_cdc_flush_tx_buffer();
....................    }
....................   #endif
.................... 
....................    //putc('*');
.................... }
.................... 
.................... void usb_cdc_putc(char c)
.................... {
....................    while (!usb_cdc_putready()) 
1726:  MOVLW  80
1728:  BSF    FD8.0
172A:  SUBFWB xB4,W
172C:  BNZ   175A
172E:  CLRF   19
1730:  BTFSC  FF2.7
1732:  BSF    19.7
1734:  BCF    FF2.7
....................    {
....................      #if 1
....................       if (usb_cdc_put_buffer_free()) 
1736:  MOVLW  02
1738:  MOVLB  2
173A:  MOVWF  x47
173C:  MOVLB  0
173E:  CALL   0DCE
1742:  BTFSC  19.7
1744:  BSF    FF2.7
1746:  MOVF   01,F
1748:  BZ    1758
174A:  CLRF   19
174C:  BTFSC  FF2.7
174E:  BSF    19.7
1750:  BCF    FF2.7
....................       {
....................          usb_cdc_flush_tx_buffer();
1752:  RCALL  11E6
1754:  BTFSC  19.7
1756:  BSF    FF2.7
....................       }
....................      #endif
.................... 
....................      #if defined(USB_ISR_POLLING)
1758:  BRA    1726
....................       usb_task();
....................      #endif
....................    }
....................    usb_cdc_putc_fast(c);
175A:  MOVFF  21D,21E
175E:  BRA    171C
1760:  GOTO   1776 (RETURN)
.................... }
.................... 
.................... int1 usb_cdc_putd(char *ptr, unsigned int8 len)
.................... {
....................  #if USB_EP2_TX_SIZE>=0x100
....................    unsigned int16 i;
....................  #else
....................    unsigned int8 i;
....................  #endif
....................    char c;
....................    
....................    i = 0;
....................    
....................    if (!usb_cdc_put_buffer_free())
....................       return(false);
....................    
....................    while(len--)
....................    {
....................       c = *ptr++;
....................       _usb_cdc_putc_fast_noflush(c);
....................       if (++i >= USB_EP2_TX_SIZE)
....................          break;
....................    }
....................    
....................    usb_cdc_flush_tx_buffer();
....................    
....................    return(true);
.................... }
.................... 
.................... int1 usb_cdc_puts(char *ptr)
.................... {   
....................    unsigned int8 len;
.................... 
....................    len = strlen(ptr);
....................   
....................    return(usb_cdc_putd(ptr, len));
.................... }
.................... 
.................... #endif //__USB_CDC_HELPERS_ONLY__
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... char gethex1_usb() 
.................... {
....................    char digit;
.................... 
....................    digit = usb_cdc_getc();
.................... 
....................    usb_cdc_putc(digit);
.................... 
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((toupper(digit)-'A')+10);
.................... }
.................... 
.................... char gethex_usb() {
....................    unsigned int8 lo,hi;
.................... 
....................    hi = gethex1_usb();
....................    lo = gethex1_usb();
....................    if(lo==0xdd)
....................      return(hi);
....................    else
....................      return( hi*16+lo );
.................... }
.................... 
.................... void get_string_usb(char* s, unsigned int max) {
....................    unsigned int len;
....................    char c;
.................... 
....................    --max;
....................    len=0;
....................    do {
....................      c=usb_cdc_getc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           usb_cdc_putc(c);
....................           usb_cdc_putc(' ');
....................           usb_cdc_putc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<max) {
....................          s[len++]=c;
....................          usb_cdc_putc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... 
.................... 
.................... // stdlib.h is required for the ato_ conversions
.................... // in the following functions
.................... #ifdef _STDLIB
.................... 
.................... signed int get_int_usb() {
....................   char s[7];
....................   signed int i;
.................... 
....................   get_string_usb(s, 7);
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... 
.................... signed long get_long_usb() {
....................   char s[13];
....................   signed long l;
.................... 
....................   get_string_usb(s, 13);
....................   l=atol(s);
....................   return(l);
.................... }
.................... 
.................... float get_float_usb() {
....................   char s[20];
....................   float f;
.................... 
....................   get_string_usb(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... uint16_t globalMs;
.................... uint8_t globalSec;
.................... uint16_t globalMin;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #use spi (MASTER, SPI1, ENABLE=PIN_A5, BAUD=10000, MODE=0, BITS=8, STREAM=SPI_1)
.................... 
.................... #byte porta = 0xf80 // Identificador para el puerto A. 
.................... #byte portb = 0xf81 // Identificador para el puerto B. 
.................... #byte portc = 0xf82 // Identificador para el puerto C. 
.................... #byte portd = 0xf83 // Identificador para el puerto D. 
.................... #byte porte = 0xf84 // Identificador para el puerto E.
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlibm.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /*********************************************************************/
.................... #ifndef _STDLIBM
.................... #define _STDLIBM
.................... 
.................... /* Memory Management Functions*/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #if defined(__PCB__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int8 next; }node_t;
.................... #elif defined(__PCM__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCH__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCD__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #endif
.................... 
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY)
....................    #USE DYNAMIC_MEMORY
.................... #endif
.................... 
.................... #ifndef debug_stdlibm
....................    #define debug_stdlibm(s)
.................... #else
....................    #define __DO_DEBUG_STDLIBM
....................    
....................    char g_DebugStdlibmStr[50];
....................    
....................    #if defined(__PCD__)
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__))
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0))
....................       #else
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0))
....................       #endif
....................    #else
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM"))
....................    #endif
.................... #endif
.................... 
.................... #if defined(STDLIBM_TRACK_WORST_CASE)
....................    static size_t _g_StdlibmCurrentBytesUsed = 0;
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0;
....................    
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \
....................       _g_StdlibmCurrentBytesUsed += _x;   \
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed
....................    
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x
.................... #else
....................    #define _STDLIBM_TRACK_WORST_INC(_x)
....................    #define _STDLIBM_TRACK_WORST_DEC(_x)
.................... #endif
.................... 
.................... #include <memmgmt.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__PCH__)
....................  #define _MEMMGMT_CSIZE 32768
....................  #define _MEMMGMT_POS 15
.................... #elif defined(__PCD__)
....................    #define _MEMMGMT_CSIZE 32768
....................    #define _MEMMGMT_POS 15
.................... #else
....................    #define _MEMMGMT_CSIZE 127
....................    #define _MEMMGMT_POS 7
.................... #endif
.................... 
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location
.................... {
....................    node_t *result;
....................    result =ptr;
*
2930:  MOVFF  1E1,1E3
2934:  MOVFF  1E0,1E2
....................    result->size=size;
2938:  MOVLB  1
293A:  MOVFF  1E2,FE9
293E:  MOVFF  1E3,FEA
2942:  MOVFF  1DF,FEC
2946:  MOVF   FED,F
2948:  MOVFF  1DE,FEF
....................    result->next = NULL;
294C:  MOVLW  02
294E:  ADDWF  xE2,W
2950:  MOVWF  FE9
2952:  MOVLW  00
2954:  ADDWFC xE3,W
2956:  MOVWF  FEA
2958:  CLRF   FEC
295A:  MOVF   FED,F
295C:  CLRF   FEF
....................    return result;
295E:  MOVFF  1E2,01
2962:  MOVFF  1E3,02
2966:  MOVLB  0
2968:  GOTO   2ABC (RETURN)
.................... }
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node
.................... {
....................    node->size=size;
*
29F2:  MOVLB  1
29F4:  MOVFF  1DF,FE9
29F8:  MOVFF  1E0,FEA
29FC:  MOVFF  1E2,FEC
2A00:  MOVF   FED,F
2A02:  MOVFF  1E1,FEF
2A06:  MOVLB  0
2A08:  RETURN 0
.................... }
.................... 
.................... /* Insert node immediately after place */ //old,new
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node
.................... {
....................     if (place->next==NULL)
*
296C:  MOVLW  02
296E:  MOVLB  1
2970:  ADDWF  xDA,W
2972:  MOVWF  FE9
2974:  MOVLW  00
2976:  ADDWFC xDB,W
2978:  MOVWF  FEA
297A:  MOVFF  FEC,1DF
297E:  MOVF   FED,F
2980:  MOVFF  FEF,1DE
2984:  MOVF   xDE,F
2986:  BNZ   29A0
2988:  MOVF   xDF,F
298A:  BNZ   29A0
....................        node->next= NULL;
298C:  MOVLW  02
298E:  ADDWF  xDC,W
2990:  MOVWF  FE9
2992:  MOVLW  00
2994:  ADDWFC xDD,W
2996:  MOVWF  FEA
2998:  CLRF   FEC
299A:  MOVF   FED,F
299C:  CLRF   FEF
299E:  BRA    29D6
....................     else
....................        node->next=place->next;
29A0:  MOVLW  02
29A2:  ADDWF  xDC,W
29A4:  MOVWF  01
29A6:  MOVLW  00
29A8:  ADDWFC xDD,W
29AA:  MOVWF  03
29AC:  MOVWF  xDF
29AE:  MOVLW  02
29B0:  ADDWF  xDA,W
29B2:  MOVWF  FE9
29B4:  MOVLW  00
29B6:  ADDWFC xDB,W
29B8:  MOVWF  FEA
29BA:  MOVFF  FEC,03
29BE:  MOVF   FED,F
29C0:  MOVFF  FEF,1E0
29C4:  MOVFF  1DF,FEA
29C8:  MOVFF  01,FE9
29CC:  MOVFF  03,FEC
29D0:  MOVF   FED,F
29D2:  MOVFF  1E0,FEF
....................     place->next=node;
29D6:  MOVLW  02
29D8:  ADDWF  xDA,W
29DA:  MOVWF  FE9
29DC:  MOVLW  00
29DE:  ADDWFC xDB,W
29E0:  MOVWF  FEA
29E2:  MOVFF  1DD,FEC
29E6:  MOVF   FED,F
29E8:  MOVFF  1DC,FEF
29EC:  MOVLB  0
29EE:  GOTO   2AD6 (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void remove_node(node_t *node) {// remove the given node from the memlist
....................    node_t *ptr;
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next);
*
2B4C:  MOVFF  C0,1E2
2B50:  MOVFF  BF,1E1
2B54:  MOVLW  02
2B56:  MOVLB  1
2B58:  ADDWF  xE1,W
2B5A:  MOVWF  FE9
2B5C:  MOVLW  00
2B5E:  ADDWFC xE2,W
2B60:  MOVWF  FEA
2B62:  MOVFF  FEC,1E4
2B66:  MOVF   FED,F
2B68:  MOVFF  FEF,1E3
2B6C:  MOVF   xDF,W
2B6E:  SUBWF  xE3,W
2B70:  BNZ   2B78
2B72:  MOVF   xE0,W
2B74:  SUBWF  xE4,W
2B76:  BZ    2B94
2B78:  MOVLW  02
2B7A:  ADDWF  xE1,W
2B7C:  MOVWF  FE9
2B7E:  MOVLW  00
2B80:  ADDWFC xE2,W
2B82:  MOVWF  FEA
2B84:  MOVFF  FEC,1E2
2B88:  MOVF   FED,F
2B8A:  MOVFF  FEF,1E1
2B8E:  MOVLB  0
2B90:  BRA    2B54
2B92:  MOVLB  1
....................    ptr->next=node->next;
2B94:  MOVLW  02
2B96:  ADDWF  xE1,W
2B98:  MOVWF  01
2B9A:  MOVLW  00
2B9C:  ADDWFC xE2,W
2B9E:  MOVWF  03
2BA0:  MOVWF  xE4
2BA2:  MOVLW  02
2BA4:  ADDWF  xDF,W
2BA6:  MOVWF  FE9
2BA8:  MOVLW  00
2BAA:  ADDWFC xE0,W
2BAC:  MOVWF  FEA
2BAE:  MOVFF  FEC,03
2BB2:  MOVF   FED,F
2BB4:  MOVFF  FEF,1E5
2BB8:  MOVFF  1E4,FEA
2BBC:  MOVFF  01,FE9
2BC0:  MOVFF  03,FEC
2BC4:  MOVF   FED,F
2BC6:  MOVFF  1E5,FEF
....................    node=NULL;
2BCA:  CLRF   xE0
2BCC:  CLRF   xDF
2BCE:  MOVLB  0
2BD0:  GOTO   2C92 (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__DO_DEBUG_STDLIBM)
.................... void print_list() { // print the current memlist
....................     node_t *node;
....................     debug_stdlibm("\r\nThe list is \n\r");
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next)
....................     {
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next);
....................         debug_stdlibm(g_DebugStdlibmStr);
....................         if (INVALID_MEMORY_LOCATION(node->next))
....................         {
....................            debug_stdlibm("Breaking because of invalid next node\r\n");
....................            break;
....................         }   
....................     }
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t));
....................     debug_stdlibm(g_DebugStdlibmStr);
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void traverse()
.................... {
....................    node_t *node,*temp;
....................    unsigned int16 nsize,nextsize;
....................    node=__DYNAMIC_HEAD;
2BD4:  MOVFF  C0,1D8
2BD8:  MOVFF  BF,1D7
....................    while(node!=NULL)
2BDC:  MOVLB  1
2BDE:  MOVF   xD7,F
2BE0:  BNZ   2BE8
2BE2:  MOVF   xD8,F
2BE4:  BTFSC  FD8.2
2BE6:  BRA    2CE0
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          break;
....................       }   
....................      #endif
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free
2BE8:  MOVFF  1D7,FE9
2BEC:  MOVFF  1D8,FEA
2BF0:  MOVFF  FEC,1E0
2BF4:  MOVF   FED,F
2BF6:  MOVFF  FEF,1DF
2BFA:  BTFSC  xE0.7
2BFC:  BRA    2CC4
....................       {
....................          nsize=node->size;
2BFE:  MOVFF  1D7,FE9
2C02:  MOVFF  1D8,FEA
2C06:  MOVFF  FEC,1DC
2C0A:  MOVF   FED,F
2C0C:  MOVFF  FEF,1DB
....................          temp=(unsigned int16)node->next;
2C10:  MOVLW  02
2C12:  ADDWF  xD7,W
2C14:  MOVWF  FE9
2C16:  MOVLW  00
2C18:  ADDWFC xD8,W
2C1A:  MOVWF  FEA
2C1C:  MOVFF  FEC,1DA
2C20:  MOVF   FED,F
2C22:  MOVFF  FEF,1D9
....................         #if defined(__DO_DEBUG_STDLIBM)
....................          if (INVALID_MEMORY_LOCATION(temp))
....................          {
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node);
....................             debug_stdlibm(g_DebugStdlibmStr);
....................             break;
....................          }
....................         #endif
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine
2C26:  MOVFF  1D9,FE9
2C2A:  MOVFF  1DA,FEA
2C2E:  MOVFF  FEC,1E0
2C32:  MOVF   FED,F
2C34:  MOVFF  FEF,1DF
2C38:  BTFSC  xE0.7
2C3A:  BRA    2CA8
2C3C:  MOVF   xDB,W
2C3E:  ADDWF  xD7,W
2C40:  MOVWF  xE1
2C42:  MOVF   xDC,W
2C44:  ADDWFC xD8,W
2C46:  MOVWF  xE2
2C48:  MOVLW  04
2C4A:  ADDWF  xE1,W
2C4C:  MOVWF  01
2C4E:  MOVLW  00
2C50:  ADDWFC xE2,W
2C52:  MOVWF  03
2C54:  MOVF   01,W
2C56:  SUBWF  xD9,W
2C58:  BNZ   2CA8
2C5A:  MOVF   03,W
2C5C:  SUBWF  xDA,W
2C5E:  BNZ   2CA8
....................          {
....................             nextsize=temp->size;
2C60:  MOVFF  1D9,FE9
2C64:  MOVFF  1DA,FEA
2C68:  MOVFF  FEC,1DE
2C6C:  MOVF   FED,F
2C6E:  MOVFF  FEF,1DD
....................             nsize+=nextsize+sizeof(node_t);
2C72:  MOVLW  04
2C74:  ADDWF  xDD,W
2C76:  MOVWF  01
2C78:  MOVLW  00
2C7A:  ADDWFC xDE,W
2C7C:  MOVWF  03
2C7E:  MOVF   01,W
2C80:  ADDWF  xDB,F
2C82:  MOVF   03,W
2C84:  ADDWFC xDC,F
....................             remove_node(temp);
2C86:  MOVFF  1DA,1E0
2C8A:  MOVFF  1D9,1DF
2C8E:  MOVLB  0
2C90:  BRA    2B4C
....................             update_node(node,nsize);
2C92:  MOVFF  1D8,1E0
2C96:  MOVFF  1D7,1DF
2C9A:  MOVFF  1DC,1E2
2C9E:  MOVFF  1DB,1E1
2CA2:  RCALL  29F2
....................          }
2CA4:  BRA    2CC0
2CA6:  MOVLB  1
....................          else
....................          node=node->next;
2CA8:  MOVLW  02
2CAA:  ADDWF  xD7,W
2CAC:  MOVWF  FE9
2CAE:  MOVLW  00
2CB0:  ADDWFC xD8,W
2CB2:  MOVWF  FEA
2CB4:  MOVFF  FEC,1D8
2CB8:  MOVF   FED,F
2CBA:  MOVFF  FEF,1D7
2CBE:  MOVLB  0
....................       }
2CC0:  BRA    2CDC
2CC2:  MOVLB  1
....................       else
....................       node=node->next;
2CC4:  MOVLW  02
2CC6:  ADDWF  xD7,W
2CC8:  MOVWF  FE9
2CCA:  MOVLW  00
2CCC:  ADDWFC xD8,W
2CCE:  MOVWF  FEA
2CD0:  MOVFF  FEC,1D8
2CD4:  MOVF   FED,F
2CD6:  MOVFF  FEF,1D7
2CDA:  MOVLB  0
2CDC:  BRA    2BDC
2CDE:  MOVLB  1
....................    }
2CE0:  MOVLB  0
2CE2:  GOTO   2D5A (RETURN)
.................... }
.................... 
.................... char *malloc(size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize;
....................    #if defined(__PCD__)
....................    if (size % 2)
....................       size++;
....................    #endif
....................    node=__DYNAMIC_HEAD;
*
2A0A:  MOVFF  C0,1D5
2A0E:  MOVFF  BF,1D4
....................    
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
....................         
....................    while(node!=NULL) // chk until end of memlist
2A12:  MOVLB  1
2A14:  MOVF   xD4,F
2A16:  BNZ   2A1E
2A18:  MOVF   xD5,F
2A1A:  BTFSC  FD8.2
2A1C:  BRA    2B28
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size
2A1E:  MOVFF  1D4,FE9
2A22:  MOVFF  1D5,FEA
2A26:  MOVFF  FEC,1DB
2A2A:  MOVF   FED,F
2A2C:  MOVFF  FEF,1DA
2A30:  BTFSC  xDB.7
2A32:  BRA    2B10
2A34:  MOVFF  1D4,FE9
2A38:  MOVFF  1D5,FEA
2A3C:  MOVFF  FEC,1DD
2A40:  MOVF   FED,F
2A42:  MOVFF  FEF,1DC
2A46:  MOVF   xD3,W
2A48:  SUBWF  xDD,W
2A4A:  BNC   2B10
2A4C:  BNZ   2A54
2A4E:  MOVF   xD2,W
2A50:  SUBWF  xDC,W
2A52:  BNC   2B10
....................       {
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at
2A54:  MOVFF  1D4,FE9
2A58:  MOVFF  1D5,FEA
2A5C:  MOVFF  FEC,1D9
2A60:  MOVF   FED,F
2A62:  MOVFF  FEF,1D8
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist
2A66:  MOVLW  04
2A68:  ADDWF  xD2,W
2A6A:  MOVWF  01
2A6C:  MOVLW  00
2A6E:  ADDWFC xD3,W
2A70:  MOVWF  03
2A72:  MOVF   03,W
2A74:  SUBWF  xD9,W
2A76:  BNC   2AF4
2A78:  BNZ   2A80
2A7A:  MOVF   xD8,W
2A7C:  SUBWF  01,W
2A7E:  BC    2AF4
....................          {
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
2A80:  MOVF   xD2,W
2A82:  SUBWF  xD8,W
2A84:  MOVWF  xDA
2A86:  MOVF   xD3,W
2A88:  SUBWFB xD9,W
2A8A:  MOVWF  xDB
2A8C:  MOVLW  04
2A8E:  SUBWF  xDA,F
2A90:  MOVLW  00
2A92:  SUBWFB xDB,F
2A94:  MOVLW  04
2A96:  ADDWF  xD4,W
2A98:  MOVWF  xDC
2A9A:  MOVLW  00
2A9C:  ADDWFC xD5,W
2A9E:  MOVWF  xDD
2AA0:  MOVF   xD2,W
2AA2:  ADDWF  xDC,F
2AA4:  MOVF   xD3,W
2AA6:  ADDWFC xDD,F
2AA8:  MOVFF  1DB,1DF
2AAC:  MOVFF  1DA,1DE
2AB0:  MOVFF  1DD,1E1
2AB4:  MOVFF  1DC,1E0
2AB8:  MOVLB  0
2ABA:  BRA    2930
2ABC:  MOVFF  02,1D7
2AC0:  MOVFF  01,1D6
....................             insert_node_after(node,new);
2AC4:  MOVFF  1D5,1DB
2AC8:  MOVFF  1D4,1DA
2ACC:  MOVFF  1D7,1DD
2AD0:  MOVFF  1D6,1DC
2AD4:  BRA    296C
....................             update_node(node,size+_MEMMGMT_CSIZE);
2AD6:  MOVLB  1
2AD8:  MOVLW  80
2ADA:  ADDWF  xD3,W
2ADC:  MOVWF  xDB
2ADE:  MOVFF  1D5,1E0
2AE2:  MOVFF  1D4,1DF
2AE6:  MOVWF  xE2
2AE8:  MOVFF  1D2,1E1
2AEC:  MOVLB  0
2AEE:  RCALL  29F2
....................          }
2AF0:  BRA    2B0C
2AF2:  MOVLB  1
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
2AF4:  MOVLW  80
2AF6:  ADDWF  xD9,W
2AF8:  MOVWF  xDB
2AFA:  MOVFF  1D5,1E0
2AFE:  MOVFF  1D4,1DF
2B02:  MOVWF  xE2
2B04:  MOVFF  1D8,1E1
2B08:  MOVLB  0
2B0A:  RCALL  29F2
....................          //end if
....................          break;
2B0C:  MOVLB  1
2B0E:  BRA    2B28
....................       }//end if
....................       node=node->next;
2B10:  MOVLW  02
2B12:  ADDWF  xD4,W
2B14:  MOVWF  FE9
2B16:  MOVLW  00
2B18:  ADDWFC xD5,W
2B1A:  MOVWF  FEA
2B1C:  MOVFF  FEC,1D5
2B20:  MOVF   FED,F
2B22:  MOVFF  FEF,1D4
2B26:  BRA    2A14
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
2B28:  MOVF   xD4,F
2B2A:  BNZ   2B3A
2B2C:  MOVF   xD5,F
2B2E:  BNZ   2B3A
....................    {
....................       debug_stdlibm("Not enough memory for mallocation\r\n");
....................       return NULL;
2B30:  MOVLW  00
2B32:  MOVWF  01
2B34:  MOVWF  02
2B36:  BRA    2B48
....................    }
2B38:  BRA    2B48
....................    else
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t));
....................       debug_stdlibm(g_DebugStdlibmStr);
....................      #endif
....................       _STDLIBM_TRACK_WORST_INC(size);
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space
2B3A:  MOVLW  04
2B3C:  ADDWF  xD4,W
2B3E:  MOVWF  01
2B40:  MOVLW  00
2B42:  ADDWFC xD5,W
2B44:  MOVWF  03
2B46:  MOVWF  02
....................    }
2B48:  MOVLB  0
2B4A:  RETURN 0
.................... }
.................... 
.................... char *calloc(size_t nmemb,size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize,resize;
....................    node=__DYNAMIC_HEAD;
....................    resize=nmemb*size;
....................    #if defined(__PCD__)
....................    if(resize%2)
....................       resize++;
....................    #endif
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size
....................       {
....................          nsize=node->size;
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize);
....................             insert_node_after(node,new);
....................             update_node(node,resize+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for callocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0
....................       _STDLIBM_TRACK_WORST_INC(resize);
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space
....................    }
.................... }
.................... void free( void * ptr)
.................... {
....................    node_t *node;
....................    unsigned int16 nsize;
.................... 
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
.................... 
....................    if(ptr==NULL) // not a valid pounsigned int8er
*
2CE6:  MOVLB  1
2CE8:  MOVF   xD1,F
2CEA:  BNZ   2CF4
2CEC:  MOVF   xD2,F
2CEE:  BNZ   2CF4
....................       return;
2CF0:  BRA    2D5C
2CF2:  BRA    2D56
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
2CF4:  MOVLW  04
2CF6:  SUBWF  xD1,W
2CF8:  MOVWF  xD3
2CFA:  MOVLW  00
2CFC:  SUBWFB xD2,W
2CFE:  MOVWF  xD4
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied
2D00:  MOVFF  1D3,FE9
2D04:  MOVFF  1D4,FEA
2D08:  MOVFF  FEC,1D8
2D0C:  MOVF   FED,F
2D0E:  MOVFF  FEF,1D7
2D12:  BTFSS  xD8.7
2D14:  BRA    2D50
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
2D16:  MOVFF  1D3,FE9
2D1A:  MOVFF  1D4,FEA
2D1E:  MOVFF  FEC,1D8
2D22:  MOVF   FED,F
2D24:  MOVFF  FEF,1D7
2D28:  MOVLW  00
2D2A:  SUBWF  xD7,W
2D2C:  MOVWF  xD5
2D2E:  MOVLW  80
2D30:  SUBWFB xD8,W
2D32:  MOVWF  xD6
....................          update_node(node,nsize);
2D34:  MOVFF  1D4,1E0
2D38:  MOVFF  1D3,1DF
2D3C:  MOVFF  1D6,1E2
2D40:  MOVFF  1D5,1E1
2D44:  MOVLB  0
2D46:  RCALL  29F2
....................          ptr=NULL;
2D48:  MOVLB  1
2D4A:  CLRF   xD2
2D4C:  CLRF   xD1
....................          _STDLIBM_TRACK_WORST_DEC(nsize);
....................       }
2D4E:  BRA    2D56
....................       else // wrong input, return
....................       {
....................          ptr=NULL;
2D50:  CLRF   xD2
2D52:  CLRF   xD1
....................          return;
2D54:  BRA    2D5C
....................       }
....................    }
....................    traverse();
2D56:  MOVLB  0
2D58:  BRA    2BD4
2D5A:  MOVLB  1
2D5C:  MOVLB  0
2D5E:  RETURN 0
.................... }
.................... 
.................... char *realloc(void *ptr,size_t size)
.................... {
....................    node_t *node,*new,*temp;
....................    unsigned int16 nsize,nextsize;
....................    char *newptr;
....................    #if defined(__PCD__)
....................    if(size %2)
....................       size++;
....................    #endif
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory
....................       return(malloc(size));
....................    else if(size==0)
....................    {
....................       free(ptr);
....................       return(NULL);
....................    }
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          temp=(unsigned int16)node->next;
....................          if(nsize>size)// block > req size
....................          {
....................        
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   nextsize=temp->size;
....................                   remove_node(temp);
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t));
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else//not enough space for new node so use original size
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block
.................... 
....................          }
....................          else // block < req size
....................          {
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................             {
....................                nextsize=temp->size;
....................                if(nextsize>=size-nsize) // next block >=difference
....................                {
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist
....................                   {
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t));
....................                       insert_node_after(node,new);
....................                      _STDLIBM_TRACK_WORST_DEC(nsize);
....................                      _STDLIBM_TRACK_WORST_INC(size);
....................                   }
....................                   else//not enough space for new node in next node, so use original size
....................                   {
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                   }
....................                }
....................                else  //next block free but too small for new size
....................                {
....................                   newptr = malloc(size);  //use malloc to find new block
....................                   if(newptr == NULL)
....................                      return(NULL);        //return NULL if malloc was unable to find new block
....................                    
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                   free(ptr);                    //free original block
....................                   return(newptr);               //return new pointer
....................                }
....................             }
....................             else  //next block not free
....................             {
....................                newptr = malloc(size);  //use malloc to find new block
....................                if(newptr == NULL)      
....................                   return(NULL);        //return NULL if malloc was unable to find new block
....................                
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                free(ptr);                    //free original block
....................                return(newptr);               //return new pointer
....................             }
....................          }
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block
....................       }
....................       else // not allocated use malloc
....................       {
....................          return(malloc(size));
....................       }
....................    }
....................  }
....................  
.................... typedef struct
.................... {
....................    size_t bytesUsed;
....................    size_t largestUsedSeg;
....................    int segmentsUsed;
....................    size_t bytesFree;
....................    size_t largestFreeSeg;
....................    int segmentsFree;
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    size_t worstCaseBytesUsed;
....................   #endif
.................... } heap_status_t;
.................... 
.................... void GetHeapStatus(heap_status_t *pHeapStatus)
.................... {
....................    heap_status_t status;
....................    node_t *node;
....................    unsigned int16 nsize;
....................    
....................    node=__DYNAMIC_HEAD;
....................    
....................    memset(&status, 0, sizeof(status));
.................... 
....................    while(node!=NULL)
....................    {
....................       nsize = node->size;
....................       node = node->next;
....................       
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free
....................       {
....................          status.bytesFree += nsize;
....................          
....................          status.segmentsFree++;
....................          
....................          if (nsize > status.largestFreeSeg)
....................          {
....................             status.largestFreeSeg = nsize;
....................          }
....................       }
....................       else
....................       {
....................          bit_clear(nsize, _MEMMGMT_POS);
....................          
....................          status.bytesUsed += nsize;
....................          
....................          status.segmentsUsed++;
....................          
....................          if (nsize > status.largestUsedSeg)
....................          {
....................             status.largestUsedSeg = nsize;
....................          }
....................       }
....................    }
.................... 
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed;
....................   #endif
.................... 
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t));
.................... }
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include <adafruit_rfm69_registers.h>
.................... 
.................... //Internal constants:
.................... #define _REG_FIFO 0x00
.................... #define _REG_OP_MODE 0x01
.................... #define _REG_DATA_MOD 0x02
.................... #define _REG_BITRATE_MSB 0x03
.................... #define _REG_BITRATE_LSB 0x04
.................... #define _REG_FDEV_MSB 0x05
.................... #define _REG_FDEV_LSB 0x06
.................... #define _REG_FRF_MSB 0x07
.................... #define _REG_FRF_MID 0x08
.................... #define _REG_FRF_LSB 0x09
.................... #define _REG_VERSION 0x10
.................... #define _REG_PA_LEVEL 0x11
.................... #define _REG_RX_BW 0x19
.................... #define _REG_AFC_BW 0x1A
.................... #define _REG_RSSI_VALUE 0x24
.................... #define _REG_DIO_MAPPING1 0x25
.................... #define _REG_IRQ_FLAGS1 0x27
.................... #define _REG_IRQ_FLAGS2 0x28
.................... #define _REG_PREAMBLE_MSB 0x2C
.................... #define _REG_PREAMBLE_LSB 0x2D
.................... #define _REG_SYNC_CONFIG 0x2E
.................... #define _REG_SYNC_VALUE1 0x2F
.................... #define _REG_PACKET_CONFIG1 0x37
.................... #define _REG_FIFO_THRESH 0x3C
.................... #define _REG_PACKET_CONFIG2 0x3D
.................... #define _REG_AES_KEY1 0x3E
.................... #define _REG_TEMP1 0x4E
.................... #define _REG_TEMP2 0x4F
.................... #define _REG_TEST_PA1 0x5A
.................... #define _REG_TEST_PA2 0x5C
.................... #define _REG_TEST_DAGC 0x6F
.................... 
.................... #define _TEST_PA1_NORMAL 0x55
.................... #define _TEST_PA1_BOOST 0x5D
.................... #define _TEST_PA2_NORMAL 0x70
.................... #define _TEST_PA2_BOOST 0x7C
.................... 
.................... //The crystal oscillator frequency and frequency synthesizer step size.
.................... //See the datasheet for details of this calculation.
.................... 
.................... //        #define _FXOSC = 32000000.0
.................... //        #define _FSTEP = _FXOSC / 524288
.................... 
.................... //RadioHead specific compatibility constants.
.................... #define _RH_BROADCAST_ADDRESS 0xFF
.................... //The acknowledgement bit in the FLAGS
.................... //The top 4 bits of the flags are reserved for RadioHead. The lower 4 bits are reserved
.................... //for application layer use.
.................... #define _RH_FLAGS_ACK 0x80
.................... #define _RH_FLAGS_RETRY 0x40
.................... 
.................... //User facing constants:
.................... #define SLEEP_MODE 0b000
.................... #define STANDBY_MODE 0b001
.................... #define FS_MODE 0b010
.................... #define TX_MODE 0b011
.................... #define RX_MODE 0b100
.................... //supervisor.ticks_ms() contants
.................... //          #define _TICKS_PERIOD = const(1 << 29)
.................... //          #define _TICKS_MAX = const(_TICKS_PERIOD - 1)
.................... //          #define _TICKS_HALFPERIOD = const(_TICKS_PERIOD // 2)
.................... 
.................... #include <utils.h>
.................... //Global buffer for SPI commands
.................... uint8_t _BUFFER[4];
.................... 
.................... void setOutput(int pin, int value){
....................     output_bit(pin,value);
*
15C6:  MOVLB  2
15C8:  MOVF   x1C,F
15CA:  BNZ   15D0
15CC:  MOVLW  00
15CE:  BRA    15D2
15D0:  MOVLW  01
15D2:  MOVFF  21B,21D
15D6:  MOVWF  x1E
15D8:  MOVLW  0F
15DA:  MOVWF  x20
15DC:  MOVLW  89
15DE:  MOVWF  x1F
15E0:  MOVLB  0
15E2:  RCALL  1584
15E4:  MOVFF  21B,21D
15E8:  MOVLB  2
15EA:  CLRF   x1E
15EC:  MOVLW  0F
15EE:  MOVWF  x20
15F0:  MOVLW  92
15F2:  MOVWF  x1F
15F4:  MOVLB  0
15F6:  RCALL  1584
15F8:  RETURN 0
.................... }
.................... void usbPrint(char* str){
....................       usb_task();  //Verifica la comunicacin USB
*
178A:  RCALL  1508
....................       if(usb_enumerated()) {
178C:  RCALL  14D4
178E:  MOVF   01,F
1790:  BZ    179C
....................          printf(usb_cdc_putc,str); 
1792:  MOVFF  21A,FEA
1796:  MOVFF  219,FE9
179A:  BRA    1764
....................       }
179C:  RETURN 0
.................... }
.................... 
.................... void spiBegin(){
.................... //SPI.beginTransaction(SPISettings(SPIBAUD, MSBFIRST, SPI_MODE0));
.................... setOutput(SSPin, 0);
*
15FA:  MOVLW  05
15FC:  MOVLB  2
15FE:  MOVWF  x1B
1600:  CLRF   x1C
1602:  MOVLB  0
1604:  RCALL  15C6
1606:  RETURN 0
.................... 
.................... }
.................... void spiEnd(){
.................... setOutput(SSPin, 1);    
*
1630:  MOVLW  05
1632:  MOVLB  2
1634:  MOVWF  x1B
1636:  MOVLW  01
1638:  MOVWF  x1C
163A:  MOVLB  0
163C:  RCALL  15C6
163E:  RETURN 0
.................... //SPI.endTransaction();
.................... }
.................... 
.................... void print(char* str){
....................     //Serial.print(str);
....................     usbPrint(str);
*
17F8:  MOVFF  1D4,21A
17FC:  MOVFF  1D3,219
1800:  RCALL  178A
1802:  RETURN 0
.................... }
.................... 
.................... void print(int str, int format){
....................     char converted[11];
....................     int i;
....................     if (format == HEX) sprintf(converted,"0x%02X",str);
....................     else if (format == BIN){
....................     //Conversion manual
....................     converted[0] = '0';
....................     converted[1] = 'b';
....................     for (i=0;i<8;i++){
....................     converted[i+2] = ((str >> (7-i)) & 0x01) + '0';
....................     }
....................     converted[10] = '\0';
....................     }
....................     else if (format == DEC){
....................       sprintf(converted,"%d",str);
....................     }
....................     usbPrint(converted);
....................     //Serial.print(str,format);
.................... }
.................... void println(char* str){
....................     usbPrint(str);
*
179E:  MOVFF  214,21A
17A2:  MOVFF  213,219
17A6:  RCALL  178A
....................     usbPrint((char*)"\n");
17A8:  MOVLW  0A
17AA:  MOVLB  2
17AC:  MOVWF  x15
17AE:  CLRF   x16
17B0:  MOVLW  02
17B2:  MOVWF  x1A
17B4:  MOVLW  15
17B6:  MOVWF  x19
17B8:  MOVLB  0
17BA:  RCALL  178A
17BC:  RETURN 0
....................     //Serial.println(str);
.................... }
.................... void println(int str, int format){
....................     print(str,format);
....................     usbPrint((char*)"\n");
....................     //Serial.println(str,format);
.................... }
.................... void print(float str){
....................  char converted[11];
....................  sprintf(converted,"%03f",str);
....................  usbPrint(converted);
.................... }
.................... void println(float str){
....................     print(str);
....................     usbPrint((char*)"\n");
.................... }
.................... float timeSec(){
*
2694:  CLRF   19
2696:  BTFSC  FF2.7
2698:  BSF    19.7
269A:  BCF    FF2.7
....................    float t;
....................    t = (float)(60*globalMin);
269C:  MOVLB  2
269E:  CLRF   x49
26A0:  MOVLW  3C
26A2:  MOVWF  x48
26A4:  MOVFF  BE,24B
26A8:  MOVFF  BD,24A
26AC:  MOVLB  0
26AE:  CALL   0442
26B2:  BTFSC  19.7
26B4:  BSF    FF2.7
26B6:  MOVFF  02,1D6
26BA:  MOVFF  01,1D5
26BE:  MOVLB  0
26C0:  RCALL  2566
26C2:  MOVFF  03,1D4
26C6:  MOVFF  02,1D3
26CA:  MOVFF  01,1D2
26CE:  MOVFF  00,1D1
....................    t += (float)globalSec;
26D2:  MOVLB  1
26D4:  CLRF   xD6
26D6:  MOVFF  BC,1D5
26DA:  MOVLB  0
26DC:  RCALL  2566
26DE:  BCF    FD8.1
26E0:  MOVFF  1D4,1DA
26E4:  MOVFF  1D3,1D9
26E8:  MOVFF  1D2,1D8
26EC:  MOVFF  1D1,1D7
26F0:  MOVFF  03,1DE
26F4:  MOVFF  02,1DD
26F8:  MOVFF  01,1DC
26FC:  MOVFF  00,1DB
2700:  CALL   1C38
2704:  MOVFF  03,1D4
2708:  MOVFF  02,1D3
270C:  MOVFF  01,1D2
2710:  MOVFF  00,1D1
....................    t += (float)((float)globalMs*0.001);
2714:  MOVFF  BB,1D6
2718:  MOVFF  BA,1D5
271C:  RCALL  2566
271E:  MOVFF  03,1D8
2722:  MOVFF  02,1D7
2726:  MOVFF  01,1D6
272A:  MOVFF  00,1D5
272E:  MOVFF  03,1DC
2732:  MOVFF  02,1DB
2736:  MOVFF  01,1DA
273A:  MOVFF  00,1D9
273E:  MOVLW  6F
2740:  MOVLB  1
2742:  MOVWF  xE0
2744:  MOVLW  12
2746:  MOVWF  xDF
2748:  MOVLW  03
274A:  MOVWF  xDE
274C:  MOVLW  75
274E:  MOVWF  xDD
2750:  MOVLB  0
2752:  BRA    259C
2754:  BCF    FD8.1
2756:  MOVFF  1D4,1DA
275A:  MOVFF  1D3,1D9
275E:  MOVFF  1D2,1D8
2762:  MOVFF  1D1,1D7
2766:  MOVFF  03,1DE
276A:  MOVFF  02,1DD
276E:  MOVFF  01,1DC
2772:  MOVFF  00,1DB
2776:  CALL   1C38
277A:  MOVFF  03,1D4
277E:  MOVFF  02,1D3
2782:  MOVFF  01,1D2
2786:  MOVFF  00,1D1
....................    //println(t);
....................    return t;
278A:  MOVFF  1D1,00
278E:  MOVFF  1D2,01
2792:  MOVFF  1D3,02
2796:  MOVFF  1D4,03
279A:  RETURN 0
.................... }
.................... void spi_read_into(uint8_t address,uint8_t* array, uint8_t length){
*
1640:  MOVLB  2
1642:  CLRF   x1A
....................     int i=0;
....................     //Select
....................     spiBegin();
1644:  MOVLB  0
1646:  RCALL  15FA
....................     _BUFFER[0] = address & 0x7F; //Strip MSB byte to read
1648:  MOVLB  2
164A:  MOVF   x16,W
164C:  ANDLW  7F
164E:  MOVLB  0
1650:  MOVWF  xC1
....................     //Write address
....................     spi_write(_BUFFER[0]);
1652:  MOVF   FC9,W
1654:  MOVFF  C1,FC9
1658:  RRCF   FC7,W
165A:  BNC   1658
....................     delay_us(100);  // Tiempo para que el esclavo responda
165C:  MOVLW  64
165E:  MOVLB  2
1660:  MOVWF  x1B
1662:  MOVLB  0
1664:  BRA    1608
....................     for (i=0;i<length;i++)
1666:  MOVLB  2
1668:  CLRF   x1A
166A:  MOVF   x19,W
166C:  SUBWF  x1A,W
166E:  BC    168C
....................         array[i] = spi_read(0xFF);
1670:  MOVF   x1A,W
1672:  ADDWF  x17,W
1674:  MOVWF  FE9
1676:  MOVLW  00
1678:  ADDWFC x18,W
167A:  MOVWF  FEA
167C:  MOVF   FC9,W
167E:  SETF   FC9
1680:  RRCF   FC7,W
1682:  BNC   1680
1684:  MOVFF  FC9,FEF
1688:  INCF   x1A,F
168A:  BRA    166A
....................     spiEnd();
168C:  MOVLB  0
168E:  RCALL  1630
1690:  RETURN 0
.................... 
.................... }
.................... void spi_write_from(uint8_t address,uint8_t* array, uint8_t length){
*
1804:  MOVLB  2
1806:  CLRF   x17
....................     int i=0;
....................     spiBegin();
1808:  MOVLB  0
180A:  RCALL  15FA
....................     spi_write(address | 0b10000000);
180C:  MOVLB  2
180E:  MOVF   x13,W
1810:  IORLW  80
1812:  MOVWF  x18
1814:  MOVF   FC9,W
1816:  MOVFF  218,FC9
181A:  RRCF   FC7,W
181C:  BNC   181A
....................     //El address se aumenta en 1 automaticamente
....................    //Serial.println("Writing SPI");
....................     for (i=0;i<length;i++){
181E:  CLRF   x17
1820:  MOVF   x16,W
1822:  SUBWF  x17,W
1824:  BC    1844
....................       // Serial.println((char)array[i]);
....................       spi_write(array[i]);}
1826:  MOVF   x17,W
1828:  ADDWF  x14,W
182A:  MOVWF  FE9
182C:  MOVLW  00
182E:  ADDWFC x15,W
1830:  MOVWF  FEA
1832:  MOVFF  FEF,218
1836:  MOVF   FC9,W
1838:  MOVFF  218,FC9
183C:  RRCF   FC7,W
183E:  BNC   183C
1840:  INCF   x17,F
1842:  BRA    1820
....................     spiEnd();    
1844:  MOVLB  0
1846:  RCALL  1630
1848:  RETURN 0
.................... }
.................... uint8_t spi_read_u8(uint8_t address){
....................     spi_read_into(address,_BUFFER,1);
*
1692:  MOVFF  215,216
1696:  MOVLB  2
1698:  CLRF   x18
169A:  MOVLW  C1
169C:  MOVWF  x17
169E:  MOVLW  01
16A0:  MOVWF  x19
16A2:  MOVLB  0
16A4:  RCALL  1640
....................     return _BUFFER[0];
16A6:  MOVFF  C1,01
16AA:  RETURN 0
.................... }
.................... uint8_t spi_write_u8(uint8_t address,uint8_t val){
....................     _BUFFER[0] = val;
*
184A:  MOVFF  212,C1
....................     spi_write_from(address,_BUFFER,1);
184E:  MOVFF  211,213
1852:  MOVLB  2
1854:  CLRF   x15
1856:  MOVLW  C1
1858:  MOVWF  x14
185A:  MOVLW  01
185C:  MOVWF  x16
185E:  MOVLB  0
1860:  RCALL  1804
....................     return _BUFFER[0];
1862:  MOVFF  C1,01
1866:  RETURN 0
.................... }
.................... void sleep_ms(int ms){
....................     delay_ms(ms);
*
17BE:  MOVFF  1AE,211
17C2:  RCALL  155A
17C4:  RETURN 0
.................... }
.................... 
.................... #include <afadruit_rfm69.h>
.................... 
.................... // # The crystal oscillator frequency and frequency synthesizer step size.
.................... // # See the datasheet for details of this calculation.
.................... const float _FXOSC = 32000000.0;
.................... const float _FSTEP = _FXOSC / 524288;
.................... 
.................... void readAllRegs();
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL);
.................... void reset();
.................... void set_boost(uint8_t setting);
.................... void idle();
.................... void rfm_sleep();
.................... void listen();
.................... void transmit();
.................... float temperature_get();
.................... uint8_t operation_mode_get();
.................... void operation_mode_set(uint8_t val);
.................... uint8_t* sync_word_get();
.................... void sync_word_set(uint8_t* wrd);
.................... uint16_t preamble_length_get();
.................... void preamble_length_set(uint16_t val);
.................... float frequency_mhz_get();
.................... void frequency_mhz_set();
.................... uint8_t* encryption_key_get();
.................... void encryption_key_set(uint8_t* val);
.................... int8_t tx_power_get();
.................... void tx_power_set(int8_t val);
.................... float rssi_get();
.................... float bitrate_get();
.................... void bitrate_set(float val);
.................... float frequency_deviation_get();
.................... void frequency_deviation_set(float val);
.................... bool packet_sent();
.................... bool payload_ready();
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256);
.................... bool send_with_ack(uint8_t* data,uint8_t len);
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false);
.................... 
.................... struct _RegisterBits{
.................... uint8_t address;
.................... uint8_t mask;
.................... uint8_t offset;
.................... };
.................... 
.................... void set(uint8_t val,struct _RegisterBits obj){
*
19C6:  MOVFF  1D2,215
19CA:  RCALL  1692
19CC:  MOVFF  01,1D5
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         regVal &= ~obj.mask;
19D0:  MOVLB  1
19D2:  MOVF   xD3,W
19D4:  XORLW  FF
19D6:  ANDWF  xD5,F
....................         regVal |= (val & 0xFF) << obj.offset;
19D8:  MOVFF  1D1,00
19DC:  MOVF   xD4,W
19DE:  MOVWF  01
19E0:  BZ    19EA
19E2:  BCF    FD8.0
19E4:  RLCF   00,F
19E6:  DECFSZ 01,F
19E8:  BRA    19E2
19EA:  MOVF   00,W
19EC:  IORWF  xD5,F
....................         spi_write_u8(obj.address,regVal);
19EE:  MOVFF  1D2,211
19F2:  MOVFF  1D5,212
19F6:  MOVLB  0
19F8:  RCALL  184A
19FA:  RETURN 0
.................... }
.................... uint8_t get(struct _RegisterBits obj){
*
1896:  MOVFF  211,215
189A:  RCALL  1692
189C:  MOVFF  01,214
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         return ((regVal & obj.mask) >> obj.offset);
18A0:  MOVLB  2
18A2:  MOVF   x14,W
18A4:  ANDWF  x12,W
18A6:  MOVWF  00
18A8:  MOVF   x13,W
18AA:  MOVWF  01
18AC:  BZ    18B6
18AE:  BCF    FD8.0
18B0:  RRCF   00,F
18B2:  DECFSZ 01,F
18B4:  BRA    18AE
18B6:  MOVF   00,W
18B8:  MOVWF  01
18BA:  MOVLB  0
18BC:  RETURN 0
....................     }
.................... uint8_t _debug_(struct _RegisterBits obj){
....................       print ((char*)"Mask: ");
....................       println(obj.mask,BIN);
....................       return obj.mask; 
.................... }
.................... 
.................... struct _RegisterBits _RegisterBits_(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
*
1468:  MOVLB  1
146A:  CLRF   x88
.................... 
....................         uint8_t i=0;
....................         struct _RegisterBits ret;
....................         ret.mask=0;
146C:  CLRF   x8A
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         ret.address = _address;
146E:  MOVFF  185,189
....................         for (i=0;i<bits;i++){
1472:  CLRF   x88
1474:  MOVF   x87,W
1476:  SUBWF  x88,W
1478:  BC    1484
....................             ret.mask<<=1;
147A:  BCF    FD8.0
147C:  RLCF   x8A,F
....................             ret.mask|=1;
147E:  BSF    x8A.0
1480:  INCF   x88,F
1482:  BRA    1474
....................         }
....................         ret.mask <<= _offset;
1484:  MOVF   x86,W
1486:  MOVWF  01
1488:  BZ    1492
148A:  BCF    FD8.0
148C:  RLCF   x8A,F
148E:  DECFSZ 01,F
1490:  BRA    148A
....................         ret.offset = _offset;
1492:  MOVFF  186,18B
....................         return ret;
1496:  MOVFF  189,01
149A:  MOVFF  18A,02
149E:  MOVFF  18B,03
14A2:  MOVLB  0
14A4:  RETURN 0
....................  }
....................  
.................... /*
.................... class _RegisterBits{
....................     public:
....................     uint8_t address;
....................     uint8_t mask;
....................     uint8_t offset;
....................     _RegisterBits(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
....................         uint8_t i=0;
....................         mask=0;
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         address = _address;
....................         for (i=0;i<bits;i++){
....................             mask<<=1;
....................             mask|=1;
....................         }
....................         mask <<= _offset;
....................         offset = _offset;
....................         }
....................     void set(uint8_t val){
....................         uint8_t regVal = spi_read_u8(address);
....................         regVal &= ~mask;
....................         regVal |= (val & 0xFF) << offset;
....................         spi_write_u8(address,regVal);
....................     }
....................     uint8_t get(){
....................         uint8_t regVal = spi_read_u8(address);
....................         return ((regVal & mask) >> offset);
....................     }
....................    
....................   
....................     }
.................... };
.................... */
.................... 
....................     
.................... //Configuraciones que solo utilizan ciertos bits   
.................... struct _RegisterBits data_mode = _RegisterBits_(_REG_DATA_MOD, 5, 2);
.................... struct _RegisterBits modulation_type = _RegisterBits_(_REG_DATA_MOD, 3, 2);
.................... struct _RegisterBits modulation_shaping = _RegisterBits_(_REG_DATA_MOD, 0, 2);
.................... struct _RegisterBits temp_start = _RegisterBits_(_REG_TEMP1, 3);
.................... struct _RegisterBits temp_running = _RegisterBits_(_REG_TEMP1, 2);
.................... struct _RegisterBits sync_on = _RegisterBits_(_REG_SYNC_CONFIG, 7);
.................... struct _RegisterBits sync_size = _RegisterBits_(_REG_SYNC_CONFIG, 3, 3);
.................... struct _RegisterBits aes_on = _RegisterBits_(_REG_PACKET_CONFIG2, 0);
.................... struct _RegisterBits pa_0_on = _RegisterBits_(_REG_PA_LEVEL, 7);
.................... struct _RegisterBits pa_1_on = _RegisterBits_(_REG_PA_LEVEL, 6);
.................... struct _RegisterBits pa_2_on = _RegisterBits_(_REG_PA_LEVEL, 5);
.................... struct _RegisterBits output_power = _RegisterBits_(_REG_PA_LEVEL, 0, 5);
.................... struct _RegisterBits rx_bw_dcc_freq = _RegisterBits_(_REG_RX_BW, 5, 3);
.................... struct _RegisterBits rx_bw_mantissa = _RegisterBits_(_REG_RX_BW, 3, 2);
.................... struct _RegisterBits rx_bw_exponent = _RegisterBits_(_REG_RX_BW, 0, 3);
.................... struct _RegisterBits afc_bw_dcc_freq = _RegisterBits_(_REG_AFC_BW, 5, 3);
.................... struct _RegisterBits afc_bw_mantissa = _RegisterBits_(_REG_AFC_BW, 3, 2);
.................... struct _RegisterBits afc_bw_exponent = _RegisterBits_(_REG_AFC_BW, 0, 3);
.................... struct _RegisterBits packet_format = _RegisterBits_(_REG_PACKET_CONFIG1, 7, 1);
.................... struct _RegisterBits dc_free = _RegisterBits_(_REG_PACKET_CONFIG1, 5, 2);
.................... struct _RegisterBits crc_on = _RegisterBits_(_REG_PACKET_CONFIG1, 4, 1);
.................... struct _RegisterBits crc_auto_clear_off = _RegisterBits_(_REG_PACKET_CONFIG1, 3, 1);
.................... struct _RegisterBits address_filter = _RegisterBits_(_REG_PACKET_CONFIG1, 1, 2);
.................... struct _RegisterBits mode_ready = _RegisterBits_(_REG_IRQ_FLAGS1, 7);
.................... struct _RegisterBits dio_0_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 6, 2);
.................... struct _RegisterBits dio_1_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 4, 2);
.................... struct _RegisterBits dio_2_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 2, 2);
.................... struct _RegisterBits dio_3_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 0, 2);
.................... struct _RegisterBits dio_4_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 6, 2);
.................... struct _RegisterBits dio_5_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 4, 2);
.................... 
.................... //Extras
.................... int8_t _tx_power;
.................... int8_t tx_power;
.................... bool high_power;
.................... uint8_t* sync_word;
.................... uint16_t preamble_length;
.................... uint32_t frequency_mhz;
.................... float bitrate;
.................... float rssi;
.................... float last_rssi;
.................... float ack_wait;
.................... float receive_timeout;
.................... float xmit_timeout;
.................... uint8_t ack_retries;
.................... float ack_delay;
.................... uint8_t sequence_number;
.................... uint8_t seen_ids[8];
.................... uint8_t node;
.................... uint8_t destination;
.................... uint8_t identifier;
.................... uint8_t flags;
.................... uint8_t operation_mode;
.................... float temperature;
.................... uint8_t encryption_key[16];
.................... float frequency_deviation;
.................... int _reset_pin;
.................... 
.................... 
.................... void readAllRegs()
.................... {
....................   uint8_t regVal;
....................   
....................   println((char*)"Address - HEX - BIN");
....................   for (uint8_t regAddr = 1; regAddr <= 0x4F; regAddr++)
....................   {
....................     /*
....................     spiBegin();
....................     SPI.transfer(regAddr & 0x7F); // send address + r/w bit
....................     regVal = SPI.transfer(0);
....................     spiEnd();*/
....................     regVal = spi_read_u8(regAddr);
....................     print(regAddr, HEX);
....................     print((char*)" - ");
....................     print(regVal,HEX);
....................     print((char*)" - ");
....................     println(regVal,BIN);
....................   }
....................   spiEnd();
.................... }    
.................... 
.................... bool checkId(){
.................... uint8_t version;
.................... version = spi_read_u8(_REG_VERSION);
*
16AC:  MOVLW  10
16AE:  MOVLB  2
16B0:  MOVWF  x15
16B2:  MOVLB  0
16B4:  RCALL  1692
16B6:  MOVFF  01,185
.................... return version==0x24;
16BA:  MOVLB  1
16BC:  MOVF   x85,W
16BE:  SUBLW  24
16C0:  BZ    16C6
16C2:  MOVLW  00
16C4:  BRA    16C8
16C6:  MOVLW  01
16C8:  MOVWF  01
16CA:  MOVLB  0
16CC:  GOTO   3934 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL){
*
20DC:  MOVLB  1
20DE:  CLRF   x90
....................     uint8_t version=0;
....................     println((char*)"Initial conf starts");
20E0:  MOVLW  01
20E2:  MOVWF  FEA
20E4:  MOVLW  91
20E6:  MOVWF  FE9
20E8:  MOVLW  14
20EA:  MOVWF  01
20EC:  CLRF   FF7
20EE:  MOVLW  00
20F0:  MOVLB  0
20F2:  CALL   0236
20F6:  TBLRD*-
20F8:  TBLRD*+
20FA:  MOVFF  FF5,FEE
20FE:  DECFSZ 01,F
2100:  BRA    20F8
2102:  MOVLW  01
2104:  MOVLB  2
2106:  MOVWF  x14
2108:  MOVLW  91
210A:  MOVWF  x13
210C:  MOVLB  0
210E:  CALL   179E
....................     //Serial.println("HOLA 2");
....................     _tx_power = 13;
2112:  MOVLW  0D
2114:  MOVLB  1
2116:  MOVWF  x21
....................     _reset_pin = resetPin;
2118:  MOVFF  187,16E
....................     high_power = _high_power;
211C:  MOVLB  0
211E:  BCF    xB5.1
2120:  MOVLB  1
2122:  BTFSS  x89.0
2124:  BRA    212C
2126:  MOVLB  0
2128:  BSF    xB5.1
212A:  MOVLB  1
....................     reset();
212C:  MOVLB  0
212E:  GOTO   17C6
....................     //readAllRegs();
....................     
....................     version = spi_read_u8(_REG_VERSION);
2132:  MOVLW  10
2134:  MOVLB  2
2136:  MOVWF  x15
2138:  MOVLB  0
213A:  CALL   1692
213E:  MOVFF  01,190
....................     if (version != 0x24){
2142:  MOVLB  1
2144:  MOVF   x90,W
2146:  SUBLW  24
2148:  BZ    21B4
....................         println((char*)"Error: ID del RFM incorrecta");
214A:  MOVLW  01
214C:  MOVWF  FEA
214E:  MOVLW  91
2150:  MOVWF  FE9
2152:  MOVLW  1D
2154:  MOVWF  01
2156:  CLRF   FF7
2158:  MOVLW  00
215A:  MOVLB  0
215C:  CALL   025A
2160:  TBLRD*-
2162:  TBLRD*+
2164:  MOVFF  FF5,FEE
2168:  DECFSZ 01,F
216A:  BRA    2162
216C:  MOVLW  01
216E:  MOVLB  2
2170:  MOVWF  x14
2172:  MOVLW  91
2174:  MOVWF  x13
2176:  MOVLB  0
2178:  CALL   179E
....................         while(1){
....................         println((char*)"ID Loop");
217C:  MOVLW  01
217E:  MOVWF  FEA
2180:  MOVLW  91
2182:  MOVWF  FE9
2184:  MOVLW  08
2186:  MOVWF  01
2188:  CLRF   FF7
218A:  MOVLW  00
218C:  CALL   0288
2190:  TBLRD*-
2192:  TBLRD*+
2194:  MOVFF  FF5,FEE
2198:  DECFSZ 01,F
219A:  BRA    2192
219C:  MOVLW  01
219E:  MOVLB  2
21A0:  MOVWF  x14
21A2:  MOVLW  91
21A4:  MOVWF  x13
21A6:  MOVLB  0
21A8:  CALL   179E
....................         usb_task();
21AC:  CALL   1508
21B0:  BRA    217C
21B2:  MOVLB  1
....................         }
....................         //exit(-1);
....................     }
....................     print((char*)"Idle");
21B4:  MOVLW  49
21B6:  MOVWF  x91
21B8:  MOVLW  64
21BA:  MOVWF  x92
21BC:  MOVLW  6C
21BE:  MOVWF  x93
21C0:  MOVLW  65
21C2:  MOVWF  x94
21C4:  CLRF   x95
21C6:  MOVLW  01
21C8:  MOVWF  xD4
21CA:  MOVLW  91
21CC:  MOVWF  xD3
21CE:  MOVLB  0
21D0:  CALL   17F8
....................     idle();
21D4:  CALL   19B0
....................     println((char*)"Ready");
21D8:  MOVLW  52
21DA:  MOVLB  1
21DC:  MOVWF  x91
21DE:  MOVLW  65
21E0:  MOVWF  x92
21E2:  MOVLW  61
21E4:  MOVWF  x93
21E6:  MOVLW  64
21E8:  MOVWF  x94
21EA:  MOVLW  79
21EC:  MOVWF  x95
21EE:  CLRF   x96
21F0:  MOVLW  01
21F2:  MOVLB  2
21F4:  MOVWF  x14
21F6:  MOVLW  91
21F8:  MOVWF  x13
21FA:  MOVLB  0
21FC:  CALL   179E
....................     //Chip setup
....................     //Set FIFO TX condition to not empty and the default FIFO threshold to 15.
....................     spi_write_u8(_REG_FIFO_THRESH, 0b10001111);
2200:  MOVLW  3C
2202:  MOVLB  2
2204:  MOVWF  x11
2206:  MOVLW  8F
2208:  MOVWF  x12
220A:  MOVLB  0
220C:  CALL   184A
....................     //Configure low beta off.
....................     spi_write_u8(_REG_TEST_DAGC, 0x30);
2210:  MOVLW  6F
2212:  MOVLB  2
2214:  MOVWF  x11
2216:  MOVLW  30
2218:  MOVWF  x12
221A:  MOVLB  0
221C:  CALL   184A
....................     //Disable boost.
....................     spi_write_u8(_REG_TEST_PA1, _TEST_PA1_NORMAL);
2220:  MOVLW  5A
2222:  MOVLB  2
2224:  MOVWF  x11
2226:  MOVLW  55
2228:  MOVWF  x12
222A:  MOVLB  0
222C:  CALL   184A
....................     spi_write_u8(_REG_TEST_PA2, _TEST_PA2_NORMAL);
2230:  MOVLW  5C
2232:  MOVLB  2
2234:  MOVWF  x11
2236:  MOVLW  70
2238:  MOVWF  x12
223A:  MOVLB  0
223C:  CALL   184A
....................     //set sync word
....................     //IMPORTANTE: Recuerda alocar el espacio para que no se sobreescriba
....................     print((char*)"Freq");
2240:  MOVLW  46
2242:  MOVLB  1
2244:  MOVWF  x91
2246:  MOVLW  72
2248:  MOVWF  x92
224A:  MOVLW  65
224C:  MOVWF  x93
224E:  MOVLW  71
2250:  MOVWF  x94
2252:  CLRF   x95
2254:  MOVLW  01
2256:  MOVWF  xD4
2258:  MOVLW  91
225A:  MOVWF  xD3
225C:  MOVLB  0
225E:  CALL   17F8
....................     sync_word_set( _sync_word); 
2262:  MOVFF  186,1AF
2266:  MOVFF  185,1AE
226A:  GOTO   19FC
....................     preamble_length_set(_preamble_length);
226E:  MOVLB  1
2270:  CLRF   xAF
2272:  MOVFF  188,1AE
2276:  MOVLB  0
2278:  BRA    1A82
....................     frequency_mhz_set(); 
227A:  BRA    1AAC
....................     println((char*)"Ready");
227C:  MOVLW  52
227E:  MOVLB  1
2280:  MOVWF  x91
2282:  MOVLW  65
2284:  MOVWF  x92
2286:  MOVLW  61
2288:  MOVWF  x93
228A:  MOVLW  64
228C:  MOVWF  x94
228E:  MOVLW  79
2290:  MOVWF  x95
2292:  CLRF   x96
2294:  MOVLW  01
2296:  MOVLB  2
2298:  MOVWF  x14
229A:  MOVLW  91
229C:  MOVWF  x13
229E:  MOVLB  0
22A0:  CALL   179E
....................     //TODO: set encryption key
....................     //encryption_key = encrypt;
....................     //encryption_key_set(encrypt);
....................     
....................     //PARA USUARIOS AVANZADOS ----------------------------------------------------------------------------------------------
....................     // Configure modulation for RadioHead library GFSK_Rb250Fd250 mode
....................     // by default.  Users with advanced knowledge can manually reconfigure
....................     // for any other mode (consulting the datasheet is absolutely
....................     // necessary!).
....................     bitrate_set(250000);  // 250kbs
22A4:  MOVLB  1
22A6:  CLRF   xB1
22A8:  MOVLW  24
22AA:  MOVWF  xB0
22AC:  MOVLW  74
22AE:  MOVWF  xAF
22B0:  MOVLW  90
22B2:  MOVWF  xAE
22B4:  MOVLB  0
22B6:  BRA    1EEC
....................     frequency_deviation_set(250000);  // 250khz
22B8:  MOVLB  1
22BA:  CLRF   xB1
22BC:  MOVLW  24
22BE:  MOVWF  xB0
22C0:  MOVLW  74
22C2:  MOVWF  xAF
22C4:  MOVLW  90
22C6:  MOVWF  xAE
22C8:  MOVLB  0
22CA:  BRA    1F8A
....................     set(0b01,modulation_shaping);  // Gaussian filter, BT=1.0
22CC:  MOVLW  01
22CE:  MOVLB  1
22D0:  MOVWF  xD1
22D2:  MOVFF  CF,1D4
22D6:  MOVFF  CE,1D3
22DA:  MOVFF  CD,1D2
22DE:  MOVLB  0
22E0:  CALL   19C6
....................     set(0b111,rx_bw_dcc_freq);  // RxBw register = 0xE0
22E4:  MOVLW  07
22E6:  MOVLB  1
22E8:  MOVWF  xD1
22EA:  MOVFF  ED,1D4
22EE:  MOVFF  EC,1D3
22F2:  MOVFF  EB,1D2
22F6:  MOVLB  0
22F8:  CALL   19C6
....................     set(0b00,rx_bw_mantissa);
22FC:  MOVLB  1
22FE:  CLRF   xD1
2300:  MOVFF  F0,1D4
2304:  MOVFF  EF,1D3
2308:  MOVFF  EE,1D2
230C:  MOVLB  0
230E:  CALL   19C6
....................     set(0b000,rx_bw_exponent);
2312:  MOVLB  1
2314:  CLRF   xD1
2316:  MOVFF  F3,1D4
231A:  MOVFF  F2,1D3
231E:  MOVFF  F1,1D2
2322:  MOVLB  0
2324:  CALL   19C6
....................     set(0b111,afc_bw_dcc_freq); // AfcBw register = 0xE0
2328:  MOVLW  07
232A:  MOVLB  1
232C:  MOVWF  xD1
232E:  MOVFF  F6,1D4
2332:  MOVFF  F5,1D3
2336:  MOVFF  F4,1D2
233A:  MOVLB  0
233C:  CALL   19C6
....................     set(0b00,afc_bw_mantissa);
2340:  MOVLB  1
2342:  CLRF   xD1
2344:  MOVFF  F9,1D4
2348:  MOVFF  F8,1D3
234C:  MOVFF  F7,1D2
2350:  MOVLB  0
2352:  CALL   19C6
....................     set(0b000,afc_bw_exponent);
2356:  MOVLB  1
2358:  CLRF   xD1
235A:  MOVFF  FC,1D4
235E:  MOVFF  FB,1D3
2362:  MOVFF  FA,1D2
2366:  MOVLB  0
2368:  CALL   19C6
....................     set(1,packet_format);  // Variable length.
236C:  MOVLW  01
236E:  MOVLB  1
2370:  MOVWF  xD1
2372:  MOVFF  FF,1D4
2376:  MOVFF  FE,1D3
237A:  MOVFF  FD,1D2
237E:  MOVLB  0
2380:  CALL   19C6
....................     set(0b10,dc_free);  // Whitening
2384:  MOVLW  02
2386:  MOVLB  1
2388:  MOVWF  xD1
238A:  MOVFF  102,1D4
238E:  MOVFF  101,1D3
2392:  MOVFF  100,1D2
2396:  MOVLB  0
2398:  CALL   19C6
....................     //-----------------------------------------------------------------------------------------------------------------------
....................     // Set transmit power to 13 dBm, a safe value any module supports.
....................     tx_power_set(13);
239C:  MOVLW  0D
239E:  MOVLB  1
23A0:  MOVWF  xAE
23A2:  MOVLB  0
23A4:  BRA    2028
....................     //
....................     // initialize last RSSI reading
....................     last_rssi = 0.0;
23A6:  MOVLB  1
23A8:  CLRF   x36
23AA:  CLRF   x35
23AC:  CLRF   x34
23AE:  CLRF   x33
....................     // """The RSSI of the last received packet. Stored when the packet was received.
....................     //    This instantaneous RSSI value may not be accurate once the
....................     //    operating mode has been changed.
....................     // """
....................     // initialize timeouts and delays delays
....................     ack_wait = 0.5;
23B0:  CLRF   x3A
23B2:  CLRF   x39
23B4:  CLRF   x38
23B6:  MOVLW  7E
23B8:  MOVWF  x37
....................     // """The delay time before attempting a retry after not receiving an ACK"""
....................     receive_timeout = 0.5;
23BA:  CLRF   x3E
23BC:  CLRF   x3D
23BE:  CLRF   x3C
23C0:  MOVWF  x3B
....................     // """The amount of time to poll for a received packet.
....................     //    If no packet is received, the returned packet will be None
....................     // """
....................     xmit_timeout = 2.0;
23C2:  CLRF   x42
23C4:  CLRF   x41
23C6:  CLRF   x40
23C8:  MOVLW  80
23CA:  MOVWF  x3F
....................     // """The amount of time to wait for the HW to transmit the packet.
....................     //    This is mainly used to prevent a hang due to a HW issue
....................     // """
....................     ack_retries = 5;
23CC:  MOVLW  05
23CE:  MOVWF  x43
....................     // """The number of ACK retries before reporting a failure."""
....................     ack_delay = 0;
23D0:  CLRF   x47
23D2:  CLRF   x46
23D4:  CLRF   x45
23D6:  CLRF   x44
....................     // """The delay time before attemting to send an ACK.
....................     //    If ACKs are being missed try setting this to .1 or .2.
....................     // """
....................     //print("<------------------------------------------------------------------------------------------------------------------------------------------>")
....................     // initialize sequence number counter for reliabe datagram mode
....................     sequence_number = 0;
23D8:  CLRF   x48
....................     // create seen Ids list
....................     //seen_ids = {0};
....................     // initialize packet header
....................     // node address - default is broadcast
....................     node = _RH_BROADCAST_ADDRESS;
23DA:  SETF   x51
....................     // """The default address of this Node. (0-255).
....................     //    If not 255 (0xff) then only packets address to this node will be accepted.
....................     //    First byte of the RadioHead header.
....................     // """
....................     // destination address - default is broadcast
....................     destination = _RH_BROADCAST_ADDRESS;
23DC:  SETF   x52
....................     // """The default destination address for packet transmissions. (0-255).
....................     //    If 255 (0xff) then any receiving node should accept the packet.
....................     //    Second byte of the RadioHead header.
....................     // """
....................     // ID - contains seq count for reliable datagram mode
....................     identifier = 0;
23DE:  CLRF   x53
....................     // """Automatically set to the sequence number when send_with_ack() used.
....................     //    Third byte of the RadioHead header.
....................     // """
....................     // flags - identifies ack/reetry packet for reliable datagram mode
....................     flags = 0;
23E0:  CLRF   x54
....................     // """Upper 4 bits reserved for use by Reliable Datagram Mode.
....................     //    Lower 4 bits may be used to pass information.
....................     //    Fourth byte of the RadioHead header.
....................     // """
....................     //Extras: paara algunos registros que no coinciden con la libreria del micropython
....................     // RSSI_CONFIG: 0x2
....................     spi_write_u8(0x23,0x02);
23E2:  MOVLW  23
23E4:  MOVLB  2
23E6:  MOVWF  x11
23E8:  MOVLW  02
23EA:  MOVWF  x12
23EC:  MOVLB  0
23EE:  CALL   184A
....................     //_REG_DIO_MAPPING1
....................     spi_write_u8(_REG_DIO_MAPPING1,0x00);
23F2:  MOVLW  25
23F4:  MOVLB  2
23F6:  MOVWF  x11
23F8:  CLRF   x12
23FA:  MOVLB  0
23FC:  CALL   184A
....................     //101  FXOSC / 32
....................     spi_write_u8(_REG_DIO_MAPPING1+1,0b101);
2400:  MOVLW  26
2402:  MOVLB  2
2404:  MOVWF  x11
2406:  MOVLW  05
2408:  MOVWF  x12
240A:  MOVLB  0
240C:  CALL   184A
....................     //RSSI_THRESH
....................     spi_write_u8(0x29,0xFF);
2410:  MOVLW  29
2412:  MOVLB  2
2414:  MOVWF  x11
2416:  SETF   x12
2418:  MOVLB  0
241A:  CALL   184A
....................     //INIT payload length to 0
....................     spi_write_u8(0x38,0x40);
241E:  MOVLW  38
2420:  MOVLB  2
2422:  MOVWF  x11
2424:  MOVLW  40
2426:  MOVWF  x12
2428:  MOVLB  0
242A:  CALL   184A
....................     //AutoRxRestartOn
....................     spi_write_u8(_REG_PACKET_CONFIG2,0x02);
242E:  MOVLW  3D
2430:  MOVLB  2
2432:  MOVWF  x11
2434:  MOVLW  02
2436:  MOVWF  x12
2438:  MOVLB  0
243A:  CALL   184A
....................     //Con esto se puede colocar un LED en DIO2 y ver los datos que se reciben y se envian
....................     set(0b01,dio_2_mapping);
243E:  MOVLW  01
2440:  MOVLB  1
2442:  MOVWF  xD1
2444:  MOVFF  117,1D4
2448:  MOVFF  116,1D3
244C:  MOVFF  115,1D2
2450:  MOVLB  0
2452:  CALL   19C6
....................     //Asi se puede saber si el buffer FIFO tiene algun dato
....................     set(0b10,dio_1_mapping);
2456:  MOVLW  02
2458:  MOVLB  1
245A:  MOVWF  xD1
245C:  MOVFF  114,1D4
2460:  MOVFF  113,1D3
2464:  MOVFF  112,1D2
2468:  MOVLB  0
246A:  CALL   19C6
....................     //En modo rx, da informacion acerca del RSSI (Recieved Signal Strength Indicator)
....................     set(0b01,dio_3_mapping);
246E:  MOVLW  01
2470:  MOVLB  1
2472:  MOVWF  xD1
2474:  MOVFF  11A,1D4
2478:  MOVFF  119,1D3
247C:  MOVFF  118,1D2
2480:  MOVLB  0
2482:  CALL   19C6
....................     print((char*)"Initial configuration end\n");
2486:  MOVLW  01
2488:  MOVWF  FEA
248A:  MOVLW  91
248C:  MOVWF  FE9
248E:  MOVLW  1B
2490:  MOVWF  01
2492:  CLRF   FF7
2494:  MOVLW  00
2496:  CALL   02A0
249A:  TBLRD*-
249C:  TBLRD*+
249E:  MOVFF  FF5,FEE
24A2:  DECFSZ 01,F
24A4:  BRA    249C
24A6:  MOVLW  01
24A8:  MOVLB  1
24AA:  MOVWF  xD4
24AC:  MOVLW  91
24AE:  MOVWF  xD3
24B0:  MOVLB  0
24B2:  CALL   17F8
24B6:  GOTO   3998 (RETURN)
.................... }
.................... void reset(){
....................     setOutput(_reset_pin,1);
*
17C6:  MOVFF  16E,21B
17CA:  MOVLW  01
17CC:  MOVLB  2
17CE:  MOVWF  x1C
17D0:  MOVLB  0
17D2:  RCALL  15C6
....................     sleep_ms(1);
17D4:  MOVLW  01
17D6:  MOVLB  1
17D8:  MOVWF  xAE
17DA:  MOVLB  0
17DC:  RCALL  17BE
....................     setOutput(_reset_pin,0);
17DE:  MOVFF  16E,21B
17E2:  MOVLB  2
17E4:  CLRF   x1C
17E6:  MOVLB  0
17E8:  RCALL  15C6
....................     sleep_ms(5);
17EA:  MOVLW  05
17EC:  MOVLB  1
17EE:  MOVWF  xAE
17F0:  MOVLB  0
17F2:  RCALL  17BE
17F4:  GOTO   2132 (RETURN)
.................... }
.................... void set_boost(uint8_t setting){
....................     //Set preamp boost if needed.
....................     if (_tx_power >= 18){
*
1868:  MOVLB  1
186A:  BTFSC  x21.7
186C:  BRA    1892
186E:  MOVF   x21,W
1870:  SUBLW  11
1872:  BC    1892
....................         spi_write_u8(_REG_TEST_PA1, setting);
1874:  MOVLW  5A
1876:  MOVLB  2
1878:  MOVWF  x11
187A:  MOVFF  1D1,212
187E:  MOVLB  0
1880:  RCALL  184A
....................         spi_write_u8(_REG_TEST_PA2, setting);
1882:  MOVLW  5C
1884:  MOVLB  2
1886:  MOVWF  x11
1888:  MOVFF  1D1,212
188C:  MOVLB  0
188E:  RCALL  184A
1890:  MOVLB  1
....................     }
1892:  MOVLB  0
1894:  RETURN 0
.................... }
.................... void idle(){
....................     //Enter idle standby mode (switching off high power amplifiers if necessary).
....................     //Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
*
19B0:  MOVLW  55
19B2:  MOVLB  1
19B4:  MOVWF  xD1
19B6:  MOVLB  0
19B8:  RCALL  1868
....................     operation_mode_set(STANDBY_MODE);
19BA:  MOVLW  01
19BC:  MOVLB  1
19BE:  MOVWF  xD1
19C0:  MOVLB  0
19C2:  RCALL  18BE
19C4:  RETURN 0
....................            
.................... }
.................... void rfm_sleep(){
....................     operation_mode_set(SLEEP_MODE); 
.................... }
.................... void listen(){
....................     //Listen for packets to be received by the chip.  Use :py:func:`receive` to listen, wait
....................     //and retrieve packets as they're available.
....................     
....................     // Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
*
2534:  MOVLW  55
2536:  MOVLB  1
2538:  MOVWF  xD1
253A:  MOVLB  0
253C:  CALL   1868
....................     // Enable payload ready interrupt for D0 line.
....................     set(0b01,dio_0_mapping);
2540:  MOVLW  01
2542:  MOVLB  1
2544:  MOVWF  xD1
2546:  MOVFF  111,1D4
254A:  MOVFF  110,1D3
254E:  MOVFF  10F,1D2
2552:  MOVLB  0
2554:  CALL   19C6
....................     // Enter RX mode (will clear FIFO!).
....................           
....................     operation_mode_set(RX_MODE); 
2558:  MOVLW  04
255A:  MOVLB  1
255C:  MOVWF  xD1
255E:  MOVLB  0
2560:  CALL   18BE
2564:  RETURN 0
.................... }
.................... void transmit(){
....................     // Transmit a packet which is queued in the FIFO.  This is a low level function for
....................     // entering transmit mode and more.  For generating and transmitting a packet of data use
....................     // :py:func:`send` instead.
....................     
....................     // # Like RadioHead library, turn on high power boost if enabled.
....................     set_boost(_TEST_PA1_BOOST);
*
2D60:  MOVLW  5D
2D62:  MOVLB  1
2D64:  MOVWF  xD1
2D66:  MOVLB  0
2D68:  CALL   1868
....................     // # Enable packet sent interrupt for D0 line.
....................     set(0b00,dio_0_mapping);
2D6C:  MOVLB  1
2D6E:  CLRF   xD1
2D70:  MOVFF  111,1D4
2D74:  MOVFF  110,1D3
2D78:  MOVFF  10F,1D2
2D7C:  MOVLB  0
2D7E:  CALL   19C6
....................     //readAllRegs(); 
....................     // # Enter TX mode (will clear FIFO!).
....................     operation_mode_set(TX_MODE);  
2D82:  MOVLW  03
2D84:  MOVLB  1
2D86:  MOVWF  xD1
2D88:  MOVLB  0
2D8A:  CALL   18BE
2D8E:  GOTO   2F40 (RETURN)
.................... }
.................... // .. warning:: Reading this will STOP any receiving/sending that might be happening!
.................... //WARNING:LOOP infinito
.................... float temperature_get(){
....................     // The internal temperature of the chip in degrees Celsius. Be warned this is not
....................     // calibrated or very accurate.
....................     // .. warning:: Reading this will STOP any receiving/sending that might be happening!
....................     // # Start a measurement then poll the measurement finished bit.
....................     set(1,temp_start);
....................     //WARNING:LOOP infinito
....................     while (get(temp_running) > 0){
....................     usb_task();
....................     
....................     }
....................     temperature = 166.0 - (float)spi_read_u8(_REG_TEMP2);
....................     return temperature;
.................... }
.................... uint8_t operation_mode_get(){
....................     // """The operation mode value.  Unless you're manually controlling the chip you shouldn't
....................     // change the operation_mode with this property as other side-effects are required for
....................     // changing logical modes--use :py:func:`idle`, :py:func:`sleep`, :py:func:`transmit`,
....................     // :py:func:`listen` instead to signal intent for explicit logical modes.
....................     // """
....................     operation_mode = (spi_read_u8(_REG_OP_MODE) >> 2) &0b111;
....................     return operation_mode;
.................... }
.................... void operation_mode_set(uint8_t val){
....................     //float start;
....................     int n;
....................     //TODO: assert 0 <= val <= 4
....................     n=0;
*
18BE:  MOVLB  1
18C0:  CLRF   xD2
....................     
....................     while (!get(mode_ready)){
18C2:  MOVFF  10E,213
18C6:  MOVFF  10D,212
18CA:  MOVFF  10C,211
18CE:  MOVLB  0
18D0:  RCALL  1896
18D2:  MOVF   01,F
18D4:  BNZ   191E
....................       delay_ms(100);
18D6:  MOVLW  64
18D8:  MOVLB  2
18DA:  MOVWF  x11
18DC:  MOVLB  0
18DE:  RCALL  155A
....................       n+=100;
18E0:  MOVLW  64
18E2:  MOVLB  1
18E4:  ADDWF  xD2,F
....................       usb_task();
18E6:  MOVLB  0
18E8:  RCALL  1508
....................       println((char*)"OP Loop 1");
18EA:  MOVLW  01
18EC:  MOVWF  FEA
18EE:  MOVLW  D3
18F0:  MOVWF  FE9
18F2:  MOVLW  0A
18F4:  MOVWF  01
18F6:  CLRF   FF7
18F8:  MOVLW  00
18FA:  CALL   02CC
18FE:  TBLRD*-
1900:  TBLRD*+
1902:  MOVFF  FF5,FEE
1906:  DECFSZ 01,F
1908:  BRA    1900
190A:  MOVLW  01
190C:  MOVLB  2
190E:  MOVWF  x14
1910:  MOVLW  D3
1912:  MOVWF  x13
1914:  MOVLB  0
1916:  RCALL  179E
....................         if (n >= 3000){
....................                  
....................             print ((char*)"Operation Mode couldnt be set\n");
....................             println(spi_read_u8(0x27),BIN);
....................             while (1){ 
....................             usb_task();
....................             }
....................             
....................             //exit(-2);
....................         }
1918:  MOVLB  1
191A:  BRA    18C2
191C:  MOVLB  0
....................     }      
....................     // Set the mode bits inside the operation mode register.
....................     operation_mode = spi_read_u8(_REG_OP_MODE);
191E:  MOVLW  01
1920:  MOVLB  2
1922:  MOVWF  x15
1924:  MOVLB  0
1926:  RCALL  1692
1928:  MOVFF  01,155
....................     operation_mode &= 0b11100011;
192C:  MOVLW  E3
192E:  MOVLB  1
1930:  ANDWF  x55,F
....................     operation_mode |= val << 2;
1932:  RLCF   xD1,W
1934:  MOVWF  00
1936:  RLCF   00,F
1938:  MOVLW  FC
193A:  ANDWF  00,F
193C:  MOVF   00,W
193E:  IORWF  x55,F
....................     //Serial.println(operation_mode,BIN);
....................     spi_write_u8(_REG_OP_MODE,operation_mode);
1940:  MOVLW  01
1942:  MOVLB  2
1944:  MOVWF  x11
1946:  MOVFF  155,212
194A:  MOVLB  0
194C:  RCALL  184A
....................    
....................     // Wait for mode to change by polling interrupt bit.
....................     // start = timeSec();
....................     n=0;
194E:  MOVLB  1
1950:  CLRF   xD2
....................     while (!get(mode_ready)){
1952:  MOVFF  10E,213
1956:  MOVFF  10D,212
195A:  MOVFF  10C,211
195E:  MOVLB  0
1960:  RCALL  1896
1962:  MOVF   01,F
1964:  BNZ   19AE
....................     usb_task();
1966:  RCALL  1508
....................     delay_ms(100);
1968:  MOVLW  64
196A:  MOVLB  2
196C:  MOVWF  x11
196E:  MOVLB  0
1970:  RCALL  155A
....................     n+=100;
1972:  MOVLW  64
1974:  MOVLB  1
1976:  ADDWF  xD2,F
....................     println((char*)"OP Loop 2");
1978:  MOVLW  01
197A:  MOVWF  FEA
197C:  MOVLW  F2
197E:  MOVWF  FE9
1980:  MOVLW  0A
1982:  MOVWF  01
1984:  CLRF   FF7
1986:  MOVLW  00
1988:  MOVLB  0
198A:  CALL   02E6
198E:  TBLRD*-
1990:  TBLRD*+
1992:  MOVFF  FF5,FEE
1996:  DECFSZ 01,F
1998:  BRA    1990
199A:  MOVLW  01
199C:  MOVLB  2
199E:  MOVWF  x14
19A0:  MOVLW  F2
19A2:  MOVWF  x13
19A4:  MOVLB  0
19A6:  RCALL  179E
....................         if (n >= 3000){
....................             print ((char*)"Timeout on Operation Mode Set\n");
....................             println(spi_read_u8(_REG_OP_MODE),BIN)  ;      
....................             while (1){
....................             usb_task();
....................             
....................             }
....................             //exit(-2);
....................         }
19A8:  MOVLB  1
19AA:  BRA    1952
19AC:  MOVLB  0
....................     }
19AE:  RETURN 0
.................... }
.................... //WARNING must free allocated memory after using
.................... uint8_t* sync_word_get(){
....................     
....................     // """The synchronization word value.  This is a byte string up to 8 bytes long (64 bits)
....................     // which indicates the synchronization word for transmitted and received packets. Any
....................     // received packet which does not include this sync word will be ignored. The default value
....................     // is 0x2D, 0xD4 which matches the RadioHead RFM69 library. Setting a value of None will
....................     // disable synchronization word matching entirely.
....................     // """
....................     // # Handle when sync word is disabled..
....................     if (!get(sync_on))return NULL;
....................     //WARNING must free allocated memory after using
....................     sync_word = (uint8_t*)malloc(get(sync_size)+2);
....................     sync_word[0] = get(sync_size)+1;
....................     spi_read_into(_REG_SYNC_VALUE1,sync_word+1,get(sync_size)+1);
....................     return sync_word;
.................... }
.................... void sync_word_set(uint8_t* wrd){
*
19FC:  MOVLB  1
19FE:  MOVFF  1AE,FE9
1A02:  MOVFF  1AF,FEA
1A06:  MOVFF  FEF,1B0
....................   uint8_t len = wrd[0];
....................     if (len == 0 || wrd == NULL)set(0,sync_on);
1A0A:  MOVF   xB0,F
1A0C:  BZ    1A16
1A0E:  MOVF   xAE,F
1A10:  BNZ   1A2C
1A12:  MOVF   xAF,F
1A14:  BNZ   1A2C
1A16:  CLRF   xD1
1A18:  MOVFF  D8,1D4
1A1C:  MOVFF  D7,1D3
1A20:  MOVFF  D6,1D2
1A24:  MOVLB  0
1A26:  RCALL  19C6
1A28:  BRA    1A7E
1A2A:  MOVLB  1
....................     
....................     else{
....................         //TODO: assert 1 <= len(val) <= 8
....................         spi_write_from(_REG_SYNC_VALUE1,wrd+1,len);
1A2C:  MOVLW  01
1A2E:  ADDWF  xAE,W
1A30:  MOVWF  xB1
1A32:  MOVLW  00
1A34:  ADDWFC xAF,W
1A36:  MOVWF  xB2
1A38:  MOVLW  2F
1A3A:  MOVLB  2
1A3C:  MOVWF  x13
1A3E:  MOVFF  1B2,215
1A42:  MOVFF  1B1,214
1A46:  MOVFF  1B0,216
1A4A:  MOVLB  0
1A4C:  RCALL  1804
....................         //Sync_size: len(SYNC_WORD) - 1
....................         set(len-1,sync_size);
1A4E:  MOVLW  01
1A50:  MOVLB  1
1A52:  SUBWF  xB0,W
1A54:  MOVWF  xB1
1A56:  MOVWF  xD1
1A58:  MOVFF  DB,1D4
1A5C:  MOVFF  DA,1D3
1A60:  MOVFF  D9,1D2
1A64:  MOVLB  0
1A66:  RCALL  19C6
....................         set(1,sync_on);
1A68:  MOVLW  01
1A6A:  MOVLB  1
1A6C:  MOVWF  xD1
1A6E:  MOVFF  D8,1D4
1A72:  MOVFF  D7,1D3
1A76:  MOVFF  D6,1D2
1A7A:  MOVLB  0
1A7C:  RCALL  19C6
....................     }
1A7E:  GOTO   226E (RETURN)
.................... }
.................... uint16_t preamble_length_get(){
....................     // The length of the preamble for sent and received packets, an unsigned 16-bit value.
....................     // Received packets must match this length or they are ignored! Set to 4 to match the
....................     // RadioHead RFM69 library.
....................     uint8_t msb = spi_read_u8(_REG_PREAMBLE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_PREAMBLE_LSB);
....................     return ((msb << 8) | lsb) & 0xFFFF;
.................... }
.................... void preamble_length_set(uint16_t val){
....................     spi_write_u8(_REG_PREAMBLE_MSB, (val >> 8) & 0xFF);
1A82:  MOVLB  1
1A84:  CLRF   xB1
1A86:  CLRF   xB1
1A88:  MOVLW  2C
1A8A:  MOVLB  2
1A8C:  MOVWF  x11
1A8E:  MOVFF  1AF,212
1A92:  MOVLB  0
1A94:  RCALL  184A
....................     spi_write_u8(_REG_PREAMBLE_LSB, val & 0xFF);
1A96:  MOVLB  1
1A98:  CLRF   xB1
1A9A:  MOVLW  2D
1A9C:  MOVLB  2
1A9E:  MOVWF  x11
1AA0:  MOVFF  1AE,212
1AA4:  MOVLB  0
1AA6:  RCALL  184A
1AA8:  GOTO   227A (RETURN)
.................... }
.................... float frequency_mhz_get(){
....................     // """The frequency of the radio in Megahertz. Only the allowed values for your radio must be
....................     // specified (i.e. 433 vs. 915 mhz)!
....................     // """
....................     // # FRF register is computed from the frequency following the datasheet.
....................     // # See section 6.2 and FRF register description.
....................     // # Read bytes of FRF register and assemble into a 24-bit unsigned value.
....................     uint8_t msb = spi_read_u8(_REG_FRF_MSB);
....................     uint8_t mid = spi_read_u8(_REG_FRF_MID);
....................     uint8_t lsb = spi_read_u8(_REG_FRF_LSB);
....................     uint32_t frf = ((msb << 16) | (mid << 8) | lsb) & 0xFFFFFF;
....................     float frequency = (frf * _FSTEP) / 1000000.0;
....................     return frequency;
.................... }
.................... //WARNING: No funciona en micros porque requiere de enteros de 32 bits    
.................... void frequency_mhz_set(){
....................     //FRF = int((freq/_FSTEP)*1,000,000) & 0xFFFFFF
....................     uint8_t msb,lsb,mid;
....................     #ifdef FREQ_433
....................     msb = 0x6C;
....................     mid = 0x40;
....................     lsb = 0x00;
....................     #endif
....................     //TODO: aadir soporte para otras frecuencias
....................     
....................     //TODO: assert 290 <= val <= 1020
....................     // Calculate FRF register 24-bit value using section 6.2 of the datasheet.
....................     // unsigned long frf = int((val/_FSTEP)* 1000000.0) ;
....................     // Serial.print("FRF: ");
....................     // Serial.println(frf);
....................     
....................     // frf &=  0xFFFFFF;
....................     // // Extract byte values and update registers.
....................     // uint8_t msb = frf >> 16;
....................     // uint8_t mid = (frf >> 8) & 0xFF;
....................     // uint8_t lsb = frf & 0xFF;
....................     spi_write_u8(_REG_FRF_MSB, msb);
1AAC:  MOVLW  07
1AAE:  MOVLB  2
1AB0:  MOVWF  x11
1AB2:  MOVFF  1AE,212
1AB6:  MOVLB  0
1AB8:  RCALL  184A
....................     spi_write_u8(_REG_FRF_MID, mid);
1ABA:  MOVLW  08
1ABC:  MOVLB  2
1ABE:  MOVWF  x11
1AC0:  MOVFF  1B0,212
1AC4:  MOVLB  0
1AC6:  RCALL  184A
....................     spi_write_u8(_REG_FRF_LSB, lsb);
1AC8:  MOVLW  09
1ACA:  MOVLB  2
1ACC:  MOVWF  x11
1ACE:  MOVFF  1AF,212
1AD2:  MOVLB  0
1AD4:  RCALL  184A
1AD6:  GOTO   227C (RETURN)
.................... }
.................... uint8_t* encryption_key_get(){
....................     // """The AES encryption key used to encrypt and decrypt packets by the chip. This can be set
....................     // to None to disable encryption (the default), otherwise it must be a 16 byte long byte
....................     // string which defines the key (both the transmitter and receiver must use the same key
....................     // value).
....................     // """
....................     // # Handle if encryption is disabled.
....................     if(get(aes_on)==0)return NULL;
....................     spi_read_into(_REG_AES_KEY1,encryption_key,16);
....................     return encryption_key;
.................... }
.................... void encryption_key_set(uint8_t* val){
....................     if (val==0)set(0,aes_on);
....................     else{
....................         // Set the encryption key and enable encryption.
....................         //TODO: assert len(val) == 16
....................         spi_write_from(_REG_AES_KEY1,val,16);
....................         set(1,aes_on);
....................     }
.................... }
.................... int8_t tx_power_get(){
....................     // The transmit power in dBm. Can be set to a value from -2 to 20 for high power devices
....................     // (RFM69HCW, high_power=True) or -18 to 13 for low power devices. Only integer power
....................     // levels are actually set (i.e. 12.5 will result in a value of 12 dBm).
....................     // """
....................     // # Follow table 10 truth table from the datasheet for determining power
....................     // # level from the individual PA level bits and output power register.
....................     uint8_t pa0 = get(pa_0_on);
....................     uint8_t pa1 = get(pa_1_on);
....................     uint8_t pa2 = get(pa_2_on);
....................     uint8_t current_output_power = get(output_power);
....................     if (pa0 &&  !pa1 &&  !pa2)
....................         //# -18 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && !pa2)
....................         //# -2 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && !high_power)
....................         //# 2 to 17 dBm range
....................         return -14 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && high_power)
....................         //# 5 to 20 dBm range
....................         return -11 + current_output_power;
....................     print((char*)"Tx power power amps state unknown!");
....................     while (1){
....................     usb_task();
....................     }
....................     //exit(-3);
.................... }
.................... void tx_power_set(int8_t val){
*
2028:  MOVLB  1
202A:  CLRF   xAF
202C:  CLRF   xB0
202E:  CLRF   xB1
2030:  CLRF   xB2
....................     // Determine power amplifier and output power values depending on
....................     // high power state and requested power.
....................     uint8_t _pa_0_on = 0;
....................     uint8_t _pa_1_on = 0;
....................     uint8_t _pa_2_on = 0;
....................     uint8_t _output_power = 0;
....................     if (high_power){
2032:  MOVLB  0
2034:  BTFSS  xB5.1
2036:  BRA    207E
....................         // Handle high power mode.
....................         //TODO: assert -2 <= val <= 20
....................         _pa_1_on = 1;
2038:  MOVLW  01
203A:  MOVLB  1
203C:  MOVWF  xB0
....................         if (val <= 13)
203E:  BTFSC  xAE.7
2040:  BRA    2048
2042:  MOVF   xAE,W
2044:  SUBLW  0D
2046:  BNC   2050
....................             _output_power = val + 18;
2048:  MOVLW  12
204A:  ADDWF  xAE,W
204C:  MOVWF  xB2
204E:  BRA    207A
....................         else if (13 < val && val <= 17){
2050:  BTFSC  xAE.7
2052:  BRA    2070
2054:  MOVF   xAE,W
2056:  SUBLW  0D
2058:  BC    2070
205A:  BTFSC  xAE.7
205C:  BRA    2064
205E:  MOVF   xAE,W
2060:  SUBLW  11
2062:  BNC   2070
....................             _pa_2_on = 1;
2064:  MOVLW  01
2066:  MOVWF  xB1
....................             _output_power = val + 14;
2068:  MOVLW  0E
206A:  ADDWF  xAE,W
206C:  MOVWF  xB2
....................             }
206E:  BRA    207A
....................         else{
....................             //  # power >= 18 dBm
....................             //# Note this also needs PA boost enabled separately!
....................             _pa_2_on = 1;
2070:  MOVLW  01
2072:  MOVWF  xB1
....................             _output_power = val + 11;
2074:  MOVLW  0B
2076:  ADDWF  xAE,W
2078:  MOVWF  xB2
....................             }
....................     }
207A:  BRA    208A
207C:  MOVLB  0
....................     else{
....................         //Handle non-high power mode.
....................         //TODO: assert -18 <= val <= 13
....................         // Enable only power amplifier 0 and set output power.
....................         _pa_0_on = 1;
207E:  MOVLW  01
2080:  MOVLB  1
2082:  MOVWF  xAF
....................         _output_power = (val+ 18);
2084:  MOVLW  12
2086:  ADDWF  xAE,W
2088:  MOVWF  xB2
....................     }
....................     //# Set power amplifiers and output power as computed above.
....................     set(_pa_0_on,pa_0_on);
208A:  MOVFF  1AF,1D1
208E:  MOVFF  E1,1D4
2092:  MOVFF  E0,1D3
2096:  MOVFF  DF,1D2
209A:  MOVLB  0
209C:  RCALL  19C6
....................     set(_pa_1_on,pa_1_on);
209E:  MOVFF  1B0,1D1
20A2:  MOVFF  E4,1D4
20A6:  MOVFF  E3,1D3
20AA:  MOVFF  E2,1D2
20AE:  RCALL  19C6
....................     set(_pa_2_on,pa_2_on);
20B0:  MOVFF  1B1,1D1
20B4:  MOVFF  E7,1D4
20B8:  MOVFF  E6,1D3
20BC:  MOVFF  E5,1D2
20C0:  RCALL  19C6
....................     set(_output_power,output_power);
20C2:  MOVFF  1B2,1D1
20C6:  MOVFF  EA,1D4
20CA:  MOVFF  E9,1D3
20CE:  MOVFF  E8,1D2
20D2:  RCALL  19C6
....................     _tx_power = val;
20D4:  MOVFF  1AE,121
20D8:  GOTO   23A6 (RETURN)
.................... }
.................... float rssi_get(){
....................     // ""The received strength indicator (in dBm).
....................     // May be inaccuate if not read immediatey. last_rssi contains the value read immediately
....................     // receipt of the last packet.
....................     // """
....................     // # Read RSSI register and convert to value using formula in datasheet.
....................     rssi = -spi_read_u8(_REG_RSSI_VALUE) / 2.0;
*
27C6:  MOVLW  24
27C8:  MOVLB  2
27CA:  MOVWF  x15
27CC:  MOVLB  0
27CE:  CALL   1692
27D2:  MOVLW  00
27D4:  BSF    FD8.0
27D6:  SUBFWB 01,W
27D8:  MOVLB  1
27DA:  CLRF   xD6
27DC:  MOVWF  xD5
27DE:  MOVLB  0
27E0:  RCALL  2566
27E2:  MOVFF  03,1B9
27E6:  MOVFF  02,1B8
27EA:  MOVFF  01,1B7
27EE:  MOVFF  00,1B6
27F2:  MOVLB  1
27F4:  CLRF   xBD
27F6:  CLRF   xBC
27F8:  CLRF   xBB
27FA:  MOVLW  80
27FC:  MOVWF  xBA
27FE:  MOVLB  0
2800:  CALL   1ADA
2804:  MOVFF  03,132
2808:  MOVFF  02,131
280C:  MOVFF  01,130
2810:  MOVFF  00,12F
....................     return rssi;
2814:  MOVFF  12F,00
2818:  MOVFF  130,01
281C:  MOVFF  131,02
2820:  MOVFF  132,03
2824:  GOTO   3186 (RETURN)
.................... }
.................... float bitrate_get(){
....................     //         """The modulation bitrate in bits/second (or chip rate if Manchester encoding is enabled).
....................     // Can be a value from ~489 to 32mbit/s, but see the datasheet for the exact supported
....................     // values.
....................     // """
....................     uint8_t msb = spi_read_u8(_REG_BITRATE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_BITRATE_LSB);
....................     bitrate = _FXOSC / ((msb << 8) | lsb);
....................     return bitrate;
.................... }
.................... void bitrate_set(float val){
*
1EEC:  MOVLB  1
1EEE:  CLRF   xB9
1EF0:  MOVLW  24
1EF2:  MOVWF  xB8
1EF4:  MOVLW  74
1EF6:  MOVWF  xB7
1EF8:  MOVLW  97
1EFA:  MOVWF  xB6
1EFC:  MOVFF  1B1,1BD
1F00:  MOVFF  1B0,1BC
1F04:  MOVFF  1AF,1BB
1F08:  MOVFF  1AE,1BA
1F0C:  MOVLB  0
1F0E:  RCALL  1ADA
1F10:  MOVFF  03,1B9
1F14:  MOVFF  02,1B8
1F18:  MOVFF  01,1B7
1F1C:  MOVFF  00,1B6
1F20:  BCF    FD8.1
1F22:  MOVFF  03,1DA
1F26:  MOVFF  02,1D9
1F2A:  MOVFF  01,1D8
1F2E:  MOVFF  00,1D7
1F32:  MOVLB  1
1F34:  CLRF   xDE
1F36:  CLRF   xDD
1F38:  CLRF   xDC
1F3A:  MOVLW  7E
1F3C:  MOVWF  xDB
1F3E:  MOVLB  0
1F40:  RCALL  1C38
1F42:  MOVFF  03,1B9
1F46:  MOVFF  02,1B8
1F4A:  MOVFF  01,1B7
1F4E:  MOVFF  00,1B6
1F52:  RCALL  1EB0
1F54:  MOVFF  01,1B2
1F58:  MOVLB  1
1F5A:  CLRF   xB3
1F5C:  CLRF   xB4
1F5E:  CLRF   xB5
....................     //TODO: assert (_FXOSC / 65535) <= val <= 32000000.0
....................     //# Round up to the next closest bit-rate value with addition of 0.5.
....................     uint32_t _bitrate = (int)((_FXOSC/val)+0.5) & 0xFFF;
....................     spi_write_u8(_REG_BITRATE_MSB, _bitrate >> 8);
1F60:  CLRF   xBA
1F62:  MOVLW  03
1F64:  MOVLB  2
1F66:  MOVWF  x11
1F68:  MOVFF  1B3,212
1F6C:  MOVLB  0
1F6E:  RCALL  184A
....................     spi_write_u8(_REG_BITRATE_LSB, _bitrate & 0xFF);
1F70:  MOVLB  1
1F72:  CLRF   xB7
1F74:  CLRF   xB8
1F76:  CLRF   xB9
1F78:  MOVLW  04
1F7A:  MOVLB  2
1F7C:  MOVWF  x11
1F7E:  MOVFF  1B2,212
1F82:  MOVLB  0
1F84:  RCALL  184A
1F86:  GOTO   22B8 (RETURN)
.................... }
.................... float frequency_deviation_get(){
....................     //"""The frequency deviation in Hertz."""
....................     uint8_t msb = spi_read_u8(_REG_FDEV_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_FDEV_LSB);
....................     frequency_deviation = _FSTEP * ((msb << 8) | lsb);
....................     return frequency_deviation;
.................... }
.................... void frequency_deviation_set(float val){
1F8A:  MOVFF  1B1,1B9
1F8E:  MOVFF  1B0,1B8
1F92:  MOVFF  1AF,1B7
1F96:  MOVFF  1AE,1B6
1F9A:  MOVLB  1
1F9C:  CLRF   xBD
1F9E:  MOVLW  24
1FA0:  MOVWF  xBC
1FA2:  MOVLW  74
1FA4:  MOVWF  xBB
1FA6:  MOVLW  84
1FA8:  MOVWF  xBA
1FAA:  MOVLB  0
1FAC:  RCALL  1ADA
1FAE:  MOVFF  03,1B9
1FB2:  MOVFF  02,1B8
1FB6:  MOVFF  01,1B7
1FBA:  MOVFF  00,1B6
1FBE:  BCF    FD8.1
1FC0:  MOVFF  03,1DA
1FC4:  MOVFF  02,1D9
1FC8:  MOVFF  01,1D8
1FCC:  MOVFF  00,1D7
1FD0:  MOVLB  1
1FD2:  CLRF   xDE
1FD4:  CLRF   xDD
1FD6:  CLRF   xDC
1FD8:  MOVLW  7E
1FDA:  MOVWF  xDB
1FDC:  MOVLB  0
1FDE:  RCALL  1C38
1FE0:  MOVFF  03,1B9
1FE4:  MOVFF  02,1B8
1FE8:  MOVFF  01,1B7
1FEC:  MOVFF  00,1B6
1FF0:  RCALL  1EB0
1FF2:  MOVFF  01,1B2
1FF6:  MOVLB  1
1FF8:  CLRF   xB3
1FFA:  CLRF   xB4
1FFC:  CLRF   xB5
....................     //TODO: assert 0 <= val <= (_FSTEP * 16383)  # fdev is a 14-bit unsigned value
....................     // # Round up to the next closest integer value with addition of 0.5.
....................     uint32_t fdev = (int)((val / _FSTEP) + 0.5) & 0x3FFF;
....................     spi_write_u8(_REG_FDEV_MSB, fdev >> 8);
1FFE:  CLRF   xBA
2000:  MOVLW  05
2002:  MOVLB  2
2004:  MOVWF  x11
2006:  MOVFF  1B3,212
200A:  MOVLB  0
200C:  RCALL  184A
....................     spi_write_u8(_REG_FDEV_LSB, fdev & 0xFF);
200E:  MOVLB  1
2010:  CLRF   xB7
2012:  CLRF   xB8
2014:  CLRF   xB9
2016:  MOVLW  06
2018:  MOVLB  2
201A:  MOVWF  x11
201C:  MOVFF  1B2,212
2020:  MOVLB  0
2022:  RCALL  184A
2024:  GOTO   22CC (RETURN)
.................... }
.................... bool packet_sent(){
....................     //Transmit status
....................     return (spi_read_u8(_REG_IRQ_FLAGS2) & 0x8) >> 3;
*
2D92:  MOVLW  28
2D94:  MOVLB  2
2D96:  MOVWF  x15
2D98:  MOVLB  0
2D9A:  CALL   1692
2D9E:  MOVF   01,W
2DA0:  ANDLW  08
2DA2:  MOVWF  00
2DA4:  RRCF   00,F
2DA6:  RRCF   00,F
2DA8:  RRCF   00,F
2DAA:  MOVLW  1F
2DAC:  ANDWF  00,F
2DAE:  MOVFF  00,01
2DB2:  GOTO   2F60 (RETURN)
.................... }
.................... bool payload_ready(){
*
279C:  MOVLW  28
279E:  MOVLB  2
27A0:  MOVWF  x15
27A2:  MOVLB  0
27A4:  CALL   1692
27A8:  MOVFF  01,1AB
....................             // """Receive status"""
....................     uint8_t p = spi_read_u8(_REG_IRQ_FLAGS2);
....................     //Serial.println(p,BIN);
....................     return (p & 0x4) >> 2;
27AC:  MOVLB  1
27AE:  MOVF   xAB,W
27B0:  ANDLW  04
27B2:  MOVWF  00
27B4:  RRCF   00,F
27B6:  RRCF   00,F
27B8:  MOVLW  3F
27BA:  ANDWF  00,F
27BC:  MOVFF  00,01
27C0:  MOVLB  0
27C2:  GOTO   30A8 (RETURN)
.................... }
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256){
....................     // """Send a string of data using the transmitter.
....................     // You can only send 60 bytes at a time
....................     // (limited by chip's FIFO size and appended headers).
....................     // This appends a 4 byte header to be compatible with the RadioHead library.
....................     // The header defaults to using the initialized attributes:
....................     // (destination,node,identifier,flags)
....................     // It may be temporarily overidden via the kwargs - destination,node,identifier,flags.
....................     // Values passed via kwargs do not alter the attribute settings.
....................     // The keep_listening argument should be set to True if you want to start listening
....................     // automatically after the packet is sent. The default setting is False.
....................     // Returns: True if success or False if the send timed out.
....................     // """
....................     // # Disable pylint warning to not use length as a check for zero.
....................     // # This is a puzzling warning as the below code is clearly the most
....................     // # efficient and proper way to ensure a precondition that the provided
....................     // # buffer be within an expected range of bounds.  Disable this check.
....................     // # pylint: disable=len-as-condition
....................     // TODO: assert 0 < len(data) <= 60
....................     // # pylint: enable=len-as-condition
....................     idle(); //# Stop receiving to clear FIFO and keep it clear.
*
2DB6:  CALL   19B0
....................     // # Fill the FIFO with a packet to send.
....................     // # Combine header and data to form payload
....................     uint32_t i=0;
....................     char* payload = (char*)malloc(5 + len + 1);
2DBA:  MOVLB  1
2DBC:  CLRF   xBF
2DBE:  CLRF   xBE
2DC0:  CLRF   xBD
2DC2:  CLRF   xBC
2DC4:  MOVLW  05
2DC6:  ADDWF  xB2,W
2DC8:  ADDLW  01
2DCA:  MOVWF  xD1
2DCC:  CLRF   xD3
2DCE:  MOVWF  xD2
2DD0:  MOVLB  0
2DD2:  RCALL  2A0A
2DD4:  MOVFF  02,1C1
2DD8:  MOVFF  01,1C0
....................     
....................     payload[0] = 4 + len;
2DDC:  MOVLB  1
2DDE:  MOVFF  1C0,FE9
2DE2:  MOVFF  1C1,FEA
2DE6:  MOVLW  04
2DE8:  ADDWF  xB2,W
2DEA:  MOVWF  FEF
....................     if (_destination >=256 )  // use attribute
2DEC:  MOVF   xB5,W
2DEE:  SUBLW  00
2DF0:  BC    2E04
....................         payload[1] = destination;
2DF2:  MOVLW  01
2DF4:  ADDWF  xC0,W
2DF6:  MOVWF  FE9
2DF8:  MOVLW  00
2DFA:  ADDWFC xC1,W
2DFC:  MOVWF  FEA
2DFE:  MOVFF  152,FEF
2E02:  BRA    2E14
....................     else//  # use kwarg
....................         payload[1] = _destination;
2E04:  MOVLW  01
2E06:  ADDWF  xC0,W
2E08:  MOVWF  FE9
2E0A:  MOVLW  00
2E0C:  ADDWFC xC1,W
2E0E:  MOVWF  FEA
2E10:  MOVFF  1B4,FEF
....................     if (_node >= 256) // use attribute
2E14:  MOVF   xB7,W
2E16:  SUBLW  00
2E18:  BC    2E2C
....................         payload[2] = node;
2E1A:  MOVLW  02
2E1C:  ADDWF  xC0,W
2E1E:  MOVWF  FE9
2E20:  MOVLW  00
2E22:  ADDWFC xC1,W
2E24:  MOVWF  FEA
2E26:  MOVFF  151,FEF
2E2A:  BRA    2E3C
....................     else  //# use kwarg
....................         payload[2] = _node;
2E2C:  MOVLW  02
2E2E:  ADDWF  xC0,W
2E30:  MOVWF  FE9
2E32:  MOVLW  00
2E34:  ADDWFC xC1,W
2E36:  MOVWF  FEA
2E38:  MOVFF  1B6,FEF
....................     if (identifier >=256)  // use attribute
....................         payload[3] = identifier;
....................     else  //# use kwarg
....................         payload[3] = _identifier;
2E3C:  MOVLW  03
2E3E:  ADDWF  xC0,W
2E40:  MOVWF  FE9
2E42:  MOVLW  00
2E44:  ADDWFC xC1,W
2E46:  MOVWF  FEA
2E48:  MOVFF  1B8,FEF
....................     if (flags >=256)  // use attribute
....................         payload[4] = flags;
....................     else  // use kwarg
....................         payload[4] = _flags;
2E4C:  MOVLW  04
2E4E:  ADDWF  xC0,W
2E50:  MOVWF  FE9
2E52:  MOVLW  00
2E54:  ADDWFC xC1,W
2E56:  MOVWF  FEA
2E58:  MOVFF  1BA,FEF
....................     for (i=0;i<= len;i++)
2E5C:  CLRF   xBF
2E5E:  CLRF   xBE
2E60:  CLRF   xBD
2E62:  CLRF   xBC
2E64:  MOVF   xBF,F
2E66:  BNZ   2ECE
2E68:  MOVF   xBE,F
2E6A:  BNZ   2ECE
2E6C:  MOVF   xBD,F
2E6E:  BNZ   2ECE
2E70:  MOVF   xBC,W
2E72:  SUBWF  xB2,W
2E74:  BNC   2ECE
....................         payload[5+i] = data[i];
2E76:  MOVLW  05
2E78:  ADDWF  xBC,W
2E7A:  MOVWF  xD1
2E7C:  MOVLW  00
2E7E:  ADDWFC xBD,W
2E80:  MOVWF  xD2
2E82:  MOVLW  00
2E84:  ADDWFC xBE,W
2E86:  MOVWF  xD3
2E88:  MOVLW  00
2E8A:  ADDWFC xBF,W
2E8C:  MOVWF  xD4
2E8E:  MOVF   xC0,W
2E90:  ADDWF  xD1,W
2E92:  MOVWF  01
2E94:  MOVF   xC1,W
2E96:  ADDWFC xD2,W
2E98:  MOVWF  03
2E9A:  MOVFF  01,1D5
2E9E:  MOVWF  xD6
2EA0:  MOVF   xB0,W
2EA2:  ADDWF  xBC,W
2EA4:  MOVWF  FE9
2EA6:  MOVF   xB1,W
2EA8:  ADDWFC xBD,W
2EAA:  MOVWF  FEA
2EAC:  MOVFF  FEF,1D7
2EB0:  MOVFF  03,FEA
2EB4:  MOVFF  01,FE9
2EB8:  MOVFF  1D7,FEF
2EBC:  MOVLW  01
2EBE:  ADDWF  xBC,F
2EC0:  BTFSC  FD8.0
2EC2:  INCF   xBD,F
2EC4:  BTFSC  FD8.2
2EC6:  INCF   xBE,F
2EC8:  BTFSC  FD8.2
2ECA:  INCF   xBF,F
2ECC:  BRA    2E64
....................        
....................     // # Write payload to transmit fifo
....................     spi_write_from(_REG_FIFO, payload,5+len);
2ECE:  MOVLW  05
2ED0:  ADDWF  xB2,W
2ED2:  MOVWF  xD1
2ED4:  MOVLB  2
2ED6:  CLRF   x13
2ED8:  MOVFF  1C1,215
2EDC:  MOVFF  1C0,214
2EE0:  MOVWF  x16
2EE2:  MOVLB  0
2EE4:  CALL   1804
....................     print((char*)"Payload: ");
2EE8:  MOVLW  01
2EEA:  MOVWF  FEA
2EEC:  MOVLW  C2
2EEE:  MOVWF  FE9
2EF0:  MOVLW  0A
2EF2:  MOVWF  01
2EF4:  CLRF   FF7
2EF6:  MOVLW  00
2EF8:  CALL   0300
2EFC:  TBLRD*-
2EFE:  TBLRD*+
2F00:  MOVFF  FF5,FEE
2F04:  DECFSZ 01,F
2F06:  BRA    2EFE
2F08:  MOVLW  01
2F0A:  MOVLB  1
2F0C:  MOVWF  xD4
2F0E:  MOVLW  C2
2F10:  MOVWF  xD3
2F12:  MOVLB  0
2F14:  CALL   17F8
....................     println(payload+5);
2F18:  MOVLW  05
2F1A:  MOVLB  1
2F1C:  ADDWF  xC0,W
2F1E:  MOVWF  xD1
2F20:  MOVLW  00
2F22:  ADDWFC xC1,W
2F24:  MOVWF  xD2
2F26:  MOVFF  FE8,214
2F2A:  MOVFF  1D1,213
2F2E:  MOVLB  0
2F30:  CALL   179E
....................     // Serial.println((char)spi_read_u8(_REG_FIFO));              
.................... 
....................     free(payload);
2F34:  MOVFF  1C1,1D2
2F38:  MOVFF  1C0,1D1
2F3C:  RCALL  2CE6
....................     // # Turn on transmit mode to send out the packet.       
....................     transmit();
2F3E:  BRA    2D60
....................    
....................     // # Wait for packet sent interrupt with explicit polling (not ideal but
....................     // # best that can be done right now without interrupts).
....................     
....................     float start = timeSec();
....................     bool timed_out = false;
2F40:  CALL   2694
2F44:  MOVFF  03,1CF
2F48:  MOVFF  02,1CE
2F4C:  MOVFF  01,1CD
2F50:  MOVFF  00,1CC
2F54:  MOVLB  1
2F56:  BCF    xD0.0
....................     while (!timed_out && !packet_sent()){
2F58:  BTFSC  xD0.0
2F5A:  BRA    2FF8
2F5C:  MOVLB  0
2F5E:  BRA    2D92
2F60:  MOVF   01,F
2F62:  BTFSC  FD8.2
2F64:  BRA    2F6A
2F66:  MOVLB  1
2F68:  BRA    2FF8
....................     usb_task();
2F6A:  CALL   1508
....................         if ((timeSec() - start) >= xmit_timeout)
2F6E:  CALL   2694
2F72:  MOVFF  03,1D4
2F76:  MOVFF  02,1D3
2F7A:  MOVFF  01,1D2
2F7E:  MOVFF  00,1D1
2F82:  MOVFF  FEA,1D6
2F86:  MOVFF  FE9,1D5
2F8A:  BSF    FD8.1
2F8C:  MOVFF  03,1DA
2F90:  MOVFF  02,1D9
2F94:  MOVFF  01,1D8
2F98:  MOVFF  00,1D7
2F9C:  MOVFF  1CF,1DE
2FA0:  MOVFF  1CE,1DD
2FA4:  MOVFF  1CD,1DC
2FA8:  MOVFF  1CC,1DB
2FAC:  CALL   1C38
2FB0:  MOVFF  1D6,FEA
2FB4:  MOVFF  1D5,FE9
2FB8:  MOVFF  03,1D4
2FBC:  MOVFF  02,1D3
2FC0:  MOVFF  01,1D2
2FC4:  MOVFF  00,1D1
2FC8:  MOVFF  142,1DA
2FCC:  MOVFF  141,1D9
2FD0:  MOVFF  140,1D8
2FD4:  MOVFF  13F,1D7
2FD8:  MOVFF  03,1DE
2FDC:  MOVFF  02,1DD
2FE0:  MOVFF  01,1DC
2FE4:  MOVFF  00,1DB
2FE8:  CALL   24BA
2FEC:  BC    2FF0
2FEE:  BNZ   2FF4
....................             timed_out = true;
2FF0:  MOVLB  1
2FF2:  BSF    xD0.0
2FF4:  MOVLB  1
2FF6:  BRA    2F58
....................     }
....................     // # Listen again if requested.
....................     if (keep_listening)
2FF8:  MOVF   xB3,F
2FFA:  BZ    3006
....................         listen();
2FFC:  MOVLB  0
2FFE:  CALL   2534
3002:  BRA    300C
3004:  MOVLB  1
....................     else  //# Enter idle mode to stop receiving other packets.
....................   
....................         idle();
3006:  MOVLB  0
3008:  CALL   19B0
....................     return !timed_out;
300C:  MOVLW  00
300E:  MOVLB  1
3010:  BTFSS  xD0.0
3012:  MOVLW  01
3014:  MOVWF  01
3016:  MOVLB  0
3018:  GOTO   33A6 (RETURN)
.................... }
.................... bool send_with_ack(uint8_t* data,uint8_t len){
....................     // Reliable Datagram mode:
....................     // Send a packet with data and wait for an ACK response.
....................     // The packet header is automatically generated.
....................     // If enabled, the packet transmission will be retried on failure
....................     int retries_remaining = 0;
....................     bool got_ack = false;
....................     uint8_t* ack_packet;
....................     if (ack_retries)retries_remaining = ack_retries;
....................     else retries_remaining=1;
....................     sequence_number = (sequence_number+1) & 0xFF;
....................     while (!got_ack && retries_remaining){
....................         identifier = sequence_number;
....................         send(data,len,true);
....................         // Don't look for ACK from Broadcast message
....................         if (destination == _RH_BROADCAST_ADDRESS)got_ack = true;
....................         else{
....................             ack_packet = receive(true,false,ack_wait,true);
....................             if(ack_packet != NULL){
....................                 if (ack_packet[4] & _RH_FLAGS_ACK){
....................                     //Check id:
....................                     if (ack_packet[3] == identifier){
....................                         got_ack = true;
....................                         break;
....................                     }
....................                 }
....................             }
....................             
....................         }
....................         //# pause before next retry -- random delay
....................         if (!got_ack){
....................             sleep_ms(ack_wait * (1.5));
....................         }
....................         retries_remaining -= 1;
....................         //# set retry flag in packet header
....................         flags |= _RH_FLAGS_RETRY;
....................     }
....................     flags = 0;  //# clear flags
....................     return got_ack;
.................... }
.................... //IMPORTANTE: La funcion es igual a la de adafruit, excepto porque retorna un array donde el primer valor es la longitud del array
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false){
301C:  MOVLB  1
301E:  BCF    x8C.0
3020:  CLRF   x8D
3022:  CLRF   x8E
3024:  CLRF   x91
3026:  CLRF   x90
....................     // Wait to receive a packet from the receiver. If a packet is found the payload bytes
....................     // are returned, otherwise None is returned (which indicates the timeout elapsed with no
....................     // reception).
....................     // If keep_listening is True (the default) the chip will immediately enter listening mode
....................     // after reception of a packet, otherwise it will fall back to idle mode and ignore any
....................     // future reception.
....................     // All packets must have a 4 byte header for compatibilty with the
....................     // RadioHead library.
....................     // The header consists of 4 bytes (To,From,ID,Flags). The default setting will  strip
....................     // the header before returning the packet to the caller.
....................     // If with_header is True then the 4 byte header will be returned with the packet.
....................     // The payload then begins at packet[4].
....................     // If with_ack is True, send an ACK after receipt (Reliable Datagram mode)
....................     // """
....................     bool timed_out = false;
....................     int start = 0;
....................     int i=0;
....................     uint8_t fifo_length;
....................     uint8_t* packet= NULL;
....................     char fifo_len_str [4];
....................     if (timeout == 0)timeout = receive_timeout;
3028:  MOVFF  18A,1DA
302C:  MOVFF  189,1D9
3030:  MOVFF  188,1D8
3034:  MOVFF  187,1D7
3038:  CLRF   xDE
303A:  CLRF   xDD
303C:  CLRF   xDC
303E:  CLRF   xDB
3040:  MOVLB  0
3042:  CALL   24BA
3046:  BNZ   3058
3048:  MOVFF  13E,18A
304C:  MOVFF  13D,189
3050:  MOVFF  13C,188
3054:  MOVFF  13B,187
....................     if (timeout!=0){
3058:  MOVFF  18A,1DA
305C:  MOVFF  189,1D9
3060:  MOVFF  188,1D8
3064:  MOVFF  187,1D7
3068:  MOVLB  1
306A:  CLRF   xDE
306C:  CLRF   xDD
306E:  CLRF   xDC
3070:  CLRF   xDB
3072:  MOVLB  0
3074:  CALL   24BA
3078:  BTFSC  FD8.2
307A:  BRA    317E
....................         //readAllRegs();
....................         //while(1){}
....................         listen();
307C:  CALL   2534
....................         start = timeSec();
3080:  CALL   2694
3084:  MOVFF  03,1B9
3088:  MOVFF  02,1B8
308C:  MOVFF  01,1B7
3090:  MOVFF  00,1B6
3094:  CALL   1EB0
3098:  MOVFF  01,18D
....................         while (!timed_out && !payload_ready()){
309C:  MOVLB  1
309E:  BTFSC  x8C.0
30A0:  BRA    3180
30A2:  MOVLB  0
30A4:  GOTO   279C
30A8:  MOVF   01,F
30AA:  BTFSC  FD8.2
30AC:  BRA    30B2
30AE:  MOVLB  1
30B0:  BRA    3180
....................         usb_task();
30B2:  CALL   1508
....................             //delay(20);
....................             if ((timeSec() - start) >= xmit_timeout){
30B6:  CALL   2694
30BA:  MOVFF  03,1AE
30BE:  MOVFF  02,1AD
30C2:  MOVFF  01,1AC
30C6:  MOVFF  00,1AB
30CA:  MOVLB  1
30CC:  CLRF   xD6
30CE:  MOVFF  18D,1D5
30D2:  MOVLB  0
30D4:  CALL   2566
30D8:  MOVFF  FEA,1B0
30DC:  MOVFF  FE9,1AF
30E0:  BSF    FD8.1
30E2:  MOVFF  1AE,1DA
30E6:  MOVFF  1AD,1D9
30EA:  MOVFF  1AC,1D8
30EE:  MOVFF  1AB,1D7
30F2:  MOVFF  03,1DE
30F6:  MOVFF  02,1DD
30FA:  MOVFF  01,1DC
30FE:  MOVFF  00,1DB
3102:  CALL   1C38
3106:  MOVFF  1B0,FEA
310A:  MOVFF  1AF,FE9
310E:  MOVFF  03,1AE
3112:  MOVFF  02,1AD
3116:  MOVFF  01,1AC
311A:  MOVFF  00,1AB
311E:  MOVFF  142,1DA
3122:  MOVFF  141,1D9
3126:  MOVFF  140,1D8
312A:  MOVFF  13F,1D7
312E:  MOVFF  03,1DE
3132:  MOVFF  02,1DD
3136:  MOVFF  01,1DC
313A:  MOVFF  00,1DB
313E:  CALL   24BA
3142:  BC    3146
3144:  BNZ   317C
....................                 println((char*)"Timed out");
3146:  MOVLW  01
3148:  MOVWF  FEA
314A:  MOVLW  96
314C:  MOVWF  FE9
314E:  MOVLW  0A
3150:  MOVWF  01
3152:  CLRF   FF7
3154:  MOVLW  00
3156:  CALL   031A
315A:  TBLRD*-
315C:  TBLRD*+
315E:  MOVFF  FF5,FEE
3162:  DECFSZ 01,F
3164:  BRA    315C
3166:  MOVLW  01
3168:  MOVLB  2
316A:  MOVWF  x14
316C:  MOVLW  96
316E:  MOVWF  x13
3170:  MOVLB  0
3172:  CALL   179E
....................                 timed_out = true;
3176:  MOVLB  1
3178:  BSF    x8C.0
317A:  MOVLB  0
....................                 }
317C:  BRA    309C
317E:  MOVLB  1
....................         }
....................     }
....................    
....................     last_rssi = rssi_get();
3180:  MOVLB  0
3182:  GOTO   27C6
3186:  MOVFF  03,136
318A:  MOVFF  02,135
318E:  MOVFF  01,134
3192:  MOVFF  00,133
....................     // Enter idle mode to stop receiving other packets.
....................     idle();
3196:  CALL   19B0
....................      
....................     if (!timed_out){
319A:  MOVLB  1
319C:  BTFSC  x8C.0
319E:  BRA    3484
....................         fifo_length = spi_read_u8(_REG_FIFO);
31A0:  MOVLB  2
31A2:  CLRF   x15
31A4:  MOVLB  0
31A6:  CALL   1692
31AA:  MOVFF  01,18F
....................         print((char*)"FIFO LEN: ");
31AE:  MOVLW  01
31B0:  MOVWF  FEA
31B2:  MOVLW  A0
31B4:  MOVWF  FE9
31B6:  MOVLW  0B
31B8:  MOVWF  01
31BA:  CLRF   FF7
31BC:  MOVLW  00
31BE:  CALL   0334
31C2:  TBLRD*-
31C4:  TBLRD*+
31C6:  MOVFF  FF5,FEE
31CA:  DECFSZ 01,F
31CC:  BRA    31C4
31CE:  MOVLW  01
31D0:  MOVLB  1
31D2:  MOVWF  xD4
31D4:  MOVLW  A0
31D6:  MOVWF  xD3
31D8:  MOVLB  0
31DA:  CALL   17F8
....................         sprintf(fifo_len_str,"%d",fifo_length);
31DE:  MOVLW  01
31E0:  MOVWF  xC6
31E2:  MOVLW  92
31E4:  MOVWF  xC5
31E6:  MOVFF  18F,1AB
31EA:  MOVLW  18
31EC:  MOVLB  1
31EE:  MOVWF  xAC
31F0:  MOVLB  0
31F2:  GOTO   2872
....................         println(fifo_len_str);
31F6:  MOVLW  01
31F8:  MOVLB  2
31FA:  MOVWF  x14
31FC:  MOVLW  92
31FE:  MOVWF  x13
3200:  MOVLB  0
3202:  CALL   179E
....................         //  # Handle if the received packet is too small to include the 4 byte
....................         // # RadioHead header and at least one byte of data --reject this packet and ignore it.
....................         if (fifo_length > 0){
3206:  MOVLB  1
3208:  MOVF   x8F,F
320A:  BZ    3264
....................             packet = (uint8_t*)malloc(fifo_length+2);
320C:  MOVLW  02
320E:  ADDWF  x8F,W
3210:  MOVWF  xAB
3212:  CLRF   xD3
3214:  MOVWF  xD2
3216:  MOVLB  0
3218:  CALL   2A0A
321C:  MOVFF  02,191
3220:  MOVFF  01,190
....................             packet[0] = fifo_length;
3224:  MOVLB  1
3226:  MOVFF  190,FE9
322A:  MOVFF  191,FEA
322E:  MOVFF  18F,FEF
....................             packet[fifo_length+1] = '\0';
3232:  MOVLW  01
3234:  ADDWF  x8F,W
3236:  ADDWF  x90,W
3238:  MOVWF  FE9
323A:  MOVLW  00
323C:  ADDWFC x91,W
323E:  MOVWF  FEA
3240:  CLRF   FEF
....................             spi_read_into(_REG_FIFO,packet+1,fifo_length);
3242:  MOVLW  01
3244:  ADDWF  x90,W
3246:  MOVWF  xAB
3248:  MOVLW  00
324A:  ADDWFC x91,W
324C:  MOVWF  xAC
324E:  MOVLB  2
3250:  CLRF   x16
3252:  MOVWF  x18
3254:  MOVFF  1AB,217
3258:  MOVFF  18F,219
325C:  MOVLB  0
325E:  CALL   1640
3262:  MOVLB  1
....................             //print(packet);
....................         }
....................         if (fifo_length < 5){
3264:  MOVF   x8F,W
3266:  SUBLW  04
3268:  BNC   3270
....................             packet = NULL;
326A:  CLRF   x91
326C:  CLRF   x90
....................         }
326E:  BRA    3484
....................         else{
....................             if (node != _RH_BROADCAST_ADDRESS && packet[1] != _RH_BROADCAST_ADDRESS && packet[1] != node){
3270:  INCFSZ x51,W
3272:  BRA    3276
3274:  BRA    32AE
3276:  MOVLW  01
3278:  ADDWF  x90,W
327A:  MOVWF  FE9
327C:  MOVLW  00
327E:  ADDWFC x91,W
3280:  MOVWF  FEA
3282:  INCFSZ FEF,W
3284:  BRA    3288
3286:  BRA    32AE
3288:  MOVLW  01
328A:  ADDWF  x90,W
328C:  MOVWF  FE9
328E:  MOVLW  00
3290:  ADDWFC x91,W
3292:  MOVWF  FEA
3294:  MOVF   x51,W
3296:  SUBWF  FEF,W
3298:  BZ    32AE
....................                 free(packet);
329A:  MOVFF  191,1D2
329E:  MOVFF  190,1D1
32A2:  MOVLB  0
32A4:  RCALL  2CE6
....................                 packet = NULL;
32A6:  MOVLB  1
32A8:  CLRF   x91
32AA:  CLRF   x90
....................             }
32AC:  BRA    3430
....................             //# send ACK unless this was an ACK or a broadcast
....................             else if (with_ack && (packet[4]&_RH_FLAGS_ACK)==0 && packet[1] != _RH_BROADCAST_ADDRESS){
32AE:  MOVF   x86,F
32B0:  BTFSC  FD8.2
32B2:  BRA    3430
32B4:  MOVLW  04
32B6:  ADDWF  x90,W
32B8:  MOVWF  FE9
32BA:  MOVLW  00
32BC:  ADDWFC x91,W
32BE:  MOVWF  FEA
32C0:  MOVF   FEF,W
32C2:  ANDLW  80
32C4:  BTFSS  FD8.2
32C6:  BRA    3430
32C8:  MOVLW  01
32CA:  ADDWF  x90,W
32CC:  MOVWF  FE9
32CE:  MOVLW  00
32D0:  ADDWFC x91,W
32D2:  MOVWF  FEA
32D4:  INCFSZ FEF,W
32D6:  BRA    32DA
32D8:  BRA    3430
....................                 if (ack_delay != 0)sleep_ms((int)(ack_delay/1000));
32DA:  MOVFF  147,1DA
32DE:  MOVFF  146,1D9
32E2:  MOVFF  145,1D8
32E6:  MOVFF  144,1D7
32EA:  CLRF   xDE
32EC:  CLRF   xDD
32EE:  CLRF   xDC
32F0:  CLRF   xDB
32F2:  MOVLB  0
32F4:  CALL   24BA
32F8:  BZ    333E
32FA:  MOVFF  147,1B9
32FE:  MOVFF  146,1B8
3302:  MOVFF  145,1B7
3306:  MOVFF  144,1B6
330A:  MOVLB  1
330C:  CLRF   xBD
330E:  CLRF   xBC
3310:  MOVLW  7A
3312:  MOVWF  xBB
3314:  MOVLW  88
3316:  MOVWF  xBA
3318:  MOVLB  0
331A:  CALL   1ADA
331E:  MOVFF  03,1B9
3322:  MOVFF  02,1B8
3326:  MOVFF  01,1B7
332A:  MOVFF  00,1B6
332E:  CALL   1EB0
3332:  MOVFF  01,1AB
3336:  MOVFF  01,1AE
333A:  CALL   17BE
....................                 //# send ACK packet to sender (data is b'!')
....................                 send((char*)"!",false,packet[2],packet[1],packet[3],packet[4]|_RH_FLAGS_ACK);
333E:  MOVLW  21
3340:  MOVLB  1
3342:  MOVWF  xA0
3344:  CLRF   xA1
3346:  MOVLW  02
3348:  ADDWF  x90,W
334A:  MOVWF  FE9
334C:  MOVLW  00
334E:  ADDWFC x91,W
3350:  MOVWF  FEA
3352:  MOVFF  FEF,1B3
3356:  MOVLW  01
3358:  ADDWF  x90,W
335A:  MOVWF  FE9
335C:  MOVLW  00
335E:  ADDWFC x91,W
3360:  MOVWF  FEA
3362:  MOVFF  FEF,1B4
3366:  MOVLW  03
3368:  ADDWF  x90,W
336A:  MOVWF  FE9
336C:  MOVLW  00
336E:  ADDWFC x91,W
3370:  MOVWF  FEA
3372:  MOVFF  FEF,1B6
3376:  MOVLW  04
3378:  ADDWF  x90,W
337A:  MOVWF  FE9
337C:  MOVLW  00
337E:  ADDWFC x91,W
3380:  MOVWF  FEA
3382:  MOVF   FEF,W
3384:  IORLW  80
3386:  MOVWF  xAF
3388:  MOVLW  01
338A:  MOVWF  xB1
338C:  MOVLW  A0
338E:  MOVWF  xB0
3390:  CLRF   xB2
3392:  CLRF   xB5
3394:  CLRF   xB7
3396:  CLRF   xB9
3398:  MOVFF  1AF,1B8
339C:  MOVLW  01
339E:  MOVWF  xBB
33A0:  CLRF   xBA
33A2:  MOVLB  0
33A4:  BRA    2DB6
....................                 // # reject Retries if we have seen this idetifier from this source before
....................                 if (seen_ids[packet[2]] == packet[3] && packet[4]&_RH_FLAGS_RETRY){
33A6:  MOVLW  02
33A8:  MOVLB  1
33AA:  ADDWF  x90,W
33AC:  MOVWF  FE9
33AE:  MOVLW  00
33B0:  ADDWFC x91,W
33B2:  MOVWF  FEA
33B4:  CLRF   03
33B6:  MOVF   FEF,W
33B8:  ADDLW  49
33BA:  MOVWF  FE9
33BC:  MOVLW  01
33BE:  ADDWFC 03,W
33C0:  MOVWF  FEA
33C2:  MOVFF  FEF,1AB
33C6:  MOVLW  03
33C8:  ADDWF  x90,W
33CA:  MOVWF  FE9
33CC:  MOVLW  00
33CE:  ADDWFC x91,W
33D0:  MOVWF  FEA
33D2:  MOVF   FEF,W
33D4:  SUBWF  xAB,W
33D6:  BNZ   33FC
33D8:  MOVLW  04
33DA:  ADDWF  x90,W
33DC:  MOVWF  FE9
33DE:  MOVLW  00
33E0:  ADDWFC x91,W
33E2:  MOVWF  FEA
33E4:  BTFSS  FEF.6
33E6:  BRA    33FC
....................                     free(packet);
33E8:  MOVFF  191,1D2
33EC:  MOVFF  190,1D1
33F0:  MOVLB  0
33F2:  RCALL  2CE6
....................                     packet= NULL;
33F4:  MOVLB  1
33F6:  CLRF   x91
33F8:  CLRF   x90
....................                 }
33FA:  BRA    3430
....................                 else{ //Save identifier from source
....................                     seen_ids[packet[2]] = packet[3];
33FC:  MOVLW  02
33FE:  ADDWF  x90,W
3400:  MOVWF  FE9
3402:  MOVLW  00
3404:  ADDWFC x91,W
3406:  MOVWF  FEA
3408:  CLRF   03
340A:  MOVF   FEF,W
340C:  ADDLW  49
340E:  MOVWF  01
3410:  MOVLW  01
3412:  ADDWFC 03,F
3414:  MOVLW  03
3416:  ADDWF  x90,W
3418:  MOVWF  FE9
341A:  MOVLW  00
341C:  ADDWFC x91,W
341E:  MOVWF  FEA
3420:  MOVFF  FEF,1AD
3424:  MOVFF  03,FEA
3428:  MOVFF  01,FE9
342C:  MOVFF  1AD,FEF
....................                 }
....................             }
....................             if (!with_header && packet != NULL){
3430:  MOVF   x8B,F
3432:  BNZ   3484
3434:  MOVF   x90,F
3436:  BNZ   343C
3438:  MOVF   x91,F
343A:  BZ    3484
....................                  //skip the header if not wanted
....................                  for (i=1; i< fifo_length-4;i++){
343C:  MOVLW  01
343E:  MOVWF  x8E
3440:  MOVLW  04
3442:  SUBWF  x8F,W
3444:  SUBWF  x8E,W
3446:  BC    3476
....................                     packet[i] = packet[i+4];
3448:  MOVF   x8E,W
344A:  ADDWF  x90,W
344C:  MOVWF  01
344E:  MOVLW  00
3450:  ADDWFC x91,W
3452:  MOVWF  03
3454:  MOVLW  04
3456:  ADDWF  x8E,W
3458:  ADDWF  x90,W
345A:  MOVWF  FE9
345C:  MOVLW  00
345E:  ADDWFC x91,W
3460:  MOVWF  FEA
3462:  MOVFF  FEF,1AD
3466:  MOVFF  03,FEA
346A:  MOVFF  01,FE9
346E:  MOVFF  1AD,FEF
3472:  INCF   x8E,F
3474:  BRA    3440
....................                  }
....................                  //reduce indicated length
....................                  packet[0] -= 4;
3476:  MOVFF  190,FE9
347A:  MOVFF  191,FEA
347E:  MOVLW  04
3480:  SUBWF  FEF,W
3482:  MOVWF  FEF
....................             }
....................         }
....................     }
....................     
....................     if (keep_listening)listen();        
3484:  MOVF   x85,F
3486:  BZ    3490
3488:  MOVLB  0
348A:  CALL   2534
348E:  BRA    3496
....................     else idle();
3490:  MOVLB  0
3492:  CALL   19B0
....................     return (char*)packet;
3496:  MOVLB  1
3498:  MOVFF  190,01
349C:  MOVFF  191,02
34A0:  MOVLB  0
34A2:  GOTO   39E0 (RETURN)
.................... }
.................... 
.................... 
.................... #ZERO_RAM
.................... 
.................... 
.................... //Define la interrupcin por recepcin Serial
.................... static void RDA_isr(void)
.................... {  
*
1388:  GOTO   140C (RETURN)
....................  
.................... }
.................... 
.................... 
.................... /* TODO: Use usb_cdc_putc() to transmit data to the USB
.................... virtual COM port. Use usb_cdc_kbhit() and usb_cdc_getc() to
.................... receive data from the USB virtual COM port. usb_enumerated()
.................... can be used to see if connected to a host and ready to
.................... communicate. */
.................... 
.................... /*
.................... Conexiones
.................... MOSI: RX (23)
.................... MISO: B0 (00) (SDI)
.................... CLK: B1 (01) (SCK)
.................... CS: A5 (13)
.................... Reset: E0
.................... */
.................... 
.................... void main()
*
34A6:  CLRF   FF8
34A8:  BCF    FD0.7
34AA:  BSF    07.7
34AC:  MOVLW  FE
34AE:  MOVWF  00
34B0:  MOVLW  04
34B2:  MOVWF  01
34B4:  MOVLW  02
34B6:  MOVWF  FE9
34B8:  MOVLW  00
34BA:  MOVWF  FEA
34BC:  CLRF   FEE
34BE:  DECFSZ 00,F
34C0:  BRA    34BC
34C2:  DECFSZ 01,F
34C4:  BRA    34BC
34C6:  MOVLW  DD
34C8:  MOVWF  00
34CA:  MOVLW  03
34CC:  MOVWF  01
34CE:  MOVLW  23
34D0:  MOVWF  FE9
34D2:  MOVLW  05
34D4:  MOVWF  FEA
34D6:  CLRF   FEE
34D8:  DECFSZ 00,F
34DA:  BRA    34D6
34DC:  DECFSZ 01,F
34DE:  BRA    34D6
34E0:  BCF    FC6.5
34E2:  MOVLW  40
34E4:  MOVWF  FC7
34E6:  MOVLW  22
34E8:  MOVWF  FC6
34EA:  BCF    F94.7
34EC:  BSF    F93.0
34EE:  BSF    F89.5
34F0:  BCF    F92.5
34F2:  BCF    F93.1
34F4:  CLRF   xC6
34F6:  CLRF   xC5
34F8:  MOVLW  02
34FA:  MOVLB  1
34FC:  MOVWF  x85
34FE:  MOVLW  05
3500:  MOVWF  x86
3502:  MOVLW  02
3504:  MOVWF  x87
3506:  MOVLB  0
3508:  CALL   1468
350C:  MOVFF  03,C9
3510:  MOVFF  02,C8
3514:  MOVFF  01,C7
3518:  MOVLW  02
351A:  MOVLB  1
351C:  MOVWF  x85
351E:  MOVLW  03
3520:  MOVWF  x86
3522:  MOVLW  02
3524:  MOVWF  x87
3526:  MOVLB  0
3528:  CALL   1468
352C:  MOVFF  03,CC
3530:  MOVFF  02,CB
3534:  MOVFF  01,CA
3538:  MOVLW  02
353A:  MOVLB  1
353C:  MOVWF  x85
353E:  CLRF   x86
3540:  MOVWF  x87
3542:  MOVLB  0
3544:  CALL   1468
3548:  MOVFF  03,CF
354C:  MOVFF  02,CE
3550:  MOVFF  01,CD
3554:  MOVLW  4E
3556:  MOVLB  1
3558:  MOVWF  x85
355A:  MOVLW  03
355C:  MOVWF  x86
355E:  MOVLW  01
3560:  MOVWF  x87
3562:  MOVLB  0
3564:  CALL   1468
3568:  MOVFF  03,D2
356C:  MOVFF  02,D1
3570:  MOVFF  01,D0
3574:  MOVLW  4E
3576:  MOVLB  1
3578:  MOVWF  x85
357A:  MOVLW  02
357C:  MOVWF  x86
357E:  MOVLW  01
3580:  MOVWF  x87
3582:  MOVLB  0
3584:  CALL   1468
3588:  MOVFF  03,D5
358C:  MOVFF  02,D4
3590:  MOVFF  01,D3
3594:  MOVLW  2E
3596:  MOVLB  1
3598:  MOVWF  x85
359A:  MOVLW  07
359C:  MOVWF  x86
359E:  MOVLW  01
35A0:  MOVWF  x87
35A2:  MOVLB  0
35A4:  CALL   1468
35A8:  MOVFF  03,D8
35AC:  MOVFF  02,D7
35B0:  MOVFF  01,D6
35B4:  MOVLW  2E
35B6:  MOVLB  1
35B8:  MOVWF  x85
35BA:  MOVLW  03
35BC:  MOVWF  x86
35BE:  MOVWF  x87
35C0:  MOVLB  0
35C2:  CALL   1468
35C6:  MOVFF  03,DB
35CA:  MOVFF  02,DA
35CE:  MOVFF  01,D9
35D2:  MOVLW  3D
35D4:  MOVLB  1
35D6:  MOVWF  x85
35D8:  CLRF   x86
35DA:  MOVLW  01
35DC:  MOVWF  x87
35DE:  MOVLB  0
35E0:  CALL   1468
35E4:  MOVFF  03,DE
35E8:  MOVFF  02,DD
35EC:  MOVFF  01,DC
35F0:  MOVLW  11
35F2:  MOVLB  1
35F4:  MOVWF  x85
35F6:  MOVLW  07
35F8:  MOVWF  x86
35FA:  MOVLW  01
35FC:  MOVWF  x87
35FE:  MOVLB  0
3600:  CALL   1468
3604:  MOVFF  03,E1
3608:  MOVFF  02,E0
360C:  MOVFF  01,DF
3610:  MOVLW  11
3612:  MOVLB  1
3614:  MOVWF  x85
3616:  MOVLW  06
3618:  MOVWF  x86
361A:  MOVLW  01
361C:  MOVWF  x87
361E:  MOVLB  0
3620:  CALL   1468
3624:  MOVFF  03,E4
3628:  MOVFF  02,E3
362C:  MOVFF  01,E2
3630:  MOVLW  11
3632:  MOVLB  1
3634:  MOVWF  x85
3636:  MOVLW  05
3638:  MOVWF  x86
363A:  MOVLW  01
363C:  MOVWF  x87
363E:  MOVLB  0
3640:  CALL   1468
3644:  MOVFF  03,E7
3648:  MOVFF  02,E6
364C:  MOVFF  01,E5
3650:  MOVLW  11
3652:  MOVLB  1
3654:  MOVWF  x85
3656:  CLRF   x86
3658:  MOVLW  05
365A:  MOVWF  x87
365C:  MOVLB  0
365E:  CALL   1468
3662:  MOVFF  03,EA
3666:  MOVFF  02,E9
366A:  MOVFF  01,E8
366E:  MOVLW  19
3670:  MOVLB  1
3672:  MOVWF  x85
3674:  MOVLW  05
3676:  MOVWF  x86
3678:  MOVLW  03
367A:  MOVWF  x87
367C:  MOVLB  0
367E:  CALL   1468
3682:  MOVFF  03,ED
3686:  MOVFF  02,EC
368A:  MOVFF  01,EB
368E:  MOVLW  19
3690:  MOVLB  1
3692:  MOVWF  x85
3694:  MOVLW  03
3696:  MOVWF  x86
3698:  MOVLW  02
369A:  MOVWF  x87
369C:  MOVLB  0
369E:  CALL   1468
36A2:  MOVFF  03,F0
36A6:  MOVFF  02,EF
36AA:  MOVFF  01,EE
36AE:  MOVLW  19
36B0:  MOVLB  1
36B2:  MOVWF  x85
36B4:  CLRF   x86
36B6:  MOVLW  03
36B8:  MOVWF  x87
36BA:  MOVLB  0
36BC:  CALL   1468
36C0:  MOVFF  03,F3
36C4:  MOVFF  02,F2
36C8:  MOVFF  01,F1
36CC:  MOVLW  1A
36CE:  MOVLB  1
36D0:  MOVWF  x85
36D2:  MOVLW  05
36D4:  MOVWF  x86
36D6:  MOVLW  03
36D8:  MOVWF  x87
36DA:  MOVLB  0
36DC:  CALL   1468
36E0:  MOVFF  03,F6
36E4:  MOVFF  02,F5
36E8:  MOVFF  01,F4
36EC:  MOVLW  1A
36EE:  MOVLB  1
36F0:  MOVWF  x85
36F2:  MOVLW  03
36F4:  MOVWF  x86
36F6:  MOVLW  02
36F8:  MOVWF  x87
36FA:  MOVLB  0
36FC:  CALL   1468
3700:  MOVFF  03,F9
3704:  MOVFF  02,F8
3708:  MOVFF  01,F7
370C:  MOVLW  1A
370E:  MOVLB  1
3710:  MOVWF  x85
3712:  CLRF   x86
3714:  MOVLW  03
3716:  MOVWF  x87
3718:  MOVLB  0
371A:  CALL   1468
371E:  MOVFF  03,FC
3722:  MOVFF  02,FB
3726:  MOVFF  01,FA
372A:  MOVLW  37
372C:  MOVLB  1
372E:  MOVWF  x85
3730:  MOVLW  07
3732:  MOVWF  x86
3734:  MOVLW  01
3736:  MOVWF  x87
3738:  MOVLB  0
373A:  CALL   1468
373E:  MOVFF  03,FF
3742:  MOVFF  02,FE
3746:  MOVFF  01,FD
374A:  MOVLW  37
374C:  MOVLB  1
374E:  MOVWF  x85
3750:  MOVLW  05
3752:  MOVWF  x86
3754:  MOVLW  02
3756:  MOVWF  x87
3758:  MOVLB  0
375A:  CALL   1468
375E:  MOVFF  03,102
3762:  MOVFF  02,101
3766:  MOVFF  01,100
376A:  MOVLW  37
376C:  MOVLB  1
376E:  MOVWF  x85
3770:  MOVLW  04
3772:  MOVWF  x86
3774:  MOVLW  01
3776:  MOVWF  x87
3778:  MOVLB  0
377A:  CALL   1468
377E:  MOVFF  03,105
3782:  MOVFF  02,104
3786:  MOVFF  01,103
378A:  MOVLW  37
378C:  MOVLB  1
378E:  MOVWF  x85
3790:  MOVLW  03
3792:  MOVWF  x86
3794:  MOVLW  01
3796:  MOVWF  x87
3798:  MOVLB  0
379A:  CALL   1468
379E:  MOVFF  03,108
37A2:  MOVFF  02,107
37A6:  MOVFF  01,106
37AA:  MOVLW  37
37AC:  MOVLB  1
37AE:  MOVWF  x85
37B0:  MOVLW  01
37B2:  MOVWF  x86
37B4:  MOVLW  02
37B6:  MOVWF  x87
37B8:  MOVLB  0
37BA:  CALL   1468
37BE:  MOVFF  03,10B
37C2:  MOVFF  02,10A
37C6:  MOVFF  01,109
37CA:  MOVLW  27
37CC:  MOVLB  1
37CE:  MOVWF  x85
37D0:  MOVLW  07
37D2:  MOVWF  x86
37D4:  MOVLW  01
37D6:  MOVWF  x87
37D8:  MOVLB  0
37DA:  CALL   1468
37DE:  MOVFF  03,10E
37E2:  MOVFF  02,10D
37E6:  MOVFF  01,10C
37EA:  MOVLW  25
37EC:  MOVLB  1
37EE:  MOVWF  x85
37F0:  MOVLW  06
37F2:  MOVWF  x86
37F4:  MOVLW  02
37F6:  MOVWF  x87
37F8:  MOVLB  0
37FA:  CALL   1468
37FE:  MOVFF  03,111
3802:  MOVFF  02,110
3806:  MOVFF  01,10F
380A:  MOVLW  25
380C:  MOVLB  1
380E:  MOVWF  x85
3810:  MOVLW  04
3812:  MOVWF  x86
3814:  MOVLW  02
3816:  MOVWF  x87
3818:  MOVLB  0
381A:  CALL   1468
381E:  MOVFF  03,114
3822:  MOVFF  02,113
3826:  MOVFF  01,112
382A:  MOVLW  25
382C:  MOVLB  1
382E:  MOVWF  x85
3830:  MOVLW  02
3832:  MOVWF  x86
3834:  MOVWF  x87
3836:  MOVLB  0
3838:  CALL   1468
383C:  MOVFF  03,117
3840:  MOVFF  02,116
3844:  MOVFF  01,115
3848:  MOVLW  25
384A:  MOVLB  1
384C:  MOVWF  x85
384E:  CLRF   x86
3850:  MOVLW  02
3852:  MOVWF  x87
3854:  MOVLB  0
3856:  CALL   1468
385A:  MOVFF  03,11A
385E:  MOVFF  02,119
3862:  MOVFF  01,118
3866:  MOVLW  26
3868:  MOVLB  1
386A:  MOVWF  x85
386C:  MOVLW  06
386E:  MOVWF  x86
3870:  MOVLW  02
3872:  MOVWF  x87
3874:  MOVLB  0
3876:  CALL   1468
387A:  MOVFF  03,11D
387E:  MOVFF  02,11C
3882:  MOVFF  01,11B
3886:  MOVLW  26
3888:  MOVLB  1
388A:  MOVWF  x85
388C:  MOVLW  04
388E:  MOVWF  x86
3890:  MOVLW  02
3892:  MOVWF  x87
3894:  MOVLB  0
3896:  CALL   1468
389A:  MOVFF  03,120
389E:  MOVFF  02,11F
38A2:  MOVFF  01,11E
38A6:  MOVF   FC1,W
38A8:  ANDLW  C0
38AA:  IORLW  0F
38AC:  MOVWF  FC1
38AE:  MOVLW  07
38B0:  MOVWF  FB4
38B2:  MOVLW  02
38B4:  MOVWF  xC0
38B6:  MOVLW  4D
38B8:  MOVWF  xBF
38BA:  MOVLW  01
38BC:  MOVLB  2
38BE:  MOVWF  x4E
38C0:  MOVLW  AF
38C2:  MOVWF  x4D
38C4:  MOVLW  05
38C6:  MOVWF  x50
38C8:  MOVLW  23
38CA:  MOVWF  x4F
38CC:  MOVLW  02
38CE:  MOVLB  5
38D0:  MOVWF  x24
38D2:  MOVLW  D9
38D4:  MOVWF  x23
38D6:  CLRF   x26
38D8:  CLRF   x25
38DA:  MOVLB  0
38DC:  CLRF   xB8
38DE:  CLRF   xB9
.................... {
....................    //Timer de 8 bits
.................... //timer0 (RTCC_INTERNAL), Preescaler de 256, timer de 8 bits
.................... setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256 | RTCC_8_bit); 
38E0:  MOVLW  C7
38E2:  MOVWF  FD5
.................... //el timer se va a desbordar dependiendo de la formula:
.................... //tiempo_desbordamiento =  (Valor_maximo_del_timer * (4*Preescaler))/Freq
.................... 
.................... //EJEMPLO, 
.................... //para un divisor de 64, reloj de 48 MHZ y tiempo de 1ms
.................... //Dado que el oscilador funciona a 48 Mhz, la formula es:
.................... //t = 256*4*64 / 48000000 = 1.365 ms (aprox. 1ms),
.................... //Para hacerlo mas preciso, es posible inicializar el timer a un valor mayor a 0, por lo que el desbordamiento ocurriria antes:
.................... //con un valor de inicio de 67 (contando el 0, esto es 68 pasos) (256-68 = 180), el valor da 1.0026ms
.................... 
.................... 
.................... set_rtcc(TIMER_START);
38E4:  CLRF   FD7
38E6:  MOVLW  72
38E8:  MOVWF  FD6
38EA:  NOP   
.................... //Interrupciones del timer
.................... enable_interrupts(INT_RTCC);
38EC:  BSF    FF2.5
.................... enable_interrupts(GLOBAL);
38EE:  MOVLW  C0
38F0:  IORWF  FF2,F
.................... 
.................... 
....................    //RFM69 radio;
....................    //PRIMER BYTE es el tamao del array 
....................    uint8_t synch[] = {3,0xAA,0x2D,0xD4};
38F2:  MOVLW  03
38F4:  MOVLB  1
38F6:  MOVWF  x6F
38F8:  MOVLW  AA
38FA:  MOVWF  x70
38FC:  MOVLW  2D
38FE:  MOVWF  x71
3900:  MOVLW  D4
3902:  MOVWF  x72
....................    int ResetPin = RF_Reset;
3904:  MOVLW  20
3906:  MOVWF  x73
....................    //radio.init(synch,ResetPin);
....................    
....................    setup_adc_ports(NO_ANALOGS, VSS_VDD);
3908:  MOVF   FC1,W
390A:  ANDLW  C0
390C:  IORLW  0F
390E:  MOVWF  FC1
....................    usb_init();
3910:  MOVLB  0
3912:  GOTO   154C
....................    //Esperar un segundo antes de iniciar
....................    delay_ms(1000);
3916:  MOVLW  04
3918:  MOVLB  1
391A:  MOVWF  x85
391C:  MOVLW  FA
391E:  MOVLB  2
3920:  MOVWF  x11
3922:  MOVLB  0
3924:  CALL   155A
3928:  MOVLB  1
392A:  DECFSZ x85,F
392C:  BRA    391C
....................    while (!checkId())println((char*)"Id incorrecto");
392E:  MOVLB  0
3930:  GOTO   16AC
3934:  MOVF   01,F
3936:  BNZ   396A
3938:  MOVLW  01
393A:  MOVWF  FEA
393C:  MOVLW  74
393E:  MOVWF  FE9
3940:  MOVLW  0E
3942:  MOVWF  01
3944:  CLRF   FF7
3946:  MOVLW  00
3948:  CALL   0350
394C:  TBLRD*-
394E:  TBLRD*+
3950:  MOVFF  FF5,FEE
3954:  DECFSZ 01,F
3956:  BRA    394E
3958:  MOVLW  01
395A:  MOVLB  2
395C:  MOVWF  x14
395E:  MOVLW  74
3960:  MOVWF  x13
3962:  MOVLB  0
3964:  CALL   179E
3968:  BRA    3930
....................    init(synch,ResetPin);
396A:  MOVLW  01
396C:  MOVLB  1
396E:  MOVWF  x86
3970:  MOVLW  6F
3972:  MOVWF  x85
3974:  MOVFF  173,187
3978:  MOVLW  04
397A:  MOVWF  x88
397C:  MOVLW  01
397E:  MOVWF  x89
3980:  CLRF   x8D
3982:  MOVLW  1E
3984:  MOVWF  x8C
3986:  MOVLW  84
3988:  MOVWF  x8B
398A:  MOVLW  80
398C:  MOVWF  x8A
398E:  CLRF   x8F
3990:  CLRF   x8E
3992:  MOVLB  0
3994:  GOTO   20DC
....................    println((char*)"INIT DONE");
3998:  MOVLW  01
399A:  MOVWF  FEA
399C:  MOVLW  74
399E:  MOVWF  FE9
39A0:  MOVLW  0A
39A2:  MOVWF  01
39A4:  CLRF   FF7
39A6:  MOVLW  00
39A8:  CALL   036E
39AC:  TBLRD*-
39AE:  TBLRD*+
39B0:  MOVFF  FF5,FEE
39B4:  DECFSZ 01,F
39B6:  BRA    39AE
39B8:  MOVLW  01
39BA:  MOVLB  2
39BC:  MOVWF  x14
39BE:  MOVLW  74
39C0:  MOVWF  x13
39C2:  MOVLB  0
39C4:  CALL   179E
....................    while(TRUE)
....................    {
....................    char* packet = receive(1,0,0,0);
39C8:  MOVLW  01
39CA:  MOVLB  1
39CC:  MOVWF  x85
39CE:  CLRF   x86
39D0:  CLRF   x8A
39D2:  CLRF   x89
39D4:  CLRF   x88
39D6:  CLRF   x87
39D8:  CLRF   x8B
39DA:  MOVLB  0
39DC:  GOTO   301C
39E0:  MOVFF  02,183
39E4:  MOVFF  01,182
....................    if (!(packet == NULL || packet[0] == 0)){
39E8:  MOVLB  1
39EA:  MOVF   x82,F
39EC:  BNZ   39F2
39EE:  MOVF   x83,F
39F0:  BZ    3A46
39F2:  MOVFF  182,FE9
39F6:  MOVFF  183,FEA
39FA:  MOVF   FEF,F
39FC:  BZ    3A46
....................     for (int i=0;i<packet[0];i++){
39FE:  CLRF   x84
3A00:  MOVFF  182,FE9
3A04:  MOVFF  183,FEA
3A08:  MOVF   FEF,W
3A0A:  SUBWF  x84,W
3A0C:  BC    3A30
....................       print((char*)packet[i+1]);
3A0E:  MOVLW  01
3A10:  ADDWF  x84,W
3A12:  ADDWF  x82,W
3A14:  MOVWF  FE9
3A16:  MOVLW  00
3A18:  ADDWFC x83,W
3A1A:  MOVWF  FEA
3A1C:  MOVF   FEF,W
3A1E:  MOVWF  x85
3A20:  CLRF   xD4
3A22:  MOVWF  xD3
3A24:  MOVLB  0
3A26:  CALL   17F8
3A2A:  MOVLB  1
3A2C:  INCF   x84,F
3A2E:  BRA    3A00
....................       }
....................   println((char*)"");
3A30:  CLRF   x74
3A32:  MOVLW  01
3A34:  MOVLB  2
3A36:  MOVWF  x14
3A38:  MOVLW  74
3A3A:  MOVWF  x13
3A3C:  MOVLB  0
3A3E:  CALL   179E
....................    }
3A42:  BRA    3A78
3A44:  MOVLB  1
....................    else println((char*) "Esperando");
3A46:  MOVLW  01
3A48:  MOVWF  FEA
3A4A:  MOVLW  74
3A4C:  MOVWF  FE9
3A4E:  MOVLW  0A
3A50:  MOVWF  01
3A52:  CLRF   FF7
3A54:  MOVLW  00
3A56:  MOVLB  0
3A58:  CALL   0388
3A5C:  TBLRD*-
3A5E:  TBLRD*+
3A60:  MOVFF  FF5,FEE
3A64:  DECFSZ 01,F
3A66:  BRA    3A5E
3A68:  MOVLW  01
3A6A:  MOVLB  2
3A6C:  MOVWF  x14
3A6E:  MOVLW  74
3A70:  MOVWF  x13
3A72:  MOVLB  0
3A74:  CALL   179E
....................   //radio.readAllRegs();
....................   free(packet);
3A78:  MOVFF  183,1D2
3A7C:  MOVFF  182,1D1
3A80:  CALL   2CE6
....................    //println(globalSec,DEC);
....................    
....................    //readAllRegs();
....................    //print((char*)"RFM ");
....................    
....................    //if (!checkId())println((char*)"incorrecto");
....................    //else println((char*)"Correcto");
....................    //radio.readAllRegs();
.................... //!   println((char*)"HOLA USB");
.................... //!   println(134,HEX);
.................... //!   println(47,BIN);
....................    delay_ms(100);
3A84:  MOVLW  64
3A86:  MOVLB  2
3A88:  MOVWF  x11
3A8A:  MOVLB  0
3A8C:  CALL   155A
3A90:  BRA    39C8
....................       //TODO: User Code
....................    }
.................... 
.................... }
.................... 
.................... //Interrupcion del timer
.................... #INT_RTCC  //TIMER0
.................... void timer0(void){
3A92:  SLEEP 
....................    set_rtcc(TIMER_START); //Timer0
*
1414:  CLRF   FD7
1416:  MOVLW  72
1418:  MOVWF  FD6
141A:  NOP   
....................    //println((char*)"Timer INT");
....................    globalMs += TIMER_STEP_MS ;       
141C:  MOVLW  03
141E:  ADDWF  xBA,F
1420:  MOVLW  00
1422:  ADDWFC xBB,F
....................    if (globalMs >= 1000){
1424:  MOVF   xBB,W
1426:  SUBLW  02
1428:  BC    143E
142A:  XORLW  FF
142C:  BNZ   1434
142E:  MOVF   xBA,W
1430:  SUBLW  E7
1432:  BC    143E
....................    globalSec ++;
1434:  INCF   xBC,F
....................    globalMs -= 1000;
1436:  MOVLW  E8
1438:  SUBWF  xBA,F
143A:  MOVLW  03
143C:  SUBWFB xBB,F
....................    }
....................    if (globalSec >= 60){
143E:  MOVF   xBC,W
1440:  SUBLW  3B
1442:  BC    144E
....................    globalMin ++;
1444:  INCF   xBD,F
1446:  BTFSC  FD8.2
1448:  INCF   xBE,F
....................    globalSec -= 60;
144A:  MOVLW  3C
144C:  SUBWF  xBC,F
....................    }
....................    //Inicializar todo al llegar a 60 minutos
....................    //Puede introducir un bug rarisimo en el que una diferencia entre tiempos de negativa, pero es muy poco probable
....................    //Y aun asi el bug ocurrira cuando gloabalMin desborde
....................    if (globalMin >= 60){
144E:  MOVF   xBE,F
1450:  BNZ   1458
1452:  MOVF   xBD,W
1454:  SUBLW  3B
1456:  BC    1462
....................    globalMs = 0;
1458:  CLRF   xBB
145A:  CLRF   xBA
....................    globalSec= 0;
145C:  CLRF   xBC
....................    globalMin = 0;
145E:  CLRF   xBE
1460:  CLRF   xBD
....................    }
1462:  BCF    FF2.2
1464:  GOTO   006C
.................... }

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
