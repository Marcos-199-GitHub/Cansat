CCS PCH C Compiler, Version 5.112, 29001               24-may.-23 00:30

               Filename:   I:\CanSat\Nueva carpeta\RFM69\Receptor\ArduPort\Receptor.lst

               ROM used:   7208 bytes (22%)
                           Largest free fragment is 25560
               RAM used:   659 (32%) at main() level
                           752 (37%) worst case
               Stack used: 20 locations (13 in main + 7 for interrupts)
               Stack size: 31

*
0000:  GOTO   17DA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.5
0056:  GOTO   0060
005A:  BTFSC  FA1.5
005C:  GOTO   1236
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #define HEX 16
.................... #define BIN 2
.................... #define SSPin PIN_A5
.................... 
.................... #include <Receptor.h>
.................... #include <18LF4550.h>
.................... //////////// Standard Header file for the PIC18LF4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18LF4550
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,03
00C0:  DATA 02,FF
00C2:  DATA FF,FF
00C4:  DATA FF,FF
00C6:  DATA FF,FF
00C8:  DATA FF,FF
00CA:  DATA FF,FF
00CC:  DATA FF,FF
00CE:  CLRF   FF7
00D0:  ADDLW  DE
00D2:  MOVWF  FF6
00D4:  MOVLW  00
00D6:  ADDWFC FF7,F
00D8:  TBLRD*+
00DA:  MOVF   FF5,W
00DC:  RETURN 0
00DE:  DATA 00,FF
00E0:  DATA 02,FF
00E2:  DATA FF,FF
00E4:  DATA FF,FF
00E6:  DATA FF,FF
00E8:  DATA FF,FF
00EA:  DATA FF,FF
00EC:  DATA FF,FF
00EE:  CLRF   FF7
00F0:  ADDLW  FE
00F2:  MOVWF  FF6
00F4:  MOVLW  00
00F6:  ADDWFC FF7,F
00F8:  TBLRD*+
00FA:  MOVF   FF5,W
00FC:  RETURN 0
00FE:  DATA 40,00
0100:  DATA 0B,00
0102:  DATA 40,00
0104:  DATA 00,00
0106:  DATA 00,00
0108:  DATA 00,00
010A:  DATA 00,00
010C:  DATA 00,00
010E:  DATA 00,00
0110:  DATA 00,00
0112:  DATA 00,00
0114:  DATA 00,00
0116:  DATA 00,00
0118:  DATA 00,00
011A:  DATA 00,00
011C:  DATA 00,00
011E:  CLRF   FF7
0120:  ADDLW  2E
0122:  MOVWF  FF6
0124:  MOVLW  01
0126:  ADDWFC FF7,F
0128:  TBLRD*+
012A:  MOVF   FF5,W
012C:  RETURN 0
012E:  DATA 40,00
0130:  DATA 00,00
0132:  DATA 40,00
0134:  DATA 00,00
0136:  DATA 00,00
0138:  DATA 00,00
013A:  DATA 00,00
013C:  DATA 00,00
013E:  DATA 00,00
0140:  DATA 00,00
0142:  DATA 00,00
0144:  DATA 00,00
0146:  DATA 00,00
0148:  DATA 00,00
014A:  DATA 00,00
014C:  DATA 00,00
014E:  CLRF   FF7
0150:  ADDLW  5E
0152:  MOVWF  FF6
0154:  MOVLW  01
0156:  ADDWFC FF7,F
0158:  TBLRD*+
015A:  MOVF   FF5,W
015C:  RETURN 0
015E:  DATA 09,02
0160:  DATA 43,00
0162:  DATA 02,01
0164:  DATA 00,80
0166:  DATA FA,09
0168:  DATA 04,00
016A:  DATA 00,01
016C:  DATA 02,02
016E:  DATA 01,00
0170:  DATA 05,24
0172:  DATA 00,10
0174:  DATA 01,04
0176:  DATA 24,02
0178:  DATA 02,05
017A:  DATA 24,06
017C:  DATA 00,01
017E:  DATA 05,24
0180:  DATA 01,00
0182:  DATA 01,07
0184:  DATA 05,81
0186:  DATA 03,0B
0188:  DATA 00,FA
018A:  DATA 09,04
018C:  DATA 01,00
018E:  DATA 02,0A
0190:  DATA 00,00
0192:  DATA 00,07
0194:  DATA 05,02
0196:  DATA 02,40
0198:  DATA 00,01
019A:  DATA 07,05
019C:  DATA 82,02
019E:  DATA 40,00
01A0:  DATA 01,00
01A2:  CLRF   FF7
01A4:  ADDLW  B2
01A6:  MOVWF  FF6
01A8:  MOVLW  01
01AA:  ADDWFC FF7,F
01AC:  TBLRD*+
01AE:  MOVF   FF5,W
01B0:  RETURN 0
01B2:  DATA 02,00
01B4:  CLRF   FF7
01B6:  ADDLW  C4
01B8:  MOVWF  FF6
01BA:  MOVLW  01
01BC:  ADDWFC FF7,F
01BE:  TBLRD*+
01C0:  MOVF   FF5,W
01C2:  RETURN 0
01C4:  DATA 12,17
01C6:  DATA 1B,20
01C8:  DATA FF,FF
01CA:  DATA FF,FF
01CC:  CLRF   FF7
01CE:  ADDLW  DC
01D0:  MOVWF  FF6
01D2:  MOVLW  01
01D4:  ADDWFC FF7,F
01D6:  TBLRD*+
01D8:  MOVF   FF5,W
01DA:  RETURN 0
01DC:  DATA 12,01
01DE:  DATA 10,01
01E0:  DATA 02,00
01E2:  DATA 00,40
01E4:  DATA 05,24
01E6:  DATA 0B,00
01E8:  DATA 00,01
01EA:  DATA 01,02
01EC:  DATA 00,01
01EE:  CLRF   FF7
01F0:  ADDLW  FE
01F2:  MOVWF  FF6
01F4:  MOVLW  01
01F6:  ADDWFC FF7,F
01F8:  TBLRD*+
01FA:  MOVF   FF5,W
01FC:  RETURN 0
01FE:  DATA 04,03
0200:  DATA 09,04
0202:  DATA 08,03
0204:  DATA 43,00
0206:  DATA 43,00
0208:  DATA 53,00
020A:  DATA 20,03
020C:  DATA 43,00
020E:  DATA 43,00
0210:  DATA 53,00
0212:  DATA 20,00
0214:  DATA 55,00
0216:  DATA 53,00
0218:  DATA 42,00
021A:  DATA 20,00
021C:  DATA 74,00
021E:  DATA 6F,00
0220:  DATA 20,00
0222:  DATA 55,00
0224:  DATA 41,00
0226:  DATA 52,00
0228:  DATA 54,00
022A:  CLRF   FF7
022C:  ADDLW  3A
022E:  MOVWF  FF6
0230:  MOVLW  02
0232:  ADDWFC FF7,F
0234:  TBLRD*+
0236:  MOVF   FF5,W
0238:  RETURN 0
023A:  DATA 41,64
023C:  DATA 64,72
023E:  DATA 65,73
0240:  DATA 73,20
0242:  DATA 2D,20
0244:  DATA 48,45
0246:  DATA 58,20
0248:  DATA 2D,20
024A:  DATA 42,49
024C:  DATA 4E,00
*
02EE:  MOVLB  1
02F0:  MOVF   xC8,W
02F2:  MULWF  xCA
02F4:  MOVFF  FF3,01
02F8:  MOVFF  FF4,00
02FC:  MULWF  xCB
02FE:  MOVF   FF3,W
0300:  ADDWF  00,F
0302:  MOVF   xC9,W
0304:  MULWF  xCA
0306:  MOVF   FF3,W
0308:  ADDWFC 00,W
030A:  MOVWF  02
030C:  MOVLB  0
030E:  RETURN 0
*
1442:  MOVF   FEF,F
1444:  BZ    1464
1446:  MOVFF  FEA,19C
144A:  MOVFF  FE9,19B
144E:  MOVFF  FEF,19D
1452:  BRA    1406
1454:  MOVFF  19C,FEA
1458:  MOVFF  19B,FE9
145C:  INCF   FE9,F
145E:  BTFSC  FD8.2
1460:  INCF   FEA,F
1462:  BRA    1442
1464:  GOTO   147A (RETURN)
*
149E:  MOVLB  1
14A0:  MOVF   x8D,W
14A2:  ANDLW  07
14A4:  MOVWF  00
14A6:  RRCF   x8D,W
14A8:  MOVWF  01
14AA:  RRCF   01,F
14AC:  RRCF   01,F
14AE:  MOVLW  1F
14B0:  ANDWF  01,F
14B2:  MOVF   01,W
14B4:  ADDWF  x8F,W
14B6:  MOVWF  FE9
14B8:  MOVLW  00
14BA:  ADDWFC x90,W
14BC:  MOVWF  FEA
14BE:  CLRF   01
14C0:  INCF   01,F
14C2:  INCF   00,F
14C4:  BRA    14C8
14C6:  RLCF   01,F
14C8:  DECFSZ 00,F
14CA:  BRA    14C6
14CC:  MOVF   x8E,F
14CE:  BZ    14D6
14D0:  MOVF   01,W
14D2:  IORWF  FEF,F
14D4:  BRA    14DC
14D6:  COMF   01,F
14D8:  MOVF   01,W
14DA:  ANDWF  FEF,F
14DC:  MOVLB  0
14DE:  RETURN 0
*
15CC:  MOVFF  C1,FEA
15D0:  MOVFF  C0,FE9
15D4:  MOVFF  19B,FEF
15D8:  INCF   FE9,F
15DA:  BTFSC  FD8.2
15DC:  INCF   FEA,F
15DE:  CLRF   FEF
15E0:  MOVLB  0
15E2:  INCF   xC0,F
15E4:  BTFSC  FD8.2
15E6:  INCF   xC1,F
15E8:  RETURN 0
15EA:  MOVLB  1
15EC:  BTFSC  x9A.7
15EE:  BRA    1612
15F0:  MOVLW  0F
15F2:  MOVWF  00
15F4:  SWAPF  x99,W
15F6:  ANDWF  00,F
15F8:  MOVLW  0A
15FA:  SUBWF  00,W
15FC:  BC    1604
15FE:  MOVLW  30
1600:  ADDWF  00,F
1602:  BRA    1608
1604:  MOVF   x9A,W
1606:  ADDWF  00,F
1608:  MOVFF  00,19B
160C:  MOVLB  0
160E:  RCALL  15CC
1610:  MOVLB  1
1612:  MOVLW  0F
1614:  ANDWF  x99,F
1616:  MOVLW  0A
1618:  SUBWF  x99,W
161A:  BC    1620
161C:  MOVLW  30
161E:  BRA    1624
1620:  BCF    x9A.7
1622:  MOVF   x9A,W
1624:  ADDWF  x99,F
1626:  MOVFF  199,19B
162A:  MOVLB  0
162C:  RCALL  15CC
162E:  GOTO   16BA (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #fuses HSPLL, NOWDT, NOPROTECT, NODEBUG, USBDIV, PLL4, CPUDIV1, VREGEN
.................... 
.................... #use delay(clock=48MHz,crystal=16MHz,USB_FULL)
*
1524:  MOVLW  01
1526:  MOVLB  1
1528:  SUBWF  x8B,F
152A:  BNC   1546
152C:  MOVLW  01
152E:  MOVWF  FEA
1530:  MOVLW  8B
1532:  MOVWF  FE9
1534:  MOVF   FEF,W
1536:  BZ    1546
1538:  MOVLW  02
153A:  MOVWF  00
153C:  DECFSZ 00,F
153E:  BRA    153C
1540:  BRA    1542
1542:  DECFSZ FEF,F
1544:  BRA    1538
1546:  MOVLB  0
1548:  GOTO   1582 (RETURN)
*
17AE:  MOVLW  01
17B0:  MOVWF  FEA
17B2:  MOVLW  70
17B4:  MOVWF  FE9
17B6:  MOVF   FEF,W
17B8:  BZ    17D6
17BA:  MOVLW  0F
17BC:  MOVWF  01
17BE:  CLRF   00
17C0:  DECFSZ 00,F
17C2:  BRA    17C0
17C4:  DECFSZ 01,F
17C6:  BRA    17BE
17C8:  MOVLW  8F
17CA:  MOVWF  00
17CC:  DECFSZ 00,F
17CE:  BRA    17CC
17D0:  NOP   
17D2:  DECFSZ FEF,F
17D4:  BRA    17BA
17D6:  GOTO   1C1C (RETURN)
.................... #use FIXED_IO( E_outputs=PIN_E0 )
.................... #define RF_RESET   PIN_E0
.................... 
.................... 
.................... #define USB_CABLE_IS_ATTACHED()  input(PIN_B2)
.................... #define USB_CONFIG_VID 0x2405
.................... #define USB_CONFIG_PID 0x000B
.................... #define USB_CONFIG_BUS_POWER 500
.................... 
.................... // if USB_CDC_ISR is defined, then this function will be called
.................... // by the USB ISR when there incoming CDC (virtual com port) data.
.................... // this is useful if you want to port old RS232 code that was use
.................... // #int_rda to CDC.
.................... #define USB_CDC_ISR() RDA_isr()
.................... 
.................... // in order for handle_incoming_usb() to be able to transmit the entire
.................... // USB message in one pass, we need to increase the CDC buffer size from
.................... // the normal size and use the USB_CDC_DELAYED_FLUSH option.
.................... // failure to do this would cause some loss of data.
.................... #define USB_CDC_DELAYED_FLUSH
.................... #define USB_CDC_DATA_LOCAL_SIZE  128
.................... 
.................... 
.................... static void RDA_isr(void);
.................... 
.................... #include <usb_cdc.h>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////                            usb_cdc.h                            ////
.................... ////                                                                 ////
.................... //// Library for adding a virtual COM port on your PC over USB using ////
.................... //// the standard Communication Device Class (CDC) specification.    ////
.................... //// Including this file in your code will add all USB code,         ////
.................... //// interrupts, descriptors and handlers required.  No other        ////
.................... //// modifications need to be made.                                  ////
.................... ////                                                                 ////
.................... //// This library creates a virtual RS232 link between the PC and    ////
.................... //// the PIC, therefore the library provided will be familiar to     ////
.................... //// anyone with standard UART stream I/O:                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          ////
.................... ////      character received and waiting in the receive buffer.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  ////
.................... ////      there is no data in the receive buffer it will wait until  ////
.................... ////      there is data in the receive buffer.  If you do not want   ////
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   ////
.................... ////      check if there is data before calling usb_cdc_getc().      ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       ////
.................... ////      buffer.  If the transmit buffer is full it will wait until ////
.................... ////      the transmit buffer is not full before putting the char    ////
.................... ////      into the transmit buffer.  The transmit buffer is read by  ////
.................... ////      the PC very quickly, and therefore the buffer should only  ////
.................... ////      be full for a few milli-seconds.  If you are concerned     ////
.................... ////      and don't want to be stuck in a long or infinite loop,     ////
.................... ////      use usb_cdc_putready() to see if there is space in the     ////
.................... ////      transmit buffer before putting data into the transmit      ////
.................... ////      buffer.                                                    ////
.................... ////                                                                 ////
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    ////
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'ptr' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    ////
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'len' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putready() - Returns the number of bytes available      ////
.................... ////     in the TX buffer for storing characters.  If this returns   ////
.................... ////     0 then the buffer is full and waiting for the host (PC)     ////
.................... ////     to read the buffer.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   ////
.................... ////     empty and fully flushed/transmitted to host (PC).           ////
.................... ////                                                                 ////
.................... //// usb_cdc_connected() - Returns TRUE if we received a             ////
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   ////
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        ////
.................... ////      message when the program starts and it opens the virtual   ////
.................... ////      COM port.  This is a simple way to determine if the PC     ////
.................... ////      is ready to display data on a serial terminal program,     ////
.................... ////      but is not garaunteed to work all the time or on other     ////
.................... ////      terminal programs.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   ////
.................... ////      if the transmit buffer is full it will skip the char.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  ////
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   ////
.................... ////                                                                 ////
.................... //// usb_cdc_break - If the PC has sent a break command, this will   ////
.................... ////       hold the break time (in milli-seconds).  If the PC sends  ////
.................... ////       a value of 0xFFFF the device is supposed to hold the      ////
.................... ////       break until it sends a value of 0                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. ////
.................... ////       Of most relevance is the field dte_present, which is the  ////
.................... ////       DTR setting.                                              ////
.................... ////                                                                 ////
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          ////
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   ////
.................... ////       ring, break and more.  See the documentation above        ////
.................... ////       usb_cdc_serial_state() for more information, including    ////
.................... ////       format of state structure.                                ////
.................... ////                                                                 ////
.................... //// The following functions are also provided, and are ports of the ////
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   ////
.................... //// documentation:                                                  ////
.................... ////   get_float_usb() - Read a float number from the user           ////
.................... ////   get_long_usb() - Read a long number from the user             ////
.................... ////   get_int_usb() - Read an integer number from the user          ////
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. ////
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             ////
.................... ////   gethex1_usb() - Read a HEX character                          ////
.................... ////                                                                 ////
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  ////
.................... //// be called when there is incoming CDC (virtual com port) data.   ////
.................... //// This is useful if you want to update legacy RS232 code that     ////
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    ////
.................... //// However, see the INTERRUPT LIMITATIONS section below.           ////
.................... ////                                                                 ////
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    ////
.................... ////  to flush the data as soon as possible.  However at times       ////
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   ////
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         ////
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     ////
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       ////
.................... ////  also attempt to flush the packet on each call to usb_task().   ////
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     ////
.................... ////  if you have a main loop that periodically calls usb_task().    ////
.................... ////                                                                 ////
.................... //// This driver will load all the rest of the USB code, and a set   ////
.................... //// of descriptors that will properly describe a CDC device for a   ////
.................... //// virtual COM port (usb_desc_cdc.h)                               ////
.................... ////                                                                 ////
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      ////
.................... //// standard CDC drivers for a virtual COM port in Windows          ////
.................... //// NT/2000/XP and above.                                           ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// Encapsuated Messages: (USB_CDC_USE_ENCAPSULATED)                ////
.................... //// -------------------------------------------------------------   ////
.................... ////                                                                 ////
.................... //// If USB_CDC_USE_ENCAPSULATED is defined, then the user must      ////
.................... //// provide the following callbacks in their application to provide ////
.................... //// encapsuated message support (SendEncapsulatedCommand and        ////
.................... ////  GetEncapsulatedResponse):                                      ////
.................... ////                                                                 ////
.................... //// usb_cdc_SendEncapsulatedCommand(byte *ptr, unsigned int16 num)  ////
.................... ////     PIC receives encapsulated command from host (PC), 'num'     ////
.................... ////     bytes of message stored in 'ptr'.                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_GetEncapsulatedResponse(byte *ptr, unsigned int16 num)  ////
.................... ////     Host (PC) is asking for 'num' bytes response from the PIC,  ////
.................... ////     PIC should store up to 'num' bytes to 'ptr' as the          ////
.................... ////     response.                                                   ////
.................... ////                                                                 ////
.................... //// Due to the design of the USB stack, all encapsulated messages   ////
.................... //// must be smaller than one endpoint 0 packet.  They cannot be     ////
.................... //// equal in size or larger than the endpoint 0 size.  See          ////
.................... //// USB_MAX_EP0_PACKET_LENGTH.                                      ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// BUFFER SIZES                                                    ////
.................... //// -------------------------------------------------------------   ////
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     ////
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        ////
.................... ////  Full speed devices limit this value to be 64.  To increase     ////
.................... ////  the size of the local PIC buffer you can also define           ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        ////
.................... ////  defined then the total PIC->PC buffer size would be            ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  ////
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      ////
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      ////
.................... ////  then this option isn't used.                                   ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// INTERRUPT LIMITATIONS                                           ////
.................... //// -------------------------------------------------------------   ////
.................... //// This section is only relevant if you are using USB interrupts   ////
.................... ////  and not the USB_ISR_POLLING option.                            ////
.................... ////                                                                 ////
.................... //// USB handling is complex, often requiring several packet         ////
.................... ////  transmissions to accomplish transfer of one block of data.     ////
.................... ////  Most of this processing is done in the USB ISR.  Because       ////
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the ////
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   ////
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  ////
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  ////
.................... ////  overflow the TX buffer than data will be lost.                 ////
.................... ////                                                                 ////
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB ////
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      ////
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           ////
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    ////
.................... ////                                                                 ////
.................... //// ex_usb_serial3.c shows an example of working around these       ////
.................... ////  ISR limitations.  Failure to follow these limitations can      ////
.................... ////  cause the PIC to lockup.  These limtations only need to be     ////
.................... ////  followed in the conditions listed above (writing code in the   ////
.................... ////  ISR or interrupts are disabled).                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// VERSION HISTORY                                                 ////
.................... ////                                                                 ////
.................... //// Nov 20th, 2014:                                                 ////
.................... ////  While usb_cdc_putc() waits for local buffer to be free, also   ////
.................... ////     check the endpoint buffer in case there was a situation     ////
.................... ////     that the ISR for this event was missed.                     ////
.................... ////                                                                 ////
.................... //// Dec 16th, 2013:                                                 ////
.................... ////  Added encapsulated message support.  See                       ////
.................... ////     USB_CDC_USE_ENCAPSULATED above for documentation.           ////
.................... ////                                                                 ////
.................... //// May 31st, 2013:                                                 ////
.................... ////  usb_cdc_putready() now returns the number of bytes available.  ////
.................... ////                                                                 ////
.................... //// May 23rd, 2013:                                                 ////
.................... ////  Added usb_cdc_putd().                                          ////
.................... ////                                                                 ////
.................... //// February 18th, 2013:                                            ////
.................... ////  Enhanced PIC16 support added.                                  ////
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 ////
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    ////
.................... ////                                                                 ////
.................... //// September 13th, 2012:                                           ////
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     ////
.................... ////     (PIC24, dsPIC33).                                           ////
.................... ////  Added usb_cdc_putempty().                                      ////
.................... ////                                                                 ////
.................... //// December 16th, 2011:                                            ////
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will ////
.................... ////     only include the get string helper functions.  This is      ////
.................... ////     a rarely used option, used only if you already wrote your   ////
.................... ////     own getc() and putc() routines.                             ////
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  ////
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      ////
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  ////
.................... ////                                                                 ////
.................... //// Oct 27th, 2011:                                                 ////
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    ////
.................... ////     documentation.  In order for this to work,                  ////
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   ////
.................... ////                                                                 ////
.................... //// Jan 28, 2010:                                                   ////
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    ////
.................... ////     one packet.                                                 ////
.................... ////                                                                 ////
.................... //// Jan 25, 2010:                                                   ////
.................... ////  Ignore incoming 0 length packets.                              ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// April 7th, 2009:                                                ////
.................... ////   Vista 'code 10' issues resolved.                              ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 26th, 2007:                                                 ////
.................... ////              usb_cdc_put_buffer_free() should be more stable.   ////
.................... ////              Fixed a hang-up that would happen if you sent      ////
.................... ////                 exactly 64 bytes.                               ////
.................... ////                                                                 ////
.................... //// Nov 6th, 2007:                                                  ////
.................... ////              Compatabible with latest pic18_usb.h, which        ////
.................... ////                 reduces RAM footprint of USB driver.            ////
.................... ////              This driver now fits on 18F4450/2450 PICs.         ////
.................... ////                                                                 ////
.................... //// October 27th, 2005: Changed the way incoming packets are        ////
.................... ////               handled in that CDC driver will not flush         ////
.................... ////               endpoint until user has handled all data.  This   ////
.................... ////               will prevent overflows as the USB will NAK        ////
.................... ////               incoming packets until it is ready to receive     ////
.................... ////               more.                                             ////
.................... ////            When using 18F4550 family, the RX buffer is          ////
.................... ////               mapped directly to the endpoint buffer - this     ////
.................... ////               saves a chunk of RAM.                             ////
.................... ////            When using the 18F4550 family, you can increase      ////
.................... ////               the TX and RX size over 64 bytes.                 ////
.................... ////            No longer send 0len packets in the TBE interrupt.    ////
.................... ////            Hopefully fixed bugs that caused random crashes      ////
.................... ////               if you tried sending more than 64 bytes.          ////
.................... ////                                                                 ////
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   ////
.................... ////                   buffer.                                       ////
.................... ////                                                                 ////
.................... //// July 1st, 2005: Initial Release.                                ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... //input.c ported to use CDC:
.................... float get_float_usb();
.................... signed long get_long_usb();
.................... signed int get_int_usb();
.................... void get_string_usb(char* s, unsigned int max);
.................... char gethex_usb();
.................... char gethex1_usb();
.................... 
.................... #if !defined(__USB_CDC_HELPERS_ONLY__)
.................... 
.................... //api for the user:
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got)
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free())
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin)
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding)
.................... void usb_cdc_putc_fast(char c);
.................... char usb_cdc_getc(void);
.................... void usb_cdc_putc(char c);
.................... void usb_cdc_get_discard(void);
.................... 
.................... //functions automatically called by USB handler code
.................... void usb_isr_tkn_cdc(void);
.................... void usb_cdc_init(void);
.................... void usb_isr_tok_out_cdc_control_dne(void);
.................... void usb_isr_tok_in_cdc_data_dne(void);
.................... void usb_isr_tok_out_cdc_data_dne(void);
.................... 
.................... void usb_cdc_flush_tx_buffer(void);
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //
.................... // Include the CCS USB Libraries.  See the comments at the top of these
.................... // files for more information
.................... //
.................... /////////////////////////////////////////////////////////////////////////////
.................... #ifndef __USB_PIC_PERIF__
.................... #define __USB_PIC_PERIF__   1
.................... #endif
.................... 
.................... #if __USB_PIC_PERIF__
....................    #if defined(__PCM__)
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c
....................    #elif defined(__PCH__)
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.h                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  This hardware layer      ////
.................... //// supports the USB peripheral on the PIC18 family chips.  Current ////
.................... //// supported families are:                                         ////
.................... ////     PIC18F2455/2550/4455/4550                                   ////
.................... ////     PIC18F2450/4450                                             ////
.................... ////     PIC18F2458/2553/4458/4553                                   ////
.................... ////     PIC18F13K50/14K50                                           ////
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     ////
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       ////
.................... ////     PIC18FxxK50                                                 ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      ////
.................... //// that are specific to only this HW peripheral that you may       ////
.................... //// find useful to use in your application.                         ////
.................... ////                                                                 ////
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    ////
.................... ////  Due to the limited USB RAM of this family, a limitation of     ////
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   ////
.................... ////  The HW actually supports more endpoints, but to simplify       ////
.................... ////  driver development this driver will only support the first 3   ////
.................... ////  so there is an easier memory block to work with.               ////
.................... ////                                                                 ////
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     ////
.................... ////  of USB speed, to save RAM.                                     ////
.................... ////                                                                 ////
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    ////
.................... ////  If you are not using internal pullups, you will need to put    ////
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    ////
.................... ////  want to use slow speed or full speed.  This code configures    ////
.................... ////  the device to use internal pullups, see usb_init() if you      ////
.................... ////  want to change that.                                           ////
.................... ////                                                                 ////
.................... ////  You need approximately 470nF cap on Vusb, even if you are      ////
.................... ////  using the internal 3.3V USB regulator.                         ////
.................... ////                                                                 ////
.................... ////  To run at full speed, you must use the oscillator              ////
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   ////
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     ////
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      ////
.................... ////  96MHz clock.  See the datasheet for details.                   ////
.................... ////                                                                 ////
.................... ////  To run at slow speed you must configure your MCU to run at     ////
.................... ////  24Mhz.  See the datasheet for details.                         ////
.................... ////                                                                 ////
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   ////
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the ////
.................... //// PIC when an event has happened on the USB Bus.  Therfore        ////
.................... //// this code enables interrupts.  A user modification can be made  ////
.................... //// to poll the USB interrupt flag instead of relying on an         ////
.................... //// interrupt.                                                      ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_H__
.................... #DEFINE __PIC18_USB_H__
.................... 
.................... #DEFINE __USB_HARDWARE__
.................... 
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral
.................... #DEFINE __PIC__   1
.................... 
.................... #ifndef USB_USE_FULL_SPEED
....................  #define USB_USE_FULL_SPEED   1
.................... #endif
.................... 
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................    //due to limited ram, force max packet length to 8 for this chip
....................    #define USB_MAX_EP0_PACKET_LENGTH   8
.................... #else
....................    #if USB_USE_FULL_SPEED==0
....................       //slow speed requires 8byte max packet size for endpoint 0
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8
....................    #else
....................       //for full speed you can still use 8bytes, but 64 will be faster
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64
....................    #endif
.................... #endif
.................... #endif
.................... 
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8))
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8
....................  #error Max Endpoint 0 length can't be less than 8!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64
....................  #error Max Endpoint 0 length can't be greater than 64!
.................... #endif
.................... 
.................... #include <usb_hw_layer.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_hw_layer.h                            ////
.................... ////                                                                   ////
.................... //// HW Layer for the USB Stack.                                       ////
.................... ////                                                                   ////
.................... //// HW drivers for the USB stack must support this API.               ////
.................... ////                                                                   ////
.................... //// The HW driver must also have a token handler that will call       ////
.................... //// usb_token_reset() when the device is init/reset, will call        ////
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          ////
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    ////
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     ////
.................... //// See usb.h for documentation of these functions.                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __USB_HW_LAYER_H__
.................... #define __USB_HW_LAYER_H__
.................... 
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0,
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4};
.................... 
.................... 
.................... // USER LEVEL FUNCTIONS:
.................... 
.................... /*****************************************************************************
.................... /* usb_init()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_init_cs()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_cs(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_task()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_task(void);
.................... 
.................... /******************************************************************************
.................... /* usb_attach()
.................... /*
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral.
.................... /*
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt.
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_attach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_detach()
.................... /*
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB.
.................... /*
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* If the user does call this function while USB is connected, the USB 
.................... /* peripheral will be disabled only momentarily because usb_task() will
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB
.................... /* reset of the device.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_detach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_put_packet()
.................... /*
.................... /* Input: endpoint - endpoint to send packet to (0..15).
.................... /*        ptr - points to data to send.
.................... /*        len - amount of data to send.
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, 
.................... /*                 or toggle from the last DATAx pid.
.................... /*
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only 
.................... /*         reason it will return FALSE is if because the TX buffer is still full 
.................... /*         from the last time it tried to send a packet.
.................... /*
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a 
.................... /*          difference between a packet and a message.  If you wanted to send a 
.................... /*          512 byte message on an endpoint that only supported 64 byte packets,
.................... /*          this would be accomplished this by sending 8 64-byte packets, 
.................... /*          followed by a 0 length packet.  If the last (or only packet) being 
.................... /*          sent is less than the max packet size defined in your descriptor 
.................... /*          then you do not need to send a 0 length packet to identify
.................... /*          an end of message.
.................... /*
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message 
.................... /*          correctly and know if a 0 lenght packet needs to be sent.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl);
.................... 
.................... /*******************************************************************************
.................... /* usb_get_packet(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer and saved to ptr.
.................... /*
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS!
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()!
.................... /*
.................... /* Summary: Gets a packet of data from the USB endpoint buffer.
.................... /*          Until this is called, if there is data in the receive buffer the
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be
.................... /*          allowed to send a new packet.  Only receives one packet, if you need 
.................... /*          to receive multiple packets or handle 0-length terminator packets,
.................... /*          then use usb_gets().
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /********************************************************************************/
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max);
.................... 
.................... /****************************************************************************
.................... /* usb_kbhit(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check (0..15)
.................... /*
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not.
.................... /*
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers.
.................... /*          See API section of USB.H for more information.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_kbhit(unsigned int8 en);
.................... 
.................... /******************************************************************************
.................... /* usb_tbe(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last
.................... /*         transmit or if this endpoint is invalid.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_tbe(unsigned int8 en);
.................... 
.................... //////////////// END USER LEVEL FUNCTIONS /////////////////////////////////////
.................... 
.................... 
.................... ///
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by
.................... ///            the USB stack, and are not meant to be called by the 
.................... ///            user/application.
.................... ///
.................... 
.................... /*****************************************************************************
.................... /* usb_stall_ep()
.................... /*
.................... /* Input: endpoint - endpoint to stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will
.................... /*          send STALL packet if the host tries to access this endpoint's 
.................... /*          buffer.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_stall_ep(unsigned int8 endpoint);
.................... 
.................... 
.................... /*****************************************************************************
.................... /* usb_unstall_ep(endpoint, direction)
.................... /*
.................... /* Input: endpoint - endpoint to un-stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Un-stalls endpoint.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_unstall_ep(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_endpoint_stalled()
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not.
.................... /*
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to
.................... /*          see if endpoint has been issued a STALL, just whether or not it is
.................... /*          configured to STALL on the next packet.  See Set_Feature and 
.................... /*          Clear_Feature Chapter 9 requests.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_set_address(address)
.................... /*
.................... /* Input: address - address the host specified that we use
.................... /*
.................... /* Summary: Configures the USB Peripheral for the specified device address.  
.................... /*          The host will now talk to use with the following address.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_address(unsigned int8 address);
.................... 
.................... /******************************************************************************
.................... /* usb_set_configured()
.................... /*
.................... /* Input: config - Configuration to use.  0 to uncofigure device.
.................... /*
.................... /* Summary: Configures or unconfigures device.  If configuring device it will
.................... /*          enable all the endpoints the user specified for this configuration.
.................... /*          If un-configuring device it will disable all endpoints.
.................... /*
.................... /*          NOTE: CCS only provides code to handle 1 configuration.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_configured(unsigned int8 config);
.................... 
.................... /******************************************************************************
.................... /* usb_disable_endpoints()
.................... /*
.................... /* Summary: Disables endpoints (all endpoints but 0)
.................... /*
.................... /*****************************************************************************/
.................... void usb_disable_endpoints(void);
.................... 
.................... 
.................... /*******************************************************************************
.................... /* usb_disable_endpoint()
.................... /*
.................... /* Input: Endpoint to disable (0..15)
.................... /*
.................... /* Summary: Disables specified endpoint
.................... /*
.................... /********************************************************************************/
.................... void usb_disable_endpoint(unsigned int8 en);
.................... 
.................... /**************************************************************
.................... /* usb_request_send_response(len)
.................... /* usb_request_get_data()
.................... /* usb_request_stall()
.................... /*
.................... /* Input: len - size of packet to send
.................... /*
.................... /* Summary: One of these 3 functions will be called by the USB stack after
.................... /*          handling a SETUP packet.
.................... /*          
.................... /*          After we process a SETUP request, we have 1 of three responses:
.................... /*            1.) send a response IN packet
.................... /*            2.) wait for followup OUT packet(s) with data
.................... /*            3.) stall because we don't support that SETUP request
.................... /*
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold
.................... /*          the response and the USB Request handler code will call
.................... /*          usb_request_send_response() to let us know how big the packet is.
.................... /*
.................... /*          If we are waiting for more data, usb_request_get_data() will
.................... /*          be called by the USB request handler code to configure the EP0 OUT
.................... /*          endpoint to be ready for more data
.................... /*
.................... /*          If we don't support a request, usb_request_stall() will be called
.................... /*          by the USB request handler code to stall the endpoint 0.
.................... /*
.................... /*          The operation of these functions depends on how SETUP packets
.................... /*          are handled in the hardware layer.
.................... /*
.................... /***************************************************************/
.................... void usb_request_send_response(unsigned int8 len);
.................... void usb_request_get_data(void);
.................... void usb_request_stall(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... //////////////////////// EXTRA USER FUNCTIONS /////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_flush_in()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for transfer
.................... /*        len - length of data that is being tramsferred
.................... /*        tgl - Data toggle synchronization for this packet
.................... /*
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint)
.................... /*
.................... /* Summary: Marks the endpoint ready for transmission.  You must
.................... /*          have already loaded the endpoint buffer with data.
.................... /*          (IN is PIC -> PC).
.................... /*          This routine is useful if you want to setup an endpoint by
.................... /*          writing to the buffer directly.
.................... /*          This routine is not necessary if you use usb_put_packet().
.................... /***************************************************************/
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_flush_out()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for release
.................... /*        tgl - Data toggle synchronization to expect in the next packet
.................... /*
.................... /* Output: NONE
.................... /*
.................... /* Summary: Clears the previously received packet, and then marks this
.................... /*          endpoint's receive buffer as ready for more data.
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not
.................... /*          want to use usb_get_packet(), instead you want to handle with
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size().
.................... /*          This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_rx_packet_size()
.................... /*
.................... /* Input: endpoint - which endpoint to mark to check
.................... /*
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer.
.................... /*
.................... /* Summary: Read the number of data stored in the receive buffer.  When you
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint.
.................... /*    This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... int16 usb_rx_packet_size(int8 endpoint);
.................... 
.................... #ENDIF
.................... 
....................    #else
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
....................    #endif
.................... #else
....................    #include <usbn960x.h>
.................... #endif
.................... #ifndef __USB_DESCRIPTORS__
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_desc_cdc.h                            ////
.................... ////                                                                   ////
.................... //// An example set of device / configuration descriptors for use with ////
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// Oct 27th, 2011:                                                   ////
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     ////
.................... ////     send SERIAL_STATE messages in one packet.                     ////
.................... ////                                                                   ////
.................... //// April 7th, 2009:                                                  ////
.................... ////   Vista 'code 10' issues resolved.                                ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// 10/28/05:                                                         ////
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        ////
.................... ////    packets.                                                       ////
.................... ////    Changed device to USB 1.10                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
.................... #DEFINE __USB_DESCRIPTORS__
.................... 
.................... ///////// config options, although it's best to leave alone for this demo /////
.................... #ifndef  USB_CONFIG_PID
....................    #define  USB_CONFIG_PID       0x000b
.................... #endif
.................... #ifndef  USB_CONFIG_VID
....................    #define  USB_CONFIG_VID       0x2405
.................... #endif
.................... #ifndef  USB_CONFIG_BUS_POWER
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500)
.................... #endif
.................... #ifndef  USB_CONFIG_VERSION
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99
.................... #endif
.................... //////// end config ///////////////////////////////////////////////////////////
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #DEFINE USB_HID_DEVICE  false
.................... #DEFINE USB_CDC_DEVICE  true
.................... 
.................... #define USB_CDC_COMM_IN_ENDPOINT       1
.................... #ifndef USB_CDC_COMM_IN_SIZE
.................... #define USB_CDC_COMM_IN_SIZE           11
.................... #endif
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE
.................... 
.................... //pic to pc endpoint config
.................... #define USB_CDC_DATA_IN_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_IN_SIZE
.................... #define USB_CDC_DATA_IN_SIZE           64
.................... #endif
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE
.................... 
.................... //pc to pic endpoint config
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_OUT_SIZE
.................... #define USB_CDC_DATA_OUT_SIZE           64
.................... #endif
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start config descriptor
.................... ///   right now we only support one configuration descriptor.
.................... ///   the config, interface, class, and endpoint goes into this array.
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints)
.................... 
....................    const char USB_CONFIG_DESC[] = {
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE:
....................       //    config(s)
....................       //    interface(s)
....................       //    class(es)
....................       //    endpoint(s)
.................... 
....................    //config_descriptor for config index 1
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3
....................          2, //number of interfaces this device supports       ==4
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5
....................          0x00, //index of string descriptor for this configuration      ==6
....................         #if USB_CONFIG_BUS_POWER
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #else
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #endif
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8
.................... 
.................... 
....................    //interface descriptor 0 (comm class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11
....................          0x00, //alternate setting     ==12
....................          1, //number of endpoints   ==13
....................          0x02, //class code, 02 = Comm Interface Class     ==14
....................          0x02, //subclass code, 2 = Abstract     ==15
....................          0x01, //protocol code, 1 = v.25ter      ==16
....................          0x00, //index of string descriptor for interface      ==17
.................... 
....................    //class descriptor [functional header]
....................          5, //length of descriptor    ==18
....................          0x24, //dscriptor type (0x24 == )      ==19
....................          0, //sub type (0=functional header) ==20
....................          0x10,0x01, //      ==21,22 //cdc version
.................... 
....................    //class descriptor [acm header]
....................          4, //length of descriptor    ==23
....................          0x24, //dscriptor type (0x24 == )      ==24
....................          2, //sub type (2=ACM)   ==25
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State.
.................... 
....................    //class descriptor [union header]
....................          5, //length of descriptor    ==27
....................          0x24, //dscriptor type (0x24 == )      ==28
....................          6, //sub type (6=union)    ==29
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union.
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. *
.................... 
....................    //class descriptor [call mgmt header]
....................          5, //length of descriptor    ==32
....................          0x24, //dscriptor type (0x24 == )      ==33
....................          1, //sub type (1=call mgmt)   ==34
....................          0, //capabilities          ==35  //device does not handle call management itself
....................          1, //data interface        ==36  //interface number of data class interface
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43
.................... 
....................    //interface descriptor 1 (data class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46
....................          0x00, //alternate setting     ==47
....................          2, //number of endpoints   ==48
....................          0x0A, //class code, 0A = Data Interface Class     ==49
....................          0x00, //subclass code      ==50
....................          0x00, //protocol code      ==51
....................          0x00, //index of string descriptor for interface      ==52
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55
....................          0x02, //transfer type supported (0x02 is bulk)         ==56
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58
....................          1,  //polling interval, in ms.   ==59
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62
....................          0x02, //transfer type supported (0x02 is bulk)         ==63
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67
....................          1  //polling interval, in ms.   ==68
....................    };
.................... 
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ********
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find
....................    //  a specific descriptor in the above table.
.................... 
....................    //the maximum number of interfaces seen on any config
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2
....................    #define USB_MAX_NUM_INTERFACES   2
.................... 
....................    //define how many interfaces there are per config.  [0] is the first config, etc.
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2};
.................... 
....................    //define where to find class descriptors
....................    //first dimension is the config number
....................    //second dimension specifies which interface
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface
....................    //if a class descriptor is not valid, set the value to 0xFFFF
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]=
....................    {
....................    //config 1
....................       //interface 0
....................          //class 1-4
....................          18,23,27,32,
....................       //interface 1
....................          //no classes for this interface
....................          0xFF,0xFF,0xFF,0xFF
....................    };
.................... 
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN)
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly
....................    #endif
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start device descriptors
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={
....................       //starts of with device configuration. only one possible
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1
....................          0x10,0x01, //usb version in bcd  ==2,3
....................          0x02, //class code. 0x02=Communication Device Class ==4
....................          0x00, //subclass code ==5
....................          0x00, //protocol code ==6
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14
....................          0x02, //index of string descriptor of the product  ==15
....................          0x00, //index of string descriptor of serial number  ==16
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17
....................    };
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start string descriptors
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone.
.................... ///
.................... ///   You must define the length else get_next_string_character() will not see the string
.................... ///   Current code only supports 10 strings (0 thru 9)
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
.................... #if !defined(USB_STRINGS_OVERWRITTEN)
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored.
.................... // Strings are saved as unicode.
.................... // These strings are mostly only displayed during the add hardware wizard.
.................... // Once the operating system drivers have been installed it will usually display
.................... // the name from the drivers .INF.
.................... char const USB_STRING_DESC[]={
....................    //string 0
....................          4, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          0x09,0x04,   //Microsoft Defined for US-English
....................    //string 1  - manufacturer
....................          8, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................    //string 2 - product
....................          32, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................          ' ',0,
....................          'U',0,
....................          'S',0,
....................          'B',0,
....................          ' ',0,
....................          't',0,
....................          'o',0,
....................          ' ',0,
....................          'U',0,
....................          'A',0,
....................          'R',0,
....................          'T',0
.................... };
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN)
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... struct {
....................    int1 got;
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100
....................    unsigned int16 len;
....................    unsigned int16 index;
....................   #else
....................    unsigned int8 len;
....................    unsigned int8 index;
....................   #endif
.................... } usb_cdc_get_buffer_status;
.................... 
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             usb.c                                 ////
.................... ////                                                                   ////
.................... //// Standard USB request and token handler code.                      ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... //// The majority of this code is called and used by the interrupt     ////
.................... //// generated by the hardware level, and therefore it is not meant    ////
.................... //// to be called by the user.  The functions that are meant to be     ////
.................... //// called by the user (init, put packet, get packet, etc) are        ////
.................... //// documented in USB.H.                                              ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////    This code will not create a multiple configuration device.     ////
.................... ////    If you wish to create a multiple configuration device then you ////
.................... ////    will have to modify these drivers.                             ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    ////
.................... ////   requests.  These requests are optional.  If you want to support ////
.................... ////   these requests you must provide the code yourself.  See         ////
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      ////
.................... ////   support.                                                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// If you wish to provide your own USB peripheral hardware layer, it ////
.................... //// must must provide the API as described in usb_hw_layer.h.         ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 20, 2015                                                    ////
.................... ////     USB_STRING_DESC_OFFSET no longer used.                        ////
.................... ////                                                                   ////
.................... //// Feb 6th, 2015                                                     ////
.................... ////     Fixed 'len' not being intiailized in usb_gets()               ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// June 8th, 2011:                                                   ////
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  ////
.................... ////     (for no timeout) resolved.                                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// November 13th, 2009:                                              ////
.................... ////  usb_endpoint_is_valid() has an extra check.                      ////
.................... ////                                                                   ////
.................... //// June 9th, 2009:                                                   ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// Dec 14, 2007:                                                     ////
.................... ////  usb_kbhit() moved to device driver.                              ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    ////
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release.                                         ////
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     ////
.................... ////    layer.                                                         ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////  TODO: alot of indexing and length handling for descriptors is    ////
.................... ////   only 8bit, so make sure all descriptor tables are less than     ////
.................... ////   256 bytes long.                                                 ////
.................... ////                                                                   ////
.................... //// Apr 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     ////
.................... ////   usb_ep_tx_size[] defined in usb.h                               ////
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             ////
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  ////
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     ////
.................... ////   the endpoint buffer until you usb_get_packet(), which will      ////
.................... ////   then free the endpoint buffer for more data.  This affects      ////
.................... ////   routines such as usb_gets() and usb_kbhit().                    ////
.................... ////  usb_gets() no longer reads buffered data (see above note),       ////
.................... ////   now it reads multiple packets in the same way usb_puts()        ////
.................... ////   writes multiple packets                                         ////
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  ////
.................... ////   layer.                                                          ////
.................... ////                                                                   ////
.................... //// Nov 11th, 2004:                                                   ////
.................... ////  No longer includes wrong descriptor header.                      ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   ////
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    ////
.................... ////                     although it didn't cause any serious problems ////
.................... ////                                                                   ////
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  ////
.................... ////                     problems with multiple packet messages        ////
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   ////
.................... ////                     descriptors that require a 0 len packet to    ////
.................... ////                     end message.                                  ////
.................... ////                                                                   ////
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DRIVER__
.................... #DEFINE __USB_DRIVER__
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #else
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) 
....................    {
....................       while(len--)
....................       {
....................          debug_usb_packet(debug_putc, "%02X", *ptr++);
....................       }
....................    }
.................... #endif
.................... 
.................... // legacy
.................... #ifndef debug_usb
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l)
.................... #endif
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if defined(__PIC16F_USB_H__)
....................  #include <pic16f_usb.c>
.................... #endif
.................... 
.................... #if defined(__PIC18_USB_H__)
....................  #include <pic18_usb.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.c                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     ////
.................... //// documentation about the PIC18 hardware layer.                   ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Dec 12, 2016:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Mar 20, 2015:                                                   ////
.................... ////  When TXing a packet, set UOWN bit as a different instruction   ////
.................... ////     as the rest of the BDSTAT flags.  Doing it this way         ////
.................... ////     prevents PIC18F45K50 family USB from locking up.            ////
.................... ////                                                                 ////
.................... //// Mar 1, 2015:                                                    ////
.................... ////  Added __STALL_ON_UEP_ERRATA__ and __UIDLE_JAM_ERRATA__ from    ////
.................... ////     PIC24 USB library, in case those erratas found              ////
.................... ////     their way on the PIC18 USB parts.                           ////
.................... ////                                                                 ////
.................... //// Dec 17, 2013:                                                   ////
.................... ////  Added 18FxxJ9x family support.                                 ////
.................... ////                                                                 ////
.................... //// Dec 11, 2013:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// July 9th, 2012:                                                 ////
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     ////
.................... ////     for non-setup packets on endpoint 0 or all other            ////
.................... ////     endpoints.  This really only affects people using           ////
.................... ////     usb_put_packet() or usb_get_packet() inside of other        ////
.................... ////     interrupts.                                                 ////
.................... ////                                                                 ////
.................... //// Sep 22, 2011:                                                   ////
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   ////
.................... ////     primarily developed for users developing code where         ////
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Added initial 18F47J53 family support.                         ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work.                          ////
.................... ////                                                                 ////
.................... //// Nov 13th, 2009:                                                 ////
.................... ////  usb_disable_endpoint() won't touch BD status registers for     ////
.................... ////     endpoints that aren't allocated.                            ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_C__
.................... #DEFINE __PIC18_USB_C__
.................... 
.................... // i got these from PIC24 library, but maybe these bugs made their way
.................... // into PIC18 usb peripherals.
.................... // __STALL_ON_UEP_ERRATA__ looked wrong on the PIC24 library.
.................... #define __STALL_ON_UEP_ERRATA__
.................... #define __UIDLE_JAM_ERRATA__
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #endif
.................... 
.................... #bit USBIE=getenv("BIT:USBIE")
.................... 
.................... //if you are worried that the PIC is not receiving packets because a bug in the
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on
.................... //receiving.
.................... #ifndef USB_IGNORE_RX_DTS
....................  #define USB_IGNORE_RX_DTS false
.................... #endif
.................... 
.................... #ifndef USB_IGNORE_TX_DTS
....................  #define USB_IGNORE_TX_DTS false
.................... #endif
.................... 
.................... // if only USB_BDT_START is defined, then BDT has a fixed location in RAM
.................... //    but endpoint memory can be anywhere on the PIC.
.................... // if only USB_RAM_START is defined, then both BDT and endpoint have a fixed
.................... //    location in RAM (BDT first, endpoint second).
.................... // if USB_BDT_START and USB_RAM_START are both defined, then BDT has a fixed
.................... //    location in RAM and the endpoint buffers have a different location
.................... //    in RAM.
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50"))
....................  #define __USB_87J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \
....................        (getenv("DEVICE")=="PIC18F24K50") || \
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF24K50"))
....................  #define __USB_45K50__
....................  #define USB_TOTAL_RAM_SPACE  1024
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50"))
....................  #define __USB_46J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || \
....................        (getenv("DEVICE")=="PIC18LF2450") || (getenv("DEVICE")=="PIC18LF4450"))
....................  #define __USB_4450__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................  #define __USB_K50__ //backwards compatability
....................  #define __USB_14K50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x200
....................  #define USB_NUM_UEP 8
....................  //technically this device supports 8 endpoints, but for RAM reasons you should
....................  //attempt to only use the first 3 endpoints.
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") || \
....................        (getenv("DEVICE")=="PIC18LF2455") || (getenv("DEVICE")=="PIC18LF2550") || \
....................        (getenv("DEVICE")=="PIC18LF4455") || (getenv("DEVICE")=="PIC18LF4550") || \
....................        (getenv("DEVICE")=="PIC18LF2458") || (getenv("DEVICE")=="PIC18LF2553") || \
....................        (getenv("DEVICE")=="PIC18LF4458") || (getenv("DEVICE")=="PIC18LF4553") \
....................        )
....................  #define __USB_4550__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") || \
....................        (getenv("DEVICE")=="PIC18LF26J53") || (getenv("DEVICE")=="PIC18LF27J53") || \ 
....................        (getenv("DEVICE")=="PIC18LF46J53") || (getenv("DEVICE")=="PIC18LF47J53") \       
....................        )
....................  #define __USB_18FJ53__
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use
....................  #define USB_BDT_START  0xD00
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F97J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F87J94") ||  \
....................        (getenv("DEVICE")=="PIC18F67J94") ||  \
....................        (getenv("DEVICE")=="PIC18F96J99") ||  \
....................        (getenv("DEVICE")=="PIC18F86J99") ||  \
....................        (getenv("DEVICE")=="PIC18F66J99") ||  \
....................        (getenv("DEVICE")=="PIC18F96J94") ||  \
....................        (getenv("DEVICE")=="PIC18F86J94") ||  \
....................        (getenv("DEVICE")=="PIC18F66J94") ||  \
....................        (getenv("DEVICE")=="PIC18F95J94") ||  \
....................        (getenv("DEVICE")=="PIC18F85J94") ||  \
....................        (getenv("DEVICE")=="PIC18F65J94"))
....................  #define __USB_18FJ94__
....................  #define USB_BDT_START  0x100
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library.
.................... #endif
.................... 
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  15
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  14
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  13
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  12
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  11
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  10
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  9
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  8
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  7
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  6
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  5
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  4
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  3
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  2
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  1
.................... #else
....................  #define USB_LAST_DEFINED_ENDPOINT  0
.................... #endif
.................... 
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8)
.................... 
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)
.................... 
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT)
....................  #error You are trying to use an invalid endpoint for this hardware!
.................... #endif
.................... 
.................... typedef struct
.................... {
....................    unsigned int8 stat;
....................    unsigned int8 cnt;
....................    unsigned int16 addr;
.................... } STRUCT_BD;
.................... 
.................... #if defined(USB_RAM_START) && !defined(USB_BDT_START)
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       struct
....................       {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................       } bd[USB_LAST_DEFINED_ENDPOINT+1];
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM.buffer)
....................    
....................    #locate g_USBRAM=USB_RAM_START
....................    
....................    #define g_USBBDT g_USBRAM.bd
.................... #else
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #if defined(USB_RAM_START)
....................       #locate g_USBRAM=USB_RAM_START
....................    #endif
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM)
....................    
....................    struct
....................    {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................    } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1];
....................    
....................    #locate g_USBBDT=USB_BDT_START
.................... #endif
.................... 
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer
.................... 
.................... //these buffer definitions needed for CDC library
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer
.................... 
.................... //if you enable this it will keep a counter of the 6 possible errors the
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time.
.................... #if !defined(USB_USE_ERROR_COUNTER)
....................    #define USB_USE_ERROR_COUNTER false
.................... #endif
.................... 
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints
.................... 
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS!
.................... #if !defined(USB_PING_PONG_MODE)
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF
.................... #endif
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................    unsigned int ERROR_COUNTER[6];
.................... #endif
.................... 
.................... //---pic18fxx5x memory locations
.................... #if defined(__USB_4550__) || defined(__USB_4450__)
....................    #byte UFRML   =  0xF66
....................    #byte UFRMH   =  0xF67
....................    #byte UIR     =  0xF68
....................    #byte UIE     =  0xF69
....................    #byte UEIR    =  0xF6A
....................    #byte UEIE    =  0xF6B
....................    #byte U1STAT   =  0xF6C
....................    #byte UCON    =  0xF6D
....................    #byte UADDR   =  0xF6E
....................    #byte UCFG    =  0xF6F
....................    #define  UEP0_LOC 0xF70
.................... #elif defined(__USB_46J50__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #elif defined(__USB_14K50__)
....................    #byte UFRML   =  0xF5D
....................    #byte UFRMH   =  0xF5E
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF60
....................    #byte UEIR    =  0xF5F
....................    #byte UEIE    =  0xF5B
....................    #byte U1STAT   =  0xF63
....................    #byte UCON    =  0xF64
....................    #byte UADDR   =  0xF5C
....................    #byte UCFG    =  0xF61
....................    #define  UEP0_LOC 0xF53
.................... #elif defined(__USB_18FJ53__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #else
....................    #byte UFRML = getenv("SFR:UFRML")
....................    #byte UFRMH = getenv("SFR:UFRMH")
....................    #byte UIR = getenv("SFR:UIR")
....................    #byte UIE = getenv("SFR:UIE")
....................    #byte UEIR = getenv("SFR:UEIR")
....................    #byte UEIE = getenv("SFR:UEIE")
....................    #byte U1STAT = getenv("SFR:USTAT")
....................    #byte UCON = getenv("SFR:UCON")
....................    #byte UADDR = getenv("SFR:UADDR")
....................    #byte UCFG = getenv("SFR:UCFG")
.................... #endif
.................... 
.................... unsigned int8 USTATCopy;
.................... 
.................... unsigned int8 g_UEP[USB_NUM_UEP];
.................... #if defined(UEP0_LOC)
.................... #locate g_UEP=UEP0_LOC
.................... #else
.................... #locate g_UEP=getenv("SFR:UEP0")
.................... #endif
.................... #define UEP(x) g_UEP[x]
.................... 
.................... #define BIT_SOF   6
.................... #define BIT_STALL 5
.................... #define BIT_IDLE  4
.................... #define BIT_TRN   3
.................... #define BIT_ACTV  2
.................... #define BIT_UERR  1
.................... #define BIT_URST  0
.................... 
.................... #BIT UIR_SOF = UIR.BIT_SOF
.................... #BIT UIR_STALL = UIR.BIT_STALL
.................... #BIT UIR_IDLE = UIR.BIT_IDLE
.................... #BIT UIR_TRN = UIR.BIT_TRN
.................... #BIT UIR_ACTV = UIR.BIT_ACTV
.................... #BIT UIR_UERR = UIR.BIT_UERR
.................... #BIT UIR_URST = UIR.BIT_URST
.................... 
.................... #BIT UIE_SOF = UIE.BIT_SOF
.................... #BIT UIE_STALL = UIE.BIT_STALL
.................... #BIT UIE_IDLE = UIE.BIT_IDLE
.................... #BIT UIE_TRN = UIE.BIT_TRN
.................... #BIT UIE_ACTV = UIE.BIT_ACTV
.................... #BIT UIE_UERR = UIE.BIT_UERR
.................... #BIT UIE_URST = UIE.BIT_URST
.................... 
.................... #if getenv("BIT_VALID:PPBRST")
....................    #bit UCON_PPBRST = getenv("BIT:PPBRST")
.................... #endif
.................... #bit UCON_SE0=UCON.5
.................... #bit UCON_PKTDIS=UCON.4
.................... #bit UCON_USBEN=UCON.3
.................... #bit UCON_RESUME=UCON.2
.................... #bit UCON_SUSPND=UCON.1
.................... 
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF)
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr
.................... #else
.................... #error Right now this driver only supports no ping pong
.................... #endif
.................... 
.................... //See UEPn (0xF70-0xF7F)
.................... #define ENDPT_DISABLED   0x00   //endpoint not used
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions
.................... 
.................... //Define the states that the USB interface can be in
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3,
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state;
.................... 
.................... //--BDendST has their PIDs upshifed 2
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction
.................... 
.................... #define USTAT_IN_E0        4
.................... #define USTAT_OUT_SETUP_E0 0
.................... 
.................... #define __USB_UIF_RESET    0x01
.................... #define __USB_UIF_ERROR    0x02
.................... #define __USB_UIF_ACTIVE   0x04
.................... #define __USB_UIF_TOKEN    0x08
.................... #define __USB_UIF_IDLE     0x10
.................... #define __USB_UIF_STALL    0x20
.................... #define __USB_UIF_SOF      0x40
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET
.................... #else
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET
.................... #endif
.................... 
.................... #define __USB_UCFG_UTEYE   0x80
.................... #if defined(__USB_4550__)
....................  #define __USB_UCFG_UOEMON  0x40
.................... #endif
.................... #define __USB_UCFG_UPUEN   0x10
.................... #if !defined(__USB_14K50__)
....................  #define __USB_UCFG_UTRDIS  0x08
.................... #endif
.................... #define __USB_UCFG_FSEN    0x04
.................... 
.................... #if defined(USB_EXTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  0
.................... #endif
.................... 
.................... #if defined(USB_INTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if !defined(__USB_UCFG_MY_UPUEN)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if USB_USE_FULL_SPEED
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE)
.................... #else
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE);
.................... #endif
.................... 
.................... #if defined(__USB_UCFG_UTRDIS)
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS
.................... #else
....................  #define __UCFG_VAL_DISABLED__   0
.................... #endif
.................... 
.................... 
.................... unsigned int8 __setup_0_tx_size;
.................... 
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only
.................... void usb_handle_interrupt();
.................... void usb_isr_rst();
.................... void usb_isr_uerr();
.................... void usb_isr_sof(void);
.................... void usb_isr_activity();
.................... void usb_isr_uidle();
.................... void usb_isr_tok_dne();
.................... void usb_isr_stall(void);
.................... void usb_init_ep0_setup(void);
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... void usb_isr(void);
.................... #endif
.................... 
.................... //// BEGIN User Functions:
.................... 
.................... // see usb_hw_layer.h for more documentation
.................... int1 usb_kbhit(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7)));
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_tbe(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7)));
*
0C78:  CLRF   03
0C7A:  MOVLB  1
0C7C:  MOVF   xC7,W
0C7E:  ADDLW  70
0C80:  MOVWF  FE9
0C82:  MOVLW  0F
0C84:  ADDWFC 03,W
0C86:  MOVWF  FEA
0C88:  MOVF   FEF,F
0C8A:  BZ    0CC2
0C8C:  CLRF   xC9
0C8E:  MOVFF  1C7,1C8
0C92:  CLRF   xCB
0C94:  MOVLW  08
0C96:  MOVWF  xCA
0C98:  MOVLB  0
0C9A:  CALL   02EE
0C9E:  MOVFF  02,1C9
0CA2:  MOVFF  01,1C8
0CA6:  MOVLW  04
0CA8:  MOVLB  1
0CAA:  ADDWF  xC8,F
0CAC:  MOVLW  00
0CAE:  ADDWFC xC9,F
0CB0:  MOVFF  1C8,FE9
0CB4:  MOVLW  04
0CB6:  ADDWF  xC9,W
0CB8:  MOVWF  FEA
0CBA:  MOVFF  FEF,1CA
0CBE:  BTFSS  xCA.7
0CC0:  BRA    0CC6
0CC2:  MOVLW  00
0CC4:  BRA    0CC8
0CC6:  MOVLW  01
0CC8:  MOVWF  01
0CCA:  MOVLB  0
0CCC:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_detach(void)
.................... {
....................    UCON_SUSPND = 0;
*
12FC:  BCF    F6D.1
....................    UCON = 0;  //disable USB hardware
12FE:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts
1300:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__;
1302:  MOVLW  08
1304:  MOVWF  F6F
.................... 
....................    // set D+/D- to inputs
....................   #if defined(__USB_87J50__)
....................    set_tris_f(get_tris_f() | 0x18);
....................   #elif defined(__USB_14K50__)
....................    set_tris_a(get_tris_a() | 0x3);
....................   #elif defined(__USB_18FJ94__)
....................    output_float(PIN_F4);
....................    output_float(PIN_F3);
....................   #elif !defined(USB_PIC_NO_USB_GPIO)
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5
1306:  MOVF   F94,W
1308:  IORLW  30
130A:  MOVLB  1
130C:  MOVWF  F94
....................   #endif
....................   
....................    usb_state = USB_STATE_DETACHED;
130E:  CLRF   22
1310:  CLRF   19
1312:  BTFSC  FF2.7
1314:  BSF    19.7
1316:  BCF    FF2.7
....................    
....................    usb_token_reset();              //clear the chapter9 stack
1318:  MOVLB  0
131A:  CALL   03DE
131E:  BTFSC  19.7
1320:  BSF    FF2.7
1322:  RETURN 0
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_attach(void) 
*
1330:  CLRF   19
1332:  BTFSC  FF2.7
1334:  BSF    19.7
1336:  BCF    FF2.7
.................... {
....................    usb_token_reset();
1338:  CALL   03DE
133C:  BTFSC  19.7
133E:  BSF    FF2.7
....................    UCON_SUSPND = 0;
1340:  BCF    F6D.1
....................    UCON = 0;
1342:  CLRF   F6D
....................   #if getenv("BIT_VALID:PPBRST")
....................    UCON_PPBRST = 1;
1344:  BSF    F6D.6
....................    delay_cycles(5);
1346:  BRA    1348
1348:  BRA    134A
134A:  NOP   
....................    UCON_PPBRST = 0;
134C:  BCF    F6D.6
....................   #endif
....................    UCFG = __UCFG_VAL_ENABLED__;
134E:  MOVLW  14
1350:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts
1352:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus
1354:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h
1356:  MOVLW  01
1358:  MOVWF  22
135A:  GOTO   137E (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init_cs(void)
.................... {
....................    usb_detach();
*
1324:  RCALL  12FC
1326:  GOTO   13A4 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_task(void) 
.................... {
....................   #if defined(USB_ISR_POLLING)
....................    if (interrupt_active(INT_USB))
....................    {
....................       usb_isr();
....................    }
....................   #endif
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_enumerated())
*
135E:  RCALL  132A
1360:  MOVF   01,F
1362:  BZ    1372
1364:  CLRF   19
1366:  BTFSC  FF2.7
1368:  BSF    19.7
136A:  BCF    FF2.7
....................    {
....................       usb_cdc_flush_tx_buffer();
136C:  RCALL  1090
136E:  BTFSC  19.7
1370:  BSF    FF2.7
....................    }
....................   #endif
.................... 
....................    if (usb_attached()) 
1372:  BSF    F93.2
1374:  BTFSS  F81.2
1376:  BRA    1380
....................    {
....................       if (UCON_USBEN==0) 
1378:  BTFSC  F6D.3
137A:  BRA    137E
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: ATTACH");
....................          usb_attach();
137C:  BRA    1330
....................       }
....................    }
137E:  BRA    1386
....................    else 
....................    {
....................       if (UCON_USBEN==1)  
1380:  BTFSS  F6D.3
1382:  BRA    1386
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: DE-ATTACH");
....................          usb_detach();
1384:  RCALL  12FC
....................       }
....................    }
.................... 
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) 
1386:  DECFSZ 22,W
1388:  BRA    13A0
138A:  BTFSC  F6D.5
138C:  BRA    13A0
....................    {
....................       UIR = 0;
138E:  CLRF   F68
....................       UIE = 0;
1390:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING)
....................       enable_interrupts(INT_USB);
1392:  BSF    FA0.5
....................       enable_interrupts(GLOBAL);
1394:  MOVLW  C0
1396:  IORWF  FF2,F
....................      #endif
....................       UIE = __USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR
1398:  MOVLW  11
139A:  MOVWF  F69
....................      #if USB_USE_ERROR_COUNTER
....................       UIE |= __USB_UIF_ERROR;
....................      #endif
....................       usb_state=USB_STATE_POWERED;
139C:  MOVLW  02
139E:  MOVWF  22
....................       debug_usb_control(debug_putc, "\r\n\nUSB TASK: POWERED");
....................    }
13A0:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init(void) 
.................... {
....................    usb_init_cs();
13A2:  BRA    1324
.................... 
....................    do 
....................    {
....................       usb_task();
13A4:  RCALL  135E
....................    } while (usb_state != USB_STATE_POWERED);
13A6:  MOVF   22,W
13A8:  SUBLW  02
13AA:  BNZ   13A4
13AC:  GOTO   1C0C (RETURN)
.................... }
.................... 
.................... 
.................... // see pic18_usb.h for documentation
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
.................... 
....................    debug_usb_packet(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len);
.................... 
....................    if (usb_tbe(endpoint)) 
*
0CCE:  MOVFF  1C2,1C7
0CD2:  RCALL  0C78
0CD4:  MOVF   01,F
0CD6:  BTFSC  FD8.2
0CD8:  BRA    0E10
....................    {
....................       EP_BDxCNT_I(endpoint)=len;
0CDA:  MOVLB  1
0CDC:  CLRF   xC9
0CDE:  MOVFF  1C2,1C8
0CE2:  CLRF   xCB
0CE4:  MOVLW  08
0CE6:  MOVWF  xCA
0CE8:  MOVLB  0
0CEA:  CALL   02EE
0CEE:  MOVFF  02,1C8
0CF2:  MOVFF  01,1C7
0CF6:  MOVLW  04
0CF8:  MOVLB  1
0CFA:  ADDWF  xC7,F
0CFC:  MOVLW  00
0CFE:  ADDWFC xC8,F
0D00:  MOVLW  01
0D02:  ADDWF  xC7,W
0D04:  MOVWF  01
0D06:  MOVLW  00
0D08:  ADDWFC xC8,W
0D0A:  MOVWF  03
0D0C:  MOVFF  01,FE9
0D10:  MOVLW  04
0D12:  ADDWF  03,W
0D14:  MOVWF  FEA
0D16:  MOVFF  1C3,FEF
.................... 
....................       debug_display_ram(len, EP_BDxADR_I(endpoint));
.................... 
....................      #if USB_IGNORE_TX_DTS
....................       i=0x80;
....................      #else
....................       if (tgl == USB_DTS_TOGGLE) 
0D1A:  MOVF   xC5,W
0D1C:  SUBLW  02
0D1E:  BNZ   0D60
....................       {
....................          i = EP_BDxST_I(endpoint);
0D20:  CLRF   xC9
0D22:  MOVFF  1C2,1C8
0D26:  CLRF   xCB
0D28:  MOVLW  08
0D2A:  MOVWF  xCA
0D2C:  MOVLB  0
0D2E:  CALL   02EE
0D32:  MOVFF  02,1C8
0D36:  MOVFF  01,1C7
0D3A:  MOVLW  04
0D3C:  MOVLB  1
0D3E:  ADDWF  xC7,F
0D40:  MOVLW  00
0D42:  ADDWFC xC8,F
0D44:  MOVFF  1C7,FE9
0D48:  MOVLW  04
0D4A:  ADDWF  xC8,W
0D4C:  MOVWF  FEA
0D4E:  MOVFF  FEF,1C6
....................          if (bit_test(i,6))
0D52:  BTFSS  xC6.6
0D54:  BRA    0D5A
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0D56:  CLRF   xC5
0D58:  BRA    0D5E
....................          else
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0D5A:  MOVLW  01
0D5C:  MOVWF  xC5
....................       }
0D5E:  BRA    0D94
....................       else if (tgl == USB_DTS_USERX) 
0D60:  MOVF   xC5,W
0D62:  SUBLW  04
0D64:  BNZ   0D94
....................       {
....................          i = EP_BDxST_O(endpoint);
0D66:  CLRF   xC9
0D68:  MOVFF  1C2,1C8
0D6C:  CLRF   xCB
0D6E:  MOVLW  08
0D70:  MOVWF  xCA
0D72:  MOVLB  0
0D74:  CALL   02EE
0D78:  MOVLB  1
0D7A:  MOVFF  01,FE9
0D7E:  MOVLW  04
0D80:  ADDWF  02,W
0D82:  MOVWF  FEA
0D84:  MOVFF  FEF,1C6
....................          if (bit_test(i,6))
0D88:  BTFSS  xC6.6
0D8A:  BRA    0D92
....................             tgl = USB_DTS_DATA1;
0D8C:  MOVLW  01
0D8E:  MOVWF  xC5
0D90:  BRA    0D94
....................          else
....................             tgl = USB_DTS_DATA0;
0D92:  CLRF   xC5
....................       }
....................       if (tgl == USB_DTS_DATA1) 
0D94:  DECFSZ xC5,W
0D96:  BRA    0D9E
....................          i=0x48;  //DATA1, UOWN  //change mar2015
0D98:  MOVLW  48
0D9A:  MOVWF  xC6
0D9C:  BRA    0DA2
....................       else //if (tgl == USB_DTS_DATA0) 
....................          i=0x08; //DATA0, UOWN   //change mar2015
0D9E:  MOVLW  08
0DA0:  MOVWF  xC6
....................      #endif
.................... 
....................       //set BC8 and BC9
....................       //if (bit_test(len,8)) {bit_set(i,0);}
....................       //if (bit_test(len,9)) {bit_set(i,1);}
.................... 
....................       debug_usb_packet(debug_putc, " %X", i);
.................... 
....................       EP_BDxST_I(endpoint) = i;  //save changes
0DA2:  CLRF   xC9
0DA4:  MOVFF  1C2,1C8
0DA8:  CLRF   xCB
0DAA:  MOVLW  08
0DAC:  MOVWF  xCA
0DAE:  MOVLB  0
0DB0:  CALL   02EE
0DB4:  MOVFF  02,1C8
0DB8:  MOVFF  01,1C7
0DBC:  MOVLW  04
0DBE:  MOVLB  1
0DC0:  ADDWF  xC7,F
0DC2:  MOVLW  00
0DC4:  ADDWFC xC8,F
0DC6:  MOVFF  1C7,FE9
0DCA:  MOVLW  04
0DCC:  ADDWF  xC8,W
0DCE:  MOVWF  FEA
0DD0:  MOVFF  1C6,FEF
....................       
....................       EP_BDxST_I(endpoint) |= 0x80; //change mar2015
0DD4:  CLRF   xC9
0DD6:  MOVFF  1C2,1C8
0DDA:  CLRF   xCB
0DDC:  MOVLW  08
0DDE:  MOVWF  xCA
0DE0:  MOVLB  0
0DE2:  CALL   02EE
0DE6:  MOVFF  02,1C8
0DEA:  MOVFF  01,1C7
0DEE:  MOVLW  04
0DF0:  MOVLB  1
0DF2:  ADDWF  xC7,F
0DF4:  MOVLW  00
0DF6:  ADDWFC xC8,F
0DF8:  MOVFF  1C7,FE9
0DFC:  MOVLW  04
0DFE:  ADDWF  xC8,W
0E00:  MOVWF  FEA
0E02:  MOVF   FEF,W
0E04:  IORLW  80
0E06:  MOVWF  FEF
....................       
....................       //putc('!');
....................       
....................       return(1);
0E08:  MOVLW  01
0E0A:  MOVWF  01
0E0C:  BRA    0E16
....................    }
0E0E:  MOVLB  0
....................    else 
....................    {
....................       //putc('_');
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
....................    return(0);
0E10:  MOVLW  00
0E12:  MOVWF  01
0E14:  MOVLB  1
0E16:  MOVLB  0
0E18:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 * buff_add;    
.................... 
....................    if (usb_tbe(endpoint)) 
*
0F16:  MOVFF  1BA,1C7
0F1A:  RCALL  0C78
0F1C:  MOVF   01,F
0F1E:  BZ    0FAE
....................    {
....................       buff_add = EP_BDxADR_I(endpoint);
0F20:  MOVLB  1
0F22:  CLRF   xC9
0F24:  MOVFF  1BA,1C8
0F28:  CLRF   xCB
0F2A:  MOVLW  08
0F2C:  MOVWF  xCA
0F2E:  MOVLB  0
0F30:  CALL   02EE
0F34:  MOVFF  02,1C3
0F38:  MOVFF  01,1C2
0F3C:  MOVLW  04
0F3E:  MOVLB  1
0F40:  ADDWF  xC2,F
0F42:  MOVLW  00
0F44:  ADDWFC xC3,F
0F46:  MOVLW  02
0F48:  ADDWF  xC2,W
0F4A:  MOVWF  01
0F4C:  MOVLW  00
0F4E:  ADDWFC xC3,W
0F50:  MOVWF  03
0F52:  MOVFF  01,FE9
0F56:  MOVLW  04
0F58:  ADDWF  03,W
0F5A:  MOVWF  FEA
0F5C:  MOVFF  FEC,1C1
0F60:  MOVF   FED,F
0F62:  MOVFF  FEF,1C0
....................       memcpy(buff_add, ptr, len);     
0F66:  MOVFF  1C1,FEA
0F6A:  MOVFF  1C0,FE9
0F6E:  MOVFF  1BC,FE2
0F72:  MOVFF  1BB,FE1
0F76:  MOVFF  1BE,02
0F7A:  MOVFF  1BD,01
0F7E:  MOVF   01,F
0F80:  BZ    0F86
0F82:  INCF   02,F
0F84:  BRA    0F8A
0F86:  MOVF   02,F
0F88:  BZ    0F96
0F8A:  MOVFF  FE6,FEE
0F8E:  DECFSZ 01,F
0F90:  BRA    0F8A
0F92:  DECFSZ 02,F
0F94:  BRA    0F8A
....................       
....................       return(usb_flush_in(endpoint, len, tgl));
0F96:  MOVFF  1BA,1C2
0F9A:  MOVFF  1BE,1C4
0F9E:  MOVFF  1BD,1C3
0FA2:  MOVFF  1BF,1C5
0FA6:  MOVLB  0
0FA8:  RCALL  0CCE
0FAA:  MOVF   01,W
0FAC:  BRA    0FB2
....................    }
....................    else 
....................    {
....................       //putc('-');
....................       //printf("%X", EP_BDxST_I(endpoint));
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
.................... 
....................    return(0);
0FAE:  MOVLW  00
0FB0:  MOVWF  01
0FB2:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
....................    unsigned int16 len;
.................... 
....................   #if USB_IGNORE_RX_DTS
....................    if (tgl == USB_DTS_STALL) 
....................    {
....................       debug_usb_token(debug_putc, '*');
....................       EP_BDxCNT_O(endpoint) = 0x84;
....................       EP_BDxST_I(endpoint) = 0x84;
....................       return;
....................    }
....................    else
....................       i=0x80;
....................   #else
....................    i = EP_BDxST_O(endpoint);
*
0B78:  MOVLB  1
0B7A:  CLRF   xC9
0B7C:  MOVFF  1B9,1C8
0B80:  CLRF   xCB
0B82:  MOVLW  08
0B84:  MOVWF  xCA
0B86:  MOVLB  0
0B88:  CALL   02EE
0B8C:  MOVLB  1
0B8E:  MOVFF  01,FE9
0B92:  MOVLW  04
0B94:  ADDWF  02,W
0B96:  MOVWF  FEA
0B98:  MOVFF  FEF,1BB
....................    if (tgl == USB_DTS_TOGGLE) 
0B9C:  MOVF   xBA,W
0B9E:  SUBLW  02
0BA0:  BNZ   0BAE
....................    {
....................       if (bit_test(i,6))
0BA2:  BTFSS  xBB.6
0BA4:  BRA    0BAA
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0BA6:  CLRF   xBA
0BA8:  BRA    0BAE
....................       else
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0BAA:  MOVLW  01
0BAC:  MOVWF  xBA
....................    }
....................    if (tgl == USB_DTS_STALL) 
0BAE:  MOVF   xBA,W
0BB0:  SUBLW  03
0BB2:  BNZ   0BEC
....................    {
....................       i = 0x84;
0BB4:  MOVLW  84
0BB6:  MOVWF  xBB
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints
0BB8:  CLRF   xC9
0BBA:  MOVFF  1B9,1C8
0BBE:  CLRF   xCB
0BC0:  MOVLW  08
0BC2:  MOVWF  xCA
0BC4:  MOVLB  0
0BC6:  CALL   02EE
0BCA:  MOVFF  02,1BF
0BCE:  MOVFF  01,1BE
0BD2:  MOVLW  04
0BD4:  MOVLB  1
0BD6:  ADDWF  xBE,F
0BD8:  MOVLW  00
0BDA:  ADDWFC xBF,F
0BDC:  MOVFF  1BE,FE9
0BE0:  MOVLW  04
0BE2:  ADDWF  xBF,W
0BE4:  MOVWF  FEA
0BE6:  MOVLW  84
0BE8:  MOVWF  FEF
....................    }
0BEA:  BRA    0BFA
....................    else if (tgl == USB_DTS_DATA1)
0BEC:  DECFSZ xBA,W
0BEE:  BRA    0BF6
....................       i = 0xC8;  //DATA1, UOWN
0BF0:  MOVLW  C8
0BF2:  MOVWF  xBB
0BF4:  BRA    0BFA
....................    else //if (tgl == USB_DTS_DATA0) 
....................       i = 0x88; //DATA0, UOWN
0BF6:  MOVLW  88
0BF8:  MOVWF  xBB
....................   #endif
.................... 
....................    //bit_clear(__usb_kbhit_status,endpoint);
.................... 
....................    len = usb_ep_rx_size[endpoint];
0BFA:  BCF    FD8.0
0BFC:  RLCF   xB9,W
0BFE:  CLRF   03
0C00:  MOVLB  0
0C02:  CALL   011E
0C06:  TBLRD*+
0C08:  MOVFF  FF5,03
0C0C:  MOVLB  1
0C0E:  MOVWF  xBC
0C10:  MOVFF  03,1BD
....................    EP_BDxCNT_O(endpoint) = len;
0C14:  CLRF   xC9
0C16:  MOVFF  1B9,1C8
0C1A:  CLRF   xCB
0C1C:  MOVLW  08
0C1E:  MOVWF  xCA
0C20:  MOVLB  0
0C22:  CALL   02EE
0C26:  MOVFF  01,1BE
0C2A:  MOVLW  01
0C2C:  MOVLB  1
0C2E:  ADDWF  01,W
0C30:  MOVWF  01
0C32:  MOVLW  00
0C34:  ADDWFC 02,W
0C36:  MOVWF  03
0C38:  MOVFF  01,FE9
0C3C:  MOVLW  04
0C3E:  ADDWF  03,W
0C40:  MOVWF  FEA
0C42:  MOVFF  1BC,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);}
0C46:  BTFSS  xBD.0
0C48:  BRA    0C4C
0C4A:  BSF    xBB.0
....................    if (bit_test(len,9)) {bit_set(i,1);}
0C4C:  BTFSS  xBD.1
0C4E:  BRA    0C52
0C50:  BSF    xBB.1
.................... 
....................    EP_BDxST_O(endpoint) = i;
0C52:  CLRF   xC9
0C54:  MOVFF  1B9,1C8
0C58:  CLRF   xCB
0C5A:  MOVLW  08
0C5C:  MOVWF  xCA
0C5E:  MOVLB  0
0C60:  CALL   02EE
0C64:  MOVLB  1
0C66:  MOVFF  01,FE9
0C6A:  MOVLW  04
0C6C:  ADDWF  02,W
0C6E:  MOVWF  FEA
0C70:  MOVFF  1BB,FEF
0C74:  MOVLB  0
0C76:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint) 
.................... {
....................    return(EP_BDxCNT_O(endpoint));
*
0E62:  MOVLB  1
0E64:  CLRF   xC9
0E66:  MOVFF  1B9,1C8
0E6A:  CLRF   xCB
0E6C:  MOVLW  08
0E6E:  MOVWF  xCA
0E70:  MOVLB  0
0E72:  CALL   02EE
0E76:  MOVFF  02,1BB
0E7A:  MOVFF  01,1BA
0E7E:  MOVLW  01
0E80:  MOVLB  1
0E82:  ADDWF  01,W
0E84:  MOVWF  01
0E86:  MOVLW  00
0E88:  ADDWFC 02,W
0E8A:  MOVWF  03
0E8C:  MOVFF  01,FE9
0E90:  MOVLW  04
0E92:  ADDWF  03,W
0E94:  MOVWF  FEA
0E96:  MOVFF  FEF,01
0E9A:  CLRF   02
0E9C:  MOVLB  0
0E9E:  GOTO   0EC2 (RETURN)
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN Hardware layer functions required by USB.
.................... 
.................... /*****************************************************************************
.................... /* usb_get_packet_buffer(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer.
.................... /*
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC 
.................... /*          RAM.
.................... /*          Does not mark the endpoint as ready for more data.  Once you are
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready
.................... /*          to receive more data.
.................... /*
.................... /*****************************************************************************/
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) 
.................... {
....................    unsigned int8 * al;
....................    unsigned int8 st;
....................    unsigned int16 i;
.................... 
....................    al = EP_BDxADR_O(endpoint);
....................    i = EP_BDxCNT_O(endpoint);
....................    st = EP_BDxST_O(endpoint);
.................... 
....................    //read BC8 and BC9
....................    if (bit_test(st,0)) {bit_set(i,8);}
....................    if (bit_test(st,1)) {bit_set(i,9);}
.................... 
....................    if (i < max) {max = i;}
....................    
....................    memcpy(ptr, al ,max);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max)
.................... {
....................    max = usb_get_packet_buffer(endpoint, ptr, max);
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_stall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=s%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
095E:  MOVLB  1
0960:  BCF    xB9.0
0962:  BTFSC  xB8.7
0964:  BSF    xB9.0
....................    endpoint &= 0x7F;
0966:  BCF    xB8.7
....................    
....................    if (direction) 
0968:  BTFSS  xB9.0
096A:  BRA    099E
....................    {
....................       EP_BDxST_I(endpoint) = 0x84;
096C:  CLRF   xC9
096E:  MOVFF  1B8,1C8
0972:  CLRF   xCB
0974:  MOVLW  08
0976:  MOVWF  xCA
0978:  MOVLB  0
097A:  RCALL  02EE
097C:  MOVFF  02,1BB
0980:  MOVFF  01,1BA
0984:  MOVLW  04
0986:  MOVLB  1
0988:  ADDWF  xBA,F
098A:  MOVLW  00
098C:  ADDWFC xBB,F
098E:  MOVFF  1BA,FE9
0992:  MOVLW  04
0994:  ADDWF  xBB,W
0996:  MOVWF  FEA
0998:  MOVLW  84
099A:  MOVWF  FEF
....................    }
099C:  BRA    09BE
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x84;
099E:  CLRF   xC9
09A0:  MOVFF  1B8,1C8
09A4:  CLRF   xCB
09A6:  MOVLW  08
09A8:  MOVWF  xCA
09AA:  MOVLB  0
09AC:  RCALL  02EE
09AE:  MOVLB  1
09B0:  MOVFF  01,FE9
09B4:  MOVLW  04
09B6:  ADDWF  02,W
09B8:  MOVWF  FEA
09BA:  MOVLW  84
09BC:  MOVWF  FEF
....................    }
09BE:  MOVLB  0
09C0:  GOTO   0A6E (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_unstall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=u%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
08E4:  MOVLB  1
08E6:  BCF    xB9.0
08E8:  BTFSC  xB8.7
08EA:  BSF    xB9.0
....................    endpoint &= 0x7F;
08EC:  BCF    xB8.7
....................    
....................    if (direction) 
08EE:  BTFSS  xB9.0
08F0:  BRA    0924
....................    {
....................      #if USB_IGNORE_RX_DTS
....................       EP_BDxST_I(endpoint) = 0x80;
....................      #else
....................       EP_BDxST_I(endpoint) = 0x88;
08F2:  CLRF   xC9
08F4:  MOVFF  1B8,1C8
08F8:  CLRF   xCB
08FA:  MOVLW  08
08FC:  MOVWF  xCA
08FE:  MOVLB  0
0900:  RCALL  02EE
0902:  MOVFF  02,1BB
0906:  MOVFF  01,1BA
090A:  MOVLW  04
090C:  MOVLB  1
090E:  ADDWF  xBA,F
0910:  MOVLW  00
0912:  ADDWFC xBB,F
0914:  MOVFF  1BA,FE9
0918:  MOVLW  04
091A:  ADDWF  xBB,W
091C:  MOVWF  FEA
091E:  MOVLW  88
0920:  MOVWF  FEF
....................      #endif
....................    }
0922:  BRA    0942
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x00;
0924:  CLRF   xC9
0926:  MOVFF  1B8,1C8
092A:  CLRF   xCB
092C:  MOVLW  08
092E:  MOVWF  xCA
0930:  MOVLB  0
0932:  RCALL  02EE
0934:  MOVLB  1
0936:  MOVFF  01,FE9
093A:  MOVLW  04
093C:  ADDWF  02,W
093E:  MOVWF  FEA
0940:  CLRF   FEF
....................    }
....................    
....................   #if defined(__STALL_ON_UEP_ERRATA__)
....................    bit_clear(UEP(endpoint), 0);
0942:  CLRF   03
0944:  MOVF   xB8,W
0946:  ADDLW  70
0948:  MOVWF  01
094A:  MOVLW  0F
094C:  ADDWFC 03,F
094E:  MOVFF  01,FE9
0952:  MOVFF  03,FEA
0956:  BCF    FEF.0
....................   #endif
0958:  MOVLB  0
095A:  GOTO   0A5E (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    unsigned int8 st;
....................    
....................    direction = bit_test(endpoint,7);
*
09C4:  MOVLB  1
09C6:  BCF    xB9.0
09C8:  BTFSC  xB8.7
09CA:  BSF    xB9.0
....................    endpoint &= 0x7F;
09CC:  BCF    xB8.7
....................    
....................    if (direction) 
09CE:  BTFSS  xB9.0
09D0:  BRA    0A04
....................    {
....................       st=EP_BDxST_I(endpoint);
09D2:  CLRF   xC9
09D4:  MOVFF  1B8,1C8
09D8:  CLRF   xCB
09DA:  MOVLW  08
09DC:  MOVWF  xCA
09DE:  MOVLB  0
09E0:  RCALL  02EE
09E2:  MOVFF  02,1BC
09E6:  MOVFF  01,1BB
09EA:  MOVLW  04
09EC:  MOVLB  1
09EE:  ADDWF  xBB,F
09F0:  MOVLW  00
09F2:  ADDWFC xBC,F
09F4:  MOVFF  1BB,FE9
09F8:  MOVLW  04
09FA:  ADDWF  xBC,W
09FC:  MOVWF  FEA
09FE:  MOVFF  FEF,1BA
....................    }
0A02:  BRA    0A24
....................    else 
....................    {
....................       st=EP_BDxST_O(endpoint);
0A04:  CLRF   xC9
0A06:  MOVFF  1B8,1C8
0A0A:  CLRF   xCB
0A0C:  MOVLW  08
0A0E:  MOVWF  xCA
0A10:  MOVLB  0
0A12:  RCALL  02EE
0A14:  MOVLB  1
0A16:  MOVFF  01,FE9
0A1A:  MOVLW  04
0A1C:  ADDWF  02,W
0A1E:  MOVWF  FEA
0A20:  MOVFF  FEF,1BA
....................    }
....................    
....................    return(bit_test(st,7) && bit_test(st,2));
0A24:  BTFSS  xBA.7
0A26:  BRA    0A2C
0A28:  BTFSC  xBA.2
0A2A:  BRA    0A30
0A2C:  MOVLW  00
0A2E:  BRA    0A32
0A30:  MOVLW  01
0A32:  MOVWF  01
0A34:  MOVLB  0
0A36:  GOTO   0A86 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_address(unsigned int8 address) 
.................... {
....................    UADDR = address;
*
0EEE:  MOVFF  1B9,F6E
....................    
....................    if (address) 
0EF2:  MOVLB  1
0EF4:  MOVF   xB9,F
0EF6:  BZ    0EFE
....................    {
....................       usb_state = USB_STATE_ADDRESS;
0EF8:  MOVLW  04
0EFA:  MOVWF  22
....................    }
0EFC:  BRA    0F02
....................    else 
....................    {
....................       usb_state = USB_STATE_POWERED;
0EFE:  MOVLW  02
0F00:  MOVWF  22
....................    }
0F02:  MOVLB  0
0F04:  GOTO   0F12 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_configured(unsigned int8 config) 
.................... {
....................    unsigned int8 en;
....................    unsigned int16 addy;
....................    unsigned int8 new_uep;
....................    unsigned int16 len;
....................    unsigned int8 i;
....................    
....................    if (config == 0)
*
059E:  MOVLB  1
05A0:  MOVF   xB8,F
05A2:  BNZ   05B0
....................    {
....................       // if config=0 then set addressed state
....................       usb_state = USB_STATE_ADDRESS;
05A4:  MOVLW  04
05A6:  MOVWF  22
....................       usb_disable_endpoints();
05A8:  MOVLB  0
05AA:  RCALL  0380
....................    }
05AC:  BRA    0782
05AE:  MOVLB  1
....................    else 
....................    {
....................       // else set configed state
....................       usb_state = USB_STATE_CONFIGURED; 
05B0:  MOVLW  05
05B2:  MOVWF  22
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH);
05B4:  MOVLW  04
05B6:  MOVWF  xBB
05B8:  MOVLW  98
05BA:  MOVWF  xBA
....................       for (en=1; en<USB_NUM_UEP; en++) 
05BC:  MOVLW  01
05BE:  MOVWF  xB9
05C0:  MOVF   xB9,W
05C2:  SUBLW  0F
05C4:  BTFSS  FD8.0
05C6:  BRA    0782
....................       {
....................          // enable and config endpoints based upon user configuration
....................          usb_disable_endpoint(en);
05C8:  MOVFF  1B9,1C1
05CC:  MOVLB  0
05CE:  RCALL  0310
....................          new_uep = 0;
05D0:  MOVLB  1
05D2:  CLRF   xBC
....................          if (usb_ep_rx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
05D4:  CLRF   03
05D6:  MOVF   xB9,W
05D8:  MOVLB  0
05DA:  RCALL  00CE
05DC:  SUBLW  FF
05DE:  BZ    06AE
....................          {
....................             new_uep = 0x04;
05E0:  MOVLW  04
05E2:  MOVLB  1
05E4:  MOVWF  xBC
....................             len = usb_ep_rx_size[en];
05E6:  BCF    FD8.0
05E8:  RLCF   xB9,W
05EA:  CLRF   03
05EC:  MOVLB  0
05EE:  RCALL  011E
05F0:  TBLRD*+
05F2:  MOVFF  FF5,03
05F6:  MOVLB  1
05F8:  MOVWF  xBD
05FA:  MOVFF  03,1BE
....................             EP_BDxCNT_O(en) = len;
05FE:  CLRF   xC9
0600:  MOVFF  1B9,1C8
0604:  CLRF   xCB
0606:  MOVLW  08
0608:  MOVWF  xCA
060A:  MOVLB  0
060C:  RCALL  02EE
060E:  MOVFF  01,1C0
0612:  MOVLW  01
0614:  MOVLB  1
0616:  ADDWF  01,W
0618:  MOVWF  01
061A:  MOVLW  00
061C:  ADDWFC 02,W
061E:  MOVWF  03
0620:  MOVFF  01,FE9
0624:  MOVLW  04
0626:  ADDWF  03,W
0628:  MOVWF  FEA
062A:  MOVFF  1BD,FEF
....................             EP_BDxADR_O(en) = addy;
062E:  CLRF   xC9
0630:  MOVFF  1B9,1C8
0634:  CLRF   xCB
0636:  MOVLW  08
0638:  MOVWF  xCA
063A:  MOVLB  0
063C:  RCALL  02EE
063E:  MOVFF  01,1C0
0642:  MOVLW  02
0644:  MOVLB  1
0646:  ADDWF  01,W
0648:  MOVWF  01
064A:  MOVLW  00
064C:  ADDWFC 02,W
064E:  MOVWF  03
0650:  MOVFF  01,FE9
0654:  MOVLW  04
0656:  ADDWF  03,W
0658:  MOVWF  FEA
065A:  MOVFF  1BB,FEC
065E:  MOVF   FED,F
0660:  MOVFF  1BA,FEF
....................             addy += usb_ep_rx_size[en];
0664:  BCF    FD8.0
0666:  RLCF   xB9,W
0668:  CLRF   03
066A:  MOVLB  0
066C:  RCALL  011E
066E:  TBLRD*+
0670:  MOVFF  FF5,03
0674:  MOVLB  1
0676:  ADDWF  xBA,F
0678:  MOVF   03,W
067A:  ADDWFC xBB,F
....................            #if USB_IGNORE_RX_DTS
....................             i = 0x80;
....................            #else
....................             i = 0x88;
067C:  MOVLW  88
067E:  MOVWF  xBF
....................            #endif
....................             if (bit_test(len,8)) {bit_set(i,0);}
0680:  BTFSS  xBE.0
0682:  BRA    0686
0684:  BSF    xBF.0
....................             if (bit_test(len,9)) {bit_set(i,1);}
0686:  BTFSS  xBE.1
0688:  BRA    068C
068A:  BSF    xBF.1
....................             EP_BDxST_O(en) = i;
068C:  CLRF   xC9
068E:  MOVFF  1B9,1C8
0692:  CLRF   xCB
0694:  MOVLW  08
0696:  MOVWF  xCA
0698:  MOVLB  0
069A:  RCALL  02EE
069C:  MOVLB  1
069E:  MOVFF  01,FE9
06A2:  MOVLW  04
06A4:  ADDWF  02,W
06A6:  MOVWF  FEA
06A8:  MOVFF  1BF,FEF
06AC:  MOVLB  0
....................          }
....................          if (usb_ep_tx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
06AE:  CLRF   03
06B0:  MOVLB  1
06B2:  MOVF   xB9,W
06B4:  MOVLB  0
06B6:  RCALL  00AE
06B8:  SUBLW  FF
06BA:  BZ    074C
....................          {
....................             new_uep |= 0x02;
06BC:  MOVLB  1
06BE:  BSF    xBC.1
....................             EP_BDxADR_I(en) = addy;
06C0:  CLRF   xC9
06C2:  MOVFF  1B9,1C8
06C6:  CLRF   xCB
06C8:  MOVLW  08
06CA:  MOVWF  xCA
06CC:  MOVLB  0
06CE:  RCALL  02EE
06D0:  MOVFF  02,1C1
06D4:  MOVFF  01,1C0
06D8:  MOVLW  04
06DA:  MOVLB  1
06DC:  ADDWF  xC0,F
06DE:  MOVLW  00
06E0:  ADDWFC xC1,F
06E2:  MOVLW  02
06E4:  ADDWF  xC0,W
06E6:  MOVWF  01
06E8:  MOVLW  00
06EA:  ADDWFC xC1,W
06EC:  MOVWF  03
06EE:  MOVFF  01,FE9
06F2:  MOVLW  04
06F4:  ADDWF  03,W
06F6:  MOVWF  FEA
06F8:  MOVFF  1BB,FEC
06FC:  MOVF   FED,F
06FE:  MOVFF  1BA,FEF
....................             addy += usb_ep_tx_size[en];
0702:  BCF    FD8.0
0704:  RLCF   xB9,W
0706:  CLRF   03
0708:  MOVLB  0
070A:  RCALL  00EE
070C:  TBLRD*+
070E:  MOVFF  FF5,03
0712:  MOVLB  1
0714:  ADDWF  xBA,F
0716:  MOVF   03,W
0718:  ADDWFC xBB,F
....................             EP_BDxST_I(en) = 0x40;
071A:  CLRF   xC9
071C:  MOVFF  1B9,1C8
0720:  CLRF   xCB
0722:  MOVLW  08
0724:  MOVWF  xCA
0726:  MOVLB  0
0728:  RCALL  02EE
072A:  MOVFF  02,1C1
072E:  MOVFF  01,1C0
0732:  MOVLW  04
0734:  MOVLB  1
0736:  ADDWF  xC0,F
0738:  MOVLW  00
073A:  ADDWFC xC1,F
073C:  MOVFF  1C0,FE9
0740:  MOVLW  04
0742:  ADDWF  xC1,W
0744:  MOVWF  FEA
0746:  MOVLW  40
0748:  MOVWF  FEF
074A:  MOVLB  0
....................          }
....................          if (new_uep == 0x06) {new_uep = 0x0E;}
074C:  MOVLB  1
074E:  MOVF   xBC,W
0750:  SUBLW  06
0752:  BNZ   0758
0754:  MOVLW  0E
0756:  MOVWF  xBC
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;}
0758:  CLRF   03
075A:  MOVF   xB9,W
075C:  MOVLB  0
075E:  RCALL  00AE
0760:  SUBLW  01
0762:  BZ    076A
0764:  MOVLB  1
0766:  BSF    xBC.4
0768:  MOVLB  0
....................          
....................          UEP(en) = new_uep;
076A:  CLRF   03
076C:  MOVLB  1
076E:  MOVF   xB9,W
0770:  ADDLW  70
0772:  MOVWF  FE9
0774:  MOVLW  0F
0776:  ADDWFC 03,W
0778:  MOVWF  FEA
077A:  MOVFF  1BC,FEF
077E:  INCF   xB9,F
0780:  BRA    05C0
0782:  MOVLB  0
....................       }
....................    }
0784:  GOTO   0830 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoint(unsigned int8 en) 
.................... {
....................    UEP(en) = ENDPT_DISABLED;
*
0310:  CLRF   03
0312:  MOVLB  1
0314:  MOVF   xC1,W
0316:  ADDLW  70
0318:  MOVWF  FE9
031A:  MOVLW  0F
031C:  ADDWFC 03,W
031E:  MOVWF  FEA
0320:  CLRF   FEF
....................    
....................    if (usb_endpoint_is_valid(en))
0322:  MOVFF  1C1,1C2
0326:  MOVLB  0
0328:  RCALL  02A0
032A:  MOVF   01,F
032C:  BZ    037E
....................    {
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary      
032E:  MOVLB  1
0330:  CLRF   xC9
0332:  MOVFF  1C1,1C8
0336:  CLRF   xCB
0338:  MOVLW  08
033A:  MOVWF  xCA
033C:  MOVLB  0
033E:  RCALL  02EE
0340:  MOVLB  1
0342:  MOVFF  01,FE9
0346:  MOVLW  04
0348:  ADDWF  02,W
034A:  MOVWF  FEA
034C:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary
034E:  CLRF   xC9
0350:  MOVFF  1C1,1C8
0354:  CLRF   xCB
0356:  MOVLW  08
0358:  MOVWF  xCA
035A:  MOVLB  0
035C:  RCALL  02EE
035E:  MOVFF  02,1C3
0362:  MOVFF  01,1C2
0366:  MOVLW  04
0368:  MOVLB  1
036A:  ADDWF  xC2,F
036C:  MOVLW  00
036E:  ADDWFC xC3,F
0370:  MOVFF  1C2,FE9
0374:  MOVLW  04
0376:  ADDWF  xC3,W
0378:  MOVWF  FEA
037A:  CLRF   FEF
037C:  MOVLB  0
....................    }
037E:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoints(void) 
.................... {
....................    unsigned int8 i;
....................    
....................    for (i=1; i<USB_NUM_UEP; i++)
0380:  MOVLW  01
0382:  MOVLB  1
0384:  MOVWF  xC0
0386:  MOVF   xC0,W
0388:  SUBLW  0F
038A:  BNC   039A
....................       usb_disable_endpoint(i);
038C:  MOVFF  1C0,1C1
0390:  MOVLB  0
0392:  RCALL  0310
0394:  MOVLB  1
0396:  INCF   xC0,F
0398:  BRA    0386
039A:  MOVLB  0
039C:  RETURN 0
....................       
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... /// END Hardware layer functions required by USB.C
.................... 
.................... 
.................... /// BEGIN USB Interrupt Service Routine
.................... 
.................... static void usb_clear_trn(void)
.................... {
....................    //UIR_TRN = 0;
....................    //delay_cycles(6);
....................    UIR &= ~(1 << BIT_TRN);
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_handle_interrupt()
.................... /*
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished
.................... /*          tokens is the majority of this code, and is handled by usb.c
.................... /*
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt 
.................... /*       method), then you must call this function rapidly.  If there is more 
.................... /*       than 10ms latency the PC may think the USB device is stalled and
.................... /*       disable it.
.................... /*       To switch to a polling method, remove the #int_usb line above this 
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the 
.................... /*       USB interrupt.
.................... /******************************************************************************/
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR)
.................... #int_usb NOCLEAR
.................... #endif
.................... void usb_isr(void)
.................... {
....................    unsigned int8 TRNAttempts;
....................    
....................    clear_interrupt(INT_USB);
*
1236:  BCF    FA1.5
....................    
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though
1238:  MOVF   22,F
123A:  BTFSC  FD8.2
123C:  BRA    12B6
....................    if (UIR) 
123E:  MOVF   F68,F
1240:  BTFSC  FD8.2
1242:  BRA    12B6
....................    {
....................       //debug_usb(debug_putc,"\r\n\n[%X] ",UIR);
.................... 
....................       //activity detected.  (only enable after sleep)
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}
1244:  BTFSS  F68.2
1246:  BRA    124E
1248:  BTFSC  F69.2
124A:  GOTO   024E
.................... 
....................       if (UCON_SUSPND) return;
124E:  BTFSC  F6D.1
1250:  BRA    12B6
.................... 
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent
1252:  BTFSS  F68.5
1254:  BRA    125C
1256:  BTFSC  F69.5
1258:  GOTO   028A
.................... 
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected
125C:  BTFSS  F68.1
125E:  BRA    1266
1260:  BTFSC  F69.1
1262:  GOTO   0298
.................... 
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected
1266:  BTFSS  F68.0
1268:  BRA    1270
126A:  BTFSC  F69.0
126C:  GOTO   040E
.................... 
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep
1270:  BTFSS  F68.4
1272:  BRA    127A
1274:  BTFSC  F69.4
1276:  GOTO   043E
....................       
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();}
127A:  BTFSS  F68.6
127C:  BRA    1284
127E:  BTFSC  F69.6
1280:  GOTO   0448
.................... 
....................       TRNAttempts = 0;
1284:  MOVLB  1
1286:  CLRF   xB5
....................       do
....................       {
....................          if (UIR_TRN && UIE_TRN) 
1288:  BTFSS  F68.3
128A:  BRA    12A0
128C:  BTFSS  F69.3
128E:  BRA    12A0
....................          {
....................             USTATCopy = U1STAT;
1290:  MOVFF  F6C,21
....................             usb_clear_trn();
1294:  MOVLB  0
1296:  CALL   0004
....................             usb_isr_tok_dne();
129A:  BRA    113A
....................          }
129C:  BRA    12A4
129E:  MOVLB  1
....................          else
....................             break;
12A0:  BRA    12AE
12A2:  MOVLB  0
....................       } while (TRNAttempts++ < 4);
12A4:  MOVLB  1
12A6:  MOVF   xB5,W
12A8:  INCF   xB5,F
12AA:  SUBLW  03
12AC:  BC    1288
.................... 
....................      #if defined(USB_CDC_ISR)
....................       //has to be done here, can't be done until TRN is empty.
....................       if (usb_cdc_kbhit())
12AE:  BTFSS  1E.0
12B0:  BRA    12B8
....................       {
....................          USB_CDC_ISR();
12B2:  MOVLB  0
12B4:  BRA    1232
12B6:  MOVLB  1
....................       }
....................      #endif
....................    }
12B8:  MOVLB  0
12BA:  GOTO   0060
.................... }
.................... 
.................... // SOF interrupt not handled.  user must add this depending on application
.................... void usb_isr_sof(void) 
.................... {
....................    //debug_usb(debug_putc, "\r\nSOF");
....................    
....................    //UIR_SOF = 0;
....................    UIR &= ~(1 << BIT_SOF);
*
0448:  BCF    F68.6
044A:  GOTO   1284 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_rst()
.................... /*
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device
.................... /*          and token handler code to initial state.
.................... /*
.................... /******************************************************************************/
.................... void usb_isr_rst(void) 
.................... {
....................    debug_usb_control(debug_putc,"-R-");
.................... 
....................    UEIE = 0;
*
040E:  CLRF   F6B
....................    UIE = 0;
0410:  CLRF   F69
....................    UEIR = 0;
0412:  CLRF   F6A
....................    UIR = 0;
0414:  CLRF   F68
.................... 
....................    UADDR = 0;
0416:  CLRF   F6E
....................    
....................    UEP(0) = ENDPT_DISABLED;
0418:  CLRF   F70
.................... 
....................    usb_disable_endpoints();
041A:  RCALL  0380
....................    
....................    usb_token_reset();
041C:  RCALL  03DE
.................... 
....................    UEP(0) = ENDPT_CONTROL | 0x10;
041E:  MOVLW  16
0420:  MOVWF  F70
.................... 
....................    while (UIR_TRN) 
0422:  BTFSS  F68.3
0424:  BRA    042A
....................    {
....................       usb_clear_trn();
0426:  RCALL  0004
0428:  BRA    0422
....................    }
.................... 
.................... 
....................    UEIE = 0x9F;
042A:  MOVLW  9F
042C:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE;
042E:  MOVLW  3D
0430:  MOVWF  F69
.................... 
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled
0432:  BCF    F6D.4
.................... 
....................    usb_init_ep0_setup();
0434:  RCALL  0260
.................... 
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state
0436:  MOVLW  03
0438:  MOVWF  22
043A:  GOTO   1270 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_init_ep0_setup()
.................... /*
.................... /* Summary: Configure EP0 to receive setup packets
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_ep0_setup(void) 
.................... {
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH;
*
0260:  MOVLW  40
0262:  MOVLB  4
0264:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION;
0266:  MOVLW  04
0268:  MOVLB  1
026A:  MOVWF  xB7
026C:  MOVLW  18
026E:  MOVFF  1B7,403
0272:  MOVFF  FE8,402
....................    #if USB_IGNORE_RX_DTS
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off
....................    #else
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on
0276:  MOVLW  88
0278:  MOVLB  4
027A:  MOVWF  x00
....................    #endif
.................... 
....................     EP_BDxST_I(0) = 0;
027C:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH;
027E:  MOVLW  04
0280:  MOVWF  x07
0282:  MOVLW  58
0284:  MOVWF  x06
0286:  MOVLB  0
0288:  RETURN 0
.................... }
.................... 
.................... /*******************************************************************************
.................... /* usb_isr_uerr()
.................... /*
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter
.................... /*          will incerement.  If having problems check the status of these 8 bytes.
.................... /*
.................... /* NOTE: This code is not enabled by default.
.................... /********************************************************************************/
.................... void usb_isr_uerr(void)
.................... {
....................   #if USB_USE_ERROR_COUNTER
....................    int ints;
....................   #endif
.................... 
....................    debug_usb_control(debug_putc,"-E%X-",UEIR);
.................... 
....................   #if USB_USE_ERROR_COUNTER
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled
.................... 
....................    if ( bit_test(ints,0) ) 
....................    { 
....................       //increment pid_error counter
....................       //debug_usb(debug_putc,"PID ");
....................       ERROR_COUNTER[0]++;
....................    }
.................... 
....................    if ( bit_test(ints,1) ) 
....................    {  
....................       //increment crc5 error counter
....................       //debug_usb(debug_putc,"CRC5 ");
....................       ERROR_COUNTER[1]++;
....................    }
.................... 
....................    if ( bit_test(ints,2) ) 
....................    {
....................       //increment crc16 error counter
....................       //debug_usb(debug_putc,"CRC16 ");
....................       ERROR_COUNTER[2]++;
....................    }
.................... 
....................    if ( bit_test(ints,3) ) 
....................    {  
....................       //increment dfn8 error counter
....................       //debug_usb(debug_putc,"DFN8 ");
....................       ERROR_COUNTER[3]++;
....................    }
.................... 
....................    if ( bit_test(ints,4) ) 
....................    {  
....................       //increment bto error counter
....................       //debug_usb(debug_putc,"BTO ");
....................       ERROR_COUNTER[4]++;
....................    }
.................... 
....................    if ( bit_test(ints,7) ) 
....................    { 
....................       //increment bts error counter
....................       //debug_usb(debug_putc,"BTS ");
....................       ERROR_COUNTER[5]++;
....................    }
....................   #endif
.................... 
....................    UEIR = 0;
*
0298:  CLRF   F6A
....................    
....................    //UIR_UERR = 0;
....................    UIR &= ~(1 << BIT_UERR);
029A:  BCF    F68.1
029C:  GOTO   1266 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_uidle()
.................... /*
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_uidle(void)
.................... {
....................    debug_usb_control(debug_putc, "-I-");
.................... 
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice)
*
043E:  BSF    F69.2
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
....................    // turn off isr instead of clearing flag
....................    UIE &= ~(unsigned int16)__USB_UIF_IDLE;
0440:  BCF    F69.4
....................   #else
....................    UIR &= ~(1 << BIT_IDLE);
....................   #endif
....................    
....................    UCON_SUSPND = 1; //set suspend. we are now suspended
0442:  BSF    F6D.1
0444:  GOTO   127A (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
.................... /* usb_isr_activity()
.................... /*
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB
.................... /*          peripheral.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_activity(void)
.................... {
....................    debug_usb_control(debug_putc, "-A-");
.................... 
....................    UCON_SUSPND = 0; //turn off low power suspending
*
024E:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling
0250:  BCF    F69.2
....................    
....................    while(UIR_ACTV)
0252:  BTFSS  F68.2
0254:  BRA    025A
....................    {
....................       //UIR_ACTV = 0;
....................       UIR &= ~(1 << BIT_ACTV);
0256:  BCF    F68.2
....................    }
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
0258:  BRA    0252
....................    // now it's safe to clear the flag
....................    UIR &= ~(1 << BIT_IDLE);
025A:  BCF    F68.4
....................   #endif   
025C:  GOTO   124E (RETURN)
.................... }
.................... 
.................... /******************************************************************************
.................... /* usb_isr_stall()
.................... /*
.................... /* Summary: Stall handshake detected.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_stall(void) 
.................... {
....................    debug_usb_control(debug_putc, "-S-");
....................    
....................    
....................    if (bit_test(UEP(0),0)) 
*
028A:  BTFSS  F70.0
028C:  BRA    0292
....................    {
....................       usb_init_ep0_setup();
028E:  RCALL  0260
....................       bit_clear(UEP(0), 0);
0290:  BCF    F70.0
....................    }
....................    
....................    //UIR_STALL = 0;
....................    UIR &= ~(1 << BIT_STALL);
0292:  BCF    F68.5
0294:  GOTO   125C (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;}
*
044E:  MOVFF  1BB,23
0452:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;}
*
0AA4:  MOVLW  FE
0AA6:  MOVWF  23
0AA8:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;}
*
0454:  SETF   23
0456:  RETURN 0
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_tok_dne()
.................... /*
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral.
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and
.................... /*          handle the request.
.................... /*          If an IN token on EP0 was received, continue transmitting any
.................... /*          unfinished requests that may take more than one packet to transmit
.................... /*          (if necessary).
.................... /*          If an OUT token on any other EP was received, mark that EP as ready
.................... /*          for a usb_get_packet().
.................... /*          Does not handle any IN or OUT tokens on EP0.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_tok_dne(void) 
.................... {
....................    unsigned int8 en;
.................... 
....................    en = USTATCopy>>3;
*
113A:  RRCF   21,W
113C:  MOVLB  1
113E:  MOVWF  xB6
1140:  RRCF   xB6,F
1142:  RRCF   xB6,F
1144:  MOVLW  1F
1146:  ANDWF  xB6,F
.................... 
....................    debug_usb_control(debug_putc, "-T%X-", USTATCopy);
.................... 
....................    if (USTATCopy == USTAT_OUT_SETUP_E0) 
1148:  MOVF   21,F
114A:  BNZ   11E8
....................    {
....................       //new out or setup token in the buffer
....................       int8 pidKey;
....................       
....................       //debug_usb(debug_putc,"%X ", EP_BDxST_O(0));
....................       
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID
114C:  MOVLB  4
114E:  MOVF   x00,W
1150:  ANDLW  3C
1152:  MOVLB  1
1154:  MOVWF  xB7
....................       
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion
1156:  MOVLW  43
1158:  MOVLB  4
115A:  ANDWF  x00,F
....................       
....................       if (pidKey == USB_PIC_PID_SETUP) 
115C:  MOVLB  1
115E:  MOVF   xB7,W
1160:  SUBLW  34
1162:  BNZ   11AE
....................       {
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00)
1164:  MOVLB  4
1166:  MOVF   x04,W
1168:  ANDLW  80
116A:  BZ    116E
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests)
116C:  CLRF   x04
.................... 
....................          //debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0));
....................          //debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer);
.................... 
....................          usb_isr_tok_setup_dne();
116E:  MOVLB  0
1170:  BRA    0B46
.................... 
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
1172:  BCF    F6D.4
.................... 
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall())
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data())
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response())
....................          if (__setup_0_tx_size == 0xFF)
1174:  INCFSZ 23,W
1176:  BRA    1186
....................             usb_flush_out(0, USB_DTS_STALL);
1178:  MOVLB  1
117A:  CLRF   xB9
117C:  MOVLW  03
117E:  MOVWF  xBA
1180:  MOVLB  0
1182:  RCALL  0B78
1184:  BRA    11AA
....................          else 
....................          {
....................             usb_flush_out(0, USB_DTS_TOGGLE);
1186:  MOVLB  1
1188:  CLRF   xB9
118A:  MOVLW  02
118C:  MOVWF  xBA
118E:  MOVLB  0
1190:  RCALL  0B78
....................             if (__setup_0_tx_size != 0xFE)
1192:  MOVF   23,W
1194:  SUBLW  FE
1196:  BZ    11AA
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX);
1198:  MOVLB  1
119A:  CLRF   xC2
119C:  CLRF   xC4
119E:  MOVFF  23,1C3
11A2:  MOVLW  04
11A4:  MOVWF  xC5
11A6:  MOVLB  0
11A8:  RCALL  0CCE
....................          }
....................          //why was this here?
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
....................       }
11AA:  BRA    11E4
11AC:  MOVLB  1
....................       else if (pidKey == USB_PIC_PID_OUT) 
11AE:  MOVF   xB7,W
11B0:  SUBLW  04
11B2:  BNZ   11E6
....................       {
....................          usb_isr_tok_out_dne(0);
11B4:  CLRF   xB8
11B6:  MOVLB  0
11B8:  RCALL  0ED0
....................          usb_flush_out(0, USB_DTS_TOGGLE);
11BA:  MOVLB  1
11BC:  CLRF   xB9
11BE:  MOVLW  02
11C0:  MOVWF  xBA
11C2:  MOVLB  0
11C4:  RCALL  0B78
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF))
11C6:  MOVF   23,W
11C8:  SUBLW  FE
11CA:  BZ    11E4
11CC:  INCFSZ 23,W
11CE:  BRA    11D2
11D0:  BRA    11E4
....................          {
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len)
11D2:  MOVLB  1
11D4:  CLRF   xC2
11D6:  CLRF   xC4
11D8:  MOVFF  23,1C3
11DC:  MOVLW  01
11DE:  MOVWF  xC5
11E0:  MOVLB  0
11E2:  RCALL  0CCE
11E4:  MOVLB  1
....................          }
....................       }
....................       //else
....................       //{
....................       //   debug_usb(debug_putc, "!!! ");
....................       //}
....................    }
11E6:  BRA    122C
....................    else if (USTATCopy == USTAT_IN_E0) 
11E8:  MOVF   21,W
11EA:  SUBLW  04
11EC:  BNZ   1212
....................    {   
....................       //pic -> host transfer completed
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion
....................       __setup_0_tx_size = 0xFF;
11EE:  SETF   23
....................       usb_isr_tok_in_dne(0);
11F0:  CLRF   xB8
11F2:  MOVLB  0
11F4:  RCALL  1108
....................       if (__setup_0_tx_size!=0xFF)
11F6:  INCFSZ 23,W
11F8:  BRA    11FC
11FA:  BRA    120E
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE);
11FC:  MOVLB  1
11FE:  CLRF   xC2
1200:  CLRF   xC4
1202:  MOVFF  23,1C3
1206:  MOVLW  02
1208:  MOVWF  xC5
120A:  MOVLB  0
120C:  RCALL  0CCE
....................       else
....................       {
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................       }  
....................    }
120E:  BRA    122A
1210:  MOVLB  1
....................    else 
....................    {
....................       if (!bit_test(USTATCopy, 2)) 
1212:  BTFSC  21.2
1214:  BRA    1222
....................       {
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_out_dne(en);
1216:  MOVFF  1B6,1B8
121A:  MOVLB  0
121C:  RCALL  0ED0
....................       }
121E:  BRA    122A
1220:  MOVLB  1
....................       else 
....................       {
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_in_dne(en);
1222:  MOVFF  1B6,1B8
1226:  MOVLB  0
1228:  RCALL  1108
122A:  MOVLB  1
....................       }
....................    }
122C:  MOVLB  0
122E:  GOTO   129C (RETURN)
.................... }
.................... 
.................... /// END USB Interrupt Service Routine
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... #if defined(__PIC24_USB_H__)
....................  #include <pic24_usb.c>
.................... #endif
.................... 
.................... #if defined(__USBN960X_H__)
....................  #include <usbn960x.c>
.................... #endif
.................... 
.................... 
.................... #IFNDEF __USB_HARDWARE__
....................    #ERROR You must include USB hardware driver.
.................... #ENDIF
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
....................    #ERROR You must include USB descriptors.
.................... #ENDIF
.................... 
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1))
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  64
.................... #else
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  8
.................... #endif
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors
.................... 
.................... #IF USB_HID_BOOT_PROTOCOL
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES];
.................... #ENDIF
.................... 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size);
.................... 
.................... void usb_isr_tkn_setup_StandardEndpoint(void);
.................... void usb_isr_tkn_setup_StandardDevice(void);
.................... void usb_isr_tkn_setup_StandardInterface(void);
.................... #IF USB_HID_DEVICE
....................    void usb_isr_tkn_setup_ClassInterface(void);
.................... #ENDIF
.................... void usb_Get_Descriptor(void);
.................... void usb_copy_desc_seg_to_ep(void);
.................... void usb_finish_set_address(void);
.................... 
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors
.................... 
.................... /// BEGIN User Functions
.................... 
.................... // see usb.h for documentation
.................... int1 usb_enumerated(void)
.................... {
....................    return(USB_stack_status.curr_config);
*
132A:  MOVF   1B,W
132C:  MOVWF  01
132E:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_wait_for_enumeration(void) 
.................... {
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();}
.................... }
.................... 
.................... // see USB.H for documentation
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) {
....................    unsigned int16 i=0;
....................    int1 res;
....................    unsigned int16 this_packet_len;
....................    unsigned int16 packet_size;
....................    unsigned int32 timeout_1us;
.................... 
....................    packet_size = usb_ep_tx_size[endpoint];
....................    
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size);
.................... 
....................    //send data packets until timeout or no more packets to send
....................    while (i < len) 
....................    {
....................       timeout_1us = (int32)timeout*1000;
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;}
....................       else {this_packet_len = len-i;}
....................       //putc('*');
....................       do 
....................       {
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets
....................          //putc('.');
....................          if (!res)
....................          {
....................             delay_us(1);
....................             //delay_ms(500);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................       i += packet_size;
....................    }
.................... 
.................... 
....................    //send 0len packet if needed
....................    if (i==len) {
....................       timeout_1us=(int32)timeout*1000;
....................       do {
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message
....................          if (!res) {
....................             delay_us(1);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................    }
.................... 
....................    return(res);
.................... }
.................... 
.................... // see usb.h for documentation
.................... unsigned int16 usb_gets(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max, unsigned int16 timeout) {
....................    unsigned int16 ret=0;
....................    unsigned int16 to;
....................    unsigned int16 len;
....................    unsigned int16 packet_size;
....................    unsigned int16 this_packet_max;
.................... 
....................    packet_size=usb_ep_rx_size[endpoint];
.................... 
....................    do {
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;}
....................       to=0;
....................       do {
....................          len = packet_size;
....................          if (usb_kbhit(endpoint)) {
....................             len=usb_get_packet(endpoint,ptr,this_packet_max);
....................             ptr+=len;
....................             max-=len;
....................             ret+=len;
....................             break;
....................          }
....................          else {
....................             to++;
....................             delay_ms(1);
....................          }
....................       } while (to!=timeout);
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max);
.................... 
....................    return(ret);
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR)
.................... 
.................... // see usb.h for documentation
.................... void usb_token_reset(void) 
.................... {
....................    unsigned int i;
.................... 
....................    usb_getdesc_len = 0;
*
03DE:  CLRF   28
03E0:  CLRF   27
....................    
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++) 
03E2:  MOVLB  1
03E4:  CLRF   xB6
03E6:  MOVF   xB6,W
03E8:  SUBLW  01
03EA:  BNC   0400
....................       USB_Interface[i] = 0;   //reset each interface to default
03EC:  CLRF   03
03EE:  MOVF   xB6,W
03F0:  ADDLW  29
03F2:  MOVWF  FE9
03F4:  MOVLW  00
03F6:  ADDWFC 03,W
03F8:  MOVWF  FEA
03FA:  CLRF   FEF
.................... 
....................   #IF USB_HID_BOOT_PROTOCOL
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++)
....................       hid_protocol[i] = 1;
....................   #endif
.................... 
....................   #if USB_CDC_DEVICE
03FC:  INCF   xB6,F
03FE:  BRA    03E6
....................    usb_cdc_init();
0400:  MOVLB  0
0402:  RCALL  039E
....................   #endif
.................... 
....................    USB_stack_status.curr_config = 0;      //unconfigured device
0404:  CLRF   1B
.................... 
....................    USB_stack_status.status_device = 1;    //previous state.  init at none
0406:  MOVLW  01
0408:  MOVWF  1C
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none
040A:  CLRF   1A
040C:  RETURN 0
.................... }
.................... 
.................... //send a 0len packet to endpoint 0 (optimization)
.................... //notice that this doesnt return the status
.................... #define usb_put_0len_0() usb_request_send_response(0)
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    direction = bit_test(endpoint,7);
*
02A0:  MOVLB  1
02A2:  BCF    xC3.0
02A4:  BTFSC  xC2.7
02A6:  BSF    xC3.0
....................    
....................    endpoint &= 0x7F;
02A8:  BCF    xC2.7
....................    
....................    if (endpoint > 16)
02AA:  MOVF   xC2,W
02AC:  SUBLW  10
02AE:  BC    02B6
....................       return(false);
02B0:  MOVLW  00
02B2:  MOVWF  01
02B4:  BRA    02EA
....................    
....................    if (direction) { //IN
02B6:  BTFSS  xC3.0
02B8:  BRA    02D4
....................       return(usb_ep_tx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
02BA:  CLRF   03
02BC:  MOVF   xC2,W
02BE:  MOVLB  0
02C0:  RCALL  00AE
02C2:  SUBLW  FF
02C4:  BNZ   02CA
02C6:  MOVLW  00
02C8:  BRA    02CC
02CA:  MOVLW  01
02CC:  MOVWF  01
02CE:  MOVLB  1
02D0:  BRA    02EA
....................    }
02D2:  BRA    02EA
....................    else {   //OUT
....................       return(usb_ep_rx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
02D4:  CLRF   03
02D6:  MOVF   xC2,W
02D8:  MOVLB  0
02DA:  RCALL  00CE
02DC:  SUBLW  FF
02DE:  BNZ   02E4
02E0:  MOVLW  00
02E2:  BRA    02E6
02E4:  MOVLW  01
02E6:  MOVWF  01
02E8:  MOVLB  1
....................    }
02EA:  MOVLB  0
02EC:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) {
....................    if (endpoint==0) {
*
1108:  MOVLB  1
110A:  MOVF   xB8,F
110C:  BNZ   112A
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor?
110E:  DECFSZ 1A,W
1110:  BRA    111C
1112:  MOVLB  0
1114:  CALL   0458
1118:  BRA    1126
111A:  MOVLB  1
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();}
111C:  MOVF   1A,W
111E:  SUBLW  02
1120:  BNZ   1128
1122:  MOVLB  0
1124:  BRA    0F08
1126:  MOVLB  1
....................    }
....................   #if USB_CDC_DEVICE
1128:  BRA    1136
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
112A:  MOVF   xB8,W
112C:  SUBLW  02
112E:  BNZ   1136
....................       usb_isr_tok_in_cdc_data_dne();
1130:  MOVLB  0
1132:  BRA    1102
1134:  MOVLB  1
....................   }
....................   #endif
1136:  MOVLB  0
1138:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint)
.................... {
....................    //TODO:
....................    if (endpoint==0) {
*
0ED0:  MOVLB  1
0ED2:  MOVF   xB8,F
0ED4:  BNZ   0EDE
....................      debug_usb(debug_putc,"TOUT 0 ");
....................      #if USB_CDC_DEVICE
....................       usb_isr_tok_out_cdc_control_dne();
0ED6:  MOVLB  0
0ED8:  BRA    0E1A
....................      //#else   //REMOVED JUN/9/2009
....................      //usb_init_ep0_setup();
....................      #endif
....................    }
....................   #if USB_CDC_DEVICE
0EDA:  BRA    0EE8
0EDC:  MOVLB  1
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
0EDE:  MOVF   xB8,W
0EE0:  SUBLW  02
0EE2:  BNZ   0EEA
....................       usb_isr_tok_out_cdc_data_dne();
0EE4:  MOVLB  0
0EE6:  BRA    0EB4
0EE8:  MOVLB  1
....................    }
....................   #endif
0EEA:  MOVLB  0
0EEC:  RETURN 0
....................    //else {
....................    //   bit_set(__usb_kbhit_status,endpoint);
....................    //}
.................... }
.................... 
.................... 
.................... //---- process setup message stage -----------//
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_setup_dne(void) 
.................... {
....................    USB_stack_status.dev_req=NONE; // clear the device request..
*
0B46:  CLRF   1A
.................... 
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) {
0B48:  MOVLB  4
0B4A:  MOVF   x18,W
0B4C:  ANDLW  7F
0B4E:  XORLW  00
0B50:  MOVLB  0
0B52:  BZ    0B62
0B54:  XORLW  01
0B56:  BZ    0B66
0B58:  XORLW  03
0B5A:  BZ    0B6A
0B5C:  XORLW  23
0B5E:  BZ    0B6E
0B60:  BRA    0B72
.................... 
....................       case 0x00:  //standard to device
....................          debug_usb_token(debug_putc," d");
....................          usb_isr_tkn_setup_StandardDevice();
0B62:  BRA    0788
....................          break;
0B64:  BRA    0B74
.................... 
....................       case 0x01:  //standard to interface
....................          debug_usb_token(debug_putc," i");
....................          usb_isr_tkn_setup_StandardInterface();
0B66:  BRA    0844
....................          break;
0B68:  BRA    0B74
.................... 
....................       case 0x02:  //standard to endpoint
....................          debug_usb_token(debug_putc," e");
....................          usb_isr_tkn_setup_StandardEndpoint();
0B6A:  BRA    0A3A
....................          break;
0B6C:  BRA    0B74
....................          
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case 0x21:  //class specific request.  the only class this driver supports is HID
....................          debug_usb_token(debug_putc, " class");
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE)
....................          {
....................             usb_isr_tkn_setup_ClassInterface();
....................          }
....................          else
....................          {
....................             usb_isr_tkn_cdc();
....................          }
....................         #elif USB_HID_DEVICE
....................          usb_isr_tkn_setup_ClassInterface();
....................         #else
....................          usb_isr_tkn_cdc();
0B6E:  BRA    0AAA
....................         #endif
....................          break;
0B70:  BRA    0B74
.................... #endif
.................... 
.................... 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE
.................... 
....................       default:
....................          usb_request_stall();
0B72:  RCALL  0454
....................          break;
....................    }
0B74:  GOTO   1172 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardDevice()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Device request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardDevice(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
*
0788:  MOVLB  4
078A:  MOVF   x19,W
078C:  XORLW  00
078E:  MOVLB  0
0790:  BZ    07AC
0792:  XORLW  01
0794:  BZ    07C0
0796:  XORLW  02
0798:  BZ    07DC
079A:  XORLW  06
079C:  BZ    07F6
079E:  XORLW  03
07A0:  BZ    0808
07A2:  XORLW  0E
07A4:  BZ    080C
07A6:  XORLW  01
07A8:  BZ    081C
07AA:  BRA    083E
.................... 
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device;
07AC:  MOVFF  1C,458
....................             usb_ep0_tx_buffer[1]=0;
07B0:  MOVLB  4
07B2:  CLRF   x59
....................             usb_request_send_response(2);
07B4:  MOVLW  02
07B6:  MOVLB  1
07B8:  MOVWF  xBB
07BA:  MOVLB  0
07BC:  RCALL  044E
....................             break;
07BE:  BRA    0840
.................... 
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1
....................             if (usb_ep0_rx_buffer[2] == 1) {
07C0:  MOVLB  4
07C2:  DECFSZ x1A,W
07C4:  BRA    07D6
....................                debug_usb_token(debug_putc,"CF");
....................                USB_stack_status.status_device &= 1;
07C6:  MOVLW  01
07C8:  ANDWF  1C,F
....................                usb_put_0len_0();
07CA:  MOVLB  1
07CC:  CLRF   xBB
07CE:  MOVLB  0
07D0:  RCALL  044E
....................             }
07D2:  BRA    07DA
07D4:  MOVLB  4
....................             else
....................                usb_request_stall();
07D6:  MOVLB  0
07D8:  RCALL  0454
....................             break;
07DA:  BRA    0840
.................... 
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3
....................             if (usb_ep0_rx_buffer[2] == 1) {
07DC:  MOVLB  4
07DE:  DECFSZ x1A,W
07E0:  BRA    07F0
....................                debug_usb_token(debug_putc,"SF");
....................                USB_stack_status.status_device |= 2;
07E2:  BSF    1C.1
....................                usb_put_0len_0();
07E4:  MOVLB  1
07E6:  CLRF   xBB
07E8:  MOVLB  0
07EA:  RCALL  044E
....................             }
07EC:  BRA    07F4
07EE:  MOVLB  4
....................             else
....................                usb_request_stall();
07F0:  MOVLB  0
07F2:  RCALL  0454
....................             break;
07F4:  BRA    0840
.................... 
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5
....................             debug_usb_token(debug_putc,"SA");
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request
07F6:  MOVLW  02
07F8:  MOVWF  1A
....................             USB_address_pending=usb_ep0_rx_buffer[2];
07FA:  MOVFF  41A,24
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request
....................             usb_set_address(USB_address_pending);
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0
....................             #endif
....................             usb_put_0len_0();
07FE:  MOVLB  1
0800:  CLRF   xBB
0802:  MOVLB  0
0804:  RCALL  044E
....................             break;
0806:  BRA    0840
.................... 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6
....................             debug_usb_token(debug_putc,"GD");
....................             usb_Get_Descriptor();
0808:  BRA    04E0
....................             break;
080A:  BRA    0840
.................... 
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8
....................             debug_usb_token(debug_putc,"GC");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config;
080C:  MOVFF  1B,458
....................             usb_request_send_response(1);
0810:  MOVLW  01
0812:  MOVLB  1
0814:  MOVWF  xBB
0816:  MOVLB  0
0818:  RCALL  044E
....................             break;
081A:  BRA    0840
.................... 
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) {
081C:  MOVLB  4
081E:  MOVF   x1A,W
0820:  SUBLW  01
0822:  BNC   083A
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2];
0824:  MOVFF  41A,1B
....................                usb_set_configured(usb_ep0_rx_buffer[2]);
0828:  MOVFF  41A,1B8
082C:  MOVLB  0
082E:  BRA    059E
....................                debug_usb_token(debug_putc,"SC%U", USB_stack_status.curr_config);               
....................                usb_put_0len_0();
0830:  MOVLB  1
0832:  CLRF   xBB
0834:  MOVLB  0
0836:  RCALL  044E
0838:  MOVLB  4
....................             }
....................             break;
083A:  MOVLB  0
083C:  BRA    0840
.................... 
....................       default:
....................             usb_request_stall();
083E:  RCALL  0454
....................             break;
....................    }
0840:  GOTO   0B74 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Interface request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardInterface(void) {
....................    unsigned int8 curr_config;
.................... 
....................    curr_config=USB_stack_status.curr_config;
0844:  MOVFF  1B,1B8
.................... 
....................    switch (usb_ep0_rx_buffer[1]) {
0848:  MOVLB  4
084A:  MOVF   x19,W
084C:  XORLW  00
084E:  MOVLB  0
0850:  BZ    085C
0852:  XORLW  0A
0854:  BZ    086E
0856:  XORLW  01
0858:  BZ    08B2
085A:  BRA    08DE
....................       case USB_STANDARD_REQUEST_GET_STATUS:
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=0;
085C:  MOVLB  4
085E:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0;
0860:  CLRF   x59
....................             usb_request_send_response(2);
0862:  MOVLW  02
0864:  MOVLB  1
0866:  MOVWF  xBB
0868:  MOVLB  0
086A:  RCALL  044E
....................             break;
086C:  BRA    08E0
.................... 
....................       case USB_STANDARD_REQUEST_GET_INTERFACE:
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state
086E:  MOVLB  1
0870:  MOVF   xB8,F
0872:  BZ    08AC
0874:  MOVLW  01
0876:  SUBWF  xB8,W
0878:  CLRF   03
087A:  MOVLB  0
087C:  RCALL  01A2
087E:  MOVWF  01
0880:  MOVLB  4
0882:  SUBWF  x1C,W
0884:  BTFSS  FD8.0
0886:  BRA    088C
0888:  MOVLB  1
088A:  BRA    08AC
....................                debug_usb_token(debug_putc,"GI");
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte
088C:  CLRF   03
088E:  MOVF   x1C,W
0890:  ADDLW  29
0892:  MOVWF  FE9
0894:  MOVLW  00
0896:  ADDWFC 03,W
0898:  MOVWF  FEA
089A:  MOVFF  FEF,458
....................                usb_request_send_response(1); //send byte back
089E:  MOVLW  01
08A0:  MOVLB  1
08A2:  MOVWF  xBB
08A4:  MOVLB  0
08A6:  RCALL  044E
....................             }
08A8:  BRA    08B0
08AA:  MOVLB  1
....................             else
....................                usb_request_stall();
08AC:  MOVLB  0
08AE:  RCALL  0454
....................             break;
08B0:  BRA    08E0
.................... 
....................       case USB_STANDARD_REQUEST_SET_INTERFACE:
....................             if (curr_config) { //if configured state
08B2:  MOVLB  1
08B4:  MOVF   xB8,F
08B6:  BZ    08D8
....................                debug_usb_token(debug_putc,"SI");
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
08B8:  CLRF   03
08BA:  MOVLB  4
08BC:  MOVF   x1C,W
08BE:  ADDLW  29
08C0:  MOVWF  FE9
08C2:  MOVLW  00
08C4:  ADDWFC 03,W
08C6:  MOVWF  FEA
08C8:  MOVFF  41A,FEF
....................                usb_put_0len_0();
08CC:  MOVLB  1
08CE:  CLRF   xBB
08D0:  MOVLB  0
08D2:  RCALL  044E
....................             }
08D4:  BRA    08DC
08D6:  MOVLB  1
....................             else
....................                usb_request_stall();
08D8:  MOVLB  0
08DA:  RCALL  0454
....................             break;
08DC:  BRA    08E0
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR:
....................             debug_usb_token(debug_putc,"GDh");
....................             usb_Get_Descriptor();
....................             break;
.................... #endif
.................... 
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE:
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE:
.................... //                let default take care of these, goto wrongstate
....................       default:
....................             usb_request_stall();
08DE:  RCALL  0454
....................             break;
....................    }
08E0:  GOTO   0B74 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardEndpoint()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardEndpoint(void) {
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) {
*
0A3A:  MOVFF  41C,1C2
0A3E:  RCALL  02A0
0A40:  MOVF   01,F
0A42:  BZ    0AA0
....................       switch(usb_ep0_rx_buffer[1]) {
0A44:  MOVLB  4
0A46:  MOVF   x19,W
0A48:  XORLW  01
0A4A:  MOVLB  0
0A4C:  BZ    0A58
0A4E:  XORLW  02
0A50:  BZ    0A68
0A52:  XORLW  03
0A54:  BZ    0A78
0A56:  BRA    0A9E
.................... 
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE:
....................                debug_usb_token(debug_putc,"CF");
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]);
0A58:  MOVFF  41C,1B8
0A5C:  BRA    08E4
....................                usb_put_0len_0();
0A5E:  MOVLB  1
0A60:  CLRF   xBB
0A62:  MOVLB  0
0A64:  RCALL  044E
....................                break;
0A66:  BRA    0AA0
.................... 
....................          case USB_STANDARD_REQUEST_SET_FEATURE:
....................                      debug_usb_token(debug_putc,"SF");
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]);
0A68:  MOVFF  41C,1B8
0A6C:  BRA    095E
....................                      usb_put_0len_0();
0A6E:  MOVLB  1
0A70:  CLRF   xBB
0A72:  MOVLB  0
0A74:  RCALL  044E
....................                      break;
0A76:  BRA    0AA0
.................... 
....................          case USB_STANDARD_REQUEST_GET_STATUS:
....................                debug_usb_token(debug_putc,"GS");
....................                usb_ep0_tx_buffer[0]=0;
0A78:  MOVLB  4
0A7A:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0;
0A7C:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) {
0A7E:  MOVFF  41C,1B8
0A82:  MOVLB  0
0A84:  BRA    09C4
0A86:  MOVF   01,F
0A88:  BZ    0A92
....................                   usb_ep0_tx_buffer[0]=1;
0A8A:  MOVLW  01
0A8C:  MOVLB  4
0A8E:  MOVWF  x58
0A90:  MOVLB  0
....................                }
....................                usb_request_send_response(2);
0A92:  MOVLW  02
0A94:  MOVLB  1
0A96:  MOVWF  xBB
0A98:  MOVLB  0
0A9A:  RCALL  044E
....................                break;
0A9C:  BRA    0AA0
.................... 
....................          default:
....................             usb_request_stall();
0A9E:  RCALL  0454
....................             break;
....................       }
....................    }
0AA0:  GOTO   0B74 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_ClassInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /* Only compiled if HID_DEVICE is TRUE
.................... /***************************************************************/
.................... #IF USB_HID_DEVICE
.................... void usb_isr_tkn_setup_ClassInterface(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03
....................             debug_usb_token(debug_putc,"GP");
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]];
....................             usb_request_send_response(1);
....................             break;
....................     #ENDIF
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b
....................             debug_usb_token(debug_putc,"SP");
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
....................             usb_put_0len_0(); //send 0len packet69
....................             break;
....................     #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_SET_IDLE:   //0a
....................          #error TODO: if you want to support SET_IDLE, add code here
....................    #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_GET_IDLE:   //02
....................          #error TODO: if you want to support GET_IDLE, add code here
....................    #ENDIF
.................... 
....................       default:
....................             usb_request_stall();
....................             break;
....................    }
.................... }
.................... #ENDIF
.................... 
.................... /**************************************************************
.................... /* usb_Get_Descriptor()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept
.................... /*
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.),
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have
.................... /*          pointers to constants we must simulate or own by setting up global registers that say
.................... /*          which constant array to deal with, which position to start in this array, and the length.
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne()
.................... /*          which will send the rest of the data.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_Get_Descriptor() {
*
04E0:  MOVLB  1
04E2:  CLRF   xB8
....................    unsigned int8 i = 0;
....................    usb_getdesc_ptr=0;
04E4:  CLRF   26
04E6:  CLRF   25
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE;
04E8:  CLRF   1D
.................... 
....................    switch(usb_ep0_rx_buffer[3]) {
04EA:  MOVLB  4
04EC:  MOVF   x1B,W
04EE:  XORLW  01
04F0:  MOVLB  0
04F2:  BZ    0502
04F4:  XORLW  03
04F6:  BZ    050E
04F8:  XORLW  01
04FA:  BZ    0516
04FC:  XORLW  22
04FE:  BZ    054E
0500:  BRA    0578
....................       case USB_DESC_DEVICE_TYPE:    //1
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN;
0502:  CLRF   28
0504:  MOVLW  12
0506:  MOVWF  27
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE;
0508:  MOVLW  03
050A:  MOVWF  1D
....................             break;
050C:  BRA    057C
.................... 
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually.
....................       case USB_DESC_CONFIG_TYPE:   //2
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN;
050E:  CLRF   28
0510:  MOVLW  43
0512:  MOVWF  27
....................             break;
0514:  BRA    057C
.................... 
....................       case USB_DESC_STRING_TYPE: //3
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE;
0516:  MOVLW  02
0518:  MOVWF  1D
....................             //usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]];
....................             for(i=0; i<usb_ep0_rx_buffer[2]; i++)
051A:  MOVLB  1
051C:  CLRF   xB8
051E:  MOVLB  4
0520:  MOVF   x1A,W
0522:  MOVLB  1
0524:  SUBWF  xB8,W
0526:  BC    053E
....................             {
....................                usb_getdesc_ptr += USB_STRING_DESC[usb_getdesc_ptr];
0528:  MOVFF  26,03
052C:  MOVF   25,W
052E:  MOVLB  0
0530:  RCALL  01EE
0532:  ADDWF  25,F
0534:  MOVLW  00
0536:  ADDWFC 26,F
0538:  MOVLB  1
053A:  INCF   xB8,F
053C:  BRA    051E
....................             }
....................             usb_getdesc_len = USB_STRING_DESC[usb_getdesc_ptr];
053E:  MOVFF  26,03
0542:  MOVF   25,W
0544:  MOVLB  0
0546:  RCALL  01EE
0548:  MOVWF  27
054A:  CLRF   28
....................             break;
054C:  BRA    057C
.................... 
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06
....................       // this is needed so host can find out about differences about this
....................       // devices ability to handle full speed verses fast speed.
....................       // since we don't support fast speed then we ignore this.
....................       //      break;
.................... 
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case USB_DESC_CLASS_TYPE:  //0x21
....................             //TODO does this work for multiple interfaces or multiple languages?
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]];
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]];
054E:  CLRF   03
0550:  MOVLB  4
0552:  MOVF   x1A,W
0554:  MOVLB  0
0556:  RCALL  01B4
0558:  MOVWF  25
055A:  CLRF   26
....................             if (usb_getdesc_ptr!=0xFF) {
055C:  INCFSZ 25,W
055E:  BRA    0564
0560:  MOVF   26,F
0562:  BZ    0574
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr];
0564:  MOVFF  26,03
0568:  MOVF   25,W
056A:  RCALL  014E
056C:  MOVWF  27
056E:  CLRF   28
....................                break;
0570:  BRA    057C
....................             }
0572:  BRA    0578
....................             else {
....................                usb_request_stall();
0574:  RCALL  0454
....................                return;
0576:  BRA    059A
....................             }
.................... #endif
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_DESC_HIDREPORT_TYPE: //0x22
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]];
....................             if (usb_getdesc_ptr !=0xFF) {
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE;
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]];
....................                break;
....................             }
....................             else {
....................                usb_request_stall();
....................                return;
....................             }
.................... #endif
.................... 
....................       default:
....................             usb_request_stall();
0578:  RCALL  0454
....................             return;
057A:  BRA    059A
....................    }
....................    if (usb_ep0_rx_buffer[7]==0) {
057C:  MOVLB  4
057E:  MOVF   x1F,F
0580:  BNZ   0592
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6])
0582:  MOVF   28,F
0584:  BNZ   058C
0586:  MOVF   27,W
0588:  SUBWF  x1E,W
058A:  BC    0592
....................          usb_getdesc_len = usb_ep0_rx_buffer[6];
058C:  CLRF   28
058E:  MOVFF  41E,27
....................    }
....................    USB_stack_status.dev_req=GET_DESCRIPTOR;
0592:  MOVLW  01
0594:  MOVWF  1A
....................    usb_copy_desc_seg_to_ep();
0596:  MOVLB  0
0598:  RCALL  0458
059A:  GOTO   0840 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_finish_set_address()
.................... /*
.................... /* Input: USB_address_pending holds the address we were asked to set to.
.................... /*
.................... /* Summary: Sets the address.
.................... /*
.................... /* This code should only be run on the PIC USB peripheral, and not the
.................... /* National peripheral.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
....................  void usb_finish_set_address() {
....................    debug_usb_token(debug_putc," FSA ");
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0
*
0F08:  CLRF   1B
.................... 
....................    #ifdef __PIC__
....................    USB_stack_status.dev_req=NONE;  // no request pending
0F0A:  CLRF   1A
....................    usb_set_address(USB_address_pending);
0F0C:  MOVFF  24,1B9
0F10:  BRA    0EEE
....................    #endif
0F12:  GOTO   1126 (RETURN)
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// The following function retrieve data from constant arrays.  This may
.................... /// look un-optimized, but remember that you can't create a pointer to
.................... /// a constant array.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... void usb_copy_desc_seg_to_ep(void) {
*
0458:  MOVLB  1
045A:  CLRF   xB9
....................    unsigned int i=0;
....................    char c;
....................    
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]);
.................... 
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH))
045C:  MOVF   27,W
045E:  IORWF  28,W
0460:  BZ    04C8
0462:  MOVF   xB9,W
0464:  SUBLW  3F
0466:  BNC   04C8
....................    {
....................       switch(USB_stack_status.getdesc_type) {
0468:  MOVF   1D,W
046A:  XORLW  00
046C:  MOVLB  0
046E:  BZ    047A
0470:  XORLW  02
0472:  BZ    0488
0474:  XORLW  01
0476:  BZ    0496
0478:  BRA    04A2
....................          case USB_GETDESC_CONFIG_TYPE:
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr];
047A:  MOVFF  26,03
047E:  MOVF   25,W
0480:  RCALL  014E
0482:  MOVFF  FE8,1BA
....................             break;
0486:  BRA    04A2
.................... 
....................         #IF USB_HID_DEVICE
....................          case USB_GETDESC_HIDREPORT_TYPE:
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr];
....................             break;
....................         #endif
.................... 
....................          case USB_GETDESC_STRING_TYPE:
....................             c=USB_STRING_DESC[usb_getdesc_ptr];
0488:  MOVFF  26,03
048C:  MOVF   25,W
048E:  RCALL  01EE
0490:  MOVFF  FE8,1BA
....................             break;
0494:  BRA    04A2
.................... 
....................          case USB_GETDESC_DEVICE_TYPE:
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr];
0496:  MOVFF  26,03
049A:  MOVF   25,W
049C:  RCALL  01CC
049E:  MOVFF  FE8,1BA
....................             //debug_usb(debug_putc, "-%X- ", c);
....................             break;
....................       }
....................       usb_getdesc_ptr++;
04A2:  INCF   25,F
04A4:  BTFSC  FD8.2
04A6:  INCF   26,F
....................       usb_getdesc_len--;
04A8:  MOVF   27,W
04AA:  BTFSC  FD8.2
04AC:  DECF   28,F
04AE:  DECF   27,F
....................       usb_ep0_tx_buffer[i++]=c;
04B0:  MOVLB  1
04B2:  MOVF   xB9,W
04B4:  INCF   xB9,F
04B6:  ADDLW  58
04B8:  MOVWF  FE9
04BA:  MOVLW  04
04BC:  MOVWF  FEA
04BE:  BTFSC  FD8.0
04C0:  INCF   FEA,F
04C2:  MOVFF  1BA,FEF
04C6:  BRA    045C
....................    }
.................... 
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) {
04C8:  MOVF   27,W
04CA:  IORWF  28,W
04CC:  BNZ   04D6
04CE:  MOVF   xB9,W
04D0:  SUBLW  40
04D2:  BZ    04D6
....................          USB_stack_status.dev_req = NONE;
04D4:  CLRF   1A
....................    }
.................... 
....................    usb_request_send_response(i);
04D6:  MOVFF  1B9,1BB
04DA:  MOVLB  0
04DC:  RCALL  044E
04DE:  RETURN 0
.................... }
.................... 
.................... #ENDIF
.................... 
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk
....................    transfer endpoints is not supported on slow speed devices per the USB
....................    specification.  You may be able to find unofficial drivers for your
....................    operating system that allows CDC to operate on a slow speed device,
....................    but CCS doesn't have any that they can recommend to you.
.................... */
.................... #if (USB_USE_FULL_SPEED==0)
....................    #error CDC and slow speed is not supported.  See comments above.
.................... #endif
.................... 
.................... struct {
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2)
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space)
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16)
.................... } __attribute__((__packed__)) usb_cdc_line_coding;
.................... 
.................... //length of time, in ms, of break signal as we received in a SendBreak message.
.................... //if ==0xFFFF, send break signal until we receive a 0x0000.
.................... unsigned int16 usb_cdc_break;
.................... 
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1];
.................... #else
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE];
.................... #endif
.................... 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT)
.................... #if sizeof(usb_cdc_put_buffer)>=0x100
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this.
....................  typedef unsigned int16 usb_cdc_tx_t;
.................... #else
....................  typedef unsigned int8 usb_cdc_tx_t;
.................... #endif
.................... 
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin;
.................... //#locate usb_cdc_put_buffer_nextin=0x1800
.................... 
.................... 
.................... #if defined(__PIC__)
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer
.................... #else
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE];
.................... #endif
.................... 
.................... int1 usb_cdc_got_set_line_coding;
.................... 
.................... struct  {
....................    int1 dte_present; //1=DTE present, 0=DTE not present
....................    int1 active;      //1=activate carrier, 0=deactivate carrier
....................    unsigned int reserved:6;
.................... } usb_cdc_carrier;
.................... 
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state;
.................... 
.................... /*
.................... #if defined(__PCH__)
....................  #byte INTCON=0xFF2
....................  #bit INT_GIE=INTCON.7
.................... #else
....................  #word SR=0x42
.................... #endif
.................... */
.................... 
.................... #if defined(USB_CDC_USE_ENCAPSULATED)
.................... unsigned int16 g_UsbCdcSendEncapsSize;
.................... #endif
.................... 
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data]
.................... void usb_isr_tok_out_cdc_control_dne(void) 
.................... {
....................    switch (__usb_cdc_state) {
*
0E1A:  MOVF   xB7,W
0E1C:  XORLW  01
0E1E:  BZ    0E26
0E20:  XORLW  03
0E22:  BZ    0E34
0E24:  BRA    0E5C
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state);
....................       case USB_CDC_OUT_COMMAND:
....................         #if defined(USB_CDC_USE_ENCAPSULATED)
....................          usb_cdc_SendEncapsulatedCommand(usb_ep0_rx_buffer, g_UsbCdcSendEncapsSize);
....................         #endif
....................          usb_put_0len_0();
0E26:  MOVLB  1
0E28:  CLRF   xBB
0E2A:  MOVLB  0
0E2C:  CALL   044E
....................          __usb_cdc_state=0;
0E30:  CLRF   xB7
....................          break;
0E32:  BRA    0E5E
.................... 
....................     #if USB_MAX_EP0_PACKET_LENGTH==8
....................       case USB_CDC_WAIT_0LEN:
....................          usb_put_0len_0();
....................          __usb_cdc_state=0;
....................          break;
....................     #endif
.................... 
....................       case USB_CDC_OUT_LINECODING:
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7);
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n");
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7);
0E34:  CLRF   FEA
0E36:  MOVLW  2B
0E38:  MOVWF  FE9
0E3A:  MOVLW  04
0E3C:  MOVWF  FE2
0E3E:  MOVLW  18
0E40:  MOVWF  FE1
0E42:  MOVLW  07
0E44:  MOVWF  01
0E46:  MOVFF  FE6,FEE
0E4A:  DECFSZ 01,F
0E4C:  BRA    0E46
....................          __usb_cdc_state=0;
0E4E:  CLRF   xB7
....................          usb_put_0len_0();
0E50:  MOVLB  1
0E52:  CLRF   xBB
0E54:  MOVLB  0
0E56:  CALL   044E
....................          break;
0E5A:  BRA    0E5E
.................... 
....................       default:
....................          __usb_cdc_state=0;
0E5C:  CLRF   xB7
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................          break;
....................    }
0E5E:  GOTO   0EDA (RETURN)
.................... }
.................... 
.................... //handle IN token on 0 (setup packet)
.................... void usb_isr_tkn_cdc(void) {
....................    unsigned int16 wLen;
....................    //make sure the request goes to a CDC interface
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) {
*
0AAA:  MOVLB  4
0AAC:  DECFSZ x1C,W
0AAE:  BRA    0AB2
0AB0:  BRA    0AB6
0AB2:  MOVF   x1C,F
0AB4:  BNZ   0B40
....................       wLen = make16(usb_ep0_rx_buffer[7], usb_ep0_rx_buffer[6]);
0AB6:  MOVFF  41F,1B9
0ABA:  MOVFF  41E,1B8
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]);
....................       switch(usb_ep0_rx_buffer[1]) {
0ABE:  MOVF   x19,W
0AC0:  XORLW  00
0AC2:  MOVLB  0
0AC4:  BZ    0ADC
0AC6:  XORLW  01
0AC8:  BZ    0AE4
0ACA:  XORLW  21
0ACC:  BZ    0AEC
0ACE:  XORLW  01
0AD0:  BZ    0AF6
0AD2:  XORLW  03
0AD4:  BZ    0B1C
0AD6:  XORLW  01
0AD8:  BZ    0B2A
0ADA:  BRA    0B3C
....................          case 0x00:  //send_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             g_UsbCdcSendEncapsSize = wLen;
....................            #endif
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND;
0ADC:  MOVLW  01
0ADE:  MOVWF  xB7
....................             usb_request_get_data();
0AE0:  RCALL  0AA4
....................             break;
0AE2:  BRA    0B3E
.................... 
....................          case 0x01:  //get_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             usb_cdc_GetEncapsulatedResponse(usb_ep0_tx_buffer, wLen);
....................            #endif
....................             usb_request_send_response(wLen);
0AE4:  MOVFF  1B8,1BB
0AE8:  RCALL  044E
....................             break;
0AEA:  BRA    0B3E
.................... 
....................          case 0x20:  //set_line_coding
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING;
0AEC:  MOVLW  02
0AEE:  MOVWF  xB7
....................             usb_cdc_got_set_line_coding=true;
0AF0:  BSF    xB5.0
....................             usb_request_get_data();
0AF2:  RCALL  0AA4
....................             break;
0AF4:  BRA    0B3E
.................... 
....................          case 0x21:  //get_line_coding
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding));
0AF6:  MOVLW  04
0AF8:  MOVWF  FEA
0AFA:  MOVLW  58
0AFC:  MOVWF  FE9
0AFE:  CLRF   FE2
0B00:  MOVLW  2B
0B02:  MOVWF  FE1
0B04:  MOVLW  07
0B06:  MOVWF  01
0B08:  MOVFF  FE6,FEE
0B0C:  DECFSZ 01,F
0B0E:  BRA    0B08
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes
0B10:  MOVLW  07
0B12:  MOVLB  1
0B14:  MOVWF  xBB
0B16:  MOVLB  0
0B18:  RCALL  044E
....................             break;
0B1A:  BRA    0B3E
.................... 
....................          case 0x22:  //set_control_line_state
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2];
0B1C:  MOVFF  41A,B6
....................             usb_put_0len_0();
0B20:  MOVLB  1
0B22:  CLRF   xBB
0B24:  MOVLB  0
0B26:  RCALL  044E
....................             break;
0B28:  BRA    0B3E
.................... 
....................          case 0x23:  //send_break
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]);
0B2A:  MOVFF  41A,33
0B2E:  MOVFF  41B,32
....................             usb_put_0len_0();
0B32:  MOVLB  1
0B34:  CLRF   xBB
0B36:  MOVLB  0
0B38:  RCALL  044E
....................             break;
0B3A:  BRA    0B3E
.................... 
....................          default:
....................             usb_request_stall();
0B3C:  RCALL  0454
....................             break;
0B3E:  MOVLB  4
....................       }
....................    }
0B40:  MOVLB  0
0B42:  GOTO   0B74 (RETURN)
.................... }
.................... 
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars]
.................... void usb_isr_tok_out_cdc_data_dne(void) {
....................    usb_cdc_get_buffer_status.got=true;
*
0EB4:  BSF    1E.0
....................    usb_cdc_get_buffer_status.index=0;
0EB6:  CLRF   20
.................... #if (defined(__PIC__) && __PIC__)
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT);
0EB8:  MOVLW  02
0EBA:  MOVLB  1
0EBC:  MOVWF  xB9
0EBE:  MOVLB  0
0EC0:  BRA    0E62
0EC2:  MOVFF  01,1F
.................... #else
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer(
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE);
.................... #endif
....................    if (!usb_cdc_get_buffer_status.len)
0EC6:  MOVF   1F,F
0EC8:  BNZ   0ECC
....................    {
....................       usb_cdc_get_discard();
0ECA:  BRA    0EA2
....................    }
0ECC:  GOTO   0EE8 (RETURN)
....................    /*
....................   #if defined(USB_CDC_ISR)
....................    else
....................    {
....................       USB_CDC_ISR();
....................    }
....................   #endif
....................   */
.................... }
.................... 
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters]
.................... void usb_isr_tok_in_cdc_data_dne(void) 
.................... {
....................    usb_cdc_flush_tx_buffer();
*
1102:  RCALL  1090
1104:  GOTO   1134 (RETURN)
.................... }
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
*
0FB4:  MOVFF  1BE,1C4
0FB8:  MOVFF  1BD,1C3
....................    sc2=s2;
0FBC:  MOVFF  1C0,1C6
0FC0:  MOVFF  1BF,1C5
....................    if(sc2<sc1 && sc1 <sc2 +n)
0FC4:  MOVLB  1
0FC6:  MOVF   xC6,W
0FC8:  SUBWF  xC4,W
0FCA:  BNC   1044
0FCC:  BNZ   0FD4
0FCE:  MOVF   xC3,W
0FD0:  SUBWF  xC5,W
0FD2:  BC    1044
0FD4:  MOVF   xC1,W
0FD6:  ADDWF  xC5,W
0FD8:  MOVWF  01
0FDA:  MOVF   xC2,W
0FDC:  ADDWFC xC6,W
0FDE:  MOVWF  03
0FE0:  MOVF   xC4,W
0FE2:  SUBWF  03,W
0FE4:  BNC   1044
0FE6:  BNZ   0FEE
0FE8:  MOVF   01,W
0FEA:  SUBWF  xC3,W
0FEC:  BC    1044
....................       for(sc1+=n,sc2+=n;0<n;--n)
0FEE:  MOVF   xC1,W
0FF0:  ADDWF  xC3,F
0FF2:  MOVF   xC2,W
0FF4:  ADDWFC xC4,F
0FF6:  MOVF   xC1,W
0FF8:  ADDWF  xC5,F
0FFA:  MOVF   xC2,W
0FFC:  ADDWFC xC6,F
0FFE:  MOVF   xC2,F
1000:  BNZ   1008
1002:  MOVF   xC1,W
1004:  SUBLW  00
1006:  BC    1042
....................          *--sc1=*--sc2;
1008:  MOVF   xC3,W
100A:  BTFSC  FD8.2
100C:  DECF   xC4,F
100E:  DECF   xC3,F
1010:  MOVFF  1C4,1C8
1014:  MOVFF  1C3,1C7
1018:  MOVF   xC5,W
101A:  BTFSC  FD8.2
101C:  DECF   xC6,F
101E:  DECF   xC5,F
1020:  MOVFF  1C6,FEA
1024:  MOVFF  1C5,FE9
1028:  MOVFF  FEF,1C9
102C:  MOVFF  1C4,FEA
1030:  MOVFF  1C3,FE9
1034:  MOVFF  1C9,FEF
1038:  MOVF   xC1,W
103A:  BTFSC  FD8.2
103C:  DECF   xC2,F
103E:  DECF   xC1,F
1040:  BRA    0FFE
1042:  BRA    1084
....................    else
....................       for(;0<n;--n)
1044:  MOVF   xC2,F
1046:  BNZ   104E
1048:  MOVF   xC1,W
104A:  SUBLW  00
104C:  BC    1084
....................          *sc1++=*sc2++;
104E:  MOVFF  1C4,1C8
1052:  MOVF   xC3,W
1054:  INCF   xC3,F
1056:  BTFSC  FD8.2
1058:  INCF   xC4,F
105A:  MOVWF  xC7
105C:  MOVFF  1C6,FEA
1060:  MOVF   xC5,W
1062:  INCF   xC5,F
1064:  BTFSC  FD8.2
1066:  INCF   xC6,F
1068:  MOVWF  FE9
106A:  MOVFF  FEF,1C9
106E:  MOVFF  1C8,FEA
1072:  MOVFF  1C7,FE9
1076:  MOVFF  1C9,FEF
107A:  MOVF   xC1,W
107C:  BTFSC  FD8.2
107E:  DECF   xC2,F
1080:  DECF   xC1,F
1082:  BRA    1044
....................   return s1;
1084:  MOVFF  1BD,01
1088:  MOVFF  1BE,02
108C:  MOVLB  0
108E:  RETURN 0
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... void usb_cdc_flush_tx_buffer(void) 
.................... {
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE
....................    usb_cdc_tx_t n;
....................   #endif
....................   
....................    if (usb_cdc_put_buffer_nextin != 0)
1090:  MOVF   xB4,F
1092:  BZ    1100
....................    {
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE))
....................       {
....................          usb_cdc_put_buffer_nextin = 0;
....................       }
....................      #else
....................       n = usb_cdc_put_buffer_nextin;
1094:  MOVFF  B4,1B9
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets
1098:  MOVLB  1
109A:  MOVF   xB9,W
109C:  SUBLW  3F
109E:  BC    10A4
....................          n = USB_CDC_DATA_IN_SIZE-1;
10A0:  MOVLW  3F
10A2:  MOVWF  xB9
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE))
10A4:  MOVLW  02
10A6:  MOVWF  xBA
10A8:  CLRF   xBC
10AA:  MOVLW  34
10AC:  MOVWF  xBB
10AE:  CLRF   xBE
10B0:  MOVFF  1B9,1BD
10B4:  MOVLW  02
10B6:  MOVWF  xBF
10B8:  MOVLB  0
10BA:  RCALL  0F16
10BC:  MOVF   01,F
10BE:  BZ    1100
....................       {
....................          //pull the buffer back
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n);
10C0:  CLRF   03
10C2:  MOVLB  1
10C4:  MOVF   xB9,W
10C6:  ADDLW  34
10C8:  MOVWF  01
10CA:  MOVLW  00
10CC:  ADDWFC 03,F
10CE:  MOVFF  01,1BA
10D2:  MOVFF  03,1BB
10D6:  MOVF   xB9,W
10D8:  MOVLB  0
10DA:  SUBWF  xB4,W
10DC:  MOVLB  1
10DE:  MOVWF  xBC
10E0:  CLRF   xBE
10E2:  MOVLW  34
10E4:  MOVWF  xBD
10E6:  MOVFF  03,1C0
10EA:  MOVFF  01,1BF
10EE:  CLRF   xC2
10F0:  MOVFF  1BC,1C1
10F4:  MOVLB  0
10F6:  RCALL  0FB4
....................          usb_cdc_put_buffer_nextin -= n;
10F8:  MOVLB  1
10FA:  MOVF   xB9,W
10FC:  MOVLB  0
10FE:  SUBWF  xB4,F
....................       }      
....................      #endif
....................    }
1100:  RETURN 0
.................... }
.................... 
.................... void usb_cdc_init(void) 
.................... {
....................    usb_cdc_line_coding.dwDTERrate = 9600;
*
039E:  MOVLB  1
03A0:  CLRF   xBA
03A2:  CLRF   xB9
03A4:  MOVLW  25
03A6:  MOVWF  xB8
03A8:  MOVLW  80
03AA:  MOVWF  xB7
03AC:  MOVFF  1B7,2B
03B0:  MOVFF  1B8,2C
03B4:  CLRF   2D
03B6:  CLRF   2E
....................    usb_cdc_line_coding.bCharFormat = 0;
03B8:  CLRF   xB7
03BA:  MOVFF  1B7,2F
....................    usb_cdc_line_coding.bParityType = 0;
03BE:  CLRF   xB7
03C0:  MOVFF  1B7,30
....................    usb_cdc_line_coding.bDataBits = 8;
03C4:  MOVLW  08
03C6:  MOVWF  xB7
03C8:  MOVFF  1B7,31
....................    (int8)usb_cdc_carrier = 0;
03CC:  MOVLB  0
03CE:  CLRF   xB6
....................    usb_cdc_got_set_line_coding = false;
03D0:  BCF    xB5.0
....................    usb_cdc_break = 0;
03D2:  CLRF   33
03D4:  CLRF   32
....................    usb_cdc_put_buffer_nextin = 0;
03D6:  CLRF   xB4
....................    usb_cdc_get_buffer_status.got = 0;
03D8:  BCF    1E.0
....................    __usb_cdc_state = 0;
03DA:  CLRF   xB7
03DC:  RETURN 0
.................... }
.................... 
.................... ////////////////// END USB CONTROL HANDLING //////////////////////////////////
.................... 
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY /////////////////////////////
.................... 
.................... typedef struct
.................... {
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD.
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device.
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device. 
....................    unsigned int bFraming:1;   //A framing error has occurred.
....................    unsigned int bParity:1;    //A parity error has occurred.
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device.
....................    unsigned int reserved0:1;   //future use
....................    unsigned int reserved1:8;   //future use
.................... } cdc_serial_state_t;
.................... 
.................... /*
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring, 
....................    break signal and more (see cdc_serial_state_t).
....................    Some of these values are held by the host (meaning it's value only needs
....................    to be sent on change), but some values are one shot (meaning you continously
....................    need to send value to host while being held).
.................... */
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state)
.................... {
....................   #if __USB_PIC_PERIF__
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer
....................   #else
....................    unsigned int8 payload[10];
....................    #define CDC_EP1_NOTIFY_BUFFER payload
....................   #endif
.................... 
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT))
....................       return(false);
.................... 
....................    //bmRequestType
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001
....................    //bNotification
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE
....................    //wValue
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0;
....................    //wIndex
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0;
....................    //wLength
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t)
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0;
....................    //data
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state;
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8;
.................... 
....................   #if __USB_PIC_PERIF__
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE);
....................   #else
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE);
....................   #endif
....................    
....................    return(true);
.................... }
.................... 
.................... void usb_cdc_get_discard(void)
.................... {
....................    usb_cdc_get_buffer_status.got = false;
*
0EA2:  BCF    1E.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE);
0EA4:  MOVLW  02
0EA6:  MOVLB  1
0EA8:  MOVWF  xB9
0EAA:  MOVWF  xBA
0EAC:  MOVLB  0
0EAE:  RCALL  0B78
0EB0:  GOTO   0ECC (RETURN)
.................... }
.................... 
.................... char usb_cdc_getc(void) 
.................... {
....................    char c;
.................... 
....................    while (!usb_cdc_kbhit()) 
....................    {
....................      #if defined(USB_ISR_POLLING)
....................       usb_task();
....................      #endif
....................    }
.................... 
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++];
.................... 
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len) 
....................    {
....................       usb_cdc_get_discard();
....................    }
.................... 
....................    return(c);
.................... }
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... #define __USB_PAUSE_ISR()
.................... #define __USB_RESTORE_ISR()
.................... #else
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1
.................... #endif
.................... 
.................... static void _usb_cdc_putc_fast_noflush(char c)
.................... {
....................    __USB_PAUSE_ISR();
*
13B0:  MOVLB  1
13B2:  BCF    xA0.0
13B4:  BTFSC  FA0.5
13B6:  BSF    xA0.0
13B8:  BCF    FA0.5
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) 
13BA:  MOVLB  0
13BC:  MOVF   xB4,W
13BE:  SUBLW  7F
13C0:  BC    13D0
13C2:  CLRF   19
13C4:  BTFSC  FF2.7
13C6:  BSF    19.7
13C8:  BCF    FF2.7
....................    {
....................       usb_cdc_flush_tx_buffer();
13CA:  RCALL  1090
13CC:  BTFSC  19.7
13CE:  BSF    FF2.7
....................    }
....................   #endif
.................... 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) {
13D0:  MOVF   xB4,W
13D2:  SUBLW  7F
13D4:  BC    13DA
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer!
13D6:  MOVLW  7F
13D8:  MOVWF  xB4
....................    }
....................    
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c;
13DA:  MOVF   xB4,W
13DC:  INCF   xB4,F
13DE:  CLRF   03
13E0:  ADDLW  34
13E2:  MOVWF  FE9
13E4:  MOVLW  00
13E6:  ADDWFC 03,W
13E8:  MOVWF  FEA
13EA:  MOVFF  19F,FEF
.................... 
....................    __USB_RESTORE_ISR();
13EE:  MOVLB  1
13F0:  BTFSS  xA0.0
13F2:  BRA    13F6
13F4:  BSF    FA0.5
13F6:  MOVLB  0
13F8:  GOTO   1402 (RETURN)
.................... }
.................... 
.................... void usb_cdc_putc_fast(char c)
.................... {
....................    _usb_cdc_putc_fast_noflush(c);
13FC:  MOVFF  19E,19F
1400:  BRA    13B0
.................... 
....................   #if defined(USB_ISR_POLLING)
....................    // if interrupts are disabled, we should clear all activity isrs
....................    // before we attempt to put any data onto an endpoint.
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT))
....................       return;
....................    usb_task();
....................   #endif
....................   
....................   #if !defined(USB_CDC_DELAYED_FLUSH)
1402:  GOTO   143E (RETURN)
....................    //if (usb_cdc_put_buffer_free()) 
....................    {
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin);
....................       usb_cdc_flush_tx_buffer();
....................    }
....................   #endif
.................... 
....................    //putc('*');
.................... }
.................... 
.................... void usb_cdc_putc(char c)
.................... {
....................    while (!usb_cdc_putready()) 
1406:  MOVLW  80
1408:  BSF    FD8.0
140A:  SUBFWB xB4,W
140C:  BNZ   1438
140E:  CLRF   19
1410:  BTFSC  FF2.7
1412:  BSF    19.7
1414:  BCF    FF2.7
....................    {
....................      #if 1
....................       if (usb_cdc_put_buffer_free()) 
1416:  MOVLW  02
1418:  MOVLB  1
141A:  MOVWF  xC7
141C:  MOVLB  0
141E:  RCALL  0C78
1420:  BTFSC  19.7
1422:  BSF    FF2.7
1424:  MOVF   01,F
1426:  BZ    1436
1428:  CLRF   19
142A:  BTFSC  FF2.7
142C:  BSF    19.7
142E:  BCF    FF2.7
....................       {
....................          usb_cdc_flush_tx_buffer();
1430:  RCALL  1090
1432:  BTFSC  19.7
1434:  BSF    FF2.7
....................       }
....................      #endif
.................... 
....................      #if defined(USB_ISR_POLLING)
1436:  BRA    1406
....................       usb_task();
....................      #endif
....................    }
....................    usb_cdc_putc_fast(c);
1438:  MOVFF  19D,19E
143C:  BRA    13FC
143E:  GOTO   1454 (RETURN)
.................... }
.................... 
.................... int1 usb_cdc_putd(char *ptr, unsigned int8 len)
.................... {
....................  #if USB_EP2_TX_SIZE>=0x100
....................    unsigned int16 i;
....................  #else
....................    unsigned int8 i;
....................  #endif
....................    char c;
....................    
....................    i = 0;
....................    
....................    if (!usb_cdc_put_buffer_free())
....................       return(false);
....................    
....................    while(len--)
....................    {
....................       c = *ptr++;
....................       _usb_cdc_putc_fast_noflush(c);
....................       if (++i >= USB_EP2_TX_SIZE)
....................          break;
....................    }
....................    
....................    usb_cdc_flush_tx_buffer();
....................    
....................    return(true);
.................... }
.................... 
.................... int1 usb_cdc_puts(char *ptr)
.................... {   
....................    unsigned int8 len;
.................... 
....................    len = strlen(ptr);
....................   
....................    return(usb_cdc_putd(ptr, len));
.................... }
.................... 
.................... #endif //__USB_CDC_HELPERS_ONLY__
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... char gethex1_usb() 
.................... {
....................    char digit;
.................... 
....................    digit = usb_cdc_getc();
.................... 
....................    usb_cdc_putc(digit);
.................... 
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((toupper(digit)-'A')+10);
.................... }
.................... 
.................... char gethex_usb() {
....................    unsigned int8 lo,hi;
.................... 
....................    hi = gethex1_usb();
....................    lo = gethex1_usb();
....................    if(lo==0xdd)
....................      return(hi);
....................    else
....................      return( hi*16+lo );
.................... }
.................... 
.................... void get_string_usb(char* s, unsigned int max) {
....................    unsigned int len;
....................    char c;
.................... 
....................    --max;
....................    len=0;
....................    do {
....................      c=usb_cdc_getc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           usb_cdc_putc(c);
....................           usb_cdc_putc(' ');
....................           usb_cdc_putc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<max) {
....................          s[len++]=c;
....................          usb_cdc_putc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... 
.................... 
.................... // stdlib.h is required for the ato_ conversions
.................... // in the following functions
.................... #ifdef _STDLIB
.................... 
.................... signed int get_int_usb() {
....................   char s[7];
....................   signed int i;
.................... 
....................   get_string_usb(s, 7);
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... 
.................... signed long get_long_usb() {
....................   char s[13];
....................   signed long l;
.................... 
....................   get_string_usb(s, 13);
....................   l=atol(s);
....................   return(l);
.................... }
.................... 
.................... float get_float_usb() {
....................   char s[20];
....................   float f;
.................... 
....................   get_string_usb(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #use spi (MASTER, SPI1, ENABLE=PIN_A5, BAUD=10000, MODE=0, BITS=8, STREAM=SPI_1)
.................... 
.................... #byte porta = 0xf80 // Identificador para el puerto A. 
.................... #byte portb = 0xf81 // Identificador para el puerto B. 
.................... #byte portc = 0xf82 // Identificador para el puerto C. 
.................... #byte portd = 0xf83 // Identificador para el puerto D. 
.................... #byte porte = 0xf84 // Identificador para el puerto E.
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlibm.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /*********************************************************************/
.................... #ifndef _STDLIBM
.................... #define _STDLIBM
.................... 
.................... /* Memory Management Functions*/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #if defined(__PCB__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int8 next; }node_t;
.................... #elif defined(__PCM__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCH__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCD__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #endif
.................... 
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY)
....................    #USE DYNAMIC_MEMORY
.................... #endif
.................... 
.................... #ifndef debug_stdlibm
....................    #define debug_stdlibm(s)
.................... #else
....................    #define __DO_DEBUG_STDLIBM
....................    
....................    char g_DebugStdlibmStr[50];
....................    
....................    #if defined(__PCD__)
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__))
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0))
....................       #else
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0))
....................       #endif
....................    #else
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM"))
....................    #endif
.................... #endif
.................... 
.................... #if defined(STDLIBM_TRACK_WORST_CASE)
....................    static size_t _g_StdlibmCurrentBytesUsed = 0;
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0;
....................    
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \
....................       _g_StdlibmCurrentBytesUsed += _x;   \
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed
....................    
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x
.................... #else
....................    #define _STDLIBM_TRACK_WORST_INC(_x)
....................    #define _STDLIBM_TRACK_WORST_DEC(_x)
.................... #endif
.................... 
.................... #include <memmgmt.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__PCH__)
....................  #define _MEMMGMT_CSIZE 32768
....................  #define _MEMMGMT_POS 15
.................... #elif defined(__PCD__)
....................    #define _MEMMGMT_CSIZE 32768
....................    #define _MEMMGMT_POS 15
.................... #else
....................    #define _MEMMGMT_CSIZE 127
....................    #define _MEMMGMT_POS 7
.................... #endif
.................... 
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location
.................... {
....................    node_t *result;
....................    result =ptr;
....................    result->size=size;
....................    result->next = NULL;
....................    return result;
.................... }
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node
.................... {
....................    node->size=size;
.................... }
.................... 
.................... /* Insert node immediately after place */ //old,new
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node
.................... {
....................     if (place->next==NULL)
....................        node->next= NULL;
....................     else
....................        node->next=place->next;
....................     place->next=node;
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void remove_node(node_t *node) {// remove the given node from the memlist
....................    node_t *ptr;
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next);
....................    ptr->next=node->next;
....................    node=NULL;
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__DO_DEBUG_STDLIBM)
.................... void print_list() { // print the current memlist
....................     node_t *node;
....................     debug_stdlibm("\r\nThe list is \n\r");
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next)
....................     {
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next);
....................         debug_stdlibm(g_DebugStdlibmStr);
....................         if (INVALID_MEMORY_LOCATION(node->next))
....................         {
....................            debug_stdlibm("Breaking because of invalid next node\r\n");
....................            break;
....................         }   
....................     }
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t));
....................     debug_stdlibm(g_DebugStdlibmStr);
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void traverse()
.................... {
....................    node_t *node,*temp;
....................    unsigned int16 nsize,nextsize;
....................    node=__DYNAMIC_HEAD;
....................    while(node!=NULL)
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          break;
....................       }   
....................      #endif
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free
....................       {
....................          nsize=node->size;
....................          temp=(unsigned int16)node->next;
....................         #if defined(__DO_DEBUG_STDLIBM)
....................          if (INVALID_MEMORY_LOCATION(temp))
....................          {
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node);
....................             debug_stdlibm(g_DebugStdlibmStr);
....................             break;
....................          }
....................         #endif
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine
....................          {
....................             nextsize=temp->size;
....................             nsize+=nextsize+sizeof(node_t);
....................             remove_node(temp);
....................             update_node(node,nsize);
....................          }
....................          else
....................          node=node->next;
....................       }
....................       else
....................       node=node->next;
....................    }
.................... }
.................... 
.................... char *malloc(size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize;
....................    #if defined(__PCD__)
....................    if (size % 2)
....................       size++;
....................    #endif
....................    node=__DYNAMIC_HEAD;
....................    
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
....................         
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size
....................       {
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................             insert_node_after(node,new);
....................             update_node(node,size+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for mallocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t));
....................       debug_stdlibm(g_DebugStdlibmStr);
....................      #endif
....................       _STDLIBM_TRACK_WORST_INC(size);
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space
....................    }
.................... }
.................... 
.................... char *calloc(size_t nmemb,size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize,resize;
....................    node=__DYNAMIC_HEAD;
....................    resize=nmemb*size;
....................    #if defined(__PCD__)
....................    if(resize%2)
....................       resize++;
....................    #endif
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size
....................       {
....................          nsize=node->size;
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize);
....................             insert_node_after(node,new);
....................             update_node(node,resize+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for callocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0
....................       _STDLIBM_TRACK_WORST_INC(resize);
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space
....................    }
.................... }
.................... void free( void * ptr)
.................... {
....................    node_t *node;
....................    unsigned int16 nsize;
.................... 
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
.................... 
....................    if(ptr==NULL) // not a valid pounsigned int8er
....................       return;
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          update_node(node,nsize);
....................          ptr=NULL;
....................          _STDLIBM_TRACK_WORST_DEC(nsize);
....................       }
....................       else // wrong input, return
....................       {
....................          ptr=NULL;
....................          return;
....................       }
....................    }
....................    traverse();
.................... }
.................... 
.................... char *realloc(void *ptr,size_t size)
.................... {
....................    node_t *node,*new,*temp;
....................    unsigned int16 nsize,nextsize;
....................    char *newptr;
....................    #if defined(__PCD__)
....................    if(size %2)
....................       size++;
....................    #endif
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory
....................       return(malloc(size));
....................    else if(size==0)
....................    {
....................       free(ptr);
....................       return(NULL);
....................    }
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          temp=(unsigned int16)node->next;
....................          if(nsize>size)// block > req size
....................          {
....................        
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   nextsize=temp->size;
....................                   remove_node(temp);
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t));
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else//not enough space for new node so use original size
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block
.................... 
....................          }
....................          else // block < req size
....................          {
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................             {
....................                nextsize=temp->size;
....................                if(nextsize>=size-nsize) // next block >=difference
....................                {
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist
....................                   {
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t));
....................                       insert_node_after(node,new);
....................                      _STDLIBM_TRACK_WORST_DEC(nsize);
....................                      _STDLIBM_TRACK_WORST_INC(size);
....................                   }
....................                   else//not enough space for new node in next node, so use original size
....................                   {
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                   }
....................                }
....................                else  //next block free but too small for new size
....................                {
....................                   newptr = malloc(size);  //use malloc to find new block
....................                   if(newptr == NULL)
....................                      return(NULL);        //return NULL if malloc was unable to find new block
....................                    
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                   free(ptr);                    //free original block
....................                   return(newptr);               //return new pointer
....................                }
....................             }
....................             else  //next block not free
....................             {
....................                newptr = malloc(size);  //use malloc to find new block
....................                if(newptr == NULL)      
....................                   return(NULL);        //return NULL if malloc was unable to find new block
....................                
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                free(ptr);                    //free original block
....................                return(newptr);               //return new pointer
....................             }
....................          }
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block
....................       }
....................       else // not allocated use malloc
....................       {
....................          return(malloc(size));
....................       }
....................    }
....................  }
....................  
.................... typedef struct
.................... {
....................    size_t bytesUsed;
....................    size_t largestUsedSeg;
....................    int segmentsUsed;
....................    size_t bytesFree;
....................    size_t largestFreeSeg;
....................    int segmentsFree;
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    size_t worstCaseBytesUsed;
....................   #endif
.................... } heap_status_t;
.................... 
.................... void GetHeapStatus(heap_status_t *pHeapStatus)
.................... {
....................    heap_status_t status;
....................    node_t *node;
....................    unsigned int16 nsize;
....................    
....................    node=__DYNAMIC_HEAD;
....................    
....................    memset(&status, 0, sizeof(status));
.................... 
....................    while(node!=NULL)
....................    {
....................       nsize = node->size;
....................       node = node->next;
....................       
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free
....................       {
....................          status.bytesFree += nsize;
....................          
....................          status.segmentsFree++;
....................          
....................          if (nsize > status.largestFreeSeg)
....................          {
....................             status.largestFreeSeg = nsize;
....................          }
....................       }
....................       else
....................       {
....................          bit_clear(nsize, _MEMMGMT_POS);
....................          
....................          status.bytesUsed += nsize;
....................          
....................          status.segmentsUsed++;
....................          
....................          if (nsize > status.largestUsedSeg)
....................          {
....................             status.largestUsedSeg = nsize;
....................          }
....................       }
....................    }
.................... 
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed;
....................   #endif
.................... 
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t));
.................... }
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include <adafruit_rfm69_registers.h>
.................... 
.................... //Internal constants:
.................... #define _REG_FIFO 0x00
.................... #define _REG_OP_MODE 0x01
.................... #define _REG_DATA_MOD 0x02
.................... #define _REG_BITRATE_MSB 0x03
.................... #define _REG_BITRATE_LSB 0x04
.................... #define _REG_FDEV_MSB 0x05
.................... #define _REG_FDEV_LSB 0x06
.................... #define _REG_FRF_MSB 0x07
.................... #define _REG_FRF_MID 0x08
.................... #define _REG_FRF_LSB 0x09
.................... #define _REG_VERSION 0x10
.................... #define _REG_PA_LEVEL 0x11
.................... #define _REG_RX_BW 0x19
.................... #define _REG_AFC_BW 0x1A
.................... #define _REG_RSSI_VALUE 0x24
.................... #define _REG_DIO_MAPPING1 0x25
.................... #define _REG_IRQ_FLAGS1 0x27
.................... #define _REG_IRQ_FLAGS2 0x28
.................... #define _REG_PREAMBLE_MSB 0x2C
.................... #define _REG_PREAMBLE_LSB 0x2D
.................... #define _REG_SYNC_CONFIG 0x2E
.................... #define _REG_SYNC_VALUE1 0x2F
.................... #define _REG_PACKET_CONFIG1 0x37
.................... #define _REG_FIFO_THRESH 0x3C
.................... #define _REG_PACKET_CONFIG2 0x3D
.................... #define _REG_AES_KEY1 0x3E
.................... #define _REG_TEMP1 0x4E
.................... #define _REG_TEMP2 0x4F
.................... #define _REG_TEST_PA1 0x5A
.................... #define _REG_TEST_PA2 0x5C
.................... #define _REG_TEST_DAGC 0x6F
.................... 
.................... #define _TEST_PA1_NORMAL 0x55
.................... #define _TEST_PA1_BOOST 0x5D
.................... #define _TEST_PA2_NORMAL 0x70
.................... #define _TEST_PA2_BOOST 0x7C
.................... 
.................... //The crystal oscillator frequency and frequency synthesizer step size.
.................... //See the datasheet for details of this calculation.
.................... 
.................... //        #define _FXOSC = 32000000.0
.................... //        #define _FSTEP = _FXOSC / 524288
.................... 
.................... //RadioHead specific compatibility constants.
.................... #define _RH_BROADCAST_ADDRESS 0xFF
.................... //The acknowledgement bit in the FLAGS
.................... //The top 4 bits of the flags are reserved for RadioHead. The lower 4 bits are reserved
.................... //for application layer use.
.................... #define _RH_FLAGS_ACK 0x80
.................... #define _RH_FLAGS_RETRY 0x40
.................... 
.................... //User facing constants:
.................... #define SLEEP_MODE 0b000
.................... #define STANDBY_MODE 0b001
.................... #define FS_MODE 0b010
.................... #define TX_MODE 0b011
.................... #define RX_MODE 0b100
.................... //supervisor.ticks_ms() contants
.................... //          #define _TICKS_PERIOD = const(1 << 29)
.................... //          #define _TICKS_MAX = const(_TICKS_PERIOD - 1)
.................... //          #define _TICKS_HALFPERIOD = const(_TICKS_PERIOD // 2)
.................... 
.................... #include <utils.h>
.................... //Global buffer for SPI commands
.................... uint8_t _BUFFER[4];
.................... 
.................... void setOutput(int pin, int value){
....................     output_bit(pin,value);
*
14E0:  MOVLB  1
14E2:  MOVF   x8C,F
14E4:  BNZ   14EA
14E6:  MOVLW  00
14E8:  BRA    14EC
14EA:  MOVLW  01
14EC:  MOVFF  18B,18D
14F0:  MOVWF  x8E
14F2:  MOVLW  0F
14F4:  MOVWF  x90
14F6:  MOVLW  89
14F8:  MOVWF  x8F
14FA:  MOVLB  0
14FC:  RCALL  149E
14FE:  MOVFF  18B,18D
1502:  MOVLB  1
1504:  CLRF   x8E
1506:  MOVLW  0F
1508:  MOVWF  x90
150A:  MOVLW  92
150C:  MOVWF  x8F
150E:  MOVLB  0
1510:  RCALL  149E
1512:  RETURN 0
.................... }
.................... void usbPrint(char* str){
....................       usb_task();  //Verifica la comunicacin USB
*
1468:  RCALL  135E
....................       if(usb_enumerated()) {
146A:  RCALL  132A
146C:  MOVF   01,F
146E:  BZ    147A
....................          printf(usb_cdc_putc,str); 
1470:  MOVFF  19A,FEA
1474:  MOVFF  199,FE9
1478:  BRA    1442
....................       }
147A:  RETURN 0
.................... }
.................... 
.................... void spiBegin(){
.................... //SPI.beginTransaction(SPISettings(SPIBAUD, MSBFIRST, SPI_MODE0));
.................... setOutput(SSPin, 0);
*
1514:  MOVLW  05
1516:  MOVLB  1
1518:  MOVWF  x8B
151A:  CLRF   x8C
151C:  MOVLB  0
151E:  RCALL  14E0
1520:  GOTO   1564 (RETURN)
.................... 
.................... }
.................... void spiEnd(){
.................... setOutput(SSPin, 1);    
*
154C:  MOVLW  05
154E:  MOVLB  1
1550:  MOVWF  x8B
1552:  MOVLW  01
1554:  MOVWF  x8C
1556:  MOVLB  0
1558:  RCALL  14E0
155A:  RETURN 0
.................... //SPI.endTransaction();
.................... }
.................... 
.................... void print(char* str){
....................     //Serial.print(str);
....................     usbPrint(str);
*
16CA:  MOVFF  188,19A
16CE:  MOVFF  187,199
16D2:  RCALL  1468
16D4:  RETURN 0
.................... }
.................... 
.................... void print(int str, int format){
....................     char converted[11];
....................     int i;
....................     if (format == HEX) sprintf(converted,"0x%02X",str);
*
1632:  MOVLB  1
1634:  MOVF   x8C,W
1636:  SUBLW  10
1638:  BNZ   166C
163A:  MOVLW  01
163C:  MOVLB  0
163E:  MOVWF  xC1
1640:  MOVLW  8D
1642:  MOVWF  xC0
1644:  MOVLW  30
1646:  MOVLB  1
1648:  MOVWF  x9B
164A:  MOVLB  0
164C:  RCALL  15CC
164E:  MOVLW  78
1650:  MOVLB  1
1652:  MOVWF  x9B
1654:  MOVLB  0
1656:  RCALL  15CC
1658:  MOVFF  18B,199
165C:  MOVLW  37
165E:  MOVLB  1
1660:  MOVWF  x9A
1662:  MOVLB  0
1664:  BRA    15EA
1666:  MOVLB  0
1668:  BRA    16BA
166A:  MOVLB  1
....................     else if (format == BIN){
166C:  MOVF   x8C,W
166E:  SUBLW  02
1670:  BNZ   16B8
....................     //Conversion manual
....................     converted[0] = '0';
1672:  MOVLW  30
1674:  MOVWF  x8D
....................     converted[1] = 'b';
1676:  MOVLW  62
1678:  MOVWF  x8E
....................     for (i=0;i<8;i++){
167A:  CLRF   x98
167C:  MOVF   x98,W
167E:  SUBLW  07
1680:  BNC   16B6
....................     converted[i+2] = ((str >> (7-i)) & 0x01) + '0';
1682:  MOVLW  02
1684:  ADDWF  x98,W
1686:  CLRF   03
1688:  ADDLW  8D
168A:  MOVWF  FE9
168C:  MOVLW  01
168E:  ADDWFC 03,W
1690:  MOVWF  FEA
1692:  MOVLW  07
1694:  BSF    FD8.0
1696:  SUBFWB x98,W
1698:  MOVWF  01
169A:  MOVFF  18B,00
169E:  MOVF   01,F
16A0:  BZ    16AA
16A2:  BCF    FD8.0
16A4:  RRCF   00,F
16A6:  DECFSZ 01,F
16A8:  BRA    16A2
16AA:  MOVF   00,W
16AC:  ANDLW  01
16AE:  ADDLW  30
16B0:  MOVWF  FEF
16B2:  INCF   x98,F
16B4:  BRA    167C
....................     }
....................     converted[10] = '\0';
16B6:  CLRF   x97
16B8:  MOVLB  0
....................     }
....................     usbPrint(converted);
16BA:  MOVLW  01
16BC:  MOVLB  1
16BE:  MOVWF  x9A
16C0:  MOVLW  8D
16C2:  MOVWF  x99
16C4:  MOVLB  0
16C6:  RCALL  1468
16C8:  RETURN 0
....................     //Serial.print(str,format);
.................... }
.................... void println(char* str){
....................     usbPrint(str);
*
147C:  MOVFF  188,19A
1480:  MOVFF  187,199
1484:  RCALL  1468
....................     usbPrint((char*)"\n");
1486:  MOVLW  0A
1488:  MOVLB  1
148A:  MOVWF  x89
148C:  CLRF   x8A
148E:  MOVLW  01
1490:  MOVWF  x9A
1492:  MOVLW  89
1494:  MOVWF  x99
1496:  MOVLB  0
1498:  RCALL  1468
149A:  GOTO   1726 (RETURN)
....................     //Serial.println(str);
.................... }
.................... void println(int str, int format){
....................     print(str,format);
*
16D6:  MOVFF  186,18B
16DA:  MOVFF  187,18C
16DE:  RCALL  1632
....................     usbPrint((char*)"\n");
16E0:  MOVLW  0A
16E2:  MOVLB  1
16E4:  MOVWF  x88
16E6:  CLRF   x89
16E8:  MOVLW  01
16EA:  MOVWF  x9A
16EC:  MOVLW  88
16EE:  MOVWF  x99
16F0:  MOVLB  0
16F2:  RCALL  1468
16F4:  GOTO   17A0 (RETURN)
....................     //Serial.println(str,format);
.................... }
.................... float timeSec(){
....................    //TODO: implementar timers
....................    return 0;
....................     //return millis()/1000;
.................... }
.................... void spi_read_into(uint8_t address,uint8_t* array, uint8_t length){
*
155C:  MOVLB  1
155E:  CLRF   x8A
....................     int i=0;
....................     //Select
....................     spiBegin();
1560:  MOVLB  0
1562:  BRA    1514
....................     _BUFFER[0] = address & 0x7F; //Strip MSB byte to read
1564:  MOVLB  1
1566:  MOVF   x86,W
1568:  ANDLW  7F
156A:  MOVLB  0
156C:  MOVWF  xBC
....................     //Write address
....................     spi_write(_BUFFER[0]);
156E:  MOVF   FC9,W
1570:  MOVFF  BC,FC9
1574:  RRCF   FC7,W
1576:  BNC   1574
....................     delay_us(100);  // Tiempo para que el esclavo responda
1578:  MOVLW  64
157A:  MOVLB  1
157C:  MOVWF  x8B
157E:  MOVLB  0
1580:  BRA    1524
....................     for (i=0;i<length;i++)
1582:  MOVLB  1
1584:  CLRF   x8A
1586:  MOVF   x89,W
1588:  SUBWF  x8A,W
158A:  BC    15A8
....................         array[i] = spi_read(0xFF);
158C:  MOVF   x8A,W
158E:  ADDWF  x87,W
1590:  MOVWF  FE9
1592:  MOVLW  00
1594:  ADDWFC x88,W
1596:  MOVWF  FEA
1598:  MOVF   FC9,W
159A:  SETF   FC9
159C:  RRCF   FC7,W
159E:  BNC   159C
15A0:  MOVFF  FC9,FEF
15A4:  INCF   x8A,F
15A6:  BRA    1586
....................     spiEnd();
15A8:  MOVLB  0
15AA:  RCALL  154C
15AC:  GOTO   15C4 (RETURN)
.................... 
.................... }
.................... void spi_write_from(uint8_t address,uint8_t* array, uint8_t length){
....................     int i=0;
....................     spiBegin();
....................     spi_write(address | 0b10000000);
....................     //El address se aumenta en 1 automaticamente
....................    //Serial.println("Writing SPI");
....................     for (i=0;i<length;i++){
....................       // Serial.println((char)array[i]);
....................       spi_write(array[i]);}
....................     spiEnd();    
.................... }
.................... uint8_t spi_read_u8(uint8_t address){
....................     spi_read_into(address,_BUFFER,1);
15B0:  MOVFF  185,186
15B4:  MOVLB  1
15B6:  CLRF   x88
15B8:  MOVLW  BC
15BA:  MOVWF  x87
15BC:  MOVLW  01
15BE:  MOVWF  x89
15C0:  MOVLB  0
15C2:  BRA    155C
....................     return _BUFFER[0];
15C4:  MOVFF  BC,01
15C8:  GOTO   173A (RETURN)
.................... }
.................... uint8_t spi_write_u8(uint8_t address,uint8_t val){
....................     _BUFFER[0] = val;
....................     spi_write_from(address,_BUFFER,1);
....................     return _BUFFER[0];
.................... }
.................... void sleep_ms(int ms){
....................     delay_ms(ms);
.................... }
.................... 
.................... #include <afadruit_rfm69.h>
.................... 
.................... // # The crystal oscillator frequency and frequency synthesizer step size.
.................... // # See the datasheet for details of this calculation.
.................... const float _FXOSC = 32000000.0;
.................... const float _FSTEP = _FXOSC / 524288;
.................... 
.................... void readAllRegs();
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL);
.................... void reset();
.................... void set_boost(uint8_t setting);
.................... void idle();
.................... void rfm_sleep();
.................... void listen();
.................... void transmit();
.................... float temperature_get();
.................... uint8_t operation_mode_get();
.................... void operation_mode_set(uint8_t val);
.................... uint8_t* sync_word_get();
.................... void sync_word_set(uint8_t* wrd);
.................... uint16_t preamble_length_get();
.................... void preamble_length_set(uint16_t val);
.................... float frequency_mhz_get();
.................... void frequency_mhz_set();
.................... uint8_t* encryption_key_get();
.................... void encryption_key_set(uint8_t* val);
.................... int8_t tx_power_get();
.................... void tx_power_set(int8_t val);
.................... float rssi_get();
.................... float bitrate_get();
.................... void bitrate_set(float val);
.................... float frequency_deviation_get();
.................... void frequency_deviation_set(float val);
.................... bool packet_sent();
.................... bool payload_ready();
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256);
.................... bool send_with_ack(uint8_t* data,uint8_t len);
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false);
.................... 
.................... struct _RegisterBits{
.................... uint8_t address;
.................... uint8_t mask;
.................... uint8_t offset;
.................... };
.................... 
.................... void set(uint8_t val,struct _RegisterBits obj){
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         regVal &= ~obj.mask;
....................         regVal |= (val & 0xFF) << obj.offset;
....................         spi_write_u8(obj.address,regVal);
.................... }
.................... uint8_t get(struct _RegisterBits obj){
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         return ((regVal & obj.mask) >> obj.offset);
....................     }
.................... uint8_t _debug_(struct _RegisterBits obj){
....................       print ((char*)"Mask: ");
....................       println(obj.mask,BIN);
....................       return obj.mask; 
.................... }
.................... 
.................... struct _RegisterBits _RegisterBits_(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
*
12BE:  MOVLB  1
12C0:  CLRF   x72
.................... 
....................         uint8_t i=0;
....................         struct _RegisterBits ret;
....................         ret.mask=0;
12C2:  CLRF   x74
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         ret.address = _address;
12C4:  MOVFF  16F,173
....................         for (i=0;i<bits;i++){
12C8:  CLRF   x72
12CA:  MOVF   x71,W
12CC:  SUBWF  x72,W
12CE:  BC    12DA
....................             ret.mask<<=1;
12D0:  BCF    FD8.0
12D2:  RLCF   x74,F
....................             ret.mask|=1;
12D4:  BSF    x74.0
12D6:  INCF   x72,F
12D8:  BRA    12CA
....................         }
....................         ret.mask <<= _offset;
12DA:  MOVF   x70,W
12DC:  MOVWF  01
12DE:  BZ    12E8
12E0:  BCF    FD8.0
12E2:  RLCF   x74,F
12E4:  DECFSZ 01,F
12E6:  BRA    12E0
....................         ret.offset = _offset;
12E8:  MOVFF  170,175
....................         return ret;
12EC:  MOVFF  173,01
12F0:  MOVFF  174,02
12F4:  MOVFF  175,03
12F8:  MOVLB  0
12FA:  RETURN 0
....................  }
....................  
.................... /*
.................... class _RegisterBits{
....................     public:
....................     uint8_t address;
....................     uint8_t mask;
....................     uint8_t offset;
....................     _RegisterBits(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
....................         uint8_t i=0;
....................         mask=0;
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         address = _address;
....................         for (i=0;i<bits;i++){
....................             mask<<=1;
....................             mask|=1;
....................         }
....................         mask <<= _offset;
....................         offset = _offset;
....................         }
....................     void set(uint8_t val){
....................         uint8_t regVal = spi_read_u8(address);
....................         regVal &= ~mask;
....................         regVal |= (val & 0xFF) << offset;
....................         spi_write_u8(address,regVal);
....................     }
....................     uint8_t get(){
....................         uint8_t regVal = spi_read_u8(address);
....................         return ((regVal & mask) >> offset);
....................     }
....................    
....................   
....................     }
.................... };
.................... */
.................... 
....................     
.................... //Configuraciones que solo utilizan ciertos bits   
.................... struct _RegisterBits data_mode = _RegisterBits_(_REG_DATA_MOD, 5, 2);
.................... struct _RegisterBits modulation_type = _RegisterBits_(_REG_DATA_MOD, 3, 2);
.................... struct _RegisterBits modulation_shaping = _RegisterBits_(_REG_DATA_MOD, 0, 2);
.................... struct _RegisterBits temp_start = _RegisterBits_(_REG_TEMP1, 3);
.................... struct _RegisterBits temp_running = _RegisterBits_(_REG_TEMP1, 2);
.................... struct _RegisterBits sync_on = _RegisterBits_(_REG_SYNC_CONFIG, 7);
.................... struct _RegisterBits sync_size = _RegisterBits_(_REG_SYNC_CONFIG, 3, 3);
.................... struct _RegisterBits aes_on = _RegisterBits_(_REG_PACKET_CONFIG2, 0);
.................... struct _RegisterBits pa_0_on = _RegisterBits_(_REG_PA_LEVEL, 7);
.................... struct _RegisterBits pa_1_on = _RegisterBits_(_REG_PA_LEVEL, 6);
.................... struct _RegisterBits pa_2_on = _RegisterBits_(_REG_PA_LEVEL, 5);
.................... struct _RegisterBits output_power = _RegisterBits_(_REG_PA_LEVEL, 0, 5);
.................... struct _RegisterBits rx_bw_dcc_freq = _RegisterBits_(_REG_RX_BW, 5, 3);
.................... struct _RegisterBits rx_bw_mantissa = _RegisterBits_(_REG_RX_BW, 3, 2);
.................... struct _RegisterBits rx_bw_exponent = _RegisterBits_(_REG_RX_BW, 0, 3);
.................... struct _RegisterBits afc_bw_dcc_freq = _RegisterBits_(_REG_AFC_BW, 5, 3);
.................... struct _RegisterBits afc_bw_mantissa = _RegisterBits_(_REG_AFC_BW, 3, 2);
.................... struct _RegisterBits afc_bw_exponent = _RegisterBits_(_REG_AFC_BW, 0, 3);
.................... struct _RegisterBits packet_format = _RegisterBits_(_REG_PACKET_CONFIG1, 7, 1);
.................... struct _RegisterBits dc_free = _RegisterBits_(_REG_PACKET_CONFIG1, 5, 2);
.................... struct _RegisterBits crc_on = _RegisterBits_(_REG_PACKET_CONFIG1, 4, 1);
.................... struct _RegisterBits crc_auto_clear_off = _RegisterBits_(_REG_PACKET_CONFIG1, 3, 1);
.................... struct _RegisterBits address_filter = _RegisterBits_(_REG_PACKET_CONFIG1, 1, 2);
.................... struct _RegisterBits mode_ready = _RegisterBits_(_REG_IRQ_FLAGS1, 7);
.................... struct _RegisterBits dio_0_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 6, 2);
.................... struct _RegisterBits dio_1_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 4, 2);
.................... struct _RegisterBits dio_2_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 2, 2);
.................... struct _RegisterBits dio_3_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 0, 2);
.................... struct _RegisterBits dio_4_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 6, 2);
.................... struct _RegisterBits dio_5_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 4, 2);
.................... 
.................... //Extras
.................... int8_t _tx_power;
.................... int8_t tx_power;
.................... bool high_power;
.................... uint8_t* sync_word;
.................... uint16_t preamble_length;
.................... uint32_t frequency_mhz;
.................... float bitrate;
.................... float rssi;
.................... float last_rssi;
.................... float ack_wait;
.................... float receive_timeout;
.................... float xmit_timeout;
.................... uint8_t ack_retries;
.................... float ack_delay;
.................... uint8_t sequence_number;
.................... uint8_t seen_ids[8];
.................... uint8_t node;
.................... uint8_t destination;
.................... uint8_t identifier;
.................... uint8_t flags;
.................... uint8_t operation_mode;
.................... float temperature;
.................... uint8_t encryption_key[16];
.................... float frequency_deviation;
.................... int _reset_pin;
.................... 
.................... 
.................... void readAllRegs()
.................... {
....................   uint8_t regVal;
....................   
....................   println((char*)"Address - HEX - BIN");
*
16F8:  MOVLW  01
16FA:  MOVWF  FEA
16FC:  MOVLW  70
16FE:  MOVWF  FE9
1700:  MOVLW  14
1702:  MOVWF  01
1704:  CLRF   FF7
1706:  MOVLW  00
1708:  CALL   022A
170C:  TBLRD*-
170E:  TBLRD*+
1710:  MOVFF  FF5,FEE
1714:  DECFSZ 01,F
1716:  BRA    170E
1718:  MOVLW  01
171A:  MOVLB  1
171C:  MOVWF  x88
171E:  MOVLW  70
1720:  MOVWF  x87
1722:  MOVLB  0
1724:  BRA    147C
....................   for (uint8_t regAddr = 1; regAddr <= 0x4F; regAddr++)
1726:  MOVLW  01
1728:  MOVLB  1
172A:  MOVWF  x84
172C:  MOVF   x84,W
172E:  SUBLW  4F
1730:  BNC   17A6
....................   {
....................     /*
....................     spiBegin();
....................     SPI.transfer(regAddr & 0x7F); // send address + r/w bit
....................     regVal = SPI.transfer(0);
....................     spiEnd();*/
....................     regVal = spi_read_u8(regAddr);
1732:  MOVFF  184,185
1736:  MOVLB  0
1738:  BRA    15B0
173A:  MOVFF  01,16F
....................     print(regAddr, HEX);
173E:  MOVFF  184,18B
1742:  MOVLW  10
1744:  MOVLB  1
1746:  MOVWF  x8C
1748:  MOVLB  0
174A:  RCALL  1632
....................     print((char*)" - ");
174C:  MOVLW  20
174E:  MOVLB  1
1750:  MOVWF  x70
1752:  MOVLW  2D
1754:  MOVWF  x71
1756:  MOVLW  20
1758:  MOVWF  x72
175A:  CLRF   x73
175C:  MOVLW  01
175E:  MOVWF  x88
1760:  MOVLW  70
1762:  MOVWF  x87
1764:  MOVLB  0
1766:  RCALL  16CA
....................     print(regVal,HEX);
1768:  MOVFF  16F,18B
176C:  MOVLW  10
176E:  MOVLB  1
1770:  MOVWF  x8C
1772:  MOVLB  0
1774:  RCALL  1632
....................     print((char*)" - ");
1776:  MOVLW  20
1778:  MOVLB  1
177A:  MOVWF  x70
177C:  MOVLW  2D
177E:  MOVWF  x71
1780:  MOVLW  20
1782:  MOVWF  x72
1784:  CLRF   x73
1786:  MOVLW  01
1788:  MOVWF  x88
178A:  MOVLW  70
178C:  MOVWF  x87
178E:  MOVLB  0
1790:  RCALL  16CA
....................     println(regVal,BIN);
1792:  MOVFF  16F,186
1796:  MOVLW  02
1798:  MOVLB  1
179A:  MOVWF  x87
179C:  MOVLB  0
179E:  BRA    16D6
17A0:  MOVLB  1
17A2:  INCF   x84,F
17A4:  BRA    172C
....................   }
....................   spiEnd();
17A6:  MOVLB  0
17A8:  RCALL  154C
17AA:  GOTO   1C0E (RETURN)
.................... }    
.................... 
.................... 
.................... 
.................... 
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL){
....................     uint8_t version=0;
....................     //Serial.println("Initial conf starts");
....................     //Serial.println("HOLA 2");
....................     _tx_power = 13;
....................     _reset_pin = resetPin;
....................     high_power = _high_power;
....................     reset();
....................     //readAllRegs();
....................     
....................     version = spi_read_u8(_REG_VERSION);
....................     if (version != 0x24){
....................         println((char*)"Error: ID del RFM incorrecta");
....................         while(1){}
....................         //exit(-1);
....................     }
....................     idle();
....................     //Chip setup
....................     //Set FIFO TX condition to not empty and the default FIFO threshold to 15.
....................     spi_write_u8(_REG_FIFO_THRESH, 0b10001111);
....................     //Configure low beta off.
....................     spi_write_u8(_REG_TEST_DAGC, 0x30);
....................     //Disable boost.
....................     spi_write_u8(_REG_TEST_PA1, _TEST_PA1_NORMAL);
....................     spi_write_u8(_REG_TEST_PA2, _TEST_PA2_NORMAL);
....................     //set sync word
....................     //IMPORTANTE: Recuerda alocar el espacio para que no se sobreescriba
....................     sync_word_set( _sync_word); 
....................     preamble_length_set(_preamble_length);
....................     frequency_mhz_set(); 
....................     //TODO: set encryption key
....................     //encryption_key = encrypt;
....................     //encryption_key_set(encrypt);
....................     
....................     //PARA USUARIOS AVANZADOS ----------------------------------------------------------------------------------------------
....................     // Configure modulation for RadioHead library GFSK_Rb250Fd250 mode
....................     // by default.  Users with advanced knowledge can manually reconfigure
....................     // for any other mode (consulting the datasheet is absolutely
....................     // necessary!).
....................     bitrate_set(250000);  // 250kbs
....................     frequency_deviation_set(250000);  // 250khz
....................     set(0b01,modulation_shaping);  // Gaussian filter, BT=1.0
....................     set(0b111,rx_bw_dcc_freq);  // RxBw register = 0xE0
....................     set(0b00,rx_bw_mantissa);
....................     set(0b000,rx_bw_exponent);
....................     set(0b111,afc_bw_dcc_freq); // AfcBw register = 0xE0
....................     set(0b00,afc_bw_mantissa);
....................     set(0b000,afc_bw_exponent);
....................     set(1,packet_format);  // Variable length.
....................     set(0b10,dc_free);  // Whitening
....................     //-----------------------------------------------------------------------------------------------------------------------
....................     // Set transmit power to 13 dBm, a safe value any module supports.
....................     tx_power_set(13);
....................     //
....................     // initialize last RSSI reading
....................     last_rssi = 0.0;
....................     // """The RSSI of the last received packet. Stored when the packet was received.
....................     //    This instantaneous RSSI value may not be accurate once the
....................     //    operating mode has been changed.
....................     // """
....................     // initialize timeouts and delays delays
....................     ack_wait = 0.5;
....................     // """The delay time before attempting a retry after not receiving an ACK"""
....................     receive_timeout = 0.5;
....................     // """The amount of time to poll for a received packet.
....................     //    If no packet is received, the returned packet will be None
....................     // """
....................     xmit_timeout = 2.0;
....................     // """The amount of time to wait for the HW to transmit the packet.
....................     //    This is mainly used to prevent a hang due to a HW issue
....................     // """
....................     ack_retries = 5;
....................     // """The number of ACK retries before reporting a failure."""
....................     ack_delay = 0;
....................     // """The delay time before attemting to send an ACK.
....................     //    If ACKs are being missed try setting this to .1 or .2.
....................     // """
....................     //print("<------------------------------------------------------------------------------------------------------------------------------------------>")
....................     // initialize sequence number counter for reliabe datagram mode
....................     sequence_number = 0;
....................     // create seen Ids list
....................     //seen_ids = {0};
....................     // initialize packet header
....................     // node address - default is broadcast
....................     node = _RH_BROADCAST_ADDRESS;
....................     // """The default address of this Node. (0-255).
....................     //    If not 255 (0xff) then only packets address to this node will be accepted.
....................     //    First byte of the RadioHead header.
....................     // """
....................     // destination address - default is broadcast
....................     destination = _RH_BROADCAST_ADDRESS;
....................     // """The default destination address for packet transmissions. (0-255).
....................     //    If 255 (0xff) then any receiving node should accept the packet.
....................     //    Second byte of the RadioHead header.
....................     // """
....................     // ID - contains seq count for reliable datagram mode
....................     identifier = 0;
....................     // """Automatically set to the sequence number when send_with_ack() used.
....................     //    Third byte of the RadioHead header.
....................     // """
....................     // flags - identifies ack/reetry packet for reliable datagram mode
....................     flags = 0;
....................     // """Upper 4 bits reserved for use by Reliable Datagram Mode.
....................     //    Lower 4 bits may be used to pass information.
....................     //    Fourth byte of the RadioHead header.
....................     // """
....................     //Extras: paara algunos registros que no coinciden con la libreria del micropython
....................     // RSSI_CONFIG: 0x2
....................     spi_write_u8(0x23,0x02);
....................     //_REG_DIO_MAPPING1
....................     spi_write_u8(_REG_DIO_MAPPING1,0x00);
....................     //101  FXOSC / 32
....................     spi_write_u8(_REG_DIO_MAPPING1+1,0b101);
....................     //RSSI_THRESH
....................     spi_write_u8(0x29,0xFF);
....................     //INIT payload length to 0
....................     spi_write_u8(0x38,0x40);
....................     //AutoRxRestartOn
....................     spi_write_u8(_REG_PACKET_CONFIG2,0x02);
....................     //Con esto se puede colocar un LED en DIO2 y ver los datos que se reciben y se envian
....................     set(0b01,dio_2_mapping);
....................     //Asi se puede saber si el buffer FIFO tiene algun dato
....................     set(0b10,dio_1_mapping);
....................     //En modo rx, da informacion acerca del RSSI (Recieved Signal Strength Indicator)
....................     set(0b01,dio_3_mapping);
....................     print((char*)"Initial configuration end\n");
.................... }
.................... void reset(){
....................     setOutput(_reset_pin,1);
....................     sleep_ms(1);
....................     setOutput(_reset_pin,0);
....................     sleep_ms(5);
.................... }
.................... void set_boost(uint8_t setting){
....................     //Set preamp boost if needed.
....................     if (_tx_power >= 18){
....................         spi_write_u8(_REG_TEST_PA1, setting);
....................         spi_write_u8(_REG_TEST_PA2, setting);
....................     }
.................... }
.................... void idle(){
....................     //Enter idle standby mode (switching off high power amplifiers if necessary).
....................     //Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
....................     operation_mode_set(STANDBY_MODE);
....................            
.................... }
.................... void rfm_sleep(){
....................     operation_mode_set(SLEEP_MODE); 
.................... }
.................... void listen(){
....................     //Listen for packets to be received by the chip.  Use :py:func:`receive` to listen, wait
....................     //and retrieve packets as they're available.
....................     
....................     // Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
....................     // Enable payload ready interrupt for D0 line.
....................     set(0b01,dio_0_mapping);
....................     // Enter RX mode (will clear FIFO!).
....................     //Serial.println("HOLAAA");        
....................     operation_mode_set(RX_MODE); 
.................... }
.................... void transmit(){
....................     // Transmit a packet which is queued in the FIFO.  This is a low level function for
....................     // entering transmit mode and more.  For generating and transmitting a packet of data use
....................     // :py:func:`send` instead.
....................     
....................     // # Like RadioHead library, turn on high power boost if enabled.
....................     set_boost(_TEST_PA1_BOOST);
....................     // # Enable packet sent interrupt for D0 line.
....................     set(0b00,dio_0_mapping);
....................     //readAllRegs(); 
....................     // # Enter TX mode (will clear FIFO!).
....................     operation_mode_set(TX_MODE);  
.................... }
.................... // .. warning:: Reading this will STOP any receiving/sending that might be happening!
.................... //WARNING:LOOP infinito
.................... float temperature_get(){
....................     // The internal temperature of the chip in degrees Celsius. Be warned this is not
....................     // calibrated or very accurate.
....................     // .. warning:: Reading this will STOP any receiving/sending that might be happening!
....................     // # Start a measurement then poll the measurement finished bit.
....................     set(1,temp_start);
....................     //WARNING:LOOP infinito
....................     while (get(temp_running) > 0){}
....................     temperature = 166.0 - (float)spi_read_u8(_REG_TEMP2);
....................     return temperature;
.................... }
.................... uint8_t operation_mode_get(){
....................     // """The operation mode value.  Unless you're manually controlling the chip you shouldn't
....................     // change the operation_mode with this property as other side-effects are required for
....................     // changing logical modes--use :py:func:`idle`, :py:func:`sleep`, :py:func:`transmit`,
....................     // :py:func:`listen` instead to signal intent for explicit logical modes.
....................     // """
....................     operation_mode = (spi_read_u8(_REG_OP_MODE) >> 2) &0b111;
....................     return operation_mode;
.................... }
.................... void operation_mode_set(uint8_t val){
....................     float start;
....................     //TODO: assert 0 <= val <= 4
....................     start = timeSec();
....................     while (!get(mode_ready)){
....................       
....................         if ((timeSec() - start) >= 3){
....................                  
....................             print ((char*)"Operation Mode couldnt be set\n");
....................             println(spi_read_u8(0x27),BIN);
....................             while (1){}
....................             //exit(-2);
....................         }
....................     }      
....................     // Set the mode bits inside the operation mode register.
....................     operation_mode = spi_read_u8(_REG_OP_MODE);
....................     operation_mode &= 0b11100011;
....................     operation_mode |= val << 2;
....................     //Serial.println(operation_mode,BIN);
....................     spi_write_u8(_REG_OP_MODE,operation_mode);
....................    
....................     // Wait for mode to change by polling interrupt bit.
....................     start = timeSec();
....................     while (!get(mode_ready)){
....................         if ((timeSec() - start) >= 3){
....................             print ((char*)"Timeout on Operation Mode Set\n");
....................             println(spi_read_u8(_REG_OP_MODE),BIN)  ;      
....................             while (1){}
....................             //exit(-2);
....................         }
....................     }
.................... }
.................... //WARNING must free allocated memory after using
.................... uint8_t* sync_word_get(){
....................     
....................     // """The synchronization word value.  This is a byte string up to 8 bytes long (64 bits)
....................     // which indicates the synchronization word for transmitted and received packets. Any
....................     // received packet which does not include this sync word will be ignored. The default value
....................     // is 0x2D, 0xD4 which matches the RadioHead RFM69 library. Setting a value of None will
....................     // disable synchronization word matching entirely.
....................     // """
....................     // # Handle when sync word is disabled..
....................     if (!get(sync_on))return NULL;
....................     //WARNING must free allocated memory after using
....................     sync_word = (uint8_t*)malloc(get(sync_size)+2);
....................     sync_word[0] = get(sync_size)+1;
....................     spi_read_into(_REG_SYNC_VALUE1,sync_word+1,get(sync_size)+1);
....................     return sync_word;
.................... }
.................... void sync_word_set(uint8_t* wrd){
....................   uint8_t len = wrd[0];
....................     if (len == 0 || wrd == NULL)set(0,sync_on);
....................     
....................     else{
....................         //TODO: assert 1 <= len(val) <= 8
....................         spi_write_from(_REG_SYNC_VALUE1,wrd+1,len);
....................         //Sync_size: len(SYNC_WORD) - 1
....................         set(len-1,sync_size);
....................         set(1,sync_on);
....................     }
.................... }
.................... uint16_t preamble_length_get(){
....................     // The length of the preamble for sent and received packets, an unsigned 16-bit value.
....................     // Received packets must match this length or they are ignored! Set to 4 to match the
....................     // RadioHead RFM69 library.
....................     uint8_t msb = spi_read_u8(_REG_PREAMBLE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_PREAMBLE_LSB);
....................     return ((msb << 8) | lsb) & 0xFFFF;
.................... }
.................... void preamble_length_set(uint16_t val){
....................     spi_write_u8(_REG_PREAMBLE_MSB, (val >> 8) & 0xFF);
....................     spi_write_u8(_REG_PREAMBLE_LSB, val & 0xFF);
.................... }
.................... float frequency_mhz_get(){
....................     // """The frequency of the radio in Megahertz. Only the allowed values for your radio must be
....................     // specified (i.e. 433 vs. 915 mhz)!
....................     // """
....................     // # FRF register is computed from the frequency following the datasheet.
....................     // # See section 6.2 and FRF register description.
....................     // # Read bytes of FRF register and assemble into a 24-bit unsigned value.
....................     uint8_t msb = spi_read_u8(_REG_FRF_MSB);
....................     uint8_t mid = spi_read_u8(_REG_FRF_MID);
....................     uint8_t lsb = spi_read_u8(_REG_FRF_LSB);
....................     uint32_t frf = ((msb << 16) | (mid << 8) | lsb) & 0xFFFFFF;
....................     float frequency = (frf * _FSTEP) / 1000000.0;
....................     return frequency;
.................... }
.................... //WARNING: No funciona en micros porque requiere de enteros de 32 bits    
.................... void frequency_mhz_set(){
....................     //FRF = int((freq/_FSTEP)*1,000,000) & 0xFFFFFF
....................     uint8_t msb,lsb,mid;
....................     #ifdef FREQ_433
....................     msb = 0x6C;
....................     mid = 0x40;
....................     lsb = 0x00;
....................     #endif
....................     //TODO: aadir soporte para otras frecuencias
....................     
....................     //TODO: assert 290 <= val <= 1020
....................     // Calculate FRF register 24-bit value using section 6.2 of the datasheet.
....................     // unsigned long frf = int((val/_FSTEP)* 1000000.0) ;
....................     // Serial.print("FRF: ");
....................     // Serial.println(frf);
....................     
....................     // frf &=  0xFFFFFF;
....................     // // Extract byte values and update registers.
....................     // uint8_t msb = frf >> 16;
....................     // uint8_t mid = (frf >> 8) & 0xFF;
....................     // uint8_t lsb = frf & 0xFF;
....................     spi_write_u8(_REG_FRF_MSB, msb);
....................     spi_write_u8(_REG_FRF_MID, mid);
....................     spi_write_u8(_REG_FRF_LSB, lsb);
.................... }
.................... uint8_t* encryption_key_get(){
....................     // """The AES encryption key used to encrypt and decrypt packets by the chip. This can be set
....................     // to None to disable encryption (the default), otherwise it must be a 16 byte long byte
....................     // string which defines the key (both the transmitter and receiver must use the same key
....................     // value).
....................     // """
....................     // # Handle if encryption is disabled.
....................     if(get(aes_on)==0)return NULL;
....................     spi_read_into(_REG_AES_KEY1,encryption_key,16);
....................     return encryption_key;
.................... }
.................... void encryption_key_set(uint8_t* val){
....................     if (val==0)set(0,aes_on);
....................     else{
....................         // Set the encryption key and enable encryption.
....................         //TODO: assert len(val) == 16
....................         spi_write_from(_REG_AES_KEY1,val,16);
....................         set(1,aes_on);
....................     }
.................... }
.................... int8_t tx_power_get(){
....................     // The transmit power in dBm. Can be set to a value from -2 to 20 for high power devices
....................     // (RFM69HCW, high_power=True) or -18 to 13 for low power devices. Only integer power
....................     // levels are actually set (i.e. 12.5 will result in a value of 12 dBm).
....................     // """
....................     // # Follow table 10 truth table from the datasheet for determining power
....................     // # level from the individual PA level bits and output power register.
....................     uint8_t pa0 = get(pa_0_on);
....................     uint8_t pa1 = get(pa_1_on);
....................     uint8_t pa2 = get(pa_2_on);
....................     uint8_t current_output_power = get(output_power);
....................     if (pa0 &&  !pa1 &&  !pa2)
....................         //# -18 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && !pa2)
....................         //# -2 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && !high_power)
....................         //# 2 to 17 dBm range
....................         return -14 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && high_power)
....................         //# 5 to 20 dBm range
....................         return -11 + current_output_power;
....................     print((char*)"Tx power power amps state unknown!");
....................     while (1){}
....................     //exit(-3);
.................... }
.................... void tx_power_set(int8_t val){
....................     // Determine power amplifier and output power values depending on
....................     // high power state and requested power.
....................     uint8_t _pa_0_on = 0;
....................     uint8_t _pa_1_on = 0;
....................     uint8_t _pa_2_on = 0;
....................     uint8_t _output_power = 0;
....................     if (high_power){
....................         // Handle high power mode.
....................         //TODO: assert -2 <= val <= 20
....................         _pa_1_on = 1;
....................         if (val <= 13)
....................             _output_power = val + 18;
....................         else if (13 < val && val <= 17){
....................             _pa_2_on = 1;
....................             _output_power = val + 14;
....................             }
....................         else{
....................             //  # power >= 18 dBm
....................             //# Note this also needs PA boost enabled separately!
....................             _pa_2_on = 1;
....................             _output_power = val + 11;
....................             }
....................     }
....................     else{
....................         //Handle non-high power mode.
....................         //TODO: assert -18 <= val <= 13
....................         // Enable only power amplifier 0 and set output power.
....................         _pa_0_on = 1;
....................         _output_power = (val+ 18);
....................     }
....................     //# Set power amplifiers and output power as computed above.
....................     set(_pa_0_on,pa_0_on);
....................     set(_pa_1_on,pa_1_on);
....................     set(_pa_2_on,pa_2_on);
....................     set(_output_power,output_power);
....................     _tx_power = val;
.................... }
.................... float rssi_get(){
....................     // ""The received strength indicator (in dBm).
....................     // May be inaccuate if not read immediatey. last_rssi contains the value read immediately
....................     // receipt of the last packet.
....................     // """
....................     // # Read RSSI register and convert to value using formula in datasheet.
....................     rssi = -spi_read_u8(_REG_RSSI_VALUE) / 2.0;
....................     return rssi;
.................... }
.................... float bitrate_get(){
....................     //         """The modulation bitrate in bits/second (or chip rate if Manchester encoding is enabled).
....................     // Can be a value from ~489 to 32mbit/s, but see the datasheet for the exact supported
....................     // values.
....................     // """
....................     uint8_t msb = spi_read_u8(_REG_BITRATE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_BITRATE_LSB);
....................     bitrate = _FXOSC / ((msb << 8) | lsb);
....................     return bitrate;
.................... }
.................... void bitrate_set(float val){
....................     //TODO: assert (_FXOSC / 65535) <= val <= 32000000.0
....................     //# Round up to the next closest bit-rate value with addition of 0.5.
....................     uint32_t _bitrate = (int)((_FXOSC/val)+0.5) & 0xFFF;
....................     spi_write_u8(_REG_BITRATE_MSB, _bitrate >> 8);
....................     spi_write_u8(_REG_BITRATE_LSB, _bitrate & 0xFF);
.................... }
.................... float frequency_deviation_get(){
....................     //"""The frequency deviation in Hertz."""
....................     uint8_t msb = spi_read_u8(_REG_FDEV_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_FDEV_LSB);
....................     frequency_deviation = _FSTEP * ((msb << 8) | lsb);
....................     return frequency_deviation;
.................... }
.................... void frequency_deviation_set(float val){
....................     //TODO: assert 0 <= val <= (_FSTEP * 16383)  # fdev is a 14-bit unsigned value
....................     // # Round up to the next closest integer value with addition of 0.5.
....................     uint32_t fdev = (int)((val / _FSTEP) + 0.5) & 0x3FFF;
....................     spi_write_u8(_REG_FDEV_MSB, fdev >> 8);
....................     spi_write_u8(_REG_FDEV_LSB, fdev & 0xFF);
.................... }
.................... bool packet_sent(){
....................     //Transmit status
....................     return (spi_read_u8(_REG_IRQ_FLAGS2) & 0x8) >> 3;
.................... }
.................... bool payload_ready(){
....................             // """Receive status"""
....................     uint8_t p = spi_read_u8(_REG_IRQ_FLAGS2);
....................     //Serial.println(p,BIN);
....................     return (p & 0x4) >> 2;
.................... }
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256){
....................     // """Send a string of data using the transmitter.
....................     // You can only send 60 bytes at a time
....................     // (limited by chip's FIFO size and appended headers).
....................     // This appends a 4 byte header to be compatible with the RadioHead library.
....................     // The header defaults to using the initialized attributes:
....................     // (destination,node,identifier,flags)
....................     // It may be temporarily overidden via the kwargs - destination,node,identifier,flags.
....................     // Values passed via kwargs do not alter the attribute settings.
....................     // The keep_listening argument should be set to True if you want to start listening
....................     // automatically after the packet is sent. The default setting is False.
....................     // Returns: True if success or False if the send timed out.
....................     // """
....................     // # Disable pylint warning to not use length as a check for zero.
....................     // # This is a puzzling warning as the below code is clearly the most
....................     // # efficient and proper way to ensure a precondition that the provided
....................     // # buffer be within an expected range of bounds.  Disable this check.
....................     // # pylint: disable=len-as-condition
....................     // TODO: assert 0 < len(data) <= 60
....................     // # pylint: enable=len-as-condition
....................     idle(); //# Stop receiving to clear FIFO and keep it clear.
....................     // # Fill the FIFO with a packet to send.
....................     // # Combine header and data to form payload
....................     uint32_t i=0;
....................     char* payload = (char*)malloc(5 + len + 1);
....................     
....................     payload[0] = 4 + len;
....................     if (_destination >=256 )  // use attribute
....................         payload[1] = destination;
....................     else//  # use kwarg
....................         payload[1] = _destination;
....................     if (_node >= 256) // use attribute
....................         payload[2] = node;
....................     else  //# use kwarg
....................         payload[2] = _node;
....................     if (identifier >=256)  // use attribute
....................         payload[3] = identifier;
....................     else  //# use kwarg
....................         payload[3] = _identifier;
....................     if (flags >=256)  // use attribute
....................         payload[4] = flags;
....................     else  // use kwarg
....................         payload[4] = _flags;
....................     for (i=0;i<= len;i++)
....................         payload[5+i] = data[i];
....................        
....................     // # Write payload to transmit fifo
....................     spi_write_from(_REG_FIFO, payload,5+len);
....................     print((char*)"Payload: ");
....................     println(payload+5);
....................     // Serial.println((char)spi_read_u8(_REG_FIFO));              
.................... 
....................     free(payload);
....................     // # Turn on transmit mode to send out the packet.       
....................     transmit();
....................    
....................     // # Wait for packet sent interrupt with explicit polling (not ideal but
....................     // # best that can be done right now without interrupts).
....................     
....................     float start = timeSec();
....................     bool timed_out = false;
....................     while (!timed_out && !packet_sent()){
....................         if ((timeSec() - start) >= xmit_timeout)
....................             timed_out = true;
....................     }
....................     // # Listen again if requested.
....................     if (keep_listening)
....................         listen();
....................     else  //# Enter idle mode to stop receiving other packets.
....................   
....................         idle();
....................     return !timed_out;
.................... }
.................... bool send_with_ack(uint8_t* data,uint8_t len){
....................     // Reliable Datagram mode:
....................     // Send a packet with data and wait for an ACK response.
....................     // The packet header is automatically generated.
....................     // If enabled, the packet transmission will be retried on failure
....................     int retries_remaining = 0;
....................     bool got_ack = false;
....................     uint8_t* ack_packet;
....................     if (ack_retries)retries_remaining = ack_retries;
....................     else retries_remaining=1;
....................     sequence_number = (sequence_number+1) & 0xFF;
....................     while (!got_ack && retries_remaining){
....................         identifier = sequence_number;
....................         send(data,len,true);
....................         // Don't look for ACK from Broadcast message
....................         if (destination == _RH_BROADCAST_ADDRESS)got_ack = true;
....................         else{
....................             ack_packet = receive(true,false,ack_wait,true);
....................             if(ack_packet != NULL){
....................                 if (ack_packet[4] & _RH_FLAGS_ACK){
....................                     //Check id:
....................                     if (ack_packet[3] == identifier){
....................                         got_ack = true;
....................                         break;
....................                     }
....................                 }
....................             }
....................             
....................         }
....................         //# pause before next retry -- random delay
....................         if (!got_ack){
....................             sleep_ms(ack_wait * (1.5));
....................         }
....................         retries_remaining -= 1;
....................         //# set retry flag in packet header
....................         flags |= _RH_FLAGS_RETRY;
....................     }
....................     flags = 0;  //# clear flags
....................     return got_ack;
.................... }
.................... //IMPORTANTE: La funcion es igual a la de adafruit, excepto porque retorna un array donde el primer valor es la longitud del array
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false){
....................     // Wait to receive a packet from the receiver. If a packet is found the payload bytes
....................     // are returned, otherwise None is returned (which indicates the timeout elapsed with no
....................     // reception).
....................     // If keep_listening is True (the default) the chip will immediately enter listening mode
....................     // after reception of a packet, otherwise it will fall back to idle mode and ignore any
....................     // future reception.
....................     // All packets must have a 4 byte header for compatibilty with the
....................     // RadioHead library.
....................     // The header consists of 4 bytes (To,From,ID,Flags). The default setting will  strip
....................     // the header before returning the packet to the caller.
....................     // If with_header is True then the 4 byte header will be returned with the packet.
....................     // The payload then begins at packet[4].
....................     // If with_ack is True, send an ACK after receipt (Reliable Datagram mode)
....................     // """
....................     bool timed_out = false;
....................     int start = 0;
....................     int i=0;
....................     uint8_t fifo_length;
....................     uint8_t* packet= NULL;
....................     char fifo_len_str [4];
....................     if (timeout == 0)timeout = receive_timeout;
....................     if (timeout!=0){
....................         //readAllRegs();
....................         //while(1){}
....................         listen();
....................         start = timeSec();
....................         while (!timed_out && !payload_ready()){
....................             //delay(20);
....................             if ((timeSec() - start) >= xmit_timeout){
....................                 println((char*)"Timed out");
....................                 timed_out = true;
....................                 }
....................         }
....................     }
....................    
....................     last_rssi = rssi_get();
....................     // Enter idle mode to stop receiving other packets.
....................     idle();
....................      
....................     if (!timed_out){
....................         fifo_length = spi_read_u8(_REG_FIFO);
....................         print((char*)"FIFO LEN: ");
....................         sprintf(fifo_len_str,"%d",fifo_length);
....................         println(fifo_len_str);
....................         //  # Handle if the received packet is too small to include the 4 byte
....................         // # RadioHead header and at least one byte of data --reject this packet and ignore it.
....................         if (fifo_length > 0){
....................             packet = (uint8_t*)malloc(fifo_length+2);
....................             packet[0] = fifo_length;
....................             packet[fifo_length+1] = '\0';
....................             spi_read_into(_REG_FIFO,packet+1,fifo_length);
....................             //print(packet);
....................         }
....................         if (fifo_length < 5){
....................             packet = NULL;
....................         }
....................         else{
....................             if (node != _RH_BROADCAST_ADDRESS && packet[1] != _RH_BROADCAST_ADDRESS && packet[1] != node){
....................                 free(packet);
....................                 packet = NULL;
....................             }
....................             //# send ACK unless this was an ACK or a broadcast
....................             else if (with_ack && (packet[4]&_RH_FLAGS_ACK)==0 && packet[1] != _RH_BROADCAST_ADDRESS){
....................                 if (ack_delay != 0)sleep_ms((int)(ack_delay/1000));
....................                 //# send ACK packet to sender (data is b'!')
....................                 send((char*)"!",false,packet[2],packet[1],packet[3],packet[4]|_RH_FLAGS_ACK);
....................                 // # reject Retries if we have seen this idetifier from this source before
....................                 if (seen_ids[packet[2]] == packet[3] && packet[4]&_RH_FLAGS_RETRY){
....................                     free(packet);
....................                     packet= NULL;
....................                 }
....................                 else{ //Save identifier from source
....................                     seen_ids[packet[2]] = packet[3];
....................                 }
....................             }
....................             if (!with_header && packet != NULL){
....................                  //skip the header if not wanted
....................                  for (i=1; i< fifo_length-4;i++){
....................                     packet[i] = packet[i+4];
....................                  }
....................                  //reduce indicated length
....................                  packet[0] -= 4;
....................             }
....................         }
....................     }
....................     
....................     if (keep_listening)listen();        
....................     else idle();
....................     return (char*)packet;
.................... }
.................... 
.................... 
.................... #ZERO_RAM
.................... 
.................... 
.................... //Define la interrupcin por recepcin Serial
.................... static void RDA_isr(void)
.................... {  
*
1232:  GOTO   12B6 (RETURN)
....................  
.................... }
.................... 
.................... 
.................... /* TODO: Use usb_cdc_putc() to transmit data to the USB
.................... virtual COM port. Use usb_cdc_kbhit() and usb_cdc_getc() to
.................... receive data from the USB virtual COM port. usb_enumerated()
.................... can be used to see if connected to a host and ready to
.................... communicate. */
.................... 
.................... void main()
*
17DA:  CLRF   FF8
17DC:  BCF    FD0.7
17DE:  BSF    07.7
17E0:  MOVLW  FE
17E2:  MOVWF  00
17E4:  MOVLW  04
17E6:  MOVWF  01
17E8:  MOVLW  02
17EA:  MOVWF  FE9
17EC:  MOVLW  00
17EE:  MOVWF  FEA
17F0:  CLRF   FEE
17F2:  DECFSZ 00,F
17F4:  BRA    17F0
17F6:  DECFSZ 01,F
17F8:  BRA    17F0
17FA:  MOVLW  DD
17FC:  MOVWF  00
17FE:  MOVLW  03
1800:  MOVWF  01
1802:  MOVLW  23
1804:  MOVWF  FE9
1806:  MOVLW  05
1808:  MOVWF  FEA
180A:  CLRF   FEE
180C:  DECFSZ 00,F
180E:  BRA    180A
1810:  DECFSZ 01,F
1812:  BRA    180A
1814:  BCF    FC6.5
1816:  MOVLW  40
1818:  MOVWF  FC7
181A:  MOVLW  22
181C:  MOVWF  FC6
181E:  BCF    F94.7
1820:  BSF    F93.0
1822:  BSF    F89.5
1824:  BCF    F92.5
1826:  BCF    F93.1
1828:  CLRF   xC1
182A:  CLRF   xC0
182C:  MOVLW  02
182E:  MOVLB  1
1830:  MOVWF  x6F
1832:  MOVLW  05
1834:  MOVWF  x70
1836:  MOVLW  02
1838:  MOVWF  x71
183A:  MOVLB  0
183C:  RCALL  12BE
183E:  MOVFF  03,C4
1842:  MOVFF  02,C3
1846:  MOVFF  01,C2
184A:  MOVLW  02
184C:  MOVLB  1
184E:  MOVWF  x6F
1850:  MOVLW  03
1852:  MOVWF  x70
1854:  MOVLW  02
1856:  MOVWF  x71
1858:  MOVLB  0
185A:  RCALL  12BE
185C:  MOVFF  03,C7
1860:  MOVFF  02,C6
1864:  MOVFF  01,C5
1868:  MOVLW  02
186A:  MOVLB  1
186C:  MOVWF  x6F
186E:  CLRF   x70
1870:  MOVWF  x71
1872:  MOVLB  0
1874:  RCALL  12BE
1876:  MOVFF  03,CA
187A:  MOVFF  02,C9
187E:  MOVFF  01,C8
1882:  MOVLW  4E
1884:  MOVLB  1
1886:  MOVWF  x6F
1888:  MOVLW  03
188A:  MOVWF  x70
188C:  MOVLW  01
188E:  MOVWF  x71
1890:  MOVLB  0
1892:  RCALL  12BE
1894:  MOVFF  03,CD
1898:  MOVFF  02,CC
189C:  MOVFF  01,CB
18A0:  MOVLW  4E
18A2:  MOVLB  1
18A4:  MOVWF  x6F
18A6:  MOVLW  02
18A8:  MOVWF  x70
18AA:  MOVLW  01
18AC:  MOVWF  x71
18AE:  MOVLB  0
18B0:  RCALL  12BE
18B2:  MOVFF  03,D0
18B6:  MOVFF  02,CF
18BA:  MOVFF  01,CE
18BE:  MOVLW  2E
18C0:  MOVLB  1
18C2:  MOVWF  x6F
18C4:  MOVLW  07
18C6:  MOVWF  x70
18C8:  MOVLW  01
18CA:  MOVWF  x71
18CC:  MOVLB  0
18CE:  RCALL  12BE
18D0:  MOVFF  03,D3
18D4:  MOVFF  02,D2
18D8:  MOVFF  01,D1
18DC:  MOVLW  2E
18DE:  MOVLB  1
18E0:  MOVWF  x6F
18E2:  MOVLW  03
18E4:  MOVWF  x70
18E6:  MOVWF  x71
18E8:  MOVLB  0
18EA:  RCALL  12BE
18EC:  MOVFF  03,D6
18F0:  MOVFF  02,D5
18F4:  MOVFF  01,D4
18F8:  MOVLW  3D
18FA:  MOVLB  1
18FC:  MOVWF  x6F
18FE:  CLRF   x70
1900:  MOVLW  01
1902:  MOVWF  x71
1904:  MOVLB  0
1906:  RCALL  12BE
1908:  MOVFF  03,D9
190C:  MOVFF  02,D8
1910:  MOVFF  01,D7
1914:  MOVLW  11
1916:  MOVLB  1
1918:  MOVWF  x6F
191A:  MOVLW  07
191C:  MOVWF  x70
191E:  MOVLW  01
1920:  MOVWF  x71
1922:  MOVLB  0
1924:  RCALL  12BE
1926:  MOVFF  03,DC
192A:  MOVFF  02,DB
192E:  MOVFF  01,DA
1932:  MOVLW  11
1934:  MOVLB  1
1936:  MOVWF  x6F
1938:  MOVLW  06
193A:  MOVWF  x70
193C:  MOVLW  01
193E:  MOVWF  x71
1940:  MOVLB  0
1942:  RCALL  12BE
1944:  MOVFF  03,DF
1948:  MOVFF  02,DE
194C:  MOVFF  01,DD
1950:  MOVLW  11
1952:  MOVLB  1
1954:  MOVWF  x6F
1956:  MOVLW  05
1958:  MOVWF  x70
195A:  MOVLW  01
195C:  MOVWF  x71
195E:  MOVLB  0
1960:  RCALL  12BE
1962:  MOVFF  03,E2
1966:  MOVFF  02,E1
196A:  MOVFF  01,E0
196E:  MOVLW  11
1970:  MOVLB  1
1972:  MOVWF  x6F
1974:  CLRF   x70
1976:  MOVLW  05
1978:  MOVWF  x71
197A:  MOVLB  0
197C:  RCALL  12BE
197E:  MOVFF  03,E5
1982:  MOVFF  02,E4
1986:  MOVFF  01,E3
198A:  MOVLW  19
198C:  MOVLB  1
198E:  MOVWF  x6F
1990:  MOVLW  05
1992:  MOVWF  x70
1994:  MOVLW  03
1996:  MOVWF  x71
1998:  MOVLB  0
199A:  RCALL  12BE
199C:  MOVFF  03,E8
19A0:  MOVFF  02,E7
19A4:  MOVFF  01,E6
19A8:  MOVLW  19
19AA:  MOVLB  1
19AC:  MOVWF  x6F
19AE:  MOVLW  03
19B0:  MOVWF  x70
19B2:  MOVLW  02
19B4:  MOVWF  x71
19B6:  MOVLB  0
19B8:  RCALL  12BE
19BA:  MOVFF  03,EB
19BE:  MOVFF  02,EA
19C2:  MOVFF  01,E9
19C6:  MOVLW  19
19C8:  MOVLB  1
19CA:  MOVWF  x6F
19CC:  CLRF   x70
19CE:  MOVLW  03
19D0:  MOVWF  x71
19D2:  MOVLB  0
19D4:  RCALL  12BE
19D6:  MOVFF  03,EE
19DA:  MOVFF  02,ED
19DE:  MOVFF  01,EC
19E2:  MOVLW  1A
19E4:  MOVLB  1
19E6:  MOVWF  x6F
19E8:  MOVLW  05
19EA:  MOVWF  x70
19EC:  MOVLW  03
19EE:  MOVWF  x71
19F0:  MOVLB  0
19F2:  RCALL  12BE
19F4:  MOVFF  03,F1
19F8:  MOVFF  02,F0
19FC:  MOVFF  01,EF
1A00:  MOVLW  1A
1A02:  MOVLB  1
1A04:  MOVWF  x6F
1A06:  MOVLW  03
1A08:  MOVWF  x70
1A0A:  MOVLW  02
1A0C:  MOVWF  x71
1A0E:  MOVLB  0
1A10:  RCALL  12BE
1A12:  MOVFF  03,F4
1A16:  MOVFF  02,F3
1A1A:  MOVFF  01,F2
1A1E:  MOVLW  1A
1A20:  MOVLB  1
1A22:  MOVWF  x6F
1A24:  CLRF   x70
1A26:  MOVLW  03
1A28:  MOVWF  x71
1A2A:  MOVLB  0
1A2C:  RCALL  12BE
1A2E:  MOVFF  03,F7
1A32:  MOVFF  02,F6
1A36:  MOVFF  01,F5
1A3A:  MOVLW  37
1A3C:  MOVLB  1
1A3E:  MOVWF  x6F
1A40:  MOVLW  07
1A42:  MOVWF  x70
1A44:  MOVLW  01
1A46:  MOVWF  x71
1A48:  MOVLB  0
1A4A:  RCALL  12BE
1A4C:  MOVFF  03,FA
1A50:  MOVFF  02,F9
1A54:  MOVFF  01,F8
1A58:  MOVLW  37
1A5A:  MOVLB  1
1A5C:  MOVWF  x6F
1A5E:  MOVLW  05
1A60:  MOVWF  x70
1A62:  MOVLW  02
1A64:  MOVWF  x71
1A66:  MOVLB  0
1A68:  RCALL  12BE
1A6A:  MOVFF  03,FD
1A6E:  MOVFF  02,FC
1A72:  MOVFF  01,FB
1A76:  MOVLW  37
1A78:  MOVLB  1
1A7A:  MOVWF  x6F
1A7C:  MOVLW  04
1A7E:  MOVWF  x70
1A80:  MOVLW  01
1A82:  MOVWF  x71
1A84:  MOVLB  0
1A86:  RCALL  12BE
1A88:  MOVFF  03,100
1A8C:  MOVFF  02,FF
1A90:  MOVFF  01,FE
1A94:  MOVLW  37
1A96:  MOVLB  1
1A98:  MOVWF  x6F
1A9A:  MOVLW  03
1A9C:  MOVWF  x70
1A9E:  MOVLW  01
1AA0:  MOVWF  x71
1AA2:  MOVLB  0
1AA4:  RCALL  12BE
1AA6:  MOVFF  03,103
1AAA:  MOVFF  02,102
1AAE:  MOVFF  01,101
1AB2:  MOVLW  37
1AB4:  MOVLB  1
1AB6:  MOVWF  x6F
1AB8:  MOVLW  01
1ABA:  MOVWF  x70
1ABC:  MOVLW  02
1ABE:  MOVWF  x71
1AC0:  MOVLB  0
1AC2:  CALL   12BE
1AC6:  MOVFF  03,106
1ACA:  MOVFF  02,105
1ACE:  MOVFF  01,104
1AD2:  MOVLW  27
1AD4:  MOVLB  1
1AD6:  MOVWF  x6F
1AD8:  MOVLW  07
1ADA:  MOVWF  x70
1ADC:  MOVLW  01
1ADE:  MOVWF  x71
1AE0:  MOVLB  0
1AE2:  CALL   12BE
1AE6:  MOVFF  03,109
1AEA:  MOVFF  02,108
1AEE:  MOVFF  01,107
1AF2:  MOVLW  25
1AF4:  MOVLB  1
1AF6:  MOVWF  x6F
1AF8:  MOVLW  06
1AFA:  MOVWF  x70
1AFC:  MOVLW  02
1AFE:  MOVWF  x71
1B00:  MOVLB  0
1B02:  CALL   12BE
1B06:  MOVFF  03,10C
1B0A:  MOVFF  02,10B
1B0E:  MOVFF  01,10A
1B12:  MOVLW  25
1B14:  MOVLB  1
1B16:  MOVWF  x6F
1B18:  MOVLW  04
1B1A:  MOVWF  x70
1B1C:  MOVLW  02
1B1E:  MOVWF  x71
1B20:  MOVLB  0
1B22:  CALL   12BE
1B26:  MOVFF  03,10F
1B2A:  MOVFF  02,10E
1B2E:  MOVFF  01,10D
1B32:  MOVLW  25
1B34:  MOVLB  1
1B36:  MOVWF  x6F
1B38:  MOVLW  02
1B3A:  MOVWF  x70
1B3C:  MOVWF  x71
1B3E:  MOVLB  0
1B40:  CALL   12BE
1B44:  MOVFF  03,112
1B48:  MOVFF  02,111
1B4C:  MOVFF  01,110
1B50:  MOVLW  25
1B52:  MOVLB  1
1B54:  MOVWF  x6F
1B56:  CLRF   x70
1B58:  MOVLW  02
1B5A:  MOVWF  x71
1B5C:  MOVLB  0
1B5E:  CALL   12BE
1B62:  MOVFF  03,115
1B66:  MOVFF  02,114
1B6A:  MOVFF  01,113
1B6E:  MOVLW  26
1B70:  MOVLB  1
1B72:  MOVWF  x6F
1B74:  MOVLW  06
1B76:  MOVWF  x70
1B78:  MOVLW  02
1B7A:  MOVWF  x71
1B7C:  MOVLB  0
1B7E:  CALL   12BE
1B82:  MOVFF  03,118
1B86:  MOVFF  02,117
1B8A:  MOVFF  01,116
1B8E:  MOVLW  26
1B90:  MOVLB  1
1B92:  MOVWF  x6F
1B94:  MOVLW  04
1B96:  MOVWF  x70
1B98:  MOVLW  02
1B9A:  MOVWF  x71
1B9C:  MOVLB  0
1B9E:  CALL   12BE
1BA2:  MOVFF  03,11B
1BA6:  MOVFF  02,11A
1BAA:  MOVFF  01,119
1BAE:  MOVF   FC1,W
1BB0:  ANDLW  C0
1BB2:  IORLW  0F
1BB4:  MOVWF  FC1
1BB6:  MOVLW  07
1BB8:  MOVWF  FB4
1BBA:  MOVLW  01
1BBC:  MOVWF  xBB
1BBE:  MOVLW  CD
1BC0:  MOVWF  xBA
1BC2:  MOVLW  02
1BC4:  MOVLB  1
1BC6:  MOVWF  xCE
1BC8:  MOVLW  2F
1BCA:  MOVWF  xCD
1BCC:  MOVLW  05
1BCE:  MOVWF  xD0
1BD0:  MOVLW  23
1BD2:  MOVWF  xCF
1BD4:  MOVLW  02
1BD6:  MOVLB  5
1BD8:  MOVWF  x24
1BDA:  MOVLW  D9
1BDC:  MOVWF  x23
1BDE:  CLRF   x26
1BE0:  CLRF   x25
1BE2:  MOVLB  0
1BE4:  CLRF   xB8
1BE6:  CLRF   xB9
*
1BFA:  MOVLW  20
1BFC:  MOVWF  x6E
.................... {
.................... 
....................    //RFM69 radio;
....................    //PRIMER BYTE es el tamao del array 
....................    uint8_t synch[] = {3,0xAA,0x2D,0xD4};
*
1BE8:  MOVLW  03
1BEA:  MOVLB  1
1BEC:  MOVWF  x6A
1BEE:  MOVLW  AA
1BF0:  MOVWF  x6B
1BF2:  MOVLW  2D
1BF4:  MOVWF  x6C
1BF6:  MOVLW  D4
1BF8:  MOVWF  x6D
....................    int ResetPin = RF_Reset;
....................    //radio.init(synch,ResetPin);
....................    
....................    setup_adc_ports(NO_ANALOGS, VSS_VDD);
*
1BFE:  MOVF   FC1,W
1C00:  ANDLW  C0
1C02:  IORLW  0F
1C04:  MOVWF  FC1
....................    usb_init();
1C06:  MOVLB  0
1C08:  GOTO   13A2
....................    //init(synch,ResetPin);
....................    while(TRUE)
....................    {
....................    readAllRegs();
1C0C:  BRA    16F8
....................    //radio.readAllRegs();
.................... //!   println((char*)"HOLA USB");
.................... //!   println(134,HEX);
.................... //!   println(47,BIN);
....................    delay_ms(1000);
1C0E:  MOVLW  04
1C10:  MOVLB  1
1C12:  MOVWF  x6F
1C14:  MOVLW  FA
1C16:  MOVWF  x70
1C18:  MOVLB  0
1C1A:  BRA    17AE
1C1C:  MOVLB  1
1C1E:  DECFSZ x6F,F
1C20:  BRA    1C14
1C22:  MOVLB  0
1C24:  BRA    1C0C
....................       //TODO: User Code
....................    }
.................... 
.................... }
1C26:  SLEEP 

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
