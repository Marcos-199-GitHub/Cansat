CCS PCH C Compiler, Version 5.112, 29001               01-jul.-23 10:50

               Filename:   I:\CanSat\Cansat\Assets\RFM69\Receptor\ArduPort\Receptor.lst

               ROM used:   16824 bytes (51%)
                           Largest free fragment is 15944
               RAM used:   692 (34%) at main() level
                           907 (44%) worst case
               Stack used: 17 locations (10 in main + 7 for interrupts)
               Stack size: 31

*
0000:  GOTO   3BC2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.5
0056:  GOTO   0060
005A:  BTFSC  FA1.5
005C:  GOTO   13E2
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #define HEX 16
.................... #define BIN 2
.................... #define DEC 10
.................... #define UDEC 11
.................... #define SSPin PIN_A5
.................... #define TIMER_START 114
.................... #define TIMER_STEP_MS 3
.................... #define FREQ_433
.................... 
.................... #include <Receptor.h>
.................... #include <18LF4550.h>
.................... //////////// Standard Header file for the PIC18LF4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18LF4550
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,03
00C0:  DATA 02,FF
00C2:  DATA FF,FF
00C4:  DATA FF,FF
00C6:  DATA FF,FF
00C8:  DATA FF,FF
00CA:  DATA FF,FF
00CC:  DATA FF,FF
00CE:  CLRF   FF7
00D0:  ADDLW  DE
00D2:  MOVWF  FF6
00D4:  MOVLW  00
00D6:  ADDWFC FF7,F
00D8:  TBLRD*+
00DA:  MOVF   FF5,W
00DC:  RETURN 0
00DE:  DATA 00,FF
00E0:  DATA 02,FF
00E2:  DATA FF,FF
00E4:  DATA FF,FF
00E6:  DATA FF,FF
00E8:  DATA FF,FF
00EA:  DATA FF,FF
00EC:  DATA FF,FF
00EE:  CLRF   FF7
00F0:  ADDLW  FE
00F2:  MOVWF  FF6
00F4:  MOVLW  00
00F6:  ADDWFC FF7,F
00F8:  TBLRD*+
00FA:  MOVF   FF5,W
00FC:  RETURN 0
00FE:  DATA 40,00
0100:  DATA 0B,00
0102:  DATA 40,00
0104:  DATA 00,00
0106:  DATA 00,00
0108:  DATA 00,00
010A:  DATA 00,00
010C:  DATA 00,00
010E:  DATA 00,00
0110:  DATA 00,00
0112:  DATA 00,00
0114:  DATA 00,00
0116:  DATA 00,00
0118:  DATA 00,00
011A:  DATA 00,00
011C:  DATA 00,00
011E:  CLRF   FF7
0120:  ADDLW  2E
0122:  MOVWF  FF6
0124:  MOVLW  01
0126:  ADDWFC FF7,F
0128:  TBLRD*+
012A:  MOVF   FF5,W
012C:  RETURN 0
012E:  DATA 40,00
0130:  DATA 00,00
0132:  DATA 40,00
0134:  DATA 00,00
0136:  DATA 00,00
0138:  DATA 00,00
013A:  DATA 00,00
013C:  DATA 00,00
013E:  DATA 00,00
0140:  DATA 00,00
0142:  DATA 00,00
0144:  DATA 00,00
0146:  DATA 00,00
0148:  DATA 00,00
014A:  DATA 00,00
014C:  DATA 00,00
014E:  CLRF   FF7
0150:  ADDLW  5E
0152:  MOVWF  FF6
0154:  MOVLW  01
0156:  ADDWFC FF7,F
0158:  TBLRD*+
015A:  MOVF   FF5,W
015C:  RETURN 0
015E:  DATA 09,02
0160:  DATA 43,00
0162:  DATA 02,01
0164:  DATA 00,80
0166:  DATA FA,09
0168:  DATA 04,00
016A:  DATA 00,01
016C:  DATA 02,02
016E:  DATA 01,00
0170:  DATA 05,24
0172:  DATA 00,10
0174:  DATA 01,04
0176:  DATA 24,02
0178:  DATA 02,05
017A:  DATA 24,06
017C:  DATA 00,01
017E:  DATA 05,24
0180:  DATA 01,00
0182:  DATA 01,07
0184:  DATA 05,81
0186:  DATA 03,0B
0188:  DATA 00,FA
018A:  DATA 09,04
018C:  DATA 01,00
018E:  DATA 02,0A
0190:  DATA 00,00
0192:  DATA 00,07
0194:  DATA 05,02
0196:  DATA 02,40
0198:  DATA 00,01
019A:  DATA 07,05
019C:  DATA 82,02
019E:  DATA 40,00
01A0:  DATA 01,00
01A2:  CLRF   FF7
01A4:  ADDLW  B2
01A6:  MOVWF  FF6
01A8:  MOVLW  01
01AA:  ADDWFC FF7,F
01AC:  TBLRD*+
01AE:  MOVF   FF5,W
01B0:  RETURN 0
01B2:  DATA 02,00
01B4:  CLRF   FF7
01B6:  ADDLW  C4
01B8:  MOVWF  FF6
01BA:  MOVLW  01
01BC:  ADDWFC FF7,F
01BE:  TBLRD*+
01C0:  MOVF   FF5,W
01C2:  RETURN 0
01C4:  DATA 12,17
01C6:  DATA 1B,20
01C8:  DATA FF,FF
01CA:  DATA FF,FF
01CC:  CLRF   FF7
01CE:  ADDLW  DC
01D0:  MOVWF  FF6
01D2:  MOVLW  01
01D4:  ADDWFC FF7,F
01D6:  TBLRD*+
01D8:  MOVF   FF5,W
01DA:  RETURN 0
01DC:  DATA 12,01
01DE:  DATA 10,01
01E0:  DATA 02,00
01E2:  DATA 00,40
01E4:  DATA 05,24
01E6:  DATA 0B,00
01E8:  DATA 00,01
01EA:  DATA 01,02
01EC:  DATA 00,01
01EE:  CLRF   FF7
01F0:  ADDLW  FE
01F2:  MOVWF  FF6
01F4:  MOVLW  01
01F6:  ADDWFC FF7,F
01F8:  TBLRD*+
01FA:  MOVF   FF5,W
01FC:  RETURN 0
01FE:  DATA 04,03
0200:  DATA 09,04
0202:  DATA 08,03
0204:  DATA 43,00
0206:  DATA 43,00
0208:  DATA 53,00
020A:  DATA 20,03
020C:  DATA 43,00
020E:  DATA 43,00
0210:  DATA 53,00
0212:  DATA 20,00
0214:  DATA 55,00
0216:  DATA 53,00
0218:  DATA 42,00
021A:  DATA 20,00
021C:  DATA 74,00
021E:  DATA 6F,00
0220:  DATA 20,00
0222:  DATA 55,00
0224:  DATA 41,00
0226:  DATA 52,00
0228:  DATA 54,00
022A:  CLRF   FF7
022C:  ADDLW  3A
022E:  MOVWF  FF6
0230:  MOVLW  02
0232:  ADDWFC FF7,F
0234:  TBLRD*+
0236:  MOVF   FF5,W
0238:  RETURN 0
023A:  DATA 49,6E
023C:  DATA 69,74
023E:  DATA 69,61
0240:  DATA 6C,20
0242:  DATA 63,6F
0244:  DATA 6E,66
0246:  DATA 20,73
0248:  DATA 74,61
024A:  DATA 72,74
024C:  DATA 73,00
024E:  CLRF   FF7
0250:  ADDLW  5E
0252:  MOVWF  FF6
0254:  MOVLW  02
0256:  ADDWFC FF7,F
0258:  TBLRD*+
025A:  MOVF   FF5,W
025C:  RETURN 0
025E:  DATA 45,72
0260:  DATA 72,6F
0262:  DATA 72,3A
0264:  DATA 20,49
0266:  DATA 44,20
0268:  DATA 64,65
026A:  DATA 6C,20
026C:  DATA 52,46
026E:  DATA 4D,20
0270:  DATA 69,6E
0272:  DATA 63,6F
0274:  DATA 72,72
0276:  DATA 65,63
0278:  DATA 74,61
027A:  DATA 00,00
027C:  CLRF   FF7
027E:  ADDLW  8C
0280:  MOVWF  FF6
0282:  MOVLW  02
0284:  ADDWFC FF7,F
0286:  TBLRD*+
0288:  MOVF   FF5,W
028A:  RETURN 0
028C:  DATA 49,44
028E:  DATA 20,4C
0290:  DATA 6F,6F
0292:  DATA 70,00
0294:  CLRF   FF7
0296:  ADDLW  A4
0298:  MOVWF  FF6
029A:  MOVLW  02
029C:  ADDWFC FF7,F
029E:  TBLRD*+
02A0:  MOVF   FF5,W
02A2:  RETURN 0
02A4:  DATA 49,6E
02A6:  DATA 69,74
02A8:  DATA 69,61
02AA:  DATA 6C,20
02AC:  DATA 63,6F
02AE:  DATA 6E,66
02B0:  DATA 69,67
02B2:  DATA 75,72
02B4:  DATA 61,74
02B6:  DATA 69,6F
02B8:  DATA 6E,20
02BA:  DATA 65,6E
02BC:  DATA 64,0A
02BE:  DATA 00,00
02C0:  CLRF   FF7
02C2:  ADDLW  D0
02C4:  MOVWF  FF6
02C6:  MOVLW  02
02C8:  ADDWFC FF7,F
02CA:  TBLRD*+
02CC:  MOVF   FF5,W
02CE:  RETURN 0
02D0:  DATA 4F,50
02D2:  DATA 20,4C
02D4:  DATA 6F,6F
02D6:  DATA 70,20
02D8:  DATA 31,00
02DA:  CLRF   FF7
02DC:  ADDLW  EA
02DE:  MOVWF  FF6
02E0:  MOVLW  02
02E2:  ADDWFC FF7,F
02E4:  TBLRD*+
02E6:  MOVF   FF5,W
02E8:  RETURN 0
02EA:  DATA 4F,70
02EC:  DATA 65,72
02EE:  DATA 61,74
02F0:  DATA 69,6F
02F2:  DATA 6E,20
02F4:  DATA 4D,6F
02F6:  DATA 64,65
02F8:  DATA 20,63
02FA:  DATA 6F,75
02FC:  DATA 6C,64
02FE:  DATA 6E,74
0300:  DATA 20,62
0302:  DATA 65,20
0304:  DATA 73,65
0306:  DATA 74,0A
0308:  DATA 00,00
030A:  CLRF   FF7
030C:  ADDLW  1A
030E:  MOVWF  FF6
0310:  MOVLW  03
0312:  ADDWFC FF7,F
0314:  TBLRD*+
0316:  MOVF   FF5,W
0318:  RETURN 0
031A:  DATA 4F,50
031C:  DATA 20,4C
031E:  DATA 6F,6F
0320:  DATA 70,20
0322:  DATA 32,00
0324:  CLRF   FF7
0326:  ADDLW  34
0328:  MOVWF  FF6
032A:  MOVLW  03
032C:  ADDWFC FF7,F
032E:  TBLRD*+
0330:  MOVF   FF5,W
0332:  RETURN 0
0334:  DATA 54,69
0336:  DATA 6D,65
0338:  DATA 6F,75
033A:  DATA 74,20
033C:  DATA 6F,6E
033E:  DATA 20,4F
0340:  DATA 70,65
0342:  DATA 72,61
0344:  DATA 74,69
0346:  DATA 6F,6E
0348:  DATA 20,4D
034A:  DATA 6F,64
034C:  DATA 65,20
034E:  DATA 53,65
0350:  DATA 74,0A
0352:  DATA 00,00
0354:  CLRF   FF7
0356:  ADDLW  64
0358:  MOVWF  FF6
035A:  MOVLW  03
035C:  ADDWFC FF7,F
035E:  TBLRD*+
0360:  MOVF   FF5,W
0362:  RETURN 0
0364:  DATA 50,61
0366:  DATA 79,6C
0368:  DATA 6F,61
036A:  DATA 64,3A
036C:  DATA 20,00
036E:  CLRF   FF7
0370:  ADDLW  7E
0372:  MOVWF  FF6
0374:  MOVLW  03
0376:  ADDWFC FF7,F
0378:  TBLRD*+
037A:  MOVF   FF5,W
037C:  RETURN 0
037E:  DATA 54,69
0380:  DATA 6D,65
0382:  DATA 64,20
0384:  DATA 6F,75
0386:  DATA 74,00
0388:  CLRF   FF7
038A:  ADDLW  98
038C:  MOVWF  FF6
038E:  MOVLW  03
0390:  ADDWFC FF7,F
0392:  TBLRD*+
0394:  MOVF   FF5,W
0396:  RETURN 0
0398:  DATA 46,49
039A:  DATA 46,4F
039C:  DATA 20,4C
039E:  DATA 45,4E
03A0:  DATA 3A,20
03A2:  DATA 00,00
03A4:  CLRF   FF7
03A6:  ADDLW  B4
03A8:  MOVWF  FF6
03AA:  MOVLW  03
03AC:  ADDWFC FF7,F
03AE:  TBLRD*+
03B0:  MOVF   FF5,W
03B2:  RETURN 0
03B4:  DATA 49,64
03B6:  DATA 20,69
03B8:  DATA 6E,63
03BA:  DATA 6F,72
03BC:  DATA 72,65
03BE:  DATA 63,74
03C0:  DATA 6F,00
03C2:  CLRF   FF7
03C4:  ADDLW  D2
03C6:  MOVWF  FF6
03C8:  MOVLW  03
03CA:  ADDWFC FF7,F
03CC:  TBLRD*+
03CE:  MOVF   FF5,W
03D0:  RETURN 0
03D2:  DATA 49,4E
03D4:  DATA 49,54
03D6:  DATA 20,44
03D8:  DATA 4F,4E
03DA:  DATA 45,00
03DC:  CLRF   FF7
03DE:  ADDLW  EC
03E0:  MOVWF  FF6
03E2:  MOVLW  03
03E4:  ADDWFC FF7,F
03E6:  TBLRD*+
03E8:  MOVF   FF5,W
03EA:  RETURN 0
03EC:  DATA 45,73
03EE:  DATA 70,65
03F0:  DATA 72,61
03F2:  DATA 6E,64
03F4:  DATA 6F,00
*
0496:  MOVLB  2
0498:  MOVF   x63,W
049A:  MULWF  x65
049C:  MOVFF  FF3,01
04A0:  MOVFF  FF4,00
04A4:  MULWF  x66
04A6:  MOVF   FF3,W
04A8:  ADDWF  00,F
04AA:  MOVF   x64,W
04AC:  MULWF  x65
04AE:  MOVF   FF3,W
04B0:  ADDWFC 00,W
04B2:  MOVWF  02
04B4:  MOVLB  0
04B6:  RETURN 0
*
14A8:  MOVLB  2
14AA:  MOVF   x2A,W
14AC:  ANDLW  07
14AE:  MOVWF  00
14B0:  RRCF   x2A,W
14B2:  MOVWF  01
14B4:  RRCF   01,F
14B6:  RRCF   01,F
14B8:  MOVLW  1F
14BA:  ANDWF  01,F
14BC:  MOVF   01,W
14BE:  ADDWF  x2C,W
14C0:  MOVWF  FE9
14C2:  MOVLW  00
14C4:  ADDWFC x2D,W
14C6:  MOVWF  FEA
14C8:  CLRF   01
14CA:  INCF   01,F
14CC:  INCF   00,F
14CE:  BRA    14D2
14D0:  RLCF   01,F
14D2:  DECFSZ 00,F
14D4:  BRA    14D0
14D6:  MOVF   x2B,F
14D8:  BZ    14E0
14DA:  MOVF   01,W
14DC:  IORWF  FEF,F
14DE:  BRA    14E6
14E0:  COMF   01,F
14E2:  MOVF   01,W
14E4:  ANDWF  FEF,F
14E6:  MOVLB  0
14E8:  RETURN 0
*
16AA:  MOVLW  8E
16AC:  MOVWF  00
16AE:  MOVFF  1E2,01
16B2:  MOVFF  1E1,02
16B6:  CLRF   03
16B8:  MOVF   01,F
16BA:  BNZ   16CE
16BC:  MOVFF  02,01
16C0:  CLRF   02
16C2:  MOVLW  08
16C4:  SUBWF  00,F
16C6:  MOVF   01,F
16C8:  BNZ   16CE
16CA:  CLRF   00
16CC:  BRA    16DE
16CE:  BCF    FD8.0
16D0:  BTFSC  01.7
16D2:  BRA    16DC
16D4:  RLCF   02,F
16D6:  RLCF   01,F
16D8:  DECF   00,F
16DA:  BRA    16CE
16DC:  BCF    01.7
16DE:  RETURN 0
16E0:  MOVLB  1
16E2:  MOVF   xE5,W
16E4:  BTFSC  FD8.2
16E6:  BRA    17CA
16E8:  MOVWF  00
16EA:  MOVF   xE9,W
16EC:  BTFSC  FD8.2
16EE:  BRA    17CA
16F0:  ADDWF  00,F
16F2:  BNC   16FC
16F4:  MOVLW  81
16F6:  ADDWF  00,F
16F8:  BC    17CA
16FA:  BRA    1704
16FC:  MOVLW  7F
16FE:  SUBWF  00,F
1700:  BNC   17CA
1702:  BZ    17CA
1704:  MOVFF  1E6,1ED
1708:  MOVF   xEA,W
170A:  XORWF  xED,F
170C:  BSF    xE6.7
170E:  BSF    xEA.7
1710:  MOVF   xE8,W
1712:  MULWF  xEC
1714:  MOVFF  FF4,1EF
1718:  MOVF   xE7,W
171A:  MULWF  xEB
171C:  MOVFF  FF4,03
1720:  MOVFF  FF3,1EE
1724:  MULWF  xEC
1726:  MOVF   FF3,W
1728:  ADDWF  xEF,F
172A:  MOVF   FF4,W
172C:  ADDWFC xEE,F
172E:  MOVLW  00
1730:  ADDWFC 03,F
1732:  MOVF   xE8,W
1734:  MULWF  xEB
1736:  MOVF   FF3,W
1738:  ADDWF  xEF,F
173A:  MOVF   FF4,W
173C:  ADDWFC xEE,F
173E:  MOVLW  00
1740:  CLRF   02
1742:  ADDWFC 03,F
1744:  ADDWFC 02,F
1746:  MOVF   xE6,W
1748:  MULWF  xEC
174A:  MOVF   FF3,W
174C:  ADDWF  xEE,F
174E:  MOVF   FF4,W
1750:  ADDWFC 03,F
1752:  MOVLW  00
1754:  ADDWFC 02,F
1756:  MOVF   xE6,W
1758:  MULWF  xEB
175A:  MOVF   FF3,W
175C:  ADDWF  03,F
175E:  MOVF   FF4,W
1760:  ADDWFC 02,F
1762:  MOVLW  00
1764:  CLRF   01
1766:  ADDWFC 01,F
1768:  MOVF   xE8,W
176A:  MULWF  xEA
176C:  MOVF   FF3,W
176E:  ADDWF  xEE,F
1770:  MOVF   FF4,W
1772:  ADDWFC 03,F
1774:  MOVLW  00
1776:  ADDWFC 02,F
1778:  ADDWFC 01,F
177A:  MOVF   xE7,W
177C:  MULWF  xEA
177E:  MOVF   FF3,W
1780:  ADDWF  03,F
1782:  MOVF   FF4,W
1784:  ADDWFC 02,F
1786:  MOVLW  00
1788:  ADDWFC 01,F
178A:  MOVF   xE6,W
178C:  MULWF  xEA
178E:  MOVF   FF3,W
1790:  ADDWF  02,F
1792:  MOVF   FF4,W
1794:  ADDWFC 01,F
1796:  INCF   00,F
1798:  BTFSC  01.7
179A:  BRA    17A6
179C:  RLCF   xEE,F
179E:  RLCF   03,F
17A0:  RLCF   02,F
17A2:  RLCF   01,F
17A4:  DECF   00,F
17A6:  MOVLW  00
17A8:  BTFSS  xEE.7
17AA:  BRA    17C0
17AC:  INCF   03,F
17AE:  ADDWFC 02,F
17B0:  ADDWFC 01,F
17B2:  MOVF   01,W
17B4:  BNZ   17C0
17B6:  MOVF   02,W
17B8:  BNZ   17C0
17BA:  MOVF   03,W
17BC:  BNZ   17C0
17BE:  INCF   00,F
17C0:  BTFSC  xED.7
17C2:  BSF    01.7
17C4:  BTFSS  xED.7
17C6:  BCF    01.7
17C8:  BRA    17D2
17CA:  CLRF   00
17CC:  CLRF   01
17CE:  CLRF   02
17D0:  CLRF   03
17D2:  MOVLB  0
17D4:  RETURN 0
17D6:  MOVLB  1
17D8:  MOVF   xB0,W
17DA:  SUBLW  B6
17DC:  MOVWF  xB0
17DE:  CLRF   03
17E0:  MOVFF  1B1,1B4
17E4:  BSF    xB1.7
17E6:  BCF    FD8.0
17E8:  RRCF   xB1,F
17EA:  RRCF   xB2,F
17EC:  RRCF   xB3,F
17EE:  RRCF   03,F
17F0:  RRCF   02,F
17F2:  RRCF   01,F
17F4:  RRCF   00,F
17F6:  DECFSZ xB0,F
17F8:  BRA    17E6
17FA:  BTFSS  xB4.7
17FC:  BRA    1814
17FE:  COMF   00,F
1800:  COMF   01,F
1802:  COMF   02,F
1804:  COMF   03,F
1806:  INCF   00,F
1808:  BTFSC  FD8.2
180A:  INCF   01,F
180C:  BTFSC  FD8.2
180E:  INCF   02,F
1810:  BTFSC  FD8.2
1812:  INCF   03,F
1814:  MOVLB  0
1816:  GOTO   1922 (RETURN)
181A:  BTFSC  FD8.1
181C:  BRA    1826
181E:  MOVLW  01
1820:  MOVWF  FEA
1822:  MOVLW  B8
1824:  MOVWF  FE9
1826:  CLRF   00
1828:  CLRF   01
182A:  CLRF   02
182C:  CLRF   03
182E:  MOVLB  1
1830:  CLRF   xB8
1832:  CLRF   xB9
1834:  CLRF   xBA
1836:  CLRF   xBB
1838:  MOVF   xB7,W
183A:  IORWF  xB6,W
183C:  IORWF  xB5,W
183E:  IORWF  xB4,W
1840:  BZ    189A
1842:  MOVLW  20
1844:  MOVWF  xBC
1846:  BCF    FD8.0
1848:  RLCF   xB0,F
184A:  RLCF   xB1,F
184C:  RLCF   xB2,F
184E:  RLCF   xB3,F
1850:  RLCF   xB8,F
1852:  RLCF   xB9,F
1854:  RLCF   xBA,F
1856:  RLCF   xBB,F
1858:  MOVF   xB7,W
185A:  SUBWF  xBB,W
185C:  BNZ   186E
185E:  MOVF   xB6,W
1860:  SUBWF  xBA,W
1862:  BNZ   186E
1864:  MOVF   xB5,W
1866:  SUBWF  xB9,W
1868:  BNZ   186E
186A:  MOVF   xB4,W
186C:  SUBWF  xB8,W
186E:  BNC   188E
1870:  MOVF   xB4,W
1872:  SUBWF  xB8,F
1874:  MOVF   xB5,W
1876:  BTFSS  FD8.0
1878:  INCFSZ xB5,W
187A:  SUBWF  xB9,F
187C:  MOVF   xB6,W
187E:  BTFSS  FD8.0
1880:  INCFSZ xB6,W
1882:  SUBWF  xBA,F
1884:  MOVF   xB7,W
1886:  BTFSS  FD8.0
1888:  INCFSZ xB7,W
188A:  SUBWF  xBB,F
188C:  BSF    FD8.0
188E:  RLCF   00,F
1890:  RLCF   01,F
1892:  RLCF   02,F
1894:  RLCF   03,F
1896:  DECFSZ xBC,F
1898:  BRA    1846
189A:  MOVFF  1B8,FEF
189E:  MOVFF  1B9,FEC
18A2:  MOVFF  1BA,FEC
18A6:  MOVFF  1BB,FEC
18AA:  MOVLB  0
18AC:  RETURN 0
18AE:  MOVFF  C6,FEA
18B2:  MOVFF  C5,FE9
18B6:  MOVFF  23D,FEF
18BA:  INCF   FE9,F
18BC:  BTFSC  FD8.2
18BE:  INCF   FEA,F
18C0:  CLRF   FEF
18C2:  MOVLB  0
18C4:  INCF   xC5,F
18C6:  BTFSC  FD8.2
18C8:  INCF   xC6,F
18CA:  RETURN 0
18CC:  MOVF   FE9,W
18CE:  MOVLB  1
18D0:  MOVWF  xA8
18D2:  MOVF   xA7,W
18D4:  MOVWF  xAA
18D6:  BZ    190E
18D8:  MOVFF  1A6,1E8
18DC:  MOVFF  1A5,1E7
18E0:  MOVFF  1A4,1E6
18E4:  MOVFF  1A3,1E5
18E8:  CLRF   xEC
18EA:  CLRF   xEB
18EC:  MOVLW  20
18EE:  MOVWF  xEA
18F0:  MOVLW  82
18F2:  MOVWF  xE9
18F4:  MOVLB  0
18F6:  RCALL  16E0
18F8:  MOVFF  03,1A6
18FC:  MOVFF  02,1A5
1900:  MOVFF  01,1A4
1904:  MOVFF  00,1A3
1908:  MOVLB  1
190A:  DECFSZ xAA,F
190C:  BRA    18D8
190E:  MOVFF  1A6,1B3
1912:  MOVFF  1A5,1B2
1916:  MOVFF  1A4,1B1
191A:  MOVFF  1A3,1B0
191E:  MOVLB  0
1920:  BRA    17D6
1922:  MOVFF  03,1A6
1926:  MOVFF  02,1A5
192A:  MOVFF  01,1A4
192E:  MOVFF  00,1A3
1932:  MOVLB  1
1934:  BTFSS  xA6.7
1936:  BRA    1952
1938:  DECF   xA8,F
193A:  BSF    xA8.5
193C:  COMF   xA3,F
193E:  COMF   xA4,F
1940:  COMF   xA5,F
1942:  COMF   xA6,F
1944:  INCF   xA3,F
1946:  BTFSC  FD8.2
1948:  INCF   xA4,F
194A:  BTFSC  FD8.2
194C:  INCF   xA5,F
194E:  BTFSC  FD8.2
1950:  INCF   xA6,F
1952:  MOVLW  3B
1954:  MOVWF  xAF
1956:  MOVLW  9A
1958:  MOVWF  xAE
195A:  MOVLW  CA
195C:  MOVWF  xAD
195E:  CLRF   xAC
1960:  MOVLW  0A
1962:  MOVWF  xAA
1964:  MOVF   xA7,W
1966:  BTFSC  FD8.2
1968:  INCF   xA8,F
196A:  BSF    FD8.1
196C:  MOVLW  01
196E:  MOVWF  FEA
1970:  MOVLW  A3
1972:  MOVWF  FE9
1974:  MOVFF  1A6,1B3
1978:  MOVFF  1A5,1B2
197C:  MOVFF  1A4,1B1
1980:  MOVFF  1A3,1B0
1984:  MOVFF  1AF,1B7
1988:  MOVFF  1AE,1B6
198C:  MOVFF  1AD,1B5
1990:  MOVFF  1AC,1B4
1994:  MOVLB  0
1996:  RCALL  181A
1998:  MOVF   01,W
199A:  MOVF   00,F
199C:  BNZ   19C4
199E:  MOVLB  1
19A0:  INCF   xA7,W
19A2:  SUBWF  xAA,W
19A4:  BTFSS  FD8.2
19A6:  BRA    19AC
19A8:  MOVLB  0
19AA:  BRA    19C4
19AC:  MOVF   xA8,W
19AE:  BZ    19CA
19B0:  ANDLW  0F
19B2:  SUBWF  xAA,W
19B4:  BZ    19B8
19B6:  BC    1A3E
19B8:  BTFSC  xA8.7
19BA:  BRA    1A3E
19BC:  BTFSC  xA8.6
19BE:  BRA    19CA
19C0:  MOVLW  20
19C2:  BRA    1A32
19C4:  MOVLW  20
19C6:  MOVLB  1
19C8:  ANDWF  xA8,F
19CA:  BTFSS  xA8.5
19CC:  BRA    19EC
19CE:  BCF    xA8.5
19D0:  MOVF   xA7,W
19D2:  BTFSS  FD8.2
19D4:  DECF   xA8,F
19D6:  MOVF   00,W
19D8:  MOVWF  xA8
19DA:  MOVLW  2D
19DC:  MOVLB  2
19DE:  MOVWF  x3D
19E0:  MOVLB  0
19E2:  RCALL  18AE
19E4:  MOVLB  1
19E6:  MOVF   xA8,W
19E8:  MOVWF  00
19EA:  CLRF   xA8
19EC:  MOVF   xA7,W
19EE:  SUBWF  xAA,W
19F0:  BNZ   1A0C
19F2:  MOVF   00,W
19F4:  MOVWF  xA8
19F6:  MOVLW  2E
19F8:  MOVLB  2
19FA:  MOVWF  x3D
19FC:  MOVLB  0
19FE:  RCALL  18AE
1A00:  MOVLB  1
1A02:  MOVF   xA8,W
1A04:  MOVWF  00
1A06:  MOVLW  20
1A08:  ANDWF  xA8,F
1A0A:  MOVLW  00
1A0C:  MOVLW  30
1A0E:  BTFSS  xA8.5
1A10:  BRA    1A32
1A12:  BCF    xA8.5
1A14:  MOVF   xA7,W
1A16:  BTFSS  FD8.2
1A18:  DECF   xA8,F
1A1A:  MOVF   00,W
1A1C:  MOVWF  xA8
1A1E:  MOVLW  2D
1A20:  MOVLB  2
1A22:  MOVWF  x3D
1A24:  MOVLB  0
1A26:  RCALL  18AE
1A28:  MOVLB  1
1A2A:  MOVF   xA8,W
1A2C:  MOVWF  00
1A2E:  CLRF   xA8
1A30:  MOVLW  30
1A32:  ADDWF  00,F
1A34:  MOVFF  00,23D
1A38:  MOVLB  0
1A3A:  RCALL  18AE
1A3C:  MOVLB  1
1A3E:  BCF    FD8.1
1A40:  MOVFF  1AF,1B3
1A44:  MOVFF  1AE,1B2
1A48:  MOVFF  1AD,1B1
1A4C:  MOVFF  1AC,1B0
1A50:  CLRF   xB7
1A52:  CLRF   xB6
1A54:  CLRF   xB5
1A56:  MOVLW  0A
1A58:  MOVWF  xB4
1A5A:  MOVLB  0
1A5C:  RCALL  181A
1A5E:  MOVFF  03,1AF
1A62:  MOVFF  02,1AE
1A66:  MOVFF  01,1AD
1A6A:  MOVFF  00,1AC
1A6E:  MOVLB  1
1A70:  DECFSZ xAA,F
1A72:  BRA    196A
1A74:  MOVLB  0
1A76:  GOTO   1B72 (RETURN)
*
1B12:  MOVF   FEF,F
1B14:  BZ    1B34
1B16:  MOVFF  FEA,237
1B1A:  MOVFF  FE9,236
1B1E:  MOVFF  FEF,238
1B22:  BRA    1AD2
1B24:  MOVFF  237,FEA
1B28:  MOVFF  236,FE9
1B2C:  INCF   FE9,F
1B2E:  BTFSC  FD8.2
1B30:  INCF   FEA,F
1B32:  BRA    1B12
1B34:  GOTO   1B4A (RETURN)
*
1CEE:  MOVLB  2
1CF0:  BTFSC  x35.7
1CF2:  BRA    1D16
1CF4:  MOVLW  0F
1CF6:  MOVWF  00
1CF8:  SWAPF  x34,W
1CFA:  ANDWF  00,F
1CFC:  MOVLW  0A
1CFE:  SUBWF  00,W
1D00:  BC    1D08
1D02:  MOVLW  30
1D04:  ADDWF  00,F
1D06:  BRA    1D0C
1D08:  MOVF   x35,W
1D0A:  ADDWF  00,F
1D0C:  MOVFF  00,23D
1D10:  MOVLB  0
1D12:  RCALL  18AE
1D14:  MOVLB  2
1D16:  MOVLW  0F
1D18:  ANDWF  x34,F
1D1A:  MOVLW  0A
1D1C:  SUBWF  x34,W
1D1E:  BC    1D24
1D20:  MOVLW  30
1D22:  BRA    1D28
1D24:  BCF    x35.7
1D26:  MOVF   x35,W
1D28:  ADDWF  x34,F
1D2A:  MOVFF  234,23D
1D2E:  MOVLB  0
1D30:  RCALL  18AE
1D32:  GOTO   1FD0 (RETURN)
1D36:  MOVFF  FEA,23C
1D3A:  MOVFF  FE9,23B
1D3E:  MOVLB  2
1D40:  BTFSS  x35.7
1D42:  BRA    1D54
1D44:  BSF    x3B.7
1D46:  BTFSS  x3B.4
1D48:  INCF   x3B,F
1D4A:  COMF   x34,F
1D4C:  COMF   x35,F
1D4E:  INCF   x34,F
1D50:  BTFSC  FD8.2
1D52:  INCF   x35,F
1D54:  SWAPF  x35,W
1D56:  IORLW  F0
1D58:  MOVWF  x37
1D5A:  ADDWF  x37,F
1D5C:  ADDLW  E2
1D5E:  MOVWF  x38
1D60:  ADDLW  32
1D62:  MOVWF  x3A
1D64:  MOVF   x35,W
1D66:  ANDLW  0F
1D68:  ADDWF  x38,F
1D6A:  ADDWF  x38,F
1D6C:  ADDWF  x3A,F
1D6E:  ADDLW  E9
1D70:  MOVWF  x39
1D72:  ADDWF  x39,F
1D74:  ADDWF  x39,F
1D76:  SWAPF  x34,W
1D78:  ANDLW  0F
1D7A:  ADDWF  x39,F
1D7C:  ADDWF  x3A,F
1D7E:  RLCF   x39,F
1D80:  RLCF   x3A,F
1D82:  COMF   x3A,F
1D84:  RLCF   x3A,F
1D86:  MOVF   x34,W
1D88:  ANDLW  0F
1D8A:  ADDWF  x3A,F
1D8C:  RLCF   x37,F
1D8E:  MOVLW  07
1D90:  MOVWF  x36
1D92:  MOVLW  0A
1D94:  DECF   x39,F
1D96:  ADDWF  x3A,F
1D98:  BNC   1D94
1D9A:  DECF   x38,F
1D9C:  ADDWF  x39,F
1D9E:  BNC   1D9A
1DA0:  DECF   x37,F
1DA2:  ADDWF  x38,F
1DA4:  BNC   1DA0
1DA6:  DECF   x36,F
1DA8:  ADDWF  x37,F
1DAA:  BNC   1DA6
1DAC:  MOVLW  02
1DAE:  MOVWF  FEA
1DB0:  MOVLW  36
1DB2:  MOVWF  FE9
1DB4:  MOVLW  07
1DB6:  ANDWF  x3B,W
1DB8:  BCF    x3B.6
1DBA:  MOVF   FED,F
1DBC:  ANDWF  x3B,W
1DBE:  BNZ   1DCE
1DC0:  BTFSC  x3B.4
1DC2:  MOVF   FEE,F
1DC4:  BTFSC  x3B.4
1DC6:  BRA    1DCE
1DC8:  MOVLW  20
1DCA:  MOVWF  00
1DCC:  BRA    1E10
1DCE:  ADDWF  FE9,F
1DD0:  MOVLW  00
1DD2:  ADDWFC FEA,F
1DD4:  MOVF   FE9,W
1DD6:  SUBLW  3A
1DD8:  BNZ   1DE2
1DDA:  MOVF   FEA,W
1DDC:  SUBLW  02
1DDE:  BNZ   1DE2
1DE0:  BSF    x3B.6
1DE2:  MOVF   FEF,W
1DE4:  MOVWF  00
1DE6:  BNZ   1DF8
1DE8:  BTFSC  x3B.6
1DEA:  BRA    1DF8
1DEC:  BTFSC  x3B.4
1DEE:  BRA    1E2A
1DF0:  BTFSC  x3B.3
1DF2:  BRA    1DF8
1DF4:  MOVLW  20
1DF6:  BRA    1E0E
1DF8:  BTFSS  x3B.7
1DFA:  BRA    1E08
1DFC:  MOVLW  2D
1DFE:  MOVWF  00
1E00:  MOVF   FED,W
1E02:  BCF    x3B.6
1E04:  BCF    x3B.7
1E06:  BRA    1E10
1E08:  BSF    x3B.3
1E0A:  BCF    x3B.4
1E0C:  MOVLW  30
1E0E:  ADDWF  00,F
1E10:  MOVFF  FEA,235
1E14:  MOVFF  FE9,234
1E18:  MOVFF  00,23D
1E1C:  MOVLB  0
1E1E:  RCALL  18AE
1E20:  MOVFF  235,FEA
1E24:  MOVFF  234,FE9
1E28:  MOVLB  2
1E2A:  MOVF   FEE,W
1E2C:  BTFSS  x3B.6
1E2E:  BRA    1DD4
1E30:  MOVLB  0
1E32:  GOTO   1FAE (RETURN)
1E36:  MOVFF  FEA,23C
1E3A:  MOVFF  FE9,23B
1E3E:  MOVLB  2
1E40:  SWAPF  x35,W
1E42:  IORLW  F0
1E44:  MOVWF  x37
1E46:  ADDWF  x37,F
1E48:  ADDLW  E2
1E4A:  MOVWF  x38
1E4C:  ADDLW  32
1E4E:  MOVWF  x3A
1E50:  MOVF   x35,W
1E52:  ANDLW  0F
1E54:  ADDWF  x38,F
1E56:  ADDWF  x38,F
1E58:  ADDWF  x3A,F
1E5A:  ADDLW  E9
1E5C:  MOVWF  x39
1E5E:  ADDWF  x39,F
1E60:  ADDWF  x39,F
1E62:  SWAPF  x34,W
1E64:  ANDLW  0F
1E66:  ADDWF  x39,F
1E68:  ADDWF  x3A,F
1E6A:  RLCF   x39,F
1E6C:  RLCF   x3A,F
1E6E:  COMF   x3A,F
1E70:  RLCF   x3A,F
1E72:  MOVF   x34,W
1E74:  ANDLW  0F
1E76:  ADDWF  x3A,F
1E78:  RLCF   x37,F
1E7A:  MOVLW  07
1E7C:  MOVWF  x36
1E7E:  MOVLW  0A
1E80:  DECF   x39,F
1E82:  ADDWF  x3A,F
1E84:  BNC   1E80
1E86:  DECF   x38,F
1E88:  ADDWF  x39,F
1E8A:  BNC   1E86
1E8C:  DECF   x37,F
1E8E:  ADDWF  x38,F
1E90:  BNC   1E8C
1E92:  DECF   x36,F
1E94:  ADDWF  x37,F
1E96:  BNC   1E92
1E98:  MOVLW  02
1E9A:  MOVWF  FEA
1E9C:  MOVLW  36
1E9E:  MOVWF  FE9
1EA0:  MOVLW  07
1EA2:  ANDWF  x3B,W
1EA4:  BCF    x3B.6
1EA6:  ADDWF  FE9,F
1EA8:  MOVLW  00
1EAA:  ADDWFC FEA,F
1EAC:  MOVF   FE9,W
1EAE:  SUBLW  3A
1EB0:  BNZ   1EBA
1EB2:  MOVF   FEA,W
1EB4:  SUBLW  02
1EB6:  BNZ   1EBA
1EB8:  BSF    x3B.6
1EBA:  MOVF   FEF,W
1EBC:  MOVWF  00
1EBE:  BNZ   1ED0
1EC0:  BTFSC  x3B.6
1EC2:  BRA    1ED0
1EC4:  BTFSC  x3B.4
1EC6:  BRA    1EF2
1EC8:  BTFSC  x3B.3
1ECA:  BRA    1ED0
1ECC:  MOVLW  20
1ECE:  BRA    1ED6
1ED0:  BSF    x3B.3
1ED2:  BCF    x3B.4
1ED4:  MOVLW  30
1ED6:  ADDWF  00,F
1ED8:  MOVFF  FEA,235
1EDC:  MOVFF  FE9,234
1EE0:  MOVFF  00,23D
1EE4:  MOVLB  0
1EE6:  RCALL  18AE
1EE8:  MOVFF  235,FEA
1EEC:  MOVFF  234,FE9
1EF0:  MOVLB  2
1EF2:  MOVF   FEE,W
1EF4:  BTFSS  x3B.6
1EF6:  BRA    1EAC
1EF8:  MOVLB  0
1EFA:  GOTO   1FD0 (RETURN)
*
2338:  MOVLB  1
233A:  MOVF   xC0,W
233C:  BTFSC  FD8.2
233E:  BRA    248A
2340:  MOVWF  xCC
2342:  MOVF   xC4,W
2344:  BTFSC  FD8.2
2346:  BRA    248A
2348:  SUBWF  xCC,F
234A:  BNC   2356
234C:  MOVLW  7F
234E:  ADDWF  xCC,F
2350:  BTFSC  FD8.0
2352:  BRA    248A
2354:  BRA    2362
2356:  MOVLW  81
2358:  SUBWF  xCC,F
235A:  BTFSS  FD8.0
235C:  BRA    248A
235E:  BTFSC  FD8.2
2360:  BRA    248A
2362:  MOVFF  1CC,00
2366:  CLRF   01
2368:  CLRF   02
236A:  CLRF   03
236C:  CLRF   xCB
236E:  MOVFF  1C1,1CA
2372:  BSF    xCA.7
2374:  MOVFF  1C2,1C9
2378:  MOVFF  1C3,1C8
237C:  MOVLW  19
237E:  MOVWF  xCC
2380:  MOVF   xC7,W
2382:  SUBWF  xC8,F
2384:  BC    23A0
2386:  MOVLW  01
2388:  SUBWF  xC9,F
238A:  BC    23A0
238C:  SUBWF  xCA,F
238E:  BC    23A0
2390:  SUBWF  xCB,F
2392:  BC    23A0
2394:  INCF   xCB,F
2396:  INCF   xCA,F
2398:  INCF   xC9,F
239A:  MOVF   xC7,W
239C:  ADDWF  xC8,F
239E:  BRA    23F0
23A0:  MOVF   xC6,W
23A2:  SUBWF  xC9,F
23A4:  BC    23CA
23A6:  MOVLW  01
23A8:  SUBWF  xCA,F
23AA:  BC    23CA
23AC:  SUBWF  xCB,F
23AE:  BC    23CA
23B0:  INCF   xCB,F
23B2:  INCF   xCA,F
23B4:  MOVF   xC6,W
23B6:  ADDWF  xC9,F
23B8:  MOVF   xC7,W
23BA:  ADDWF  xC8,F
23BC:  BNC   23F0
23BE:  INCF   xC9,F
23C0:  BNZ   23F0
23C2:  INCF   xCA,F
23C4:  BNZ   23F0
23C6:  INCF   xCB,F
23C8:  BRA    23F0
23CA:  MOVF   xC5,W
23CC:  IORLW  80
23CE:  SUBWF  xCA,F
23D0:  BC    23EE
23D2:  MOVLW  01
23D4:  SUBWF  xCB,F
23D6:  BC    23EE
23D8:  INCF   xCB,F
23DA:  MOVF   xC5,W
23DC:  IORLW  80
23DE:  ADDWF  xCA,F
23E0:  MOVF   xC6,W
23E2:  ADDWF  xC9,F
23E4:  BNC   23B8
23E6:  INCF   xCA,F
23E8:  BNZ   23B8
23EA:  INCF   xCB,F
23EC:  BRA    23B8
23EE:  BSF    03.0
23F0:  DECFSZ xCC,F
23F2:  BRA    23F6
23F4:  BRA    240C
23F6:  BCF    FD8.0
23F8:  RLCF   xC8,F
23FA:  RLCF   xC9,F
23FC:  RLCF   xCA,F
23FE:  RLCF   xCB,F
2400:  BCF    FD8.0
2402:  RLCF   03,F
2404:  RLCF   02,F
2406:  RLCF   01,F
2408:  RLCF   xCD,F
240A:  BRA    2380
240C:  BTFSS  xCD.0
240E:  BRA    241C
2410:  BCF    FD8.0
2412:  RRCF   01,F
2414:  RRCF   02,F
2416:  RRCF   03,F
2418:  RRCF   xCD,F
241A:  BRA    2420
241C:  DECF   00,F
241E:  BZ    248A
2420:  BTFSC  xCD.7
2422:  BRA    2460
2424:  BCF    FD8.0
2426:  RLCF   xC8,F
2428:  RLCF   xC9,F
242A:  RLCF   xCA,F
242C:  RLCF   xCB,F
242E:  MOVF   xC7,W
2430:  SUBWF  xC8,F
2432:  BC    2442
2434:  MOVLW  01
2436:  SUBWF  xC9,F
2438:  BC    2442
243A:  SUBWF  xCA,F
243C:  BC    2442
243E:  SUBWF  xCB,F
2440:  BNC   2476
2442:  MOVF   xC6,W
2444:  SUBWF  xC9,F
2446:  BC    2452
2448:  MOVLW  01
244A:  SUBWF  xCA,F
244C:  BC    2452
244E:  SUBWF  xCB,F
2450:  BNC   2476
2452:  MOVF   xC5,W
2454:  IORLW  80
2456:  SUBWF  xCA,F
2458:  BC    2460
245A:  MOVLW  01
245C:  SUBWF  xCB,F
245E:  BNC   2476
2460:  INCF   03,F
2462:  BNZ   2476
2464:  INCF   02,F
2466:  BNZ   2476
2468:  INCF   01,F
246A:  BNZ   2476
246C:  INCF   00,F
246E:  BZ    248A
2470:  RRCF   01,F
2472:  RRCF   02,F
2474:  RRCF   03,F
2476:  MOVFF  1C1,1CC
247A:  MOVF   xC5,W
247C:  XORWF  xCC,F
247E:  BTFSS  xCC.7
2480:  BRA    2486
2482:  BSF    01.7
2484:  BRA    2492
2486:  BCF    01.7
2488:  BRA    2492
248A:  CLRF   00
248C:  CLRF   01
248E:  CLRF   02
2490:  CLRF   03
2492:  MOVLB  0
2494:  RETURN 0
2496:  MOVLW  80
2498:  BTFSS  FD8.1
249A:  BRA    24A0
249C:  MOVLB  1
249E:  XORWF  xE8,F
24A0:  MOVLB  1
24A2:  CLRF   xED
24A4:  CLRF   xEE
24A6:  MOVFF  1E4,1EC
24AA:  MOVF   xE8,W
24AC:  XORWF  xEC,F
24AE:  MOVF   xE3,W
24B0:  BTFSC  FD8.2
24B2:  BRA    2672
24B4:  MOVWF  xEB
24B6:  MOVWF  00
24B8:  MOVF   xE7,W
24BA:  BTFSC  FD8.2
24BC:  BRA    2684
24BE:  SUBWF  xEB,F
24C0:  BTFSC  FD8.2
24C2:  BRA    25CA
24C4:  BNC   2542
24C6:  MOVFF  1E8,1F1
24CA:  BSF    xF1.7
24CC:  MOVFF  1E9,1F0
24D0:  MOVFF  1EA,1EF
24D4:  CLRF   xEE
24D6:  BCF    FD8.0
24D8:  RRCF   xF1,F
24DA:  RRCF   xF0,F
24DC:  RRCF   xEF,F
24DE:  RRCF   xEE,F
24E0:  DECFSZ xEB,F
24E2:  BRA    24D4
24E4:  BTFSS  xEC.7
24E6:  BRA    24EE
24E8:  BSF    xED.0
24EA:  BRA    26AC
24EC:  BCF    xED.0
24EE:  BCF    xEB.0
24F0:  BSF    xED.4
24F2:  MOVLW  01
24F4:  MOVWF  FEA
24F6:  MOVLW  E6
24F8:  MOVWF  FE9
24FA:  BRA    26D2
24FC:  BCF    xED.4
24FE:  BTFSC  xEC.7
2500:  BRA    2516
2502:  BTFSS  xEB.0
2504:  BRA    252C
2506:  RRCF   xF1,F
2508:  RRCF   xF0,F
250A:  RRCF   xEF,F
250C:  RRCF   xEE,F
250E:  INCF   00,F
2510:  BTFSC  FD8.2
2512:  BRA    26A2
2514:  BRA    252C
2516:  BTFSC  xF1.7
2518:  BRA    2532
251A:  BCF    FD8.0
251C:  RLCF   xEE,F
251E:  RLCF   xEF,F
2520:  RLCF   xF0,F
2522:  RLCF   xF1,F
2524:  DECF   00,F
2526:  BTFSC  FD8.2
2528:  BRA    26A2
252A:  BRA    2516
252C:  BSF    xED.6
252E:  BRA    260A
2530:  BCF    xED.6
2532:  MOVFF  1E4,1EC
2536:  BTFSS  xE4.7
2538:  BRA    253E
253A:  BSF    xF1.7
253C:  BRA    2694
253E:  BCF    xF1.7
2540:  BRA    2694
2542:  MOVFF  1E7,1EB
2546:  MOVFF  1E7,00
254A:  MOVF   xE3,W
254C:  SUBWF  xEB,F
254E:  MOVFF  1E4,1F1
2552:  BSF    xF1.7
2554:  MOVFF  1E5,1F0
2558:  MOVFF  1E6,1EF
255C:  CLRF   xEE
255E:  BCF    FD8.0
2560:  RRCF   xF1,F
2562:  RRCF   xF0,F
2564:  RRCF   xEF,F
2566:  RRCF   xEE,F
2568:  DECFSZ xEB,F
256A:  BRA    255C
256C:  BTFSS  xEC.7
256E:  BRA    2576
2570:  BSF    xED.1
2572:  BRA    26AC
2574:  BCF    xED.1
2576:  BCF    xEB.0
2578:  BSF    xED.5
257A:  MOVLW  01
257C:  MOVWF  FEA
257E:  MOVLW  EA
2580:  MOVWF  FE9
2582:  BRA    26D2
2584:  BCF    xED.5
2586:  BTFSC  xEC.7
2588:  BRA    259E
258A:  BTFSS  xEB.0
258C:  BRA    25B4
258E:  RRCF   xF1,F
2590:  RRCF   xF0,F
2592:  RRCF   xEF,F
2594:  RRCF   xEE,F
2596:  INCF   00,F
2598:  BTFSC  FD8.2
259A:  BRA    26A2
259C:  BRA    25B4
259E:  BTFSC  xF1.7
25A0:  BRA    25BA
25A2:  BCF    FD8.0
25A4:  RLCF   xEE,F
25A6:  RLCF   xEF,F
25A8:  RLCF   xF0,F
25AA:  RLCF   xF1,F
25AC:  DECF   00,F
25AE:  BTFSC  FD8.2
25B0:  BRA    26A2
25B2:  BRA    259E
25B4:  BSF    xED.7
25B6:  BRA    260A
25B8:  BCF    xED.7
25BA:  MOVFF  1E8,1EC
25BE:  BTFSS  xE8.7
25C0:  BRA    25C6
25C2:  BSF    xF1.7
25C4:  BRA    2694
25C6:  BCF    xF1.7
25C8:  BRA    2694
25CA:  MOVFF  1E8,1F1
25CE:  BSF    xF1.7
25D0:  MOVFF  1E9,1F0
25D4:  MOVFF  1EA,1EF
25D8:  BTFSS  xEC.7
25DA:  BRA    25E4
25DC:  BCF    xF1.7
25DE:  BSF    xED.2
25E0:  BRA    26AC
25E2:  BCF    xED.2
25E4:  CLRF   xEE
25E6:  BCF    xEB.0
25E8:  MOVLW  01
25EA:  MOVWF  FEA
25EC:  MOVLW  E6
25EE:  MOVWF  FE9
25F0:  BRA    26D2
25F2:  BTFSC  xEC.7
25F4:  BRA    262E
25F6:  MOVFF  1E4,1EC
25FA:  BTFSS  xEB.0
25FC:  BRA    260A
25FE:  RRCF   xF1,F
2600:  RRCF   xF0,F
2602:  RRCF   xEF,F
2604:  RRCF   xEE,F
2606:  INCF   00,F
2608:  BZ    26A2
260A:  BTFSS  xEE.7
260C:  BRA    2624
260E:  INCF   xEF,F
2610:  BNZ   2624
2612:  INCF   xF0,F
2614:  BNZ   2624
2616:  INCF   xF1,F
2618:  BNZ   2624
261A:  RRCF   xF1,F
261C:  RRCF   xF0,F
261E:  RRCF   xEF,F
2620:  INCF   00,F
2622:  BZ    26A2
2624:  BTFSC  xED.6
2626:  BRA    2530
2628:  BTFSC  xED.7
262A:  BRA    25B8
262C:  BRA    2666
262E:  MOVLW  80
2630:  XORWF  xF1,F
2632:  BTFSS  xF1.7
2634:  BRA    263E
2636:  BRA    26AC
2638:  MOVFF  1E8,1EC
263C:  BRA    2652
263E:  MOVFF  1E4,1EC
2642:  MOVF   xF1,F
2644:  BNZ   2652
2646:  MOVF   xF0,F
2648:  BNZ   2652
264A:  MOVF   xEF,F
264C:  BNZ   2652
264E:  CLRF   00
2650:  BRA    2694
2652:  BTFSC  xF1.7
2654:  BRA    2666
2656:  BCF    FD8.0
2658:  RLCF   xEE,F
265A:  RLCF   xEF,F
265C:  RLCF   xF0,F
265E:  RLCF   xF1,F
2660:  DECFSZ 00,F
2662:  BRA    2652
2664:  BRA    26A2
2666:  BTFSS  xEC.7
2668:  BRA    266E
266A:  BSF    xF1.7
266C:  BRA    2694
266E:  BCF    xF1.7
2670:  BRA    2694
2672:  MOVFF  1E7,00
2676:  MOVFF  1E8,1F1
267A:  MOVFF  1E9,1F0
267E:  MOVFF  1EA,1EF
2682:  BRA    2694
2684:  MOVFF  1E3,00
2688:  MOVFF  1E4,1F1
268C:  MOVFF  1E5,1F0
2690:  MOVFF  1E6,1EF
2694:  MOVFF  1F1,01
2698:  MOVFF  1F0,02
269C:  MOVFF  1EF,03
26A0:  BRA    270A
26A2:  CLRF   00
26A4:  CLRF   01
26A6:  CLRF   02
26A8:  CLRF   03
26AA:  BRA    270A
26AC:  CLRF   xEE
26AE:  COMF   xEF,F
26B0:  COMF   xF0,F
26B2:  COMF   xF1,F
26B4:  COMF   xEE,F
26B6:  INCF   xEE,F
26B8:  BNZ   26C4
26BA:  INCF   xEF,F
26BC:  BNZ   26C4
26BE:  INCF   xF0,F
26C0:  BNZ   26C4
26C2:  INCF   xF1,F
26C4:  BTFSC  xED.0
26C6:  BRA    24EC
26C8:  BTFSC  xED.1
26CA:  BRA    2574
26CC:  BTFSC  xED.2
26CE:  BRA    25E2
26D0:  BRA    2638
26D2:  MOVF   FEF,W
26D4:  ADDWF  xEF,F
26D6:  BNC   26E2
26D8:  INCF   xF0,F
26DA:  BNZ   26E2
26DC:  INCF   xF1,F
26DE:  BTFSC  FD8.2
26E0:  BSF    xEB.0
26E2:  MOVF   FED,F
26E4:  MOVF   FEF,W
26E6:  ADDWF  xF0,F
26E8:  BNC   26F0
26EA:  INCF   xF1,F
26EC:  BTFSC  FD8.2
26EE:  BSF    xEB.0
26F0:  MOVF   FED,F
26F2:  MOVF   FEF,W
26F4:  BTFSC  FEF.7
26F6:  BRA    26FA
26F8:  XORLW  80
26FA:  ADDWF  xF1,F
26FC:  BTFSC  FD8.0
26FE:  BSF    xEB.0
2700:  BTFSC  xED.4
2702:  BRA    24FC
2704:  BTFSC  xED.5
2706:  BRA    2584
2708:  BRA    25F2
270A:  MOVLB  0
270C:  RETURN 0
270E:  MOVLW  8E
2710:  MOVWF  00
2712:  MOVLB  1
2714:  MOVF   xC0,W
2716:  SUBWF  00,F
2718:  MOVFF  1C1,02
271C:  MOVFF  1C2,01
2720:  BSF    02.7
2722:  MOVF   00,F
2724:  BZ    2738
2726:  BCF    FD8.0
2728:  MOVF   02,F
272A:  BNZ   2730
272C:  MOVF   01,F
272E:  BZ    2738
2730:  RRCF   02,F
2732:  RRCF   01,F
2734:  DECFSZ 00,F
2736:  BRA    2726
2738:  BTFSS  xC1.7
273A:  BRA    2746
273C:  COMF   01,F
273E:  COMF   02,F
2740:  INCF   01,F
2742:  BTFSC  FD8.2
2744:  INCF   02,F
2746:  MOVLB  0
2748:  RETURN 0
*
2D26:  MOVFF  1E4,1EB
2D2A:  MOVLB  1
2D2C:  MOVF   xE8,W
2D2E:  XORWF  xEB,F
2D30:  BTFSS  xEB.7
2D32:  BRA    2D3E
2D34:  BCF    FD8.2
2D36:  BCF    FD8.0
2D38:  BTFSC  xE4.7
2D3A:  BSF    FD8.0
2D3C:  BRA    2D9C
2D3E:  MOVFF  1E4,1EB
2D42:  MOVFF  1E7,1EC
2D46:  MOVF   xE3,W
2D48:  SUBWF  xEC,F
2D4A:  BZ    2D58
2D4C:  BTFSS  xEB.7
2D4E:  BRA    2D9C
2D50:  MOVF   FD8,W
2D52:  XORLW  01
2D54:  MOVWF  FD8
2D56:  BRA    2D9C
2D58:  MOVFF  1E8,1EC
2D5C:  MOVF   xE4,W
2D5E:  SUBWF  xEC,F
2D60:  BZ    2D6E
2D62:  BTFSS  xEB.7
2D64:  BRA    2D9C
2D66:  MOVF   FD8,W
2D68:  XORLW  01
2D6A:  MOVWF  FD8
2D6C:  BRA    2D9C
2D6E:  MOVFF  1E9,1EC
2D72:  MOVF   xE5,W
2D74:  SUBWF  xEC,F
2D76:  BZ    2D84
2D78:  BTFSS  xEB.7
2D7A:  BRA    2D9C
2D7C:  MOVF   FD8,W
2D7E:  XORLW  01
2D80:  MOVWF  FD8
2D82:  BRA    2D9C
2D84:  MOVFF  1EA,1EC
2D88:  MOVF   xE6,W
2D8A:  SUBWF  xEC,F
2D8C:  BZ    2D9A
2D8E:  BTFSS  xEB.7
2D90:  BRA    2D9C
2D92:  MOVF   FD8,W
2D94:  XORLW  01
2D96:  MOVWF  FD8
2D98:  BRA    2D9C
2D9A:  BCF    FD8.0
2D9C:  MOVLB  0
2D9E:  RETURN 0
*
2F70:  MOVLB  1
2F72:  MOVF   xBE,W
2F74:  CLRF   01
2F76:  SUBWF  xBD,W
2F78:  BC    2F80
2F7A:  MOVFF  1BD,00
2F7E:  BRA    2F98
2F80:  CLRF   00
2F82:  MOVLW  08
2F84:  MOVWF  xBF
2F86:  RLCF   xBD,F
2F88:  RLCF   00,F
2F8A:  MOVF   xBE,W
2F8C:  SUBWF  00,W
2F8E:  BTFSC  FD8.0
2F90:  MOVWF  00
2F92:  RLCF   01,F
2F94:  DECFSZ xBF,F
2F96:  BRA    2F86
2F98:  MOVLB  0
2F9A:  RETURN 0
2F9C:  MOVLW  20
2F9E:  MOVLB  1
2FA0:  BTFSS  xB8.4
2FA2:  MOVLW  30
2FA4:  MOVWF  xB9
2FA6:  MOVFF  1B7,00
2FAA:  BTFSS  00.7
2FAC:  BRA    2FBE
2FAE:  COMF   00,F
2FB0:  INCF   00,F
2FB2:  MOVFF  00,1B7
2FB6:  MOVLW  2D
2FB8:  MOVWF  xB9
2FBA:  BSF    xB8.7
2FBC:  BSF    xB8.0
2FBE:  MOVF   01,W
2FC0:  MOVFF  1B7,1BD
2FC4:  MOVLW  64
2FC6:  MOVWF  xBE
2FC8:  MOVLB  0
2FCA:  RCALL  2F70
2FCC:  MOVFF  00,1B7
2FD0:  MOVLW  30
2FD2:  ADDWF  01,W
2FD4:  MOVLB  1
2FD6:  MOVWF  xBA
2FD8:  MOVFF  1B7,1BD
2FDC:  MOVLW  0A
2FDE:  MOVWF  xBE
2FE0:  MOVLB  0
2FE2:  RCALL  2F70
2FE4:  MOVLW  30
2FE6:  ADDWF  00,W
2FE8:  MOVLB  1
2FEA:  MOVWF  xBC
2FEC:  MOVLW  30
2FEE:  ADDWF  01,W
2FF0:  MOVWF  xBB
2FF2:  MOVFF  1B9,00
2FF6:  MOVLW  30
2FF8:  SUBWF  xBA,W
2FFA:  BZ    3004
2FFC:  BSF    xB8.1
2FFE:  BTFSC  xB8.7
3000:  BSF    xB8.2
3002:  BRA    3028
3004:  MOVFF  1B9,1BA
3008:  MOVLW  20
300A:  MOVWF  xB9
300C:  MOVLW  30
300E:  SUBWF  xBB,W
3010:  BZ    301A
3012:  BSF    xB8.0
3014:  BTFSC  xB8.7
3016:  BSF    xB8.1
3018:  BRA    3028
301A:  BTFSS  FD8.2
301C:  BSF    xB8.0
301E:  BNZ   3028
3020:  MOVFF  1BA,1BB
3024:  MOVLW  20
3026:  MOVWF  xBA
3028:  BTFSC  xB8.2
302A:  BRA    3036
302C:  BTFSC  xB8.1
302E:  BRA    3040
3030:  BTFSC  xB8.0
3032:  BRA    304A
3034:  BRA    3054
3036:  MOVFF  1B9,23D
303A:  MOVLB  0
303C:  CALL   18AE
3040:  MOVFF  1BA,23D
3044:  MOVLB  0
3046:  CALL   18AE
304A:  MOVFF  1BB,23D
304E:  MOVLB  0
3050:  CALL   18AE
3054:  MOVFF  1BC,23D
3058:  MOVLB  0
305A:  CALL   18AE
305E:  GOTO   3914 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #fuses HSPLL, NOWDT, NOPROTECT, NODEBUG, USBDIV, PLL4, CPUDIV1, VREGEN
.................... 
.................... #use delay(clock=48MHz,crystal=16MHz,USB_FULL)
*
15C6:  MOVLW  02
15C8:  MOVWF  FEA
15CA:  MOVLW  1E
15CC:  MOVWF  FE9
15CE:  MOVF   FEF,W
15D0:  BZ    15EE
15D2:  MOVLW  0F
15D4:  MOVWF  01
15D6:  CLRF   00
15D8:  DECFSZ 00,F
15DA:  BRA    15D8
15DC:  DECFSZ 01,F
15DE:  BRA    15D6
15E0:  MOVLW  8F
15E2:  MOVWF  00
15E4:  DECFSZ 00,F
15E6:  BRA    15E4
15E8:  NOP   
15EA:  DECFSZ FEF,F
15EC:  BRA    15D2
15EE:  RETURN 0
*
1606:  MOVLW  01
1608:  MOVLB  2
160A:  SUBWF  x28,F
160C:  BNC   1628
160E:  MOVLW  02
1610:  MOVWF  FEA
1612:  MOVLW  28
1614:  MOVWF  FE9
1616:  MOVF   FEF,W
1618:  BZ    1628
161A:  MOVLW  02
161C:  MOVWF  00
161E:  DECFSZ 00,F
1620:  BRA    161E
1622:  BRA    1624
1624:  DECFSZ FEF,F
1626:  BRA    161A
1628:  MOVLB  0
162A:  GOTO   1664 (RETURN)
.................... #use FIXED_IO( E_outputs=PIN_E0 )
.................... #use FIXED_IO( A_outputs=PIN_A4 )
.................... #define RF_RESET   PIN_E0
.................... #define INDICATOR_LED PIN_A4
.................... 
.................... 
.................... //#define USB_CABLE_IS_ATTACHED()  input(PIN_B2)
.................... #define USB_CONFIG_VID 0x2405
.................... #define USB_CONFIG_PID 0x000B
.................... #define USB_CONFIG_BUS_POWER 500
.................... 
.................... // if USB_CDC_ISR is defined, then this function will be called
.................... // by the USB ISR when there incoming CDC (virtual com port) data.
.................... // this is useful if you want to port old RS232 code that was use
.................... // #int_rda to CDC.
.................... #define USB_CDC_ISR() RDA_isr()
.................... 
.................... // in order for handle_incoming_usb() to be able to transmit the entire
.................... // USB message in one pass, we need to increase the CDC buffer size from
.................... // the normal size and use the USB_CDC_DELAYED_FLUSH option.
.................... // failure to do this would cause some loss of data.
.................... #define USB_CDC_DELAYED_FLUSH
.................... #define USB_CDC_DATA_LOCAL_SIZE  128
.................... 
.................... 
.................... static void RDA_isr(void);
.................... 
.................... #include <usb_cdc.h>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////                            usb_cdc.h                            ////
.................... ////                                                                 ////
.................... //// Library for adding a virtual COM port on your PC over USB using ////
.................... //// the standard Communication Device Class (CDC) specification.    ////
.................... //// Including this file in your code will add all USB code,         ////
.................... //// interrupts, descriptors and handlers required.  No other        ////
.................... //// modifications need to be made.                                  ////
.................... ////                                                                 ////
.................... //// This library creates a virtual RS232 link between the PC and    ////
.................... //// the PIC, therefore the library provided will be familiar to     ////
.................... //// anyone with standard UART stream I/O:                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          ////
.................... ////      character received and waiting in the receive buffer.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  ////
.................... ////      there is no data in the receive buffer it will wait until  ////
.................... ////      there is data in the receive buffer.  If you do not want   ////
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   ////
.................... ////      check if there is data before calling usb_cdc_getc().      ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       ////
.................... ////      buffer.  If the transmit buffer is full it will wait until ////
.................... ////      the transmit buffer is not full before putting the char    ////
.................... ////      into the transmit buffer.  The transmit buffer is read by  ////
.................... ////      the PC very quickly, and therefore the buffer should only  ////
.................... ////      be full for a few milli-seconds.  If you are concerned     ////
.................... ////      and don't want to be stuck in a long or infinite loop,     ////
.................... ////      use usb_cdc_putready() to see if there is space in the     ////
.................... ////      transmit buffer before putting data into the transmit      ////
.................... ////      buffer.                                                    ////
.................... ////                                                                 ////
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    ////
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'ptr' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    ////
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'len' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putready() - Returns the number of bytes available      ////
.................... ////     in the TX buffer for storing characters.  If this returns   ////
.................... ////     0 then the buffer is full and waiting for the host (PC)     ////
.................... ////     to read the buffer.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   ////
.................... ////     empty and fully flushed/transmitted to host (PC).           ////
.................... ////                                                                 ////
.................... //// usb_cdc_connected() - Returns TRUE if we received a             ////
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   ////
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        ////
.................... ////      message when the program starts and it opens the virtual   ////
.................... ////      COM port.  This is a simple way to determine if the PC     ////
.................... ////      is ready to display data on a serial terminal program,     ////
.................... ////      but is not garaunteed to work all the time or on other     ////
.................... ////      terminal programs.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   ////
.................... ////      if the transmit buffer is full it will skip the char.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  ////
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   ////
.................... ////                                                                 ////
.................... //// usb_cdc_break - If the PC has sent a break command, this will   ////
.................... ////       hold the break time (in milli-seconds).  If the PC sends  ////
.................... ////       a value of 0xFFFF the device is supposed to hold the      ////
.................... ////       break until it sends a value of 0                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. ////
.................... ////       Of most relevance is the field dte_present, which is the  ////
.................... ////       DTR setting.                                              ////
.................... ////                                                                 ////
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          ////
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   ////
.................... ////       ring, break and more.  See the documentation above        ////
.................... ////       usb_cdc_serial_state() for more information, including    ////
.................... ////       format of state structure.                                ////
.................... ////                                                                 ////
.................... //// The following functions are also provided, and are ports of the ////
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   ////
.................... //// documentation:                                                  ////
.................... ////   get_float_usb() - Read a float number from the user           ////
.................... ////   get_long_usb() - Read a long number from the user             ////
.................... ////   get_int_usb() - Read an integer number from the user          ////
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. ////
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             ////
.................... ////   gethex1_usb() - Read a HEX character                          ////
.................... ////                                                                 ////
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  ////
.................... //// be called when there is incoming CDC (virtual com port) data.   ////
.................... //// This is useful if you want to update legacy RS232 code that     ////
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    ////
.................... //// However, see the INTERRUPT LIMITATIONS section below.           ////
.................... ////                                                                 ////
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    ////
.................... ////  to flush the data as soon as possible.  However at times       ////
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   ////
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         ////
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     ////
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       ////
.................... ////  also attempt to flush the packet on each call to usb_task().   ////
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     ////
.................... ////  if you have a main loop that periodically calls usb_task().    ////
.................... ////                                                                 ////
.................... //// This driver will load all the rest of the USB code, and a set   ////
.................... //// of descriptors that will properly describe a CDC device for a   ////
.................... //// virtual COM port (usb_desc_cdc.h)                               ////
.................... ////                                                                 ////
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      ////
.................... //// standard CDC drivers for a virtual COM port in Windows          ////
.................... //// NT/2000/XP and above.                                           ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// Encapsuated Messages: (USB_CDC_USE_ENCAPSULATED)                ////
.................... //// -------------------------------------------------------------   ////
.................... ////                                                                 ////
.................... //// If USB_CDC_USE_ENCAPSULATED is defined, then the user must      ////
.................... //// provide the following callbacks in their application to provide ////
.................... //// encapsuated message support (SendEncapsulatedCommand and        ////
.................... ////  GetEncapsulatedResponse):                                      ////
.................... ////                                                                 ////
.................... //// usb_cdc_SendEncapsulatedCommand(byte *ptr, unsigned int16 num)  ////
.................... ////     PIC receives encapsulated command from host (PC), 'num'     ////
.................... ////     bytes of message stored in 'ptr'.                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_GetEncapsulatedResponse(byte *ptr, unsigned int16 num)  ////
.................... ////     Host (PC) is asking for 'num' bytes response from the PIC,  ////
.................... ////     PIC should store up to 'num' bytes to 'ptr' as the          ////
.................... ////     response.                                                   ////
.................... ////                                                                 ////
.................... //// Due to the design of the USB stack, all encapsulated messages   ////
.................... //// must be smaller than one endpoint 0 packet.  They cannot be     ////
.................... //// equal in size or larger than the endpoint 0 size.  See          ////
.................... //// USB_MAX_EP0_PACKET_LENGTH.                                      ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// BUFFER SIZES                                                    ////
.................... //// -------------------------------------------------------------   ////
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     ////
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        ////
.................... ////  Full speed devices limit this value to be 64.  To increase     ////
.................... ////  the size of the local PIC buffer you can also define           ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        ////
.................... ////  defined then the total PIC->PC buffer size would be            ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  ////
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      ////
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      ////
.................... ////  then this option isn't used.                                   ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// INTERRUPT LIMITATIONS                                           ////
.................... //// -------------------------------------------------------------   ////
.................... //// This section is only relevant if you are using USB interrupts   ////
.................... ////  and not the USB_ISR_POLLING option.                            ////
.................... ////                                                                 ////
.................... //// USB handling is complex, often requiring several packet         ////
.................... ////  transmissions to accomplish transfer of one block of data.     ////
.................... ////  Most of this processing is done in the USB ISR.  Because       ////
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the ////
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   ////
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  ////
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  ////
.................... ////  overflow the TX buffer than data will be lost.                 ////
.................... ////                                                                 ////
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB ////
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      ////
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           ////
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    ////
.................... ////                                                                 ////
.................... //// ex_usb_serial3.c shows an example of working around these       ////
.................... ////  ISR limitations.  Failure to follow these limitations can      ////
.................... ////  cause the PIC to lockup.  These limtations only need to be     ////
.................... ////  followed in the conditions listed above (writing code in the   ////
.................... ////  ISR or interrupts are disabled).                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// VERSION HISTORY                                                 ////
.................... ////                                                                 ////
.................... //// Nov 20th, 2014:                                                 ////
.................... ////  While usb_cdc_putc() waits for local buffer to be free, also   ////
.................... ////     check the endpoint buffer in case there was a situation     ////
.................... ////     that the ISR for this event was missed.                     ////
.................... ////                                                                 ////
.................... //// Dec 16th, 2013:                                                 ////
.................... ////  Added encapsulated message support.  See                       ////
.................... ////     USB_CDC_USE_ENCAPSULATED above for documentation.           ////
.................... ////                                                                 ////
.................... //// May 31st, 2013:                                                 ////
.................... ////  usb_cdc_putready() now returns the number of bytes available.  ////
.................... ////                                                                 ////
.................... //// May 23rd, 2013:                                                 ////
.................... ////  Added usb_cdc_putd().                                          ////
.................... ////                                                                 ////
.................... //// February 18th, 2013:                                            ////
.................... ////  Enhanced PIC16 support added.                                  ////
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 ////
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    ////
.................... ////                                                                 ////
.................... //// September 13th, 2012:                                           ////
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     ////
.................... ////     (PIC24, dsPIC33).                                           ////
.................... ////  Added usb_cdc_putempty().                                      ////
.................... ////                                                                 ////
.................... //// December 16th, 2011:                                            ////
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will ////
.................... ////     only include the get string helper functions.  This is      ////
.................... ////     a rarely used option, used only if you already wrote your   ////
.................... ////     own getc() and putc() routines.                             ////
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  ////
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      ////
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  ////
.................... ////                                                                 ////
.................... //// Oct 27th, 2011:                                                 ////
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    ////
.................... ////     documentation.  In order for this to work,                  ////
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   ////
.................... ////                                                                 ////
.................... //// Jan 28, 2010:                                                   ////
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    ////
.................... ////     one packet.                                                 ////
.................... ////                                                                 ////
.................... //// Jan 25, 2010:                                                   ////
.................... ////  Ignore incoming 0 length packets.                              ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// April 7th, 2009:                                                ////
.................... ////   Vista 'code 10' issues resolved.                              ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 26th, 2007:                                                 ////
.................... ////              usb_cdc_put_buffer_free() should be more stable.   ////
.................... ////              Fixed a hang-up that would happen if you sent      ////
.................... ////                 exactly 64 bytes.                               ////
.................... ////                                                                 ////
.................... //// Nov 6th, 2007:                                                  ////
.................... ////              Compatabible with latest pic18_usb.h, which        ////
.................... ////                 reduces RAM footprint of USB driver.            ////
.................... ////              This driver now fits on 18F4450/2450 PICs.         ////
.................... ////                                                                 ////
.................... //// October 27th, 2005: Changed the way incoming packets are        ////
.................... ////               handled in that CDC driver will not flush         ////
.................... ////               endpoint until user has handled all data.  This   ////
.................... ////               will prevent overflows as the USB will NAK        ////
.................... ////               incoming packets until it is ready to receive     ////
.................... ////               more.                                             ////
.................... ////            When using 18F4550 family, the RX buffer is          ////
.................... ////               mapped directly to the endpoint buffer - this     ////
.................... ////               saves a chunk of RAM.                             ////
.................... ////            When using the 18F4550 family, you can increase      ////
.................... ////               the TX and RX size over 64 bytes.                 ////
.................... ////            No longer send 0len packets in the TBE interrupt.    ////
.................... ////            Hopefully fixed bugs that caused random crashes      ////
.................... ////               if you tried sending more than 64 bytes.          ////
.................... ////                                                                 ////
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   ////
.................... ////                   buffer.                                       ////
.................... ////                                                                 ////
.................... //// July 1st, 2005: Initial Release.                                ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... //input.c ported to use CDC:
.................... float get_float_usb();
.................... signed long get_long_usb();
.................... signed int get_int_usb();
.................... void get_string_usb(char* s, unsigned int max);
.................... char gethex_usb();
.................... char gethex1_usb();
.................... 
.................... #if !defined(__USB_CDC_HELPERS_ONLY__)
.................... 
.................... //api for the user:
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got)
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free())
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin)
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding)
.................... void usb_cdc_putc_fast(char c);
.................... char usb_cdc_getc(void);
.................... void usb_cdc_putc(char c);
.................... void usb_cdc_get_discard(void);
.................... 
.................... //functions automatically called by USB handler code
.................... void usb_isr_tkn_cdc(void);
.................... void usb_cdc_init(void);
.................... void usb_isr_tok_out_cdc_control_dne(void);
.................... void usb_isr_tok_in_cdc_data_dne(void);
.................... void usb_isr_tok_out_cdc_data_dne(void);
.................... 
.................... void usb_cdc_flush_tx_buffer(void);
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //
.................... // Include the CCS USB Libraries.  See the comments at the top of these
.................... // files for more information
.................... //
.................... /////////////////////////////////////////////////////////////////////////////
.................... #ifndef __USB_PIC_PERIF__
.................... #define __USB_PIC_PERIF__   1
.................... #endif
.................... 
.................... #if __USB_PIC_PERIF__
....................    #if defined(__PCM__)
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c
....................    #elif defined(__PCH__)
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.h                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  This hardware layer      ////
.................... //// supports the USB peripheral on the PIC18 family chips.  Current ////
.................... //// supported families are:                                         ////
.................... ////     PIC18F2455/2550/4455/4550                                   ////
.................... ////     PIC18F2450/4450                                             ////
.................... ////     PIC18F2458/2553/4458/4553                                   ////
.................... ////     PIC18F13K50/14K50                                           ////
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     ////
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       ////
.................... ////     PIC18FxxK50                                                 ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      ////
.................... //// that are specific to only this HW peripheral that you may       ////
.................... //// find useful to use in your application.                         ////
.................... ////                                                                 ////
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    ////
.................... ////  Due to the limited USB RAM of this family, a limitation of     ////
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   ////
.................... ////  The HW actually supports more endpoints, but to simplify       ////
.................... ////  driver development this driver will only support the first 3   ////
.................... ////  so there is an easier memory block to work with.               ////
.................... ////                                                                 ////
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     ////
.................... ////  of USB speed, to save RAM.                                     ////
.................... ////                                                                 ////
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    ////
.................... ////  If you are not using internal pullups, you will need to put    ////
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    ////
.................... ////  want to use slow speed or full speed.  This code configures    ////
.................... ////  the device to use internal pullups, see usb_init() if you      ////
.................... ////  want to change that.                                           ////
.................... ////                                                                 ////
.................... ////  You need approximately 470nF cap on Vusb, even if you are      ////
.................... ////  using the internal 3.3V USB regulator.                         ////
.................... ////                                                                 ////
.................... ////  To run at full speed, you must use the oscillator              ////
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   ////
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     ////
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      ////
.................... ////  96MHz clock.  See the datasheet for details.                   ////
.................... ////                                                                 ////
.................... ////  To run at slow speed you must configure your MCU to run at     ////
.................... ////  24Mhz.  See the datasheet for details.                         ////
.................... ////                                                                 ////
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   ////
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the ////
.................... //// PIC when an event has happened on the USB Bus.  Therfore        ////
.................... //// this code enables interrupts.  A user modification can be made  ////
.................... //// to poll the USB interrupt flag instead of relying on an         ////
.................... //// interrupt.                                                      ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_H__
.................... #DEFINE __PIC18_USB_H__
.................... 
.................... #DEFINE __USB_HARDWARE__
.................... 
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral
.................... #DEFINE __PIC__   1
.................... 
.................... #ifndef USB_USE_FULL_SPEED
....................  #define USB_USE_FULL_SPEED   1
.................... #endif
.................... 
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................    //due to limited ram, force max packet length to 8 for this chip
....................    #define USB_MAX_EP0_PACKET_LENGTH   8
.................... #else
....................    #if USB_USE_FULL_SPEED==0
....................       //slow speed requires 8byte max packet size for endpoint 0
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8
....................    #else
....................       //for full speed you can still use 8bytes, but 64 will be faster
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64
....................    #endif
.................... #endif
.................... #endif
.................... 
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8))
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8
....................  #error Max Endpoint 0 length can't be less than 8!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64
....................  #error Max Endpoint 0 length can't be greater than 64!
.................... #endif
.................... 
.................... #include <usb_hw_layer.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_hw_layer.h                            ////
.................... ////                                                                   ////
.................... //// HW Layer for the USB Stack.                                       ////
.................... ////                                                                   ////
.................... //// HW drivers for the USB stack must support this API.               ////
.................... ////                                                                   ////
.................... //// The HW driver must also have a token handler that will call       ////
.................... //// usb_token_reset() when the device is init/reset, will call        ////
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          ////
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    ////
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     ////
.................... //// See usb.h for documentation of these functions.                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __USB_HW_LAYER_H__
.................... #define __USB_HW_LAYER_H__
.................... 
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0,
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4};
.................... 
.................... 
.................... // USER LEVEL FUNCTIONS:
.................... 
.................... /*****************************************************************************
.................... /* usb_init()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_init_cs()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_cs(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_task()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_task(void);
.................... 
.................... /******************************************************************************
.................... /* usb_attach()
.................... /*
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral.
.................... /*
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt.
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_attach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_detach()
.................... /*
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB.
.................... /*
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* If the user does call this function while USB is connected, the USB 
.................... /* peripheral will be disabled only momentarily because usb_task() will
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB
.................... /* reset of the device.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_detach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_put_packet()
.................... /*
.................... /* Input: endpoint - endpoint to send packet to (0..15).
.................... /*        ptr - points to data to send.
.................... /*        len - amount of data to send.
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, 
.................... /*                 or toggle from the last DATAx pid.
.................... /*
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only 
.................... /*         reason it will return FALSE is if because the TX buffer is still full 
.................... /*         from the last time it tried to send a packet.
.................... /*
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a 
.................... /*          difference between a packet and a message.  If you wanted to send a 
.................... /*          512 byte message on an endpoint that only supported 64 byte packets,
.................... /*          this would be accomplished this by sending 8 64-byte packets, 
.................... /*          followed by a 0 length packet.  If the last (or only packet) being 
.................... /*          sent is less than the max packet size defined in your descriptor 
.................... /*          then you do not need to send a 0 length packet to identify
.................... /*          an end of message.
.................... /*
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message 
.................... /*          correctly and know if a 0 lenght packet needs to be sent.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl);
.................... 
.................... /*******************************************************************************
.................... /* usb_get_packet(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer and saved to ptr.
.................... /*
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS!
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()!
.................... /*
.................... /* Summary: Gets a packet of data from the USB endpoint buffer.
.................... /*          Until this is called, if there is data in the receive buffer the
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be
.................... /*          allowed to send a new packet.  Only receives one packet, if you need 
.................... /*          to receive multiple packets or handle 0-length terminator packets,
.................... /*          then use usb_gets().
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /********************************************************************************/
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max);
.................... 
.................... /****************************************************************************
.................... /* usb_kbhit(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check (0..15)
.................... /*
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not.
.................... /*
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers.
.................... /*          See API section of USB.H for more information.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_kbhit(unsigned int8 en);
.................... 
.................... /******************************************************************************
.................... /* usb_tbe(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last
.................... /*         transmit or if this endpoint is invalid.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_tbe(unsigned int8 en);
.................... 
.................... //////////////// END USER LEVEL FUNCTIONS /////////////////////////////////////
.................... 
.................... 
.................... ///
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by
.................... ///            the USB stack, and are not meant to be called by the 
.................... ///            user/application.
.................... ///
.................... 
.................... /*****************************************************************************
.................... /* usb_stall_ep()
.................... /*
.................... /* Input: endpoint - endpoint to stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will
.................... /*          send STALL packet if the host tries to access this endpoint's 
.................... /*          buffer.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_stall_ep(unsigned int8 endpoint);
.................... 
.................... 
.................... /*****************************************************************************
.................... /* usb_unstall_ep(endpoint, direction)
.................... /*
.................... /* Input: endpoint - endpoint to un-stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Un-stalls endpoint.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_unstall_ep(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_endpoint_stalled()
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not.
.................... /*
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to
.................... /*          see if endpoint has been issued a STALL, just whether or not it is
.................... /*          configured to STALL on the next packet.  See Set_Feature and 
.................... /*          Clear_Feature Chapter 9 requests.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_set_address(address)
.................... /*
.................... /* Input: address - address the host specified that we use
.................... /*
.................... /* Summary: Configures the USB Peripheral for the specified device address.  
.................... /*          The host will now talk to use with the following address.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_address(unsigned int8 address);
.................... 
.................... /******************************************************************************
.................... /* usb_set_configured()
.................... /*
.................... /* Input: config - Configuration to use.  0 to uncofigure device.
.................... /*
.................... /* Summary: Configures or unconfigures device.  If configuring device it will
.................... /*          enable all the endpoints the user specified for this configuration.
.................... /*          If un-configuring device it will disable all endpoints.
.................... /*
.................... /*          NOTE: CCS only provides code to handle 1 configuration.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_configured(unsigned int8 config);
.................... 
.................... /******************************************************************************
.................... /* usb_disable_endpoints()
.................... /*
.................... /* Summary: Disables endpoints (all endpoints but 0)
.................... /*
.................... /*****************************************************************************/
.................... void usb_disable_endpoints(void);
.................... 
.................... 
.................... /*******************************************************************************
.................... /* usb_disable_endpoint()
.................... /*
.................... /* Input: Endpoint to disable (0..15)
.................... /*
.................... /* Summary: Disables specified endpoint
.................... /*
.................... /********************************************************************************/
.................... void usb_disable_endpoint(unsigned int8 en);
.................... 
.................... /**************************************************************
.................... /* usb_request_send_response(len)
.................... /* usb_request_get_data()
.................... /* usb_request_stall()
.................... /*
.................... /* Input: len - size of packet to send
.................... /*
.................... /* Summary: One of these 3 functions will be called by the USB stack after
.................... /*          handling a SETUP packet.
.................... /*          
.................... /*          After we process a SETUP request, we have 1 of three responses:
.................... /*            1.) send a response IN packet
.................... /*            2.) wait for followup OUT packet(s) with data
.................... /*            3.) stall because we don't support that SETUP request
.................... /*
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold
.................... /*          the response and the USB Request handler code will call
.................... /*          usb_request_send_response() to let us know how big the packet is.
.................... /*
.................... /*          If we are waiting for more data, usb_request_get_data() will
.................... /*          be called by the USB request handler code to configure the EP0 OUT
.................... /*          endpoint to be ready for more data
.................... /*
.................... /*          If we don't support a request, usb_request_stall() will be called
.................... /*          by the USB request handler code to stall the endpoint 0.
.................... /*
.................... /*          The operation of these functions depends on how SETUP packets
.................... /*          are handled in the hardware layer.
.................... /*
.................... /***************************************************************/
.................... void usb_request_send_response(unsigned int8 len);
.................... void usb_request_get_data(void);
.................... void usb_request_stall(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... //////////////////////// EXTRA USER FUNCTIONS /////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_flush_in()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for transfer
.................... /*        len - length of data that is being tramsferred
.................... /*        tgl - Data toggle synchronization for this packet
.................... /*
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint)
.................... /*
.................... /* Summary: Marks the endpoint ready for transmission.  You must
.................... /*          have already loaded the endpoint buffer with data.
.................... /*          (IN is PIC -> PC).
.................... /*          This routine is useful if you want to setup an endpoint by
.................... /*          writing to the buffer directly.
.................... /*          This routine is not necessary if you use usb_put_packet().
.................... /***************************************************************/
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_flush_out()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for release
.................... /*        tgl - Data toggle synchronization to expect in the next packet
.................... /*
.................... /* Output: NONE
.................... /*
.................... /* Summary: Clears the previously received packet, and then marks this
.................... /*          endpoint's receive buffer as ready for more data.
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not
.................... /*          want to use usb_get_packet(), instead you want to handle with
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size().
.................... /*          This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_rx_packet_size()
.................... /*
.................... /* Input: endpoint - which endpoint to mark to check
.................... /*
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer.
.................... /*
.................... /* Summary: Read the number of data stored in the receive buffer.  When you
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint.
.................... /*    This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... int16 usb_rx_packet_size(int8 endpoint);
.................... 
.................... #ENDIF
.................... 
....................    #else
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
....................    #endif
.................... #else
....................    #include <usbn960x.h>
.................... #endif
.................... #ifndef __USB_DESCRIPTORS__
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_desc_cdc.h                            ////
.................... ////                                                                   ////
.................... //// An example set of device / configuration descriptors for use with ////
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// Oct 27th, 2011:                                                   ////
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     ////
.................... ////     send SERIAL_STATE messages in one packet.                     ////
.................... ////                                                                   ////
.................... //// April 7th, 2009:                                                  ////
.................... ////   Vista 'code 10' issues resolved.                                ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// 10/28/05:                                                         ////
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        ////
.................... ////    packets.                                                       ////
.................... ////    Changed device to USB 1.10                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
.................... #DEFINE __USB_DESCRIPTORS__
.................... 
.................... ///////// config options, although it's best to leave alone for this demo /////
.................... #ifndef  USB_CONFIG_PID
....................    #define  USB_CONFIG_PID       0x000b
.................... #endif
.................... #ifndef  USB_CONFIG_VID
....................    #define  USB_CONFIG_VID       0x2405
.................... #endif
.................... #ifndef  USB_CONFIG_BUS_POWER
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500)
.................... #endif
.................... #ifndef  USB_CONFIG_VERSION
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99
.................... #endif
.................... //////// end config ///////////////////////////////////////////////////////////
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #DEFINE USB_HID_DEVICE  false
.................... #DEFINE USB_CDC_DEVICE  true
.................... 
.................... #define USB_CDC_COMM_IN_ENDPOINT       1
.................... #ifndef USB_CDC_COMM_IN_SIZE
.................... #define USB_CDC_COMM_IN_SIZE           11
.................... #endif
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE
.................... 
.................... //pic to pc endpoint config
.................... #define USB_CDC_DATA_IN_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_IN_SIZE
.................... #define USB_CDC_DATA_IN_SIZE           64
.................... #endif
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE
.................... 
.................... //pc to pic endpoint config
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_OUT_SIZE
.................... #define USB_CDC_DATA_OUT_SIZE           64
.................... #endif
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start config descriptor
.................... ///   right now we only support one configuration descriptor.
.................... ///   the config, interface, class, and endpoint goes into this array.
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints)
.................... 
....................    const char USB_CONFIG_DESC[] = {
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE:
....................       //    config(s)
....................       //    interface(s)
....................       //    class(es)
....................       //    endpoint(s)
.................... 
....................    //config_descriptor for config index 1
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3
....................          2, //number of interfaces this device supports       ==4
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5
....................          0x00, //index of string descriptor for this configuration      ==6
....................         #if USB_CONFIG_BUS_POWER
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #else
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #endif
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8
.................... 
.................... 
....................    //interface descriptor 0 (comm class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11
....................          0x00, //alternate setting     ==12
....................          1, //number of endpoints   ==13
....................          0x02, //class code, 02 = Comm Interface Class     ==14
....................          0x02, //subclass code, 2 = Abstract     ==15
....................          0x01, //protocol code, 1 = v.25ter      ==16
....................          0x00, //index of string descriptor for interface      ==17
.................... 
....................    //class descriptor [functional header]
....................          5, //length of descriptor    ==18
....................          0x24, //dscriptor type (0x24 == )      ==19
....................          0, //sub type (0=functional header) ==20
....................          0x10,0x01, //      ==21,22 //cdc version
.................... 
....................    //class descriptor [acm header]
....................          4, //length of descriptor    ==23
....................          0x24, //dscriptor type (0x24 == )      ==24
....................          2, //sub type (2=ACM)   ==25
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State.
.................... 
....................    //class descriptor [union header]
....................          5, //length of descriptor    ==27
....................          0x24, //dscriptor type (0x24 == )      ==28
....................          6, //sub type (6=union)    ==29
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union.
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. *
.................... 
....................    //class descriptor [call mgmt header]
....................          5, //length of descriptor    ==32
....................          0x24, //dscriptor type (0x24 == )      ==33
....................          1, //sub type (1=call mgmt)   ==34
....................          0, //capabilities          ==35  //device does not handle call management itself
....................          1, //data interface        ==36  //interface number of data class interface
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43
.................... 
....................    //interface descriptor 1 (data class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46
....................          0x00, //alternate setting     ==47
....................          2, //number of endpoints   ==48
....................          0x0A, //class code, 0A = Data Interface Class     ==49
....................          0x00, //subclass code      ==50
....................          0x00, //protocol code      ==51
....................          0x00, //index of string descriptor for interface      ==52
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55
....................          0x02, //transfer type supported (0x02 is bulk)         ==56
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58
....................          1,  //polling interval, in ms.   ==59
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62
....................          0x02, //transfer type supported (0x02 is bulk)         ==63
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67
....................          1  //polling interval, in ms.   ==68
....................    };
.................... 
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ********
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find
....................    //  a specific descriptor in the above table.
.................... 
....................    //the maximum number of interfaces seen on any config
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2
....................    #define USB_MAX_NUM_INTERFACES   2
.................... 
....................    //define how many interfaces there are per config.  [0] is the first config, etc.
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2};
.................... 
....................    //define where to find class descriptors
....................    //first dimension is the config number
....................    //second dimension specifies which interface
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface
....................    //if a class descriptor is not valid, set the value to 0xFFFF
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]=
....................    {
....................    //config 1
....................       //interface 0
....................          //class 1-4
....................          18,23,27,32,
....................       //interface 1
....................          //no classes for this interface
....................          0xFF,0xFF,0xFF,0xFF
....................    };
.................... 
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN)
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly
....................    #endif
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start device descriptors
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={
....................       //starts of with device configuration. only one possible
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1
....................          0x10,0x01, //usb version in bcd  ==2,3
....................          0x02, //class code. 0x02=Communication Device Class ==4
....................          0x00, //subclass code ==5
....................          0x00, //protocol code ==6
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14
....................          0x02, //index of string descriptor of the product  ==15
....................          0x00, //index of string descriptor of serial number  ==16
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17
....................    };
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start string descriptors
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone.
.................... ///
.................... ///   You must define the length else get_next_string_character() will not see the string
.................... ///   Current code only supports 10 strings (0 thru 9)
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
.................... #if !defined(USB_STRINGS_OVERWRITTEN)
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored.
.................... // Strings are saved as unicode.
.................... // These strings are mostly only displayed during the add hardware wizard.
.................... // Once the operating system drivers have been installed it will usually display
.................... // the name from the drivers .INF.
.................... char const USB_STRING_DESC[]={
....................    //string 0
....................          4, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          0x09,0x04,   //Microsoft Defined for US-English
....................    //string 1  - manufacturer
....................          8, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................    //string 2 - product
....................          32, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................          ' ',0,
....................          'U',0,
....................          'S',0,
....................          'B',0,
....................          ' ',0,
....................          't',0,
....................          'o',0,
....................          ' ',0,
....................          'U',0,
....................          'A',0,
....................          'R',0,
....................          'T',0
.................... };
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN)
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... struct {
....................    int1 got;
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100
....................    unsigned int16 len;
....................    unsigned int16 index;
....................   #else
....................    unsigned int8 len;
....................    unsigned int8 index;
....................   #endif
.................... } usb_cdc_get_buffer_status;
.................... 
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             usb.c                                 ////
.................... ////                                                                   ////
.................... //// Standard USB request and token handler code.                      ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... //// The majority of this code is called and used by the interrupt     ////
.................... //// generated by the hardware level, and therefore it is not meant    ////
.................... //// to be called by the user.  The functions that are meant to be     ////
.................... //// called by the user (init, put packet, get packet, etc) are        ////
.................... //// documented in USB.H.                                              ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////    This code will not create a multiple configuration device.     ////
.................... ////    If you wish to create a multiple configuration device then you ////
.................... ////    will have to modify these drivers.                             ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    ////
.................... ////   requests.  These requests are optional.  If you want to support ////
.................... ////   these requests you must provide the code yourself.  See         ////
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      ////
.................... ////   support.                                                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// If you wish to provide your own USB peripheral hardware layer, it ////
.................... //// must must provide the API as described in usb_hw_layer.h.         ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 20, 2015                                                    ////
.................... ////     USB_STRING_DESC_OFFSET no longer used.                        ////
.................... ////                                                                   ////
.................... //// Feb 6th, 2015                                                     ////
.................... ////     Fixed 'len' not being intiailized in usb_gets()               ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// June 8th, 2011:                                                   ////
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  ////
.................... ////     (for no timeout) resolved.                                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// November 13th, 2009:                                              ////
.................... ////  usb_endpoint_is_valid() has an extra check.                      ////
.................... ////                                                                   ////
.................... //// June 9th, 2009:                                                   ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// Dec 14, 2007:                                                     ////
.................... ////  usb_kbhit() moved to device driver.                              ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    ////
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release.                                         ////
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     ////
.................... ////    layer.                                                         ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////  TODO: alot of indexing and length handling for descriptors is    ////
.................... ////   only 8bit, so make sure all descriptor tables are less than     ////
.................... ////   256 bytes long.                                                 ////
.................... ////                                                                   ////
.................... //// Apr 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     ////
.................... ////   usb_ep_tx_size[] defined in usb.h                               ////
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             ////
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  ////
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     ////
.................... ////   the endpoint buffer until you usb_get_packet(), which will      ////
.................... ////   then free the endpoint buffer for more data.  This affects      ////
.................... ////   routines such as usb_gets() and usb_kbhit().                    ////
.................... ////  usb_gets() no longer reads buffered data (see above note),       ////
.................... ////   now it reads multiple packets in the same way usb_puts()        ////
.................... ////   writes multiple packets                                         ////
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  ////
.................... ////   layer.                                                          ////
.................... ////                                                                   ////
.................... //// Nov 11th, 2004:                                                   ////
.................... ////  No longer includes wrong descriptor header.                      ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   ////
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    ////
.................... ////                     although it didn't cause any serious problems ////
.................... ////                                                                   ////
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  ////
.................... ////                     problems with multiple packet messages        ////
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   ////
.................... ////                     descriptors that require a 0 len packet to    ////
.................... ////                     end message.                                  ////
.................... ////                                                                   ////
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DRIVER__
.................... #DEFINE __USB_DRIVER__
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #else
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) 
....................    {
....................       while(len--)
....................       {
....................          debug_usb_packet(debug_putc, "%02X", *ptr++);
....................       }
....................    }
.................... #endif
.................... 
.................... // legacy
.................... #ifndef debug_usb
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l)
.................... #endif
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if defined(__PIC16F_USB_H__)
....................  #include <pic16f_usb.c>
.................... #endif
.................... 
.................... #if defined(__PIC18_USB_H__)
....................  #include <pic18_usb.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.c                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     ////
.................... //// documentation about the PIC18 hardware layer.                   ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Dec 12, 2016:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Mar 20, 2015:                                                   ////
.................... ////  When TXing a packet, set UOWN bit as a different instruction   ////
.................... ////     as the rest of the BDSTAT flags.  Doing it this way         ////
.................... ////     prevents PIC18F45K50 family USB from locking up.            ////
.................... ////                                                                 ////
.................... //// Mar 1, 2015:                                                    ////
.................... ////  Added __STALL_ON_UEP_ERRATA__ and __UIDLE_JAM_ERRATA__ from    ////
.................... ////     PIC24 USB library, in case those erratas found              ////
.................... ////     their way on the PIC18 USB parts.                           ////
.................... ////                                                                 ////
.................... //// Dec 17, 2013:                                                   ////
.................... ////  Added 18FxxJ9x family support.                                 ////
.................... ////                                                                 ////
.................... //// Dec 11, 2013:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// July 9th, 2012:                                                 ////
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     ////
.................... ////     for non-setup packets on endpoint 0 or all other            ////
.................... ////     endpoints.  This really only affects people using           ////
.................... ////     usb_put_packet() or usb_get_packet() inside of other        ////
.................... ////     interrupts.                                                 ////
.................... ////                                                                 ////
.................... //// Sep 22, 2011:                                                   ////
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   ////
.................... ////     primarily developed for users developing code where         ////
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Added initial 18F47J53 family support.                         ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work.                          ////
.................... ////                                                                 ////
.................... //// Nov 13th, 2009:                                                 ////
.................... ////  usb_disable_endpoint() won't touch BD status registers for     ////
.................... ////     endpoints that aren't allocated.                            ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_C__
.................... #DEFINE __PIC18_USB_C__
.................... 
.................... // i got these from PIC24 library, but maybe these bugs made their way
.................... // into PIC18 usb peripherals.
.................... // __STALL_ON_UEP_ERRATA__ looked wrong on the PIC24 library.
.................... #define __STALL_ON_UEP_ERRATA__
.................... #define __UIDLE_JAM_ERRATA__
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #endif
.................... 
.................... #bit USBIE=getenv("BIT:USBIE")
.................... 
.................... //if you are worried that the PIC is not receiving packets because a bug in the
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on
.................... //receiving.
.................... #ifndef USB_IGNORE_RX_DTS
....................  #define USB_IGNORE_RX_DTS false
.................... #endif
.................... 
.................... #ifndef USB_IGNORE_TX_DTS
....................  #define USB_IGNORE_TX_DTS false
.................... #endif
.................... 
.................... // if only USB_BDT_START is defined, then BDT has a fixed location in RAM
.................... //    but endpoint memory can be anywhere on the PIC.
.................... // if only USB_RAM_START is defined, then both BDT and endpoint have a fixed
.................... //    location in RAM (BDT first, endpoint second).
.................... // if USB_BDT_START and USB_RAM_START are both defined, then BDT has a fixed
.................... //    location in RAM and the endpoint buffers have a different location
.................... //    in RAM.
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50"))
....................  #define __USB_87J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \
....................        (getenv("DEVICE")=="PIC18F24K50") || \
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF24K50"))
....................  #define __USB_45K50__
....................  #define USB_TOTAL_RAM_SPACE  1024
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50"))
....................  #define __USB_46J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || \
....................        (getenv("DEVICE")=="PIC18LF2450") || (getenv("DEVICE")=="PIC18LF4450"))
....................  #define __USB_4450__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................  #define __USB_K50__ //backwards compatability
....................  #define __USB_14K50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x200
....................  #define USB_NUM_UEP 8
....................  //technically this device supports 8 endpoints, but for RAM reasons you should
....................  //attempt to only use the first 3 endpoints.
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") || \
....................        (getenv("DEVICE")=="PIC18LF2455") || (getenv("DEVICE")=="PIC18LF2550") || \
....................        (getenv("DEVICE")=="PIC18LF4455") || (getenv("DEVICE")=="PIC18LF4550") || \
....................        (getenv("DEVICE")=="PIC18LF2458") || (getenv("DEVICE")=="PIC18LF2553") || \
....................        (getenv("DEVICE")=="PIC18LF4458") || (getenv("DEVICE")=="PIC18LF4553") \
....................        )
....................  #define __USB_4550__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") || \
....................        (getenv("DEVICE")=="PIC18LF26J53") || (getenv("DEVICE")=="PIC18LF27J53") || \ 
....................        (getenv("DEVICE")=="PIC18LF46J53") || (getenv("DEVICE")=="PIC18LF47J53") \       
....................        )
....................  #define __USB_18FJ53__
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use
....................  #define USB_BDT_START  0xD00
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F97J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F87J94") ||  \
....................        (getenv("DEVICE")=="PIC18F67J94") ||  \
....................        (getenv("DEVICE")=="PIC18F96J99") ||  \
....................        (getenv("DEVICE")=="PIC18F86J99") ||  \
....................        (getenv("DEVICE")=="PIC18F66J99") ||  \
....................        (getenv("DEVICE")=="PIC18F96J94") ||  \
....................        (getenv("DEVICE")=="PIC18F86J94") ||  \
....................        (getenv("DEVICE")=="PIC18F66J94") ||  \
....................        (getenv("DEVICE")=="PIC18F95J94") ||  \
....................        (getenv("DEVICE")=="PIC18F85J94") ||  \
....................        (getenv("DEVICE")=="PIC18F65J94"))
....................  #define __USB_18FJ94__
....................  #define USB_BDT_START  0x100
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library.
.................... #endif
.................... 
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  15
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  14
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  13
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  12
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  11
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  10
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  9
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  8
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  7
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  6
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  5
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  4
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  3
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  2
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  1
.................... #else
....................  #define USB_LAST_DEFINED_ENDPOINT  0
.................... #endif
.................... 
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8)
.................... 
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)
.................... 
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT)
....................  #error You are trying to use an invalid endpoint for this hardware!
.................... #endif
.................... 
.................... typedef struct
.................... {
....................    unsigned int8 stat;
....................    unsigned int8 cnt;
....................    unsigned int16 addr;
.................... } STRUCT_BD;
.................... 
.................... #if defined(USB_RAM_START) && !defined(USB_BDT_START)
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       struct
....................       {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................       } bd[USB_LAST_DEFINED_ENDPOINT+1];
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM.buffer)
....................    
....................    #locate g_USBRAM=USB_RAM_START
....................    
....................    #define g_USBBDT g_USBRAM.bd
.................... #else
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #if defined(USB_RAM_START)
....................       #locate g_USBRAM=USB_RAM_START
....................    #endif
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM)
....................    
....................    struct
....................    {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................    } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1];
....................    
....................    #locate g_USBBDT=USB_BDT_START
.................... #endif
.................... 
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer
.................... 
.................... //these buffer definitions needed for CDC library
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer
.................... 
.................... //if you enable this it will keep a counter of the 6 possible errors the
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time.
.................... #if !defined(USB_USE_ERROR_COUNTER)
....................    #define USB_USE_ERROR_COUNTER false
.................... #endif
.................... 
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints
.................... 
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS!
.................... #if !defined(USB_PING_PONG_MODE)
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF
.................... #endif
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................    unsigned int ERROR_COUNTER[6];
.................... #endif
.................... 
.................... //---pic18fxx5x memory locations
.................... #if defined(__USB_4550__) || defined(__USB_4450__)
....................    #byte UFRML   =  0xF66
....................    #byte UFRMH   =  0xF67
....................    #byte UIR     =  0xF68
....................    #byte UIE     =  0xF69
....................    #byte UEIR    =  0xF6A
....................    #byte UEIE    =  0xF6B
....................    #byte U1STAT   =  0xF6C
....................    #byte UCON    =  0xF6D
....................    #byte UADDR   =  0xF6E
....................    #byte UCFG    =  0xF6F
....................    #define  UEP0_LOC 0xF70
.................... #elif defined(__USB_46J50__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #elif defined(__USB_14K50__)
....................    #byte UFRML   =  0xF5D
....................    #byte UFRMH   =  0xF5E
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF60
....................    #byte UEIR    =  0xF5F
....................    #byte UEIE    =  0xF5B
....................    #byte U1STAT   =  0xF63
....................    #byte UCON    =  0xF64
....................    #byte UADDR   =  0xF5C
....................    #byte UCFG    =  0xF61
....................    #define  UEP0_LOC 0xF53
.................... #elif defined(__USB_18FJ53__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #else
....................    #byte UFRML = getenv("SFR:UFRML")
....................    #byte UFRMH = getenv("SFR:UFRMH")
....................    #byte UIR = getenv("SFR:UIR")
....................    #byte UIE = getenv("SFR:UIE")
....................    #byte UEIR = getenv("SFR:UEIR")
....................    #byte UEIE = getenv("SFR:UEIE")
....................    #byte U1STAT = getenv("SFR:USTAT")
....................    #byte UCON = getenv("SFR:UCON")
....................    #byte UADDR = getenv("SFR:UADDR")
....................    #byte UCFG = getenv("SFR:UCFG")
.................... #endif
.................... 
.................... unsigned int8 USTATCopy;
.................... 
.................... unsigned int8 g_UEP[USB_NUM_UEP];
.................... #if defined(UEP0_LOC)
.................... #locate g_UEP=UEP0_LOC
.................... #else
.................... #locate g_UEP=getenv("SFR:UEP0")
.................... #endif
.................... #define UEP(x) g_UEP[x]
.................... 
.................... #define BIT_SOF   6
.................... #define BIT_STALL 5
.................... #define BIT_IDLE  4
.................... #define BIT_TRN   3
.................... #define BIT_ACTV  2
.................... #define BIT_UERR  1
.................... #define BIT_URST  0
.................... 
.................... #BIT UIR_SOF = UIR.BIT_SOF
.................... #BIT UIR_STALL = UIR.BIT_STALL
.................... #BIT UIR_IDLE = UIR.BIT_IDLE
.................... #BIT UIR_TRN = UIR.BIT_TRN
.................... #BIT UIR_ACTV = UIR.BIT_ACTV
.................... #BIT UIR_UERR = UIR.BIT_UERR
.................... #BIT UIR_URST = UIR.BIT_URST
.................... 
.................... #BIT UIE_SOF = UIE.BIT_SOF
.................... #BIT UIE_STALL = UIE.BIT_STALL
.................... #BIT UIE_IDLE = UIE.BIT_IDLE
.................... #BIT UIE_TRN = UIE.BIT_TRN
.................... #BIT UIE_ACTV = UIE.BIT_ACTV
.................... #BIT UIE_UERR = UIE.BIT_UERR
.................... #BIT UIE_URST = UIE.BIT_URST
.................... 
.................... #if getenv("BIT_VALID:PPBRST")
....................    #bit UCON_PPBRST = getenv("BIT:PPBRST")
.................... #endif
.................... #bit UCON_SE0=UCON.5
.................... #bit UCON_PKTDIS=UCON.4
.................... #bit UCON_USBEN=UCON.3
.................... #bit UCON_RESUME=UCON.2
.................... #bit UCON_SUSPND=UCON.1
.................... 
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF)
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr
.................... #else
.................... #error Right now this driver only supports no ping pong
.................... #endif
.................... 
.................... //See UEPn (0xF70-0xF7F)
.................... #define ENDPT_DISABLED   0x00   //endpoint not used
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions
.................... 
.................... //Define the states that the USB interface can be in
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3,
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state;
.................... 
.................... //--BDendST has their PIDs upshifed 2
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction
.................... 
.................... #define USTAT_IN_E0        4
.................... #define USTAT_OUT_SETUP_E0 0
.................... 
.................... #define __USB_UIF_RESET    0x01
.................... #define __USB_UIF_ERROR    0x02
.................... #define __USB_UIF_ACTIVE   0x04
.................... #define __USB_UIF_TOKEN    0x08
.................... #define __USB_UIF_IDLE     0x10
.................... #define __USB_UIF_STALL    0x20
.................... #define __USB_UIF_SOF      0x40
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET
.................... #else
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET
.................... #endif
.................... 
.................... #define __USB_UCFG_UTEYE   0x80
.................... #if defined(__USB_4550__)
....................  #define __USB_UCFG_UOEMON  0x40
.................... #endif
.................... #define __USB_UCFG_UPUEN   0x10
.................... #if !defined(__USB_14K50__)
....................  #define __USB_UCFG_UTRDIS  0x08
.................... #endif
.................... #define __USB_UCFG_FSEN    0x04
.................... 
.................... #if defined(USB_EXTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  0
.................... #endif
.................... 
.................... #if defined(USB_INTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if !defined(__USB_UCFG_MY_UPUEN)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if USB_USE_FULL_SPEED
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE)
.................... #else
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE);
.................... #endif
.................... 
.................... #if defined(__USB_UCFG_UTRDIS)
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS
.................... #else
....................  #define __UCFG_VAL_DISABLED__   0
.................... #endif
.................... 
.................... 
.................... unsigned int8 __setup_0_tx_size;
.................... 
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only
.................... void usb_handle_interrupt();
.................... void usb_isr_rst();
.................... void usb_isr_uerr();
.................... void usb_isr_sof(void);
.................... void usb_isr_activity();
.................... void usb_isr_uidle();
.................... void usb_isr_tok_dne();
.................... void usb_isr_stall(void);
.................... void usb_init_ep0_setup(void);
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... void usb_isr(void);
.................... #endif
.................... 
.................... //// BEGIN User Functions:
.................... 
.................... // see usb_hw_layer.h for more documentation
.................... int1 usb_kbhit(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7)));
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_tbe(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7)));
*
0E24:  CLRF   03
0E26:  MOVLB  2
0E28:  MOVF   x62,W
0E2A:  ADDLW  70
0E2C:  MOVWF  FE9
0E2E:  MOVLW  0F
0E30:  ADDWFC 03,W
0E32:  MOVWF  FEA
0E34:  MOVF   FEF,F
0E36:  BZ    0E6E
0E38:  CLRF   x64
0E3A:  MOVFF  262,263
0E3E:  CLRF   x66
0E40:  MOVLW  08
0E42:  MOVWF  x65
0E44:  MOVLB  0
0E46:  CALL   0496
0E4A:  MOVFF  02,264
0E4E:  MOVFF  01,263
0E52:  MOVLW  04
0E54:  MOVLB  2
0E56:  ADDWF  x63,F
0E58:  MOVLW  00
0E5A:  ADDWFC x64,F
0E5C:  MOVFF  263,FE9
0E60:  MOVLW  04
0E62:  ADDWF  x64,W
0E64:  MOVWF  FEA
0E66:  MOVFF  FEF,265
0E6A:  BTFSS  x65.7
0E6C:  BRA    0E72
0E6E:  MOVLW  00
0E70:  BRA    0E74
0E72:  MOVLW  01
0E74:  MOVWF  01
0E76:  MOVLB  0
0E78:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_detach(void)
.................... {
....................    UCON_SUSPND = 0;
*
151E:  BCF    F6D.1
....................    UCON = 0;  //disable USB hardware
1520:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts
1522:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__;
1524:  MOVLW  08
1526:  MOVWF  F6F
.................... 
....................    // set D+/D- to inputs
....................   #if defined(__USB_87J50__)
....................    set_tris_f(get_tris_f() | 0x18);
....................   #elif defined(__USB_14K50__)
....................    set_tris_a(get_tris_a() | 0x3);
....................   #elif defined(__USB_18FJ94__)
....................    output_float(PIN_F4);
....................    output_float(PIN_F3);
....................   #elif !defined(USB_PIC_NO_USB_GPIO)
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5
1528:  MOVF   F94,W
152A:  IORLW  30
152C:  MOVLB  1
152E:  MOVWF  F94
....................   #endif
....................   
....................    usb_state = USB_STATE_DETACHED;
1530:  CLRF   22
1532:  CLRF   19
1534:  BTFSC  FF2.7
1536:  BSF    19.7
1538:  BCF    FF2.7
....................    
....................    usb_token_reset();              //clear the chapter9 stack
153A:  MOVLB  0
153C:  CALL   0586
1540:  BTFSC  19.7
1542:  BSF    FF2.7
1544:  GOTO   154A (RETURN)
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_attach(void) 
*
1554:  CLRF   19
1556:  BTFSC  FF2.7
1558:  BSF    19.7
155A:  BCF    FF2.7
.................... {
....................    usb_token_reset();
155C:  CALL   0586
1560:  BTFSC  19.7
1562:  BSF    FF2.7
....................    UCON_SUSPND = 0;
1564:  BCF    F6D.1
....................    UCON = 0;
1566:  CLRF   F6D
....................   #if getenv("BIT_VALID:PPBRST")
....................    UCON_PPBRST = 1;
1568:  BSF    F6D.6
....................    delay_cycles(5);
156A:  BRA    156C
156C:  BRA    156E
156E:  NOP   
....................    UCON_PPBRST = 0;
1570:  BCF    F6D.6
....................   #endif
....................    UCFG = __UCFG_VAL_ENABLED__;
1572:  MOVLW  14
1574:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts
1576:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus
1578:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h
157A:  MOVLW  01
157C:  MOVWF  22
157E:  GOTO   159C (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init_cs(void)
.................... {
....................    usb_detach();
*
1548:  BRA    151E
154A:  GOTO   15BA (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_task(void) 
.................... {
....................   #if defined(USB_ISR_POLLING)
....................    if (interrupt_active(INT_USB))
....................    {
....................       usb_isr();
....................    }
....................   #endif
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_enumerated())
*
1582:  RCALL  154E
1584:  MOVF   01,F
1586:  BZ    1596
1588:  CLRF   19
158A:  BTFSC  FF2.7
158C:  BSF    19.7
158E:  BCF    FF2.7
....................    {
....................       usb_cdc_flush_tx_buffer();
1590:  RCALL  123C
1592:  BTFSC  19.7
1594:  BSF    FF2.7
....................    }
....................   #endif
.................... 
....................    if (usb_attached()) 
....................    {
....................       if (UCON_USBEN==0) 
1596:  BTFSC  F6D.3
1598:  BRA    159C
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: ATTACH");
....................          usb_attach();
159A:  BRA    1554
....................       }
....................    }
....................    else 
....................    {
....................       if (UCON_USBEN==1)  
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: DE-ATTACH");
....................          usb_detach();
....................       }
....................    }
.................... 
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) 
159C:  DECFSZ 22,W
159E:  BRA    15B6
15A0:  BTFSC  F6D.5
15A2:  BRA    15B6
....................    {
....................       UIR = 0;
15A4:  CLRF   F68
....................       UIE = 0;
15A6:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING)
....................       enable_interrupts(INT_USB);
15A8:  BSF    FA0.5
....................       enable_interrupts(GLOBAL);
15AA:  MOVLW  C0
15AC:  IORWF  FF2,F
....................      #endif
....................       UIE = __USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR
15AE:  MOVLW  11
15B0:  MOVWF  F69
....................      #if USB_USE_ERROR_COUNTER
....................       UIE |= __USB_UIF_ERROR;
....................      #endif
....................       usb_state=USB_STATE_POWERED;
15B2:  MOVLW  02
15B4:  MOVWF  22
....................       debug_usb_control(debug_putc, "\r\n\nUSB TASK: POWERED");
....................    }
15B6:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init(void) 
.................... {
....................    usb_init_cs();
15B8:  BRA    1548
.................... 
....................    do 
....................    {
....................       usb_task();
15BA:  RCALL  1582
....................    } while (usb_state != USB_STATE_POWERED);
15BC:  MOVF   22,W
15BE:  SUBLW  02
15C0:  BNZ   15BA
15C2:  GOTO   402E (RETURN)
.................... }
.................... 
.................... 
.................... // see pic18_usb.h for documentation
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
.................... 
....................    debug_usb_packet(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len);
.................... 
....................    if (usb_tbe(endpoint)) 
*
0E7A:  MOVFF  25D,262
0E7E:  RCALL  0E24
0E80:  MOVF   01,F
0E82:  BTFSC  FD8.2
0E84:  BRA    0FBC
....................    {
....................       EP_BDxCNT_I(endpoint)=len;
0E86:  MOVLB  2
0E88:  CLRF   x64
0E8A:  MOVFF  25D,263
0E8E:  CLRF   x66
0E90:  MOVLW  08
0E92:  MOVWF  x65
0E94:  MOVLB  0
0E96:  CALL   0496
0E9A:  MOVFF  02,263
0E9E:  MOVFF  01,262
0EA2:  MOVLW  04
0EA4:  MOVLB  2
0EA6:  ADDWF  x62,F
0EA8:  MOVLW  00
0EAA:  ADDWFC x63,F
0EAC:  MOVLW  01
0EAE:  ADDWF  x62,W
0EB0:  MOVWF  01
0EB2:  MOVLW  00
0EB4:  ADDWFC x63,W
0EB6:  MOVWF  03
0EB8:  MOVFF  01,FE9
0EBC:  MOVLW  04
0EBE:  ADDWF  03,W
0EC0:  MOVWF  FEA
0EC2:  MOVFF  25E,FEF
.................... 
....................       debug_display_ram(len, EP_BDxADR_I(endpoint));
.................... 
....................      #if USB_IGNORE_TX_DTS
....................       i=0x80;
....................      #else
....................       if (tgl == USB_DTS_TOGGLE) 
0EC6:  MOVF   x60,W
0EC8:  SUBLW  02
0ECA:  BNZ   0F0C
....................       {
....................          i = EP_BDxST_I(endpoint);
0ECC:  CLRF   x64
0ECE:  MOVFF  25D,263
0ED2:  CLRF   x66
0ED4:  MOVLW  08
0ED6:  MOVWF  x65
0ED8:  MOVLB  0
0EDA:  CALL   0496
0EDE:  MOVFF  02,263
0EE2:  MOVFF  01,262
0EE6:  MOVLW  04
0EE8:  MOVLB  2
0EEA:  ADDWF  x62,F
0EEC:  MOVLW  00
0EEE:  ADDWFC x63,F
0EF0:  MOVFF  262,FE9
0EF4:  MOVLW  04
0EF6:  ADDWF  x63,W
0EF8:  MOVWF  FEA
0EFA:  MOVFF  FEF,261
....................          if (bit_test(i,6))
0EFE:  BTFSS  x61.6
0F00:  BRA    0F06
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0F02:  CLRF   x60
0F04:  BRA    0F0A
....................          else
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0F06:  MOVLW  01
0F08:  MOVWF  x60
....................       }
0F0A:  BRA    0F40
....................       else if (tgl == USB_DTS_USERX) 
0F0C:  MOVF   x60,W
0F0E:  SUBLW  04
0F10:  BNZ   0F40
....................       {
....................          i = EP_BDxST_O(endpoint);
0F12:  CLRF   x64
0F14:  MOVFF  25D,263
0F18:  CLRF   x66
0F1A:  MOVLW  08
0F1C:  MOVWF  x65
0F1E:  MOVLB  0
0F20:  CALL   0496
0F24:  MOVLB  2
0F26:  MOVFF  01,FE9
0F2A:  MOVLW  04
0F2C:  ADDWF  02,W
0F2E:  MOVWF  FEA
0F30:  MOVFF  FEF,261
....................          if (bit_test(i,6))
0F34:  BTFSS  x61.6
0F36:  BRA    0F3E
....................             tgl = USB_DTS_DATA1;
0F38:  MOVLW  01
0F3A:  MOVWF  x60
0F3C:  BRA    0F40
....................          else
....................             tgl = USB_DTS_DATA0;
0F3E:  CLRF   x60
....................       }
....................       if (tgl == USB_DTS_DATA1) 
0F40:  DECFSZ x60,W
0F42:  BRA    0F4A
....................          i=0x48;  //DATA1, UOWN  //change mar2015
0F44:  MOVLW  48
0F46:  MOVWF  x61
0F48:  BRA    0F4E
....................       else //if (tgl == USB_DTS_DATA0) 
....................          i=0x08; //DATA0, UOWN   //change mar2015
0F4A:  MOVLW  08
0F4C:  MOVWF  x61
....................      #endif
.................... 
....................       //set BC8 and BC9
....................       //if (bit_test(len,8)) {bit_set(i,0);}
....................       //if (bit_test(len,9)) {bit_set(i,1);}
.................... 
....................       debug_usb_packet(debug_putc, " %X", i);
.................... 
....................       EP_BDxST_I(endpoint) = i;  //save changes
0F4E:  CLRF   x64
0F50:  MOVFF  25D,263
0F54:  CLRF   x66
0F56:  MOVLW  08
0F58:  MOVWF  x65
0F5A:  MOVLB  0
0F5C:  CALL   0496
0F60:  MOVFF  02,263
0F64:  MOVFF  01,262
0F68:  MOVLW  04
0F6A:  MOVLB  2
0F6C:  ADDWF  x62,F
0F6E:  MOVLW  00
0F70:  ADDWFC x63,F
0F72:  MOVFF  262,FE9
0F76:  MOVLW  04
0F78:  ADDWF  x63,W
0F7A:  MOVWF  FEA
0F7C:  MOVFF  261,FEF
....................       
....................       EP_BDxST_I(endpoint) |= 0x80; //change mar2015
0F80:  CLRF   x64
0F82:  MOVFF  25D,263
0F86:  CLRF   x66
0F88:  MOVLW  08
0F8A:  MOVWF  x65
0F8C:  MOVLB  0
0F8E:  CALL   0496
0F92:  MOVFF  02,263
0F96:  MOVFF  01,262
0F9A:  MOVLW  04
0F9C:  MOVLB  2
0F9E:  ADDWF  x62,F
0FA0:  MOVLW  00
0FA2:  ADDWFC x63,F
0FA4:  MOVFF  262,FE9
0FA8:  MOVLW  04
0FAA:  ADDWF  x63,W
0FAC:  MOVWF  FEA
0FAE:  MOVF   FEF,W
0FB0:  IORLW  80
0FB2:  MOVWF  FEF
....................       
....................       //putc('!');
....................       
....................       return(1);
0FB4:  MOVLW  01
0FB6:  MOVWF  01
0FB8:  BRA    0FC2
....................    }
0FBA:  MOVLB  0
....................    else 
....................    {
....................       //putc('_');
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
....................    return(0);
0FBC:  MOVLW  00
0FBE:  MOVWF  01
0FC0:  MOVLB  2
0FC2:  MOVLB  0
0FC4:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 * buff_add;    
.................... 
....................    if (usb_tbe(endpoint)) 
*
10C2:  MOVFF  255,262
10C6:  RCALL  0E24
10C8:  MOVF   01,F
10CA:  BZ    115A
....................    {
....................       buff_add = EP_BDxADR_I(endpoint);
10CC:  MOVLB  2
10CE:  CLRF   x64
10D0:  MOVFF  255,263
10D4:  CLRF   x66
10D6:  MOVLW  08
10D8:  MOVWF  x65
10DA:  MOVLB  0
10DC:  CALL   0496
10E0:  MOVFF  02,25E
10E4:  MOVFF  01,25D
10E8:  MOVLW  04
10EA:  MOVLB  2
10EC:  ADDWF  x5D,F
10EE:  MOVLW  00
10F0:  ADDWFC x5E,F
10F2:  MOVLW  02
10F4:  ADDWF  x5D,W
10F6:  MOVWF  01
10F8:  MOVLW  00
10FA:  ADDWFC x5E,W
10FC:  MOVWF  03
10FE:  MOVFF  01,FE9
1102:  MOVLW  04
1104:  ADDWF  03,W
1106:  MOVWF  FEA
1108:  MOVFF  FEC,25C
110C:  MOVF   FED,F
110E:  MOVFF  FEF,25B
....................       memcpy(buff_add, ptr, len);     
1112:  MOVFF  25C,FEA
1116:  MOVFF  25B,FE9
111A:  MOVFF  257,FE2
111E:  MOVFF  256,FE1
1122:  MOVFF  259,02
1126:  MOVFF  258,01
112A:  MOVF   01,F
112C:  BZ    1132
112E:  INCF   02,F
1130:  BRA    1136
1132:  MOVF   02,F
1134:  BZ    1142
1136:  MOVFF  FE6,FEE
113A:  DECFSZ 01,F
113C:  BRA    1136
113E:  DECFSZ 02,F
1140:  BRA    1136
....................       
....................       return(usb_flush_in(endpoint, len, tgl));
1142:  MOVFF  255,25D
1146:  MOVFF  259,25F
114A:  MOVFF  258,25E
114E:  MOVFF  25A,260
1152:  MOVLB  0
1154:  RCALL  0E7A
1156:  MOVF   01,W
1158:  BRA    115E
....................    }
....................    else 
....................    {
....................       //putc('-');
....................       //printf("%X", EP_BDxST_I(endpoint));
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
.................... 
....................    return(0);
115A:  MOVLW  00
115C:  MOVWF  01
115E:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
....................    unsigned int16 len;
.................... 
....................   #if USB_IGNORE_RX_DTS
....................    if (tgl == USB_DTS_STALL) 
....................    {
....................       debug_usb_token(debug_putc, '*');
....................       EP_BDxCNT_O(endpoint) = 0x84;
....................       EP_BDxST_I(endpoint) = 0x84;
....................       return;
....................    }
....................    else
....................       i=0x80;
....................   #else
....................    i = EP_BDxST_O(endpoint);
*
0D24:  MOVLB  2
0D26:  CLRF   x64
0D28:  MOVFF  254,263
0D2C:  CLRF   x66
0D2E:  MOVLW  08
0D30:  MOVWF  x65
0D32:  MOVLB  0
0D34:  CALL   0496
0D38:  MOVLB  2
0D3A:  MOVFF  01,FE9
0D3E:  MOVLW  04
0D40:  ADDWF  02,W
0D42:  MOVWF  FEA
0D44:  MOVFF  FEF,256
....................    if (tgl == USB_DTS_TOGGLE) 
0D48:  MOVF   x55,W
0D4A:  SUBLW  02
0D4C:  BNZ   0D5A
....................    {
....................       if (bit_test(i,6))
0D4E:  BTFSS  x56.6
0D50:  BRA    0D56
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0D52:  CLRF   x55
0D54:  BRA    0D5A
....................       else
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0D56:  MOVLW  01
0D58:  MOVWF  x55
....................    }
....................    if (tgl == USB_DTS_STALL) 
0D5A:  MOVF   x55,W
0D5C:  SUBLW  03
0D5E:  BNZ   0D98
....................    {
....................       i = 0x84;
0D60:  MOVLW  84
0D62:  MOVWF  x56
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints
0D64:  CLRF   x64
0D66:  MOVFF  254,263
0D6A:  CLRF   x66
0D6C:  MOVLW  08
0D6E:  MOVWF  x65
0D70:  MOVLB  0
0D72:  CALL   0496
0D76:  MOVFF  02,25A
0D7A:  MOVFF  01,259
0D7E:  MOVLW  04
0D80:  MOVLB  2
0D82:  ADDWF  x59,F
0D84:  MOVLW  00
0D86:  ADDWFC x5A,F
0D88:  MOVFF  259,FE9
0D8C:  MOVLW  04
0D8E:  ADDWF  x5A,W
0D90:  MOVWF  FEA
0D92:  MOVLW  84
0D94:  MOVWF  FEF
....................    }
0D96:  BRA    0DA6
....................    else if (tgl == USB_DTS_DATA1)
0D98:  DECFSZ x55,W
0D9A:  BRA    0DA2
....................       i = 0xC8;  //DATA1, UOWN
0D9C:  MOVLW  C8
0D9E:  MOVWF  x56
0DA0:  BRA    0DA6
....................    else //if (tgl == USB_DTS_DATA0) 
....................       i = 0x88; //DATA0, UOWN
0DA2:  MOVLW  88
0DA4:  MOVWF  x56
....................   #endif
.................... 
....................    //bit_clear(__usb_kbhit_status,endpoint);
.................... 
....................    len = usb_ep_rx_size[endpoint];
0DA6:  BCF    FD8.0
0DA8:  RLCF   x54,W
0DAA:  CLRF   03
0DAC:  MOVLB  0
0DAE:  CALL   011E
0DB2:  TBLRD*+
0DB4:  MOVFF  FF5,03
0DB8:  MOVLB  2
0DBA:  MOVWF  x57
0DBC:  MOVFF  03,258
....................    EP_BDxCNT_O(endpoint) = len;
0DC0:  CLRF   x64
0DC2:  MOVFF  254,263
0DC6:  CLRF   x66
0DC8:  MOVLW  08
0DCA:  MOVWF  x65
0DCC:  MOVLB  0
0DCE:  CALL   0496
0DD2:  MOVFF  01,259
0DD6:  MOVLW  01
0DD8:  MOVLB  2
0DDA:  ADDWF  01,W
0DDC:  MOVWF  01
0DDE:  MOVLW  00
0DE0:  ADDWFC 02,W
0DE2:  MOVWF  03
0DE4:  MOVFF  01,FE9
0DE8:  MOVLW  04
0DEA:  ADDWF  03,W
0DEC:  MOVWF  FEA
0DEE:  MOVFF  257,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);}
0DF2:  BTFSS  x58.0
0DF4:  BRA    0DF8
0DF6:  BSF    x56.0
....................    if (bit_test(len,9)) {bit_set(i,1);}
0DF8:  BTFSS  x58.1
0DFA:  BRA    0DFE
0DFC:  BSF    x56.1
.................... 
....................    EP_BDxST_O(endpoint) = i;
0DFE:  CLRF   x64
0E00:  MOVFF  254,263
0E04:  CLRF   x66
0E06:  MOVLW  08
0E08:  MOVWF  x65
0E0A:  MOVLB  0
0E0C:  CALL   0496
0E10:  MOVLB  2
0E12:  MOVFF  01,FE9
0E16:  MOVLW  04
0E18:  ADDWF  02,W
0E1A:  MOVWF  FEA
0E1C:  MOVFF  256,FEF
0E20:  MOVLB  0
0E22:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint) 
.................... {
....................    return(EP_BDxCNT_O(endpoint));
*
100E:  MOVLB  2
1010:  CLRF   x64
1012:  MOVFF  254,263
1016:  CLRF   x66
1018:  MOVLW  08
101A:  MOVWF  x65
101C:  MOVLB  0
101E:  CALL   0496
1022:  MOVFF  02,256
1026:  MOVFF  01,255
102A:  MOVLW  01
102C:  MOVLB  2
102E:  ADDWF  01,W
1030:  MOVWF  01
1032:  MOVLW  00
1034:  ADDWFC 02,W
1036:  MOVWF  03
1038:  MOVFF  01,FE9
103C:  MOVLW  04
103E:  ADDWF  03,W
1040:  MOVWF  FEA
1042:  MOVFF  FEF,01
1046:  CLRF   02
1048:  MOVLB  0
104A:  GOTO   106E (RETURN)
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN Hardware layer functions required by USB.
.................... 
.................... /*****************************************************************************
.................... /* usb_get_packet_buffer(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer.
.................... /*
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC 
.................... /*          RAM.
.................... /*          Does not mark the endpoint as ready for more data.  Once you are
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready
.................... /*          to receive more data.
.................... /*
.................... /*****************************************************************************/
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) 
.................... {
....................    unsigned int8 * al;
....................    unsigned int8 st;
....................    unsigned int16 i;
.................... 
....................    al = EP_BDxADR_O(endpoint);
....................    i = EP_BDxCNT_O(endpoint);
....................    st = EP_BDxST_O(endpoint);
.................... 
....................    //read BC8 and BC9
....................    if (bit_test(st,0)) {bit_set(i,8);}
....................    if (bit_test(st,1)) {bit_set(i,9);}
.................... 
....................    if (i < max) {max = i;}
....................    
....................    memcpy(ptr, al ,max);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max)
.................... {
....................    max = usb_get_packet_buffer(endpoint, ptr, max);
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_stall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=s%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0B0A:  MOVLB  2
0B0C:  BCF    x54.0
0B0E:  BTFSC  x53.7
0B10:  BSF    x54.0
....................    endpoint &= 0x7F;
0B12:  BCF    x53.7
....................    
....................    if (direction) 
0B14:  BTFSS  x54.0
0B16:  BRA    0B4A
....................    {
....................       EP_BDxST_I(endpoint) = 0x84;
0B18:  CLRF   x64
0B1A:  MOVFF  253,263
0B1E:  CLRF   x66
0B20:  MOVLW  08
0B22:  MOVWF  x65
0B24:  MOVLB  0
0B26:  RCALL  0496
0B28:  MOVFF  02,256
0B2C:  MOVFF  01,255
0B30:  MOVLW  04
0B32:  MOVLB  2
0B34:  ADDWF  x55,F
0B36:  MOVLW  00
0B38:  ADDWFC x56,F
0B3A:  MOVFF  255,FE9
0B3E:  MOVLW  04
0B40:  ADDWF  x56,W
0B42:  MOVWF  FEA
0B44:  MOVLW  84
0B46:  MOVWF  FEF
....................    }
0B48:  BRA    0B6A
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x84;
0B4A:  CLRF   x64
0B4C:  MOVFF  253,263
0B50:  CLRF   x66
0B52:  MOVLW  08
0B54:  MOVWF  x65
0B56:  MOVLB  0
0B58:  RCALL  0496
0B5A:  MOVLB  2
0B5C:  MOVFF  01,FE9
0B60:  MOVLW  04
0B62:  ADDWF  02,W
0B64:  MOVWF  FEA
0B66:  MOVLW  84
0B68:  MOVWF  FEF
....................    }
0B6A:  MOVLB  0
0B6C:  GOTO   0C1A (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_unstall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=u%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0A90:  MOVLB  2
0A92:  BCF    x54.0
0A94:  BTFSC  x53.7
0A96:  BSF    x54.0
....................    endpoint &= 0x7F;
0A98:  BCF    x53.7
....................    
....................    if (direction) 
0A9A:  BTFSS  x54.0
0A9C:  BRA    0AD0
....................    {
....................      #if USB_IGNORE_RX_DTS
....................       EP_BDxST_I(endpoint) = 0x80;
....................      #else
....................       EP_BDxST_I(endpoint) = 0x88;
0A9E:  CLRF   x64
0AA0:  MOVFF  253,263
0AA4:  CLRF   x66
0AA6:  MOVLW  08
0AA8:  MOVWF  x65
0AAA:  MOVLB  0
0AAC:  RCALL  0496
0AAE:  MOVFF  02,256
0AB2:  MOVFF  01,255
0AB6:  MOVLW  04
0AB8:  MOVLB  2
0ABA:  ADDWF  x55,F
0ABC:  MOVLW  00
0ABE:  ADDWFC x56,F
0AC0:  MOVFF  255,FE9
0AC4:  MOVLW  04
0AC6:  ADDWF  x56,W
0AC8:  MOVWF  FEA
0ACA:  MOVLW  88
0ACC:  MOVWF  FEF
....................      #endif
....................    }
0ACE:  BRA    0AEE
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x00;
0AD0:  CLRF   x64
0AD2:  MOVFF  253,263
0AD6:  CLRF   x66
0AD8:  MOVLW  08
0ADA:  MOVWF  x65
0ADC:  MOVLB  0
0ADE:  RCALL  0496
0AE0:  MOVLB  2
0AE2:  MOVFF  01,FE9
0AE6:  MOVLW  04
0AE8:  ADDWF  02,W
0AEA:  MOVWF  FEA
0AEC:  CLRF   FEF
....................    }
....................    
....................   #if defined(__STALL_ON_UEP_ERRATA__)
....................    bit_clear(UEP(endpoint), 0);
0AEE:  CLRF   03
0AF0:  MOVF   x53,W
0AF2:  ADDLW  70
0AF4:  MOVWF  01
0AF6:  MOVLW  0F
0AF8:  ADDWFC 03,F
0AFA:  MOVFF  01,FE9
0AFE:  MOVFF  03,FEA
0B02:  BCF    FEF.0
....................   #endif
0B04:  MOVLB  0
0B06:  GOTO   0C0A (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    unsigned int8 st;
....................    
....................    direction = bit_test(endpoint,7);
*
0B70:  MOVLB  2
0B72:  BCF    x54.0
0B74:  BTFSC  x53.7
0B76:  BSF    x54.0
....................    endpoint &= 0x7F;
0B78:  BCF    x53.7
....................    
....................    if (direction) 
0B7A:  BTFSS  x54.0
0B7C:  BRA    0BB0
....................    {
....................       st=EP_BDxST_I(endpoint);
0B7E:  CLRF   x64
0B80:  MOVFF  253,263
0B84:  CLRF   x66
0B86:  MOVLW  08
0B88:  MOVWF  x65
0B8A:  MOVLB  0
0B8C:  RCALL  0496
0B8E:  MOVFF  02,257
0B92:  MOVFF  01,256
0B96:  MOVLW  04
0B98:  MOVLB  2
0B9A:  ADDWF  x56,F
0B9C:  MOVLW  00
0B9E:  ADDWFC x57,F
0BA0:  MOVFF  256,FE9
0BA4:  MOVLW  04
0BA6:  ADDWF  x57,W
0BA8:  MOVWF  FEA
0BAA:  MOVFF  FEF,255
....................    }
0BAE:  BRA    0BD0
....................    else 
....................    {
....................       st=EP_BDxST_O(endpoint);
0BB0:  CLRF   x64
0BB2:  MOVFF  253,263
0BB6:  CLRF   x66
0BB8:  MOVLW  08
0BBA:  MOVWF  x65
0BBC:  MOVLB  0
0BBE:  RCALL  0496
0BC0:  MOVLB  2
0BC2:  MOVFF  01,FE9
0BC6:  MOVLW  04
0BC8:  ADDWF  02,W
0BCA:  MOVWF  FEA
0BCC:  MOVFF  FEF,255
....................    }
....................    
....................    return(bit_test(st,7) && bit_test(st,2));
0BD0:  BTFSS  x55.7
0BD2:  BRA    0BD8
0BD4:  BTFSC  x55.2
0BD6:  BRA    0BDC
0BD8:  MOVLW  00
0BDA:  BRA    0BDE
0BDC:  MOVLW  01
0BDE:  MOVWF  01
0BE0:  MOVLB  0
0BE2:  GOTO   0C32 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_address(unsigned int8 address) 
.................... {
....................    UADDR = address;
*
109A:  MOVFF  254,F6E
....................    
....................    if (address) 
109E:  MOVLB  2
10A0:  MOVF   x54,F
10A2:  BZ    10AA
....................    {
....................       usb_state = USB_STATE_ADDRESS;
10A4:  MOVLW  04
10A6:  MOVWF  22
....................    }
10A8:  BRA    10AE
....................    else 
....................    {
....................       usb_state = USB_STATE_POWERED;
10AA:  MOVLW  02
10AC:  MOVWF  22
....................    }
10AE:  MOVLB  0
10B0:  GOTO   10BE (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_configured(unsigned int8 config) 
.................... {
....................    unsigned int8 en;
....................    unsigned int16 addy;
....................    unsigned int8 new_uep;
....................    unsigned int16 len;
....................    unsigned int8 i;
....................    
....................    if (config == 0)
*
0746:  MOVLB  2
0748:  MOVF   x53,F
074A:  BNZ   0758
....................    {
....................       // if config=0 then set addressed state
....................       usb_state = USB_STATE_ADDRESS;
074C:  MOVLW  04
074E:  MOVWF  22
....................       usb_disable_endpoints();
0750:  MOVLB  0
0752:  RCALL  0528
....................    }
0754:  BRA    092C
0756:  MOVLB  2
....................    else 
....................    {
....................       // else set configed state
....................       usb_state = USB_STATE_CONFIGURED; 
0758:  MOVLW  05
075A:  MOVWF  22
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH);
075C:  MOVLW  04
075E:  MOVWF  x56
0760:  MOVLW  98
0762:  MOVWF  x55
....................       for (en=1; en<USB_NUM_UEP; en++) 
0764:  MOVLW  01
0766:  MOVWF  x54
0768:  MOVF   x54,W
076A:  SUBLW  0F
076C:  BTFSS  FD8.0
076E:  BRA    092C
....................       {
....................          // enable and config endpoints based upon user configuration
....................          usb_disable_endpoint(en);
0770:  MOVFF  254,25C
0774:  MOVLB  0
0776:  RCALL  04B8
....................          new_uep = 0;
0778:  MOVLB  2
077A:  CLRF   x57
....................          if (usb_ep_rx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
077C:  CLRF   03
077E:  MOVF   x54,W
0780:  MOVLB  0
0782:  RCALL  00CE
0784:  SUBLW  FF
0786:  BZ    0856
....................          {
....................             new_uep = 0x04;
0788:  MOVLW  04
078A:  MOVLB  2
078C:  MOVWF  x57
....................             len = usb_ep_rx_size[en];
078E:  BCF    FD8.0
0790:  RLCF   x54,W
0792:  CLRF   03
0794:  MOVLB  0
0796:  RCALL  011E
0798:  TBLRD*+
079A:  MOVFF  FF5,03
079E:  MOVLB  2
07A0:  MOVWF  x58
07A2:  MOVFF  03,259
....................             EP_BDxCNT_O(en) = len;
07A6:  CLRF   x64
07A8:  MOVFF  254,263
07AC:  CLRF   x66
07AE:  MOVLW  08
07B0:  MOVWF  x65
07B2:  MOVLB  0
07B4:  RCALL  0496
07B6:  MOVFF  01,25B
07BA:  MOVLW  01
07BC:  MOVLB  2
07BE:  ADDWF  01,W
07C0:  MOVWF  01
07C2:  MOVLW  00
07C4:  ADDWFC 02,W
07C6:  MOVWF  03
07C8:  MOVFF  01,FE9
07CC:  MOVLW  04
07CE:  ADDWF  03,W
07D0:  MOVWF  FEA
07D2:  MOVFF  258,FEF
....................             EP_BDxADR_O(en) = addy;
07D6:  CLRF   x64
07D8:  MOVFF  254,263
07DC:  CLRF   x66
07DE:  MOVLW  08
07E0:  MOVWF  x65
07E2:  MOVLB  0
07E4:  RCALL  0496
07E6:  MOVFF  01,25B
07EA:  MOVLW  02
07EC:  MOVLB  2
07EE:  ADDWF  01,W
07F0:  MOVWF  01
07F2:  MOVLW  00
07F4:  ADDWFC 02,W
07F6:  MOVWF  03
07F8:  MOVFF  01,FE9
07FC:  MOVLW  04
07FE:  ADDWF  03,W
0800:  MOVWF  FEA
0802:  MOVFF  256,FEC
0806:  MOVF   FED,F
0808:  MOVFF  255,FEF
....................             addy += usb_ep_rx_size[en];
080C:  BCF    FD8.0
080E:  RLCF   x54,W
0810:  CLRF   03
0812:  MOVLB  0
0814:  RCALL  011E
0816:  TBLRD*+
0818:  MOVFF  FF5,03
081C:  MOVLB  2
081E:  ADDWF  x55,F
0820:  MOVF   03,W
0822:  ADDWFC x56,F
....................            #if USB_IGNORE_RX_DTS
....................             i = 0x80;
....................            #else
....................             i = 0x88;
0824:  MOVLW  88
0826:  MOVWF  x5A
....................            #endif
....................             if (bit_test(len,8)) {bit_set(i,0);}
0828:  BTFSS  x59.0
082A:  BRA    082E
082C:  BSF    x5A.0
....................             if (bit_test(len,9)) {bit_set(i,1);}
082E:  BTFSS  x59.1
0830:  BRA    0834
0832:  BSF    x5A.1
....................             EP_BDxST_O(en) = i;
0834:  CLRF   x64
0836:  MOVFF  254,263
083A:  CLRF   x66
083C:  MOVLW  08
083E:  MOVWF  x65
0840:  MOVLB  0
0842:  RCALL  0496
0844:  MOVLB  2
0846:  MOVFF  01,FE9
084A:  MOVLW  04
084C:  ADDWF  02,W
084E:  MOVWF  FEA
0850:  MOVFF  25A,FEF
0854:  MOVLB  0
....................          }
....................          if (usb_ep_tx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
0856:  CLRF   03
0858:  MOVLB  2
085A:  MOVF   x54,W
085C:  MOVLB  0
085E:  RCALL  00AE
0860:  SUBLW  FF
0862:  BZ    08F4
....................          {
....................             new_uep |= 0x02;
0864:  MOVLB  2
0866:  BSF    x57.1
....................             EP_BDxADR_I(en) = addy;
0868:  CLRF   x64
086A:  MOVFF  254,263
086E:  CLRF   x66
0870:  MOVLW  08
0872:  MOVWF  x65
0874:  MOVLB  0
0876:  RCALL  0496
0878:  MOVFF  02,25C
087C:  MOVFF  01,25B
0880:  MOVLW  04
0882:  MOVLB  2
0884:  ADDWF  x5B,F
0886:  MOVLW  00
0888:  ADDWFC x5C,F
088A:  MOVLW  02
088C:  ADDWF  x5B,W
088E:  MOVWF  01
0890:  MOVLW  00
0892:  ADDWFC x5C,W
0894:  MOVWF  03
0896:  MOVFF  01,FE9
089A:  MOVLW  04
089C:  ADDWF  03,W
089E:  MOVWF  FEA
08A0:  MOVFF  256,FEC
08A4:  MOVF   FED,F
08A6:  MOVFF  255,FEF
....................             addy += usb_ep_tx_size[en];
08AA:  BCF    FD8.0
08AC:  RLCF   x54,W
08AE:  CLRF   03
08B0:  MOVLB  0
08B2:  RCALL  00EE
08B4:  TBLRD*+
08B6:  MOVFF  FF5,03
08BA:  MOVLB  2
08BC:  ADDWF  x55,F
08BE:  MOVF   03,W
08C0:  ADDWFC x56,F
....................             EP_BDxST_I(en) = 0x40;
08C2:  CLRF   x64
08C4:  MOVFF  254,263
08C8:  CLRF   x66
08CA:  MOVLW  08
08CC:  MOVWF  x65
08CE:  MOVLB  0
08D0:  RCALL  0496
08D2:  MOVFF  02,25C
08D6:  MOVFF  01,25B
08DA:  MOVLW  04
08DC:  MOVLB  2
08DE:  ADDWF  x5B,F
08E0:  MOVLW  00
08E2:  ADDWFC x5C,F
08E4:  MOVFF  25B,FE9
08E8:  MOVLW  04
08EA:  ADDWF  x5C,W
08EC:  MOVWF  FEA
08EE:  MOVLW  40
08F0:  MOVWF  FEF
08F2:  MOVLB  0
....................          }
....................          if (new_uep == 0x06) {new_uep = 0x0E;}
08F4:  MOVLB  2
08F6:  MOVF   x57,W
08F8:  SUBLW  06
08FA:  BNZ   0900
08FC:  MOVLW  0E
08FE:  MOVWF  x57
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;}
0900:  CLRF   03
0902:  MOVF   x54,W
0904:  MOVLB  0
0906:  CALL   00AE
090A:  SUBLW  01
090C:  BZ    0914
090E:  MOVLB  2
0910:  BSF    x57.4
0912:  MOVLB  0
....................          
....................          UEP(en) = new_uep;
0914:  CLRF   03
0916:  MOVLB  2
0918:  MOVF   x54,W
091A:  ADDLW  70
091C:  MOVWF  FE9
091E:  MOVLW  0F
0920:  ADDWFC 03,W
0922:  MOVWF  FEA
0924:  MOVFF  257,FEF
0928:  INCF   x54,F
092A:  BRA    0768
092C:  MOVLB  0
....................       }
....................    }
092E:  GOTO   09DA (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoint(unsigned int8 en) 
.................... {
....................    UEP(en) = ENDPT_DISABLED;
*
04B8:  CLRF   03
04BA:  MOVLB  2
04BC:  MOVF   x5C,W
04BE:  ADDLW  70
04C0:  MOVWF  FE9
04C2:  MOVLW  0F
04C4:  ADDWFC 03,W
04C6:  MOVWF  FEA
04C8:  CLRF   FEF
....................    
....................    if (usb_endpoint_is_valid(en))
04CA:  MOVFF  25C,25D
04CE:  MOVLB  0
04D0:  RCALL  0448
04D2:  MOVF   01,F
04D4:  BZ    0526
....................    {
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary      
04D6:  MOVLB  2
04D8:  CLRF   x64
04DA:  MOVFF  25C,263
04DE:  CLRF   x66
04E0:  MOVLW  08
04E2:  MOVWF  x65
04E4:  MOVLB  0
04E6:  RCALL  0496
04E8:  MOVLB  2
04EA:  MOVFF  01,FE9
04EE:  MOVLW  04
04F0:  ADDWF  02,W
04F2:  MOVWF  FEA
04F4:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary
04F6:  CLRF   x64
04F8:  MOVFF  25C,263
04FC:  CLRF   x66
04FE:  MOVLW  08
0500:  MOVWF  x65
0502:  MOVLB  0
0504:  RCALL  0496
0506:  MOVFF  02,25E
050A:  MOVFF  01,25D
050E:  MOVLW  04
0510:  MOVLB  2
0512:  ADDWF  x5D,F
0514:  MOVLW  00
0516:  ADDWFC x5E,F
0518:  MOVFF  25D,FE9
051C:  MOVLW  04
051E:  ADDWF  x5E,W
0520:  MOVWF  FEA
0522:  CLRF   FEF
0524:  MOVLB  0
....................    }
0526:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoints(void) 
.................... {
....................    unsigned int8 i;
....................    
....................    for (i=1; i<USB_NUM_UEP; i++)
0528:  MOVLW  01
052A:  MOVLB  2
052C:  MOVWF  x5B
052E:  MOVF   x5B,W
0530:  SUBLW  0F
0532:  BNC   0542
....................       usb_disable_endpoint(i);
0534:  MOVFF  25B,25C
0538:  MOVLB  0
053A:  RCALL  04B8
053C:  MOVLB  2
053E:  INCF   x5B,F
0540:  BRA    052E
0542:  MOVLB  0
0544:  RETURN 0
....................       
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... /// END Hardware layer functions required by USB.C
.................... 
.................... 
.................... /// BEGIN USB Interrupt Service Routine
.................... 
.................... static void usb_clear_trn(void)
.................... {
....................    //UIR_TRN = 0;
....................    //delay_cycles(6);
....................    UIR &= ~(1 << BIT_TRN);
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_handle_interrupt()
.................... /*
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished
.................... /*          tokens is the majority of this code, and is handled by usb.c
.................... /*
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt 
.................... /*       method), then you must call this function rapidly.  If there is more 
.................... /*       than 10ms latency the PC may think the USB device is stalled and
.................... /*       disable it.
.................... /*       To switch to a polling method, remove the #int_usb line above this 
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the 
.................... /*       USB interrupt.
.................... /******************************************************************************/
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR)
.................... #int_usb NOCLEAR
.................... #endif
.................... void usb_isr(void)
.................... {
....................    unsigned int8 TRNAttempts;
....................    
....................    clear_interrupt(INT_USB);
*
13E2:  BCF    FA1.5
....................    
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though
13E4:  MOVF   22,F
13E6:  BTFSC  FD8.2
13E8:  BRA    1462
....................    if (UIR) 
13EA:  MOVF   F68,F
13EC:  BTFSC  FD8.2
13EE:  BRA    1462
....................    {
....................       //debug_usb(debug_putc,"\r\n\n[%X] ",UIR);
.................... 
....................       //activity detected.  (only enable after sleep)
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}
13F0:  BTFSS  F68.2
13F2:  BRA    13FA
13F4:  BTFSC  F69.2
13F6:  GOTO   03F6
.................... 
....................       if (UCON_SUSPND) return;
13FA:  BTFSC  F6D.1
13FC:  BRA    1462
.................... 
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent
13FE:  BTFSS  F68.5
1400:  BRA    1408
1402:  BTFSC  F69.5
1404:  GOTO   0432
.................... 
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected
1408:  BTFSS  F68.1
140A:  BRA    1412
140C:  BTFSC  F69.1
140E:  GOTO   0440
.................... 
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected
1412:  BTFSS  F68.0
1414:  BRA    141C
1416:  BTFSC  F69.0
1418:  GOTO   05B6
.................... 
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep
141C:  BTFSS  F68.4
141E:  BRA    1426
1420:  BTFSC  F69.4
1422:  GOTO   05E6
....................       
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();}
1426:  BTFSS  F68.6
1428:  BRA    1430
142A:  BTFSC  F69.6
142C:  GOTO   05F0
.................... 
....................       TRNAttempts = 0;
1430:  MOVLB  2
1432:  CLRF   x50
....................       do
....................       {
....................          if (UIR_TRN && UIE_TRN) 
1434:  BTFSS  F68.3
1436:  BRA    144C
1438:  BTFSS  F69.3
143A:  BRA    144C
....................          {
....................             USTATCopy = U1STAT;
143C:  MOVFF  F6C,21
....................             usb_clear_trn();
1440:  MOVLB  0
1442:  CALL   0004
....................             usb_isr_tok_dne();
1446:  BRA    12E6
....................          }
1448:  BRA    1450
144A:  MOVLB  2
....................          else
....................             break;
144C:  BRA    145A
144E:  MOVLB  0
....................       } while (TRNAttempts++ < 4);
1450:  MOVLB  2
1452:  MOVF   x50,W
1454:  INCF   x50,F
1456:  SUBLW  03
1458:  BC    1434
.................... 
....................      #if defined(USB_CDC_ISR)
....................       //has to be done here, can't be done until TRN is empty.
....................       if (usb_cdc_kbhit())
145A:  BTFSS  1E.0
145C:  BRA    1464
....................       {
....................          USB_CDC_ISR();
145E:  MOVLB  0
1460:  BRA    13DE
1462:  MOVLB  2
....................       }
....................      #endif
....................    }
1464:  MOVLB  0
1466:  GOTO   0060
.................... }
.................... 
.................... // SOF interrupt not handled.  user must add this depending on application
.................... void usb_isr_sof(void) 
.................... {
....................    //debug_usb(debug_putc, "\r\nSOF");
....................    
....................    //UIR_SOF = 0;
....................    UIR &= ~(1 << BIT_SOF);
*
05F0:  BCF    F68.6
05F2:  GOTO   1430 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_rst()
.................... /*
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device
.................... /*          and token handler code to initial state.
.................... /*
.................... /******************************************************************************/
.................... void usb_isr_rst(void) 
.................... {
....................    debug_usb_control(debug_putc,"-R-");
.................... 
....................    UEIE = 0;
*
05B6:  CLRF   F6B
....................    UIE = 0;
05B8:  CLRF   F69
....................    UEIR = 0;
05BA:  CLRF   F6A
....................    UIR = 0;
05BC:  CLRF   F68
.................... 
....................    UADDR = 0;
05BE:  CLRF   F6E
....................    
....................    UEP(0) = ENDPT_DISABLED;
05C0:  CLRF   F70
.................... 
....................    usb_disable_endpoints();
05C2:  RCALL  0528
....................    
....................    usb_token_reset();
05C4:  RCALL  0586
.................... 
....................    UEP(0) = ENDPT_CONTROL | 0x10;
05C6:  MOVLW  16
05C8:  MOVWF  F70
.................... 
....................    while (UIR_TRN) 
05CA:  BTFSS  F68.3
05CC:  BRA    05D2
....................    {
....................       usb_clear_trn();
05CE:  RCALL  0004
05D0:  BRA    05CA
....................    }
.................... 
.................... 
....................    UEIE = 0x9F;
05D2:  MOVLW  9F
05D4:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE;
05D6:  MOVLW  3D
05D8:  MOVWF  F69
.................... 
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled
05DA:  BCF    F6D.4
.................... 
....................    usb_init_ep0_setup();
05DC:  RCALL  0408
.................... 
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state
05DE:  MOVLW  03
05E0:  MOVWF  22
05E2:  GOTO   141C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_init_ep0_setup()
.................... /*
.................... /* Summary: Configure EP0 to receive setup packets
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_ep0_setup(void) 
.................... {
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH;
*
0408:  MOVLW  40
040A:  MOVLB  4
040C:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION;
040E:  MOVLW  04
0410:  MOVLB  2
0412:  MOVWF  x52
0414:  MOVLW  18
0416:  MOVFF  252,403
041A:  MOVFF  FE8,402
....................    #if USB_IGNORE_RX_DTS
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off
....................    #else
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on
041E:  MOVLW  88
0420:  MOVLB  4
0422:  MOVWF  x00
....................    #endif
.................... 
....................     EP_BDxST_I(0) = 0;
0424:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH;
0426:  MOVLW  04
0428:  MOVWF  x07
042A:  MOVLW  58
042C:  MOVWF  x06
042E:  MOVLB  0
0430:  RETURN 0
.................... }
.................... 
.................... /*******************************************************************************
.................... /* usb_isr_uerr()
.................... /*
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter
.................... /*          will incerement.  If having problems check the status of these 8 bytes.
.................... /*
.................... /* NOTE: This code is not enabled by default.
.................... /********************************************************************************/
.................... void usb_isr_uerr(void)
.................... {
....................   #if USB_USE_ERROR_COUNTER
....................    int ints;
....................   #endif
.................... 
....................    debug_usb_control(debug_putc,"-E%X-",UEIR);
.................... 
....................   #if USB_USE_ERROR_COUNTER
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled
.................... 
....................    if ( bit_test(ints,0) ) 
....................    { 
....................       //increment pid_error counter
....................       //debug_usb(debug_putc,"PID ");
....................       ERROR_COUNTER[0]++;
....................    }
.................... 
....................    if ( bit_test(ints,1) ) 
....................    {  
....................       //increment crc5 error counter
....................       //debug_usb(debug_putc,"CRC5 ");
....................       ERROR_COUNTER[1]++;
....................    }
.................... 
....................    if ( bit_test(ints,2) ) 
....................    {
....................       //increment crc16 error counter
....................       //debug_usb(debug_putc,"CRC16 ");
....................       ERROR_COUNTER[2]++;
....................    }
.................... 
....................    if ( bit_test(ints,3) ) 
....................    {  
....................       //increment dfn8 error counter
....................       //debug_usb(debug_putc,"DFN8 ");
....................       ERROR_COUNTER[3]++;
....................    }
.................... 
....................    if ( bit_test(ints,4) ) 
....................    {  
....................       //increment bto error counter
....................       //debug_usb(debug_putc,"BTO ");
....................       ERROR_COUNTER[4]++;
....................    }
.................... 
....................    if ( bit_test(ints,7) ) 
....................    { 
....................       //increment bts error counter
....................       //debug_usb(debug_putc,"BTS ");
....................       ERROR_COUNTER[5]++;
....................    }
....................   #endif
.................... 
....................    UEIR = 0;
*
0440:  CLRF   F6A
....................    
....................    //UIR_UERR = 0;
....................    UIR &= ~(1 << BIT_UERR);
0442:  BCF    F68.1
0444:  GOTO   1412 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_uidle()
.................... /*
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_uidle(void)
.................... {
....................    debug_usb_control(debug_putc, "-I-");
.................... 
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice)
*
05E6:  BSF    F69.2
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
....................    // turn off isr instead of clearing flag
....................    UIE &= ~(unsigned int16)__USB_UIF_IDLE;
05E8:  BCF    F69.4
....................   #else
....................    UIR &= ~(1 << BIT_IDLE);
....................   #endif
....................    
....................    UCON_SUSPND = 1; //set suspend. we are now suspended
05EA:  BSF    F6D.1
05EC:  GOTO   1426 (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
.................... /* usb_isr_activity()
.................... /*
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB
.................... /*          peripheral.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_activity(void)
.................... {
....................    debug_usb_control(debug_putc, "-A-");
.................... 
....................    UCON_SUSPND = 0; //turn off low power suspending
*
03F6:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling
03F8:  BCF    F69.2
....................    
....................    while(UIR_ACTV)
03FA:  BTFSS  F68.2
03FC:  BRA    0402
....................    {
....................       //UIR_ACTV = 0;
....................       UIR &= ~(1 << BIT_ACTV);
03FE:  BCF    F68.2
....................    }
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
0400:  BRA    03FA
....................    // now it's safe to clear the flag
....................    UIR &= ~(1 << BIT_IDLE);
0402:  BCF    F68.4
....................   #endif   
0404:  GOTO   13FA (RETURN)
.................... }
.................... 
.................... /******************************************************************************
.................... /* usb_isr_stall()
.................... /*
.................... /* Summary: Stall handshake detected.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_stall(void) 
.................... {
....................    debug_usb_control(debug_putc, "-S-");
....................    
....................    
....................    if (bit_test(UEP(0),0)) 
*
0432:  BTFSS  F70.0
0434:  BRA    043A
....................    {
....................       usb_init_ep0_setup();
0436:  RCALL  0408
....................       bit_clear(UEP(0), 0);
0438:  BCF    F70.0
....................    }
....................    
....................    //UIR_STALL = 0;
....................    UIR &= ~(1 << BIT_STALL);
043A:  BCF    F68.5
043C:  GOTO   1408 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;}
*
05F6:  MOVFF  256,23
05FA:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;}
*
0C50:  MOVLW  FE
0C52:  MOVWF  23
0C54:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;}
*
05FC:  SETF   23
05FE:  RETURN 0
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_tok_dne()
.................... /*
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral.
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and
.................... /*          handle the request.
.................... /*          If an IN token on EP0 was received, continue transmitting any
.................... /*          unfinished requests that may take more than one packet to transmit
.................... /*          (if necessary).
.................... /*          If an OUT token on any other EP was received, mark that EP as ready
.................... /*          for a usb_get_packet().
.................... /*          Does not handle any IN or OUT tokens on EP0.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_tok_dne(void) 
.................... {
....................    unsigned int8 en;
.................... 
....................    en = USTATCopy>>3;
*
12E6:  RRCF   21,W
12E8:  MOVLB  2
12EA:  MOVWF  x51
12EC:  RRCF   x51,F
12EE:  RRCF   x51,F
12F0:  MOVLW  1F
12F2:  ANDWF  x51,F
.................... 
....................    debug_usb_control(debug_putc, "-T%X-", USTATCopy);
.................... 
....................    if (USTATCopy == USTAT_OUT_SETUP_E0) 
12F4:  MOVF   21,F
12F6:  BNZ   1394
....................    {
....................       //new out or setup token in the buffer
....................       int8 pidKey;
....................       
....................       //debug_usb(debug_putc,"%X ", EP_BDxST_O(0));
....................       
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID
12F8:  MOVLB  4
12FA:  MOVF   x00,W
12FC:  ANDLW  3C
12FE:  MOVLB  2
1300:  MOVWF  x52
....................       
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion
1302:  MOVLW  43
1304:  MOVLB  4
1306:  ANDWF  x00,F
....................       
....................       if (pidKey == USB_PIC_PID_SETUP) 
1308:  MOVLB  2
130A:  MOVF   x52,W
130C:  SUBLW  34
130E:  BNZ   135A
....................       {
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00)
1310:  MOVLB  4
1312:  MOVF   x04,W
1314:  ANDLW  80
1316:  BZ    131A
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests)
1318:  CLRF   x04
.................... 
....................          //debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0));
....................          //debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer);
.................... 
....................          usb_isr_tok_setup_dne();
131A:  MOVLB  0
131C:  BRA    0CF2
.................... 
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
131E:  BCF    F6D.4
.................... 
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall())
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data())
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response())
....................          if (__setup_0_tx_size == 0xFF)
1320:  INCFSZ 23,W
1322:  BRA    1332
....................             usb_flush_out(0, USB_DTS_STALL);
1324:  MOVLB  2
1326:  CLRF   x54
1328:  MOVLW  03
132A:  MOVWF  x55
132C:  MOVLB  0
132E:  RCALL  0D24
1330:  BRA    1356
....................          else 
....................          {
....................             usb_flush_out(0, USB_DTS_TOGGLE);
1332:  MOVLB  2
1334:  CLRF   x54
1336:  MOVLW  02
1338:  MOVWF  x55
133A:  MOVLB  0
133C:  RCALL  0D24
....................             if (__setup_0_tx_size != 0xFE)
133E:  MOVF   23,W
1340:  SUBLW  FE
1342:  BZ    1356
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX);
1344:  MOVLB  2
1346:  CLRF   x5D
1348:  CLRF   x5F
134A:  MOVFF  23,25E
134E:  MOVLW  04
1350:  MOVWF  x60
1352:  MOVLB  0
1354:  RCALL  0E7A
....................          }
....................          //why was this here?
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
....................       }
1356:  BRA    1390
1358:  MOVLB  2
....................       else if (pidKey == USB_PIC_PID_OUT) 
135A:  MOVF   x52,W
135C:  SUBLW  04
135E:  BNZ   1392
....................       {
....................          usb_isr_tok_out_dne(0);
1360:  CLRF   x53
1362:  MOVLB  0
1364:  RCALL  107C
....................          usb_flush_out(0, USB_DTS_TOGGLE);
1366:  MOVLB  2
1368:  CLRF   x54
136A:  MOVLW  02
136C:  MOVWF  x55
136E:  MOVLB  0
1370:  RCALL  0D24
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF))
1372:  MOVF   23,W
1374:  SUBLW  FE
1376:  BZ    1390
1378:  INCFSZ 23,W
137A:  BRA    137E
137C:  BRA    1390
....................          {
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len)
137E:  MOVLB  2
1380:  CLRF   x5D
1382:  CLRF   x5F
1384:  MOVFF  23,25E
1388:  MOVLW  01
138A:  MOVWF  x60
138C:  MOVLB  0
138E:  RCALL  0E7A
1390:  MOVLB  2
....................          }
....................       }
....................       //else
....................       //{
....................       //   debug_usb(debug_putc, "!!! ");
....................       //}
....................    }
1392:  BRA    13D8
....................    else if (USTATCopy == USTAT_IN_E0) 
1394:  MOVF   21,W
1396:  SUBLW  04
1398:  BNZ   13BE
....................    {   
....................       //pic -> host transfer completed
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion
....................       __setup_0_tx_size = 0xFF;
139A:  SETF   23
....................       usb_isr_tok_in_dne(0);
139C:  CLRF   x53
139E:  MOVLB  0
13A0:  RCALL  12B4
....................       if (__setup_0_tx_size!=0xFF)
13A2:  INCFSZ 23,W
13A4:  BRA    13A8
13A6:  BRA    13BA
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE);
13A8:  MOVLB  2
13AA:  CLRF   x5D
13AC:  CLRF   x5F
13AE:  MOVFF  23,25E
13B2:  MOVLW  02
13B4:  MOVWF  x60
13B6:  MOVLB  0
13B8:  RCALL  0E7A
....................       else
....................       {
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................       }  
....................    }
13BA:  BRA    13D6
13BC:  MOVLB  2
....................    else 
....................    {
....................       if (!bit_test(USTATCopy, 2)) 
13BE:  BTFSC  21.2
13C0:  BRA    13CE
....................       {
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_out_dne(en);
13C2:  MOVFF  251,253
13C6:  MOVLB  0
13C8:  RCALL  107C
....................       }
13CA:  BRA    13D6
13CC:  MOVLB  2
....................       else 
....................       {
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_in_dne(en);
13CE:  MOVFF  251,253
13D2:  MOVLB  0
13D4:  RCALL  12B4
13D6:  MOVLB  2
....................       }
....................    }
13D8:  MOVLB  0
13DA:  GOTO   1448 (RETURN)
.................... }
.................... 
.................... /// END USB Interrupt Service Routine
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... #if defined(__PIC24_USB_H__)
....................  #include <pic24_usb.c>
.................... #endif
.................... 
.................... #if defined(__USBN960X_H__)
....................  #include <usbn960x.c>
.................... #endif
.................... 
.................... 
.................... #IFNDEF __USB_HARDWARE__
....................    #ERROR You must include USB hardware driver.
.................... #ENDIF
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
....................    #ERROR You must include USB descriptors.
.................... #ENDIF
.................... 
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1))
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  64
.................... #else
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  8
.................... #endif
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors
.................... 
.................... #IF USB_HID_BOOT_PROTOCOL
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES];
.................... #ENDIF
.................... 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size);
.................... 
.................... void usb_isr_tkn_setup_StandardEndpoint(void);
.................... void usb_isr_tkn_setup_StandardDevice(void);
.................... void usb_isr_tkn_setup_StandardInterface(void);
.................... #IF USB_HID_DEVICE
....................    void usb_isr_tkn_setup_ClassInterface(void);
.................... #ENDIF
.................... void usb_Get_Descriptor(void);
.................... void usb_copy_desc_seg_to_ep(void);
.................... void usb_finish_set_address(void);
.................... 
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors
.................... 
.................... /// BEGIN User Functions
.................... 
.................... // see usb.h for documentation
.................... int1 usb_enumerated(void)
.................... {
....................    return(USB_stack_status.curr_config);
*
154E:  MOVF   1B,W
1550:  MOVWF  01
1552:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_wait_for_enumeration(void) 
.................... {
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();}
.................... }
.................... 
.................... // see USB.H for documentation
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) {
....................    unsigned int16 i=0;
....................    int1 res;
....................    unsigned int16 this_packet_len;
....................    unsigned int16 packet_size;
....................    unsigned int32 timeout_1us;
.................... 
....................    packet_size = usb_ep_tx_size[endpoint];
....................    
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size);
.................... 
....................    //send data packets until timeout or no more packets to send
....................    while (i < len) 
....................    {
....................       timeout_1us = (int32)timeout*1000;
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;}
....................       else {this_packet_len = len-i;}
....................       //putc('*');
....................       do 
....................       {
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets
....................          //putc('.');
....................          if (!res)
....................          {
....................             delay_us(1);
....................             //delay_ms(500);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................       i += packet_size;
....................    }
.................... 
.................... 
....................    //send 0len packet if needed
....................    if (i==len) {
....................       timeout_1us=(int32)timeout*1000;
....................       do {
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message
....................          if (!res) {
....................             delay_us(1);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................    }
.................... 
....................    return(res);
.................... }
.................... 
.................... // see usb.h for documentation
.................... unsigned int16 usb_gets(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max, unsigned int16 timeout) {
....................    unsigned int16 ret=0;
....................    unsigned int16 to;
....................    unsigned int16 len;
....................    unsigned int16 packet_size;
....................    unsigned int16 this_packet_max;
.................... 
....................    packet_size=usb_ep_rx_size[endpoint];
.................... 
....................    do {
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;}
....................       to=0;
....................       do {
....................          len = packet_size;
....................          if (usb_kbhit(endpoint)) {
....................             len=usb_get_packet(endpoint,ptr,this_packet_max);
....................             ptr+=len;
....................             max-=len;
....................             ret+=len;
....................             break;
....................          }
....................          else {
....................             to++;
....................             delay_ms(1);
....................          }
....................       } while (to!=timeout);
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max);
.................... 
....................    return(ret);
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR)
.................... 
.................... // see usb.h for documentation
.................... void usb_token_reset(void) 
.................... {
....................    unsigned int i;
.................... 
....................    usb_getdesc_len = 0;
*
0586:  CLRF   28
0588:  CLRF   27
....................    
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++) 
058A:  MOVLB  2
058C:  CLRF   x51
058E:  MOVF   x51,W
0590:  SUBLW  01
0592:  BNC   05A8
....................       USB_Interface[i] = 0;   //reset each interface to default
0594:  CLRF   03
0596:  MOVF   x51,W
0598:  ADDLW  29
059A:  MOVWF  FE9
059C:  MOVLW  00
059E:  ADDWFC 03,W
05A0:  MOVWF  FEA
05A2:  CLRF   FEF
.................... 
....................   #IF USB_HID_BOOT_PROTOCOL
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++)
....................       hid_protocol[i] = 1;
....................   #endif
.................... 
....................   #if USB_CDC_DEVICE
05A4:  INCF   x51,F
05A6:  BRA    058E
....................    usb_cdc_init();
05A8:  MOVLB  0
05AA:  RCALL  0546
....................   #endif
.................... 
....................    USB_stack_status.curr_config = 0;      //unconfigured device
05AC:  CLRF   1B
.................... 
....................    USB_stack_status.status_device = 1;    //previous state.  init at none
05AE:  MOVLW  01
05B0:  MOVWF  1C
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none
05B2:  CLRF   1A
05B4:  RETURN 0
.................... }
.................... 
.................... //send a 0len packet to endpoint 0 (optimization)
.................... //notice that this doesnt return the status
.................... #define usb_put_0len_0() usb_request_send_response(0)
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    direction = bit_test(endpoint,7);
*
0448:  MOVLB  2
044A:  BCF    x5E.0
044C:  BTFSC  x5D.7
044E:  BSF    x5E.0
....................    
....................    endpoint &= 0x7F;
0450:  BCF    x5D.7
....................    
....................    if (endpoint > 16)
0452:  MOVF   x5D,W
0454:  SUBLW  10
0456:  BC    045E
....................       return(false);
0458:  MOVLW  00
045A:  MOVWF  01
045C:  BRA    0492
....................    
....................    if (direction) { //IN
045E:  BTFSS  x5E.0
0460:  BRA    047C
....................       return(usb_ep_tx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
0462:  CLRF   03
0464:  MOVF   x5D,W
0466:  MOVLB  0
0468:  RCALL  00AE
046A:  SUBLW  FF
046C:  BNZ   0472
046E:  MOVLW  00
0470:  BRA    0474
0472:  MOVLW  01
0474:  MOVWF  01
0476:  MOVLB  2
0478:  BRA    0492
....................    }
047A:  BRA    0492
....................    else {   //OUT
....................       return(usb_ep_rx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
047C:  CLRF   03
047E:  MOVF   x5D,W
0480:  MOVLB  0
0482:  RCALL  00CE
0484:  SUBLW  FF
0486:  BNZ   048C
0488:  MOVLW  00
048A:  BRA    048E
048C:  MOVLW  01
048E:  MOVWF  01
0490:  MOVLB  2
....................    }
0492:  MOVLB  0
0494:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) {
....................    if (endpoint==0) {
*
12B4:  MOVLB  2
12B6:  MOVF   x53,F
12B8:  BNZ   12D6
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor?
12BA:  DECFSZ 1A,W
12BC:  BRA    12C8
12BE:  MOVLB  0
12C0:  CALL   0600
12C4:  BRA    12D2
12C6:  MOVLB  2
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();}
12C8:  MOVF   1A,W
12CA:  SUBLW  02
12CC:  BNZ   12D4
12CE:  MOVLB  0
12D0:  BRA    10B4
12D2:  MOVLB  2
....................    }
....................   #if USB_CDC_DEVICE
12D4:  BRA    12E2
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
12D6:  MOVF   x53,W
12D8:  SUBLW  02
12DA:  BNZ   12E2
....................       usb_isr_tok_in_cdc_data_dne();
12DC:  MOVLB  0
12DE:  BRA    12AE
12E0:  MOVLB  2
....................   }
....................   #endif
12E2:  MOVLB  0
12E4:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint)
.................... {
....................    //TODO:
....................    if (endpoint==0) {
*
107C:  MOVLB  2
107E:  MOVF   x53,F
1080:  BNZ   108A
....................      debug_usb(debug_putc,"TOUT 0 ");
....................      #if USB_CDC_DEVICE
....................       usb_isr_tok_out_cdc_control_dne();
1082:  MOVLB  0
1084:  BRA    0FC6
....................      //#else   //REMOVED JUN/9/2009
....................      //usb_init_ep0_setup();
....................      #endif
....................    }
....................   #if USB_CDC_DEVICE
1086:  BRA    1094
1088:  MOVLB  2
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
108A:  MOVF   x53,W
108C:  SUBLW  02
108E:  BNZ   1096
....................       usb_isr_tok_out_cdc_data_dne();
1090:  MOVLB  0
1092:  BRA    1060
1094:  MOVLB  2
....................    }
....................   #endif
1096:  MOVLB  0
1098:  RETURN 0
....................    //else {
....................    //   bit_set(__usb_kbhit_status,endpoint);
....................    //}
.................... }
.................... 
.................... 
.................... //---- process setup message stage -----------//
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_setup_dne(void) 
.................... {
....................    USB_stack_status.dev_req=NONE; // clear the device request..
*
0CF2:  CLRF   1A
.................... 
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) {
0CF4:  MOVLB  4
0CF6:  MOVF   x18,W
0CF8:  ANDLW  7F
0CFA:  XORLW  00
0CFC:  MOVLB  0
0CFE:  BZ    0D0E
0D00:  XORLW  01
0D02:  BZ    0D12
0D04:  XORLW  03
0D06:  BZ    0D16
0D08:  XORLW  23
0D0A:  BZ    0D1A
0D0C:  BRA    0D1E
.................... 
....................       case 0x00:  //standard to device
....................          debug_usb_token(debug_putc," d");
....................          usb_isr_tkn_setup_StandardDevice();
0D0E:  BRA    0932
....................          break;
0D10:  BRA    0D20
.................... 
....................       case 0x01:  //standard to interface
....................          debug_usb_token(debug_putc," i");
....................          usb_isr_tkn_setup_StandardInterface();
0D12:  BRA    09EE
....................          break;
0D14:  BRA    0D20
.................... 
....................       case 0x02:  //standard to endpoint
....................          debug_usb_token(debug_putc," e");
....................          usb_isr_tkn_setup_StandardEndpoint();
0D16:  BRA    0BE6
....................          break;
0D18:  BRA    0D20
....................          
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case 0x21:  //class specific request.  the only class this driver supports is HID
....................          debug_usb_token(debug_putc, " class");
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE)
....................          {
....................             usb_isr_tkn_setup_ClassInterface();
....................          }
....................          else
....................          {
....................             usb_isr_tkn_cdc();
....................          }
....................         #elif USB_HID_DEVICE
....................          usb_isr_tkn_setup_ClassInterface();
....................         #else
....................          usb_isr_tkn_cdc();
0D1A:  BRA    0C56
....................         #endif
....................          break;
0D1C:  BRA    0D20
.................... #endif
.................... 
.................... 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE
.................... 
....................       default:
....................          usb_request_stall();
0D1E:  RCALL  05FC
....................          break;
....................    }
0D20:  GOTO   131E (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardDevice()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Device request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardDevice(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
*
0932:  MOVLB  4
0934:  MOVF   x19,W
0936:  XORLW  00
0938:  MOVLB  0
093A:  BZ    0956
093C:  XORLW  01
093E:  BZ    096A
0940:  XORLW  02
0942:  BZ    0986
0944:  XORLW  06
0946:  BZ    09A0
0948:  XORLW  03
094A:  BZ    09B2
094C:  XORLW  0E
094E:  BZ    09B6
0950:  XORLW  01
0952:  BZ    09C6
0954:  BRA    09E8
.................... 
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device;
0956:  MOVFF  1C,458
....................             usb_ep0_tx_buffer[1]=0;
095A:  MOVLB  4
095C:  CLRF   x59
....................             usb_request_send_response(2);
095E:  MOVLW  02
0960:  MOVLB  2
0962:  MOVWF  x56
0964:  MOVLB  0
0966:  RCALL  05F6
....................             break;
0968:  BRA    09EA
.................... 
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1
....................             if (usb_ep0_rx_buffer[2] == 1) {
096A:  MOVLB  4
096C:  DECFSZ x1A,W
096E:  BRA    0980
....................                debug_usb_token(debug_putc,"CF");
....................                USB_stack_status.status_device &= 1;
0970:  MOVLW  01
0972:  ANDWF  1C,F
....................                usb_put_0len_0();
0974:  MOVLB  2
0976:  CLRF   x56
0978:  MOVLB  0
097A:  RCALL  05F6
....................             }
097C:  BRA    0984
097E:  MOVLB  4
....................             else
....................                usb_request_stall();
0980:  MOVLB  0
0982:  RCALL  05FC
....................             break;
0984:  BRA    09EA
.................... 
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3
....................             if (usb_ep0_rx_buffer[2] == 1) {
0986:  MOVLB  4
0988:  DECFSZ x1A,W
098A:  BRA    099A
....................                debug_usb_token(debug_putc,"SF");
....................                USB_stack_status.status_device |= 2;
098C:  BSF    1C.1
....................                usb_put_0len_0();
098E:  MOVLB  2
0990:  CLRF   x56
0992:  MOVLB  0
0994:  RCALL  05F6
....................             }
0996:  BRA    099E
0998:  MOVLB  4
....................             else
....................                usb_request_stall();
099A:  MOVLB  0
099C:  RCALL  05FC
....................             break;
099E:  BRA    09EA
.................... 
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5
....................             debug_usb_token(debug_putc,"SA");
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request
09A0:  MOVLW  02
09A2:  MOVWF  1A
....................             USB_address_pending=usb_ep0_rx_buffer[2];
09A4:  MOVFF  41A,24
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request
....................             usb_set_address(USB_address_pending);
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0
....................             #endif
....................             usb_put_0len_0();
09A8:  MOVLB  2
09AA:  CLRF   x56
09AC:  MOVLB  0
09AE:  RCALL  05F6
....................             break;
09B0:  BRA    09EA
.................... 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6
....................             debug_usb_token(debug_putc,"GD");
....................             usb_Get_Descriptor();
09B2:  BRA    0688
....................             break;
09B4:  BRA    09EA
.................... 
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8
....................             debug_usb_token(debug_putc,"GC");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config;
09B6:  MOVFF  1B,458
....................             usb_request_send_response(1);
09BA:  MOVLW  01
09BC:  MOVLB  2
09BE:  MOVWF  x56
09C0:  MOVLB  0
09C2:  RCALL  05F6
....................             break;
09C4:  BRA    09EA
.................... 
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) {
09C6:  MOVLB  4
09C8:  MOVF   x1A,W
09CA:  SUBLW  01
09CC:  BNC   09E4
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2];
09CE:  MOVFF  41A,1B
....................                usb_set_configured(usb_ep0_rx_buffer[2]);
09D2:  MOVFF  41A,253
09D6:  MOVLB  0
09D8:  BRA    0746
....................                debug_usb_token(debug_putc,"SC%U", USB_stack_status.curr_config);               
....................                usb_put_0len_0();
09DA:  MOVLB  2
09DC:  CLRF   x56
09DE:  MOVLB  0
09E0:  RCALL  05F6
09E2:  MOVLB  4
....................             }
....................             break;
09E4:  MOVLB  0
09E6:  BRA    09EA
.................... 
....................       default:
....................             usb_request_stall();
09E8:  RCALL  05FC
....................             break;
....................    }
09EA:  GOTO   0D20 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Interface request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardInterface(void) {
....................    unsigned int8 curr_config;
.................... 
....................    curr_config=USB_stack_status.curr_config;
09EE:  MOVFF  1B,253
.................... 
....................    switch (usb_ep0_rx_buffer[1]) {
09F2:  MOVLB  4
09F4:  MOVF   x19,W
09F6:  XORLW  00
09F8:  MOVLB  0
09FA:  BZ    0A06
09FC:  XORLW  0A
09FE:  BZ    0A18
0A00:  XORLW  01
0A02:  BZ    0A5E
0A04:  BRA    0A8A
....................       case USB_STANDARD_REQUEST_GET_STATUS:
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=0;
0A06:  MOVLB  4
0A08:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0;
0A0A:  CLRF   x59
....................             usb_request_send_response(2);
0A0C:  MOVLW  02
0A0E:  MOVLB  2
0A10:  MOVWF  x56
0A12:  MOVLB  0
0A14:  RCALL  05F6
....................             break;
0A16:  BRA    0A8C
.................... 
....................       case USB_STANDARD_REQUEST_GET_INTERFACE:
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state
0A18:  MOVLB  2
0A1A:  MOVF   x53,F
0A1C:  BZ    0A58
0A1E:  MOVLW  01
0A20:  SUBWF  x53,W
0A22:  CLRF   03
0A24:  MOVLB  0
0A26:  CALL   01A2
0A2A:  MOVWF  01
0A2C:  MOVLB  4
0A2E:  SUBWF  x1C,W
0A30:  BTFSS  FD8.0
0A32:  BRA    0A38
0A34:  MOVLB  2
0A36:  BRA    0A58
....................                debug_usb_token(debug_putc,"GI");
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte
0A38:  CLRF   03
0A3A:  MOVF   x1C,W
0A3C:  ADDLW  29
0A3E:  MOVWF  FE9
0A40:  MOVLW  00
0A42:  ADDWFC 03,W
0A44:  MOVWF  FEA
0A46:  MOVFF  FEF,458
....................                usb_request_send_response(1); //send byte back
0A4A:  MOVLW  01
0A4C:  MOVLB  2
0A4E:  MOVWF  x56
0A50:  MOVLB  0
0A52:  RCALL  05F6
....................             }
0A54:  BRA    0A5C
0A56:  MOVLB  2
....................             else
....................                usb_request_stall();
0A58:  MOVLB  0
0A5A:  RCALL  05FC
....................             break;
0A5C:  BRA    0A8C
.................... 
....................       case USB_STANDARD_REQUEST_SET_INTERFACE:
....................             if (curr_config) { //if configured state
0A5E:  MOVLB  2
0A60:  MOVF   x53,F
0A62:  BZ    0A84
....................                debug_usb_token(debug_putc,"SI");
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
0A64:  CLRF   03
0A66:  MOVLB  4
0A68:  MOVF   x1C,W
0A6A:  ADDLW  29
0A6C:  MOVWF  FE9
0A6E:  MOVLW  00
0A70:  ADDWFC 03,W
0A72:  MOVWF  FEA
0A74:  MOVFF  41A,FEF
....................                usb_put_0len_0();
0A78:  MOVLB  2
0A7A:  CLRF   x56
0A7C:  MOVLB  0
0A7E:  RCALL  05F6
....................             }
0A80:  BRA    0A88
0A82:  MOVLB  2
....................             else
....................                usb_request_stall();
0A84:  MOVLB  0
0A86:  RCALL  05FC
....................             break;
0A88:  BRA    0A8C
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR:
....................             debug_usb_token(debug_putc,"GDh");
....................             usb_Get_Descriptor();
....................             break;
.................... #endif
.................... 
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE:
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE:
.................... //                let default take care of these, goto wrongstate
....................       default:
....................             usb_request_stall();
0A8A:  RCALL  05FC
....................             break;
....................    }
0A8C:  GOTO   0D20 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardEndpoint()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardEndpoint(void) {
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) {
*
0BE6:  MOVFF  41C,25D
0BEA:  RCALL  0448
0BEC:  MOVF   01,F
0BEE:  BZ    0C4C
....................       switch(usb_ep0_rx_buffer[1]) {
0BF0:  MOVLB  4
0BF2:  MOVF   x19,W
0BF4:  XORLW  01
0BF6:  MOVLB  0
0BF8:  BZ    0C04
0BFA:  XORLW  02
0BFC:  BZ    0C14
0BFE:  XORLW  03
0C00:  BZ    0C24
0C02:  BRA    0C4A
.................... 
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE:
....................                debug_usb_token(debug_putc,"CF");
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]);
0C04:  MOVFF  41C,253
0C08:  BRA    0A90
....................                usb_put_0len_0();
0C0A:  MOVLB  2
0C0C:  CLRF   x56
0C0E:  MOVLB  0
0C10:  RCALL  05F6
....................                break;
0C12:  BRA    0C4C
.................... 
....................          case USB_STANDARD_REQUEST_SET_FEATURE:
....................                      debug_usb_token(debug_putc,"SF");
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]);
0C14:  MOVFF  41C,253
0C18:  BRA    0B0A
....................                      usb_put_0len_0();
0C1A:  MOVLB  2
0C1C:  CLRF   x56
0C1E:  MOVLB  0
0C20:  RCALL  05F6
....................                      break;
0C22:  BRA    0C4C
.................... 
....................          case USB_STANDARD_REQUEST_GET_STATUS:
....................                debug_usb_token(debug_putc,"GS");
....................                usb_ep0_tx_buffer[0]=0;
0C24:  MOVLB  4
0C26:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0;
0C28:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) {
0C2A:  MOVFF  41C,253
0C2E:  MOVLB  0
0C30:  BRA    0B70
0C32:  MOVF   01,F
0C34:  BZ    0C3E
....................                   usb_ep0_tx_buffer[0]=1;
0C36:  MOVLW  01
0C38:  MOVLB  4
0C3A:  MOVWF  x58
0C3C:  MOVLB  0
....................                }
....................                usb_request_send_response(2);
0C3E:  MOVLW  02
0C40:  MOVLB  2
0C42:  MOVWF  x56
0C44:  MOVLB  0
0C46:  RCALL  05F6
....................                break;
0C48:  BRA    0C4C
.................... 
....................          default:
....................             usb_request_stall();
0C4A:  RCALL  05FC
....................             break;
....................       }
....................    }
0C4C:  GOTO   0D20 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_ClassInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /* Only compiled if HID_DEVICE is TRUE
.................... /***************************************************************/
.................... #IF USB_HID_DEVICE
.................... void usb_isr_tkn_setup_ClassInterface(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03
....................             debug_usb_token(debug_putc,"GP");
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]];
....................             usb_request_send_response(1);
....................             break;
....................     #ENDIF
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b
....................             debug_usb_token(debug_putc,"SP");
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
....................             usb_put_0len_0(); //send 0len packet69
....................             break;
....................     #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_SET_IDLE:   //0a
....................          #error TODO: if you want to support SET_IDLE, add code here
....................    #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_GET_IDLE:   //02
....................          #error TODO: if you want to support GET_IDLE, add code here
....................    #ENDIF
.................... 
....................       default:
....................             usb_request_stall();
....................             break;
....................    }
.................... }
.................... #ENDIF
.................... 
.................... /**************************************************************
.................... /* usb_Get_Descriptor()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept
.................... /*
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.),
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have
.................... /*          pointers to constants we must simulate or own by setting up global registers that say
.................... /*          which constant array to deal with, which position to start in this array, and the length.
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne()
.................... /*          which will send the rest of the data.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_Get_Descriptor() {
*
0688:  MOVLB  2
068A:  CLRF   x53
....................    unsigned int8 i = 0;
....................    usb_getdesc_ptr=0;
068C:  CLRF   26
068E:  CLRF   25
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE;
0690:  CLRF   1D
.................... 
....................    switch(usb_ep0_rx_buffer[3]) {
0692:  MOVLB  4
0694:  MOVF   x1B,W
0696:  XORLW  01
0698:  MOVLB  0
069A:  BZ    06AA
069C:  XORLW  03
069E:  BZ    06B6
06A0:  XORLW  01
06A2:  BZ    06BE
06A4:  XORLW  22
06A6:  BZ    06F6
06A8:  BRA    0720
....................       case USB_DESC_DEVICE_TYPE:    //1
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN;
06AA:  CLRF   28
06AC:  MOVLW  12
06AE:  MOVWF  27
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE;
06B0:  MOVLW  03
06B2:  MOVWF  1D
....................             break;
06B4:  BRA    0724
.................... 
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually.
....................       case USB_DESC_CONFIG_TYPE:   //2
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN;
06B6:  CLRF   28
06B8:  MOVLW  43
06BA:  MOVWF  27
....................             break;
06BC:  BRA    0724
.................... 
....................       case USB_DESC_STRING_TYPE: //3
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE;
06BE:  MOVLW  02
06C0:  MOVWF  1D
....................             //usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]];
....................             for(i=0; i<usb_ep0_rx_buffer[2]; i++)
06C2:  MOVLB  2
06C4:  CLRF   x53
06C6:  MOVLB  4
06C8:  MOVF   x1A,W
06CA:  MOVLB  2
06CC:  SUBWF  x53,W
06CE:  BC    06E6
....................             {
....................                usb_getdesc_ptr += USB_STRING_DESC[usb_getdesc_ptr];
06D0:  MOVFF  26,03
06D4:  MOVF   25,W
06D6:  MOVLB  0
06D8:  RCALL  01EE
06DA:  ADDWF  25,F
06DC:  MOVLW  00
06DE:  ADDWFC 26,F
06E0:  MOVLB  2
06E2:  INCF   x53,F
06E4:  BRA    06C6
....................             }
....................             usb_getdesc_len = USB_STRING_DESC[usb_getdesc_ptr];
06E6:  MOVFF  26,03
06EA:  MOVF   25,W
06EC:  MOVLB  0
06EE:  RCALL  01EE
06F0:  MOVWF  27
06F2:  CLRF   28
....................             break;
06F4:  BRA    0724
.................... 
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06
....................       // this is needed so host can find out about differences about this
....................       // devices ability to handle full speed verses fast speed.
....................       // since we don't support fast speed then we ignore this.
....................       //      break;
.................... 
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case USB_DESC_CLASS_TYPE:  //0x21
....................             //TODO does this work for multiple interfaces or multiple languages?
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]];
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]];
06F6:  CLRF   03
06F8:  MOVLB  4
06FA:  MOVF   x1A,W
06FC:  MOVLB  0
06FE:  RCALL  01B4
0700:  MOVWF  25
0702:  CLRF   26
....................             if (usb_getdesc_ptr!=0xFF) {
0704:  INCFSZ 25,W
0706:  BRA    070C
0708:  MOVF   26,F
070A:  BZ    071C
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr];
070C:  MOVFF  26,03
0710:  MOVF   25,W
0712:  RCALL  014E
0714:  MOVWF  27
0716:  CLRF   28
....................                break;
0718:  BRA    0724
....................             }
071A:  BRA    0720
....................             else {
....................                usb_request_stall();
071C:  RCALL  05FC
....................                return;
071E:  BRA    0742
....................             }
.................... #endif
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_DESC_HIDREPORT_TYPE: //0x22
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]];
....................             if (usb_getdesc_ptr !=0xFF) {
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE;
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]];
....................                break;
....................             }
....................             else {
....................                usb_request_stall();
....................                return;
....................             }
.................... #endif
.................... 
....................       default:
....................             usb_request_stall();
0720:  RCALL  05FC
....................             return;
0722:  BRA    0742
....................    }
....................    if (usb_ep0_rx_buffer[7]==0) {
0724:  MOVLB  4
0726:  MOVF   x1F,F
0728:  BNZ   073A
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6])
072A:  MOVF   28,F
072C:  BNZ   0734
072E:  MOVF   27,W
0730:  SUBWF  x1E,W
0732:  BC    073A
....................          usb_getdesc_len = usb_ep0_rx_buffer[6];
0734:  CLRF   28
0736:  MOVFF  41E,27
....................    }
....................    USB_stack_status.dev_req=GET_DESCRIPTOR;
073A:  MOVLW  01
073C:  MOVWF  1A
....................    usb_copy_desc_seg_to_ep();
073E:  MOVLB  0
0740:  RCALL  0600
0742:  GOTO   09EA (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_finish_set_address()
.................... /*
.................... /* Input: USB_address_pending holds the address we were asked to set to.
.................... /*
.................... /* Summary: Sets the address.
.................... /*
.................... /* This code should only be run on the PIC USB peripheral, and not the
.................... /* National peripheral.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
....................  void usb_finish_set_address() {
....................    debug_usb_token(debug_putc," FSA ");
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0
*
10B4:  CLRF   1B
.................... 
....................    #ifdef __PIC__
....................    USB_stack_status.dev_req=NONE;  // no request pending
10B6:  CLRF   1A
....................    usb_set_address(USB_address_pending);
10B8:  MOVFF  24,254
10BC:  BRA    109A
....................    #endif
10BE:  GOTO   12D2 (RETURN)
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// The following function retrieve data from constant arrays.  This may
.................... /// look un-optimized, but remember that you can't create a pointer to
.................... /// a constant array.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... void usb_copy_desc_seg_to_ep(void) {
*
0600:  MOVLB  2
0602:  CLRF   x54
....................    unsigned int i=0;
....................    char c;
....................    
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]);
.................... 
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH))
0604:  MOVF   27,W
0606:  IORWF  28,W
0608:  BZ    0670
060A:  MOVF   x54,W
060C:  SUBLW  3F
060E:  BNC   0670
....................    {
....................       switch(USB_stack_status.getdesc_type) {
0610:  MOVF   1D,W
0612:  XORLW  00
0614:  MOVLB  0
0616:  BZ    0622
0618:  XORLW  02
061A:  BZ    0630
061C:  XORLW  01
061E:  BZ    063E
0620:  BRA    064A
....................          case USB_GETDESC_CONFIG_TYPE:
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr];
0622:  MOVFF  26,03
0626:  MOVF   25,W
0628:  RCALL  014E
062A:  MOVFF  FE8,255
....................             break;
062E:  BRA    064A
.................... 
....................         #IF USB_HID_DEVICE
....................          case USB_GETDESC_HIDREPORT_TYPE:
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr];
....................             break;
....................         #endif
.................... 
....................          case USB_GETDESC_STRING_TYPE:
....................             c=USB_STRING_DESC[usb_getdesc_ptr];
0630:  MOVFF  26,03
0634:  MOVF   25,W
0636:  RCALL  01EE
0638:  MOVFF  FE8,255
....................             break;
063C:  BRA    064A
.................... 
....................          case USB_GETDESC_DEVICE_TYPE:
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr];
063E:  MOVFF  26,03
0642:  MOVF   25,W
0644:  RCALL  01CC
0646:  MOVFF  FE8,255
....................             //debug_usb(debug_putc, "-%X- ", c);
....................             break;
....................       }
....................       usb_getdesc_ptr++;
064A:  INCF   25,F
064C:  BTFSC  FD8.2
064E:  INCF   26,F
....................       usb_getdesc_len--;
0650:  MOVF   27,W
0652:  BTFSC  FD8.2
0654:  DECF   28,F
0656:  DECF   27,F
....................       usb_ep0_tx_buffer[i++]=c;
0658:  MOVLB  2
065A:  MOVF   x54,W
065C:  INCF   x54,F
065E:  ADDLW  58
0660:  MOVWF  FE9
0662:  MOVLW  04
0664:  MOVWF  FEA
0666:  BTFSC  FD8.0
0668:  INCF   FEA,F
066A:  MOVFF  255,FEF
066E:  BRA    0604
....................    }
.................... 
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) {
0670:  MOVF   27,W
0672:  IORWF  28,W
0674:  BNZ   067E
0676:  MOVF   x54,W
0678:  SUBLW  40
067A:  BZ    067E
....................          USB_stack_status.dev_req = NONE;
067C:  CLRF   1A
....................    }
.................... 
....................    usb_request_send_response(i);
067E:  MOVFF  254,256
0682:  MOVLB  0
0684:  RCALL  05F6
0686:  RETURN 0
.................... }
.................... 
.................... #ENDIF
.................... 
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk
....................    transfer endpoints is not supported on slow speed devices per the USB
....................    specification.  You may be able to find unofficial drivers for your
....................    operating system that allows CDC to operate on a slow speed device,
....................    but CCS doesn't have any that they can recommend to you.
.................... */
.................... #if (USB_USE_FULL_SPEED==0)
....................    #error CDC and slow speed is not supported.  See comments above.
.................... #endif
.................... 
.................... struct {
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2)
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space)
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16)
.................... } __attribute__((__packed__)) usb_cdc_line_coding;
.................... 
.................... //length of time, in ms, of break signal as we received in a SendBreak message.
.................... //if ==0xFFFF, send break signal until we receive a 0x0000.
.................... unsigned int16 usb_cdc_break;
.................... 
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1];
.................... #else
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE];
.................... #endif
.................... 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT)
.................... #if sizeof(usb_cdc_put_buffer)>=0x100
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this.
....................  typedef unsigned int16 usb_cdc_tx_t;
.................... #else
....................  typedef unsigned int8 usb_cdc_tx_t;
.................... #endif
.................... 
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin;
.................... //#locate usb_cdc_put_buffer_nextin=0x1800
.................... 
.................... 
.................... #if defined(__PIC__)
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer
.................... #else
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE];
.................... #endif
.................... 
.................... int1 usb_cdc_got_set_line_coding;
.................... 
.................... struct  {
....................    int1 dte_present; //1=DTE present, 0=DTE not present
....................    int1 active;      //1=activate carrier, 0=deactivate carrier
....................    unsigned int reserved:6;
.................... } usb_cdc_carrier;
.................... 
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state;
.................... 
.................... /*
.................... #if defined(__PCH__)
....................  #byte INTCON=0xFF2
....................  #bit INT_GIE=INTCON.7
.................... #else
....................  #word SR=0x42
.................... #endif
.................... */
.................... 
.................... #if defined(USB_CDC_USE_ENCAPSULATED)
.................... unsigned int16 g_UsbCdcSendEncapsSize;
.................... #endif
.................... 
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data]
.................... void usb_isr_tok_out_cdc_control_dne(void) 
.................... {
....................    switch (__usb_cdc_state) {
*
0FC6:  MOVF   xB7,W
0FC8:  XORLW  01
0FCA:  BZ    0FD2
0FCC:  XORLW  03
0FCE:  BZ    0FE0
0FD0:  BRA    1008
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state);
....................       case USB_CDC_OUT_COMMAND:
....................         #if defined(USB_CDC_USE_ENCAPSULATED)
....................          usb_cdc_SendEncapsulatedCommand(usb_ep0_rx_buffer, g_UsbCdcSendEncapsSize);
....................         #endif
....................          usb_put_0len_0();
0FD2:  MOVLB  2
0FD4:  CLRF   x56
0FD6:  MOVLB  0
0FD8:  CALL   05F6
....................          __usb_cdc_state=0;
0FDC:  CLRF   xB7
....................          break;
0FDE:  BRA    100A
.................... 
....................     #if USB_MAX_EP0_PACKET_LENGTH==8
....................       case USB_CDC_WAIT_0LEN:
....................          usb_put_0len_0();
....................          __usb_cdc_state=0;
....................          break;
....................     #endif
.................... 
....................       case USB_CDC_OUT_LINECODING:
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7);
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n");
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7);
0FE0:  CLRF   FEA
0FE2:  MOVLW  2B
0FE4:  MOVWF  FE9
0FE6:  MOVLW  04
0FE8:  MOVWF  FE2
0FEA:  MOVLW  18
0FEC:  MOVWF  FE1
0FEE:  MOVLW  07
0FF0:  MOVWF  01
0FF2:  MOVFF  FE6,FEE
0FF6:  DECFSZ 01,F
0FF8:  BRA    0FF2
....................          __usb_cdc_state=0;
0FFA:  CLRF   xB7
....................          usb_put_0len_0();
0FFC:  MOVLB  2
0FFE:  CLRF   x56
1000:  MOVLB  0
1002:  CALL   05F6
....................          break;
1006:  BRA    100A
.................... 
....................       default:
....................          __usb_cdc_state=0;
1008:  CLRF   xB7
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................          break;
....................    }
100A:  GOTO   1086 (RETURN)
.................... }
.................... 
.................... //handle IN token on 0 (setup packet)
.................... void usb_isr_tkn_cdc(void) {
....................    unsigned int16 wLen;
....................    //make sure the request goes to a CDC interface
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) {
*
0C56:  MOVLB  4
0C58:  DECFSZ x1C,W
0C5A:  BRA    0C5E
0C5C:  BRA    0C62
0C5E:  MOVF   x1C,F
0C60:  BNZ   0CEC
....................       wLen = make16(usb_ep0_rx_buffer[7], usb_ep0_rx_buffer[6]);
0C62:  MOVFF  41F,254
0C66:  MOVFF  41E,253
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]);
....................       switch(usb_ep0_rx_buffer[1]) {
0C6A:  MOVF   x19,W
0C6C:  XORLW  00
0C6E:  MOVLB  0
0C70:  BZ    0C88
0C72:  XORLW  01
0C74:  BZ    0C90
0C76:  XORLW  21
0C78:  BZ    0C98
0C7A:  XORLW  01
0C7C:  BZ    0CA2
0C7E:  XORLW  03
0C80:  BZ    0CC8
0C82:  XORLW  01
0C84:  BZ    0CD6
0C86:  BRA    0CE8
....................          case 0x00:  //send_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             g_UsbCdcSendEncapsSize = wLen;
....................            #endif
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND;
0C88:  MOVLW  01
0C8A:  MOVWF  xB7
....................             usb_request_get_data();
0C8C:  RCALL  0C50
....................             break;
0C8E:  BRA    0CEA
.................... 
....................          case 0x01:  //get_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             usb_cdc_GetEncapsulatedResponse(usb_ep0_tx_buffer, wLen);
....................            #endif
....................             usb_request_send_response(wLen);
0C90:  MOVFF  253,256
0C94:  RCALL  05F6
....................             break;
0C96:  BRA    0CEA
.................... 
....................          case 0x20:  //set_line_coding
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING;
0C98:  MOVLW  02
0C9A:  MOVWF  xB7
....................             usb_cdc_got_set_line_coding=true;
0C9C:  BSF    xB5.0
....................             usb_request_get_data();
0C9E:  RCALL  0C50
....................             break;
0CA0:  BRA    0CEA
.................... 
....................          case 0x21:  //get_line_coding
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding));
0CA2:  MOVLW  04
0CA4:  MOVWF  FEA
0CA6:  MOVLW  58
0CA8:  MOVWF  FE9
0CAA:  CLRF   FE2
0CAC:  MOVLW  2B
0CAE:  MOVWF  FE1
0CB0:  MOVLW  07
0CB2:  MOVWF  01
0CB4:  MOVFF  FE6,FEE
0CB8:  DECFSZ 01,F
0CBA:  BRA    0CB4
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes
0CBC:  MOVLW  07
0CBE:  MOVLB  2
0CC0:  MOVWF  x56
0CC2:  MOVLB  0
0CC4:  RCALL  05F6
....................             break;
0CC6:  BRA    0CEA
.................... 
....................          case 0x22:  //set_control_line_state
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2];
0CC8:  MOVFF  41A,B6
....................             usb_put_0len_0();
0CCC:  MOVLB  2
0CCE:  CLRF   x56
0CD0:  MOVLB  0
0CD2:  RCALL  05F6
....................             break;
0CD4:  BRA    0CEA
.................... 
....................          case 0x23:  //send_break
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]);
0CD6:  MOVFF  41A,33
0CDA:  MOVFF  41B,32
....................             usb_put_0len_0();
0CDE:  MOVLB  2
0CE0:  CLRF   x56
0CE2:  MOVLB  0
0CE4:  RCALL  05F6
....................             break;
0CE6:  BRA    0CEA
.................... 
....................          default:
....................             usb_request_stall();
0CE8:  RCALL  05FC
....................             break;
0CEA:  MOVLB  4
....................       }
....................    }
0CEC:  MOVLB  0
0CEE:  GOTO   0D20 (RETURN)
.................... }
.................... 
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars]
.................... void usb_isr_tok_out_cdc_data_dne(void) {
....................    usb_cdc_get_buffer_status.got=true;
*
1060:  BSF    1E.0
....................    usb_cdc_get_buffer_status.index=0;
1062:  CLRF   20
.................... #if (defined(__PIC__) && __PIC__)
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT);
1064:  MOVLW  02
1066:  MOVLB  2
1068:  MOVWF  x54
106A:  MOVLB  0
106C:  BRA    100E
106E:  MOVFF  01,1F
.................... #else
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer(
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE);
.................... #endif
....................    if (!usb_cdc_get_buffer_status.len)
1072:  MOVF   1F,F
1074:  BNZ   1078
....................    {
....................       usb_cdc_get_discard();
1076:  BRA    104E
....................    }
1078:  GOTO   1094 (RETURN)
....................    /*
....................   #if defined(USB_CDC_ISR)
....................    else
....................    {
....................       USB_CDC_ISR();
....................    }
....................   #endif
....................   */
.................... }
.................... 
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters]
.................... void usb_isr_tok_in_cdc_data_dne(void) 
.................... {
....................    usb_cdc_flush_tx_buffer();
*
12AE:  RCALL  123C
12B0:  GOTO   12E0 (RETURN)
.................... }
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
*
1160:  MOVFF  259,25F
1164:  MOVFF  258,25E
....................    sc2=s2;
1168:  MOVFF  25B,261
116C:  MOVFF  25A,260
....................    if(sc2<sc1 && sc1 <sc2 +n)
1170:  MOVLB  2
1172:  MOVF   x61,W
1174:  SUBWF  x5F,W
1176:  BNC   11F0
1178:  BNZ   1180
117A:  MOVF   x5E,W
117C:  SUBWF  x60,W
117E:  BC    11F0
1180:  MOVF   x5C,W
1182:  ADDWF  x60,W
1184:  MOVWF  01
1186:  MOVF   x5D,W
1188:  ADDWFC x61,W
118A:  MOVWF  03
118C:  MOVF   x5F,W
118E:  SUBWF  03,W
1190:  BNC   11F0
1192:  BNZ   119A
1194:  MOVF   01,W
1196:  SUBWF  x5E,W
1198:  BC    11F0
....................       for(sc1+=n,sc2+=n;0<n;--n)
119A:  MOVF   x5C,W
119C:  ADDWF  x5E,F
119E:  MOVF   x5D,W
11A0:  ADDWFC x5F,F
11A2:  MOVF   x5C,W
11A4:  ADDWF  x60,F
11A6:  MOVF   x5D,W
11A8:  ADDWFC x61,F
11AA:  MOVF   x5D,F
11AC:  BNZ   11B4
11AE:  MOVF   x5C,W
11B0:  SUBLW  00
11B2:  BC    11EE
....................          *--sc1=*--sc2;
11B4:  MOVF   x5E,W
11B6:  BTFSC  FD8.2
11B8:  DECF   x5F,F
11BA:  DECF   x5E,F
11BC:  MOVFF  25F,263
11C0:  MOVFF  25E,262
11C4:  MOVF   x60,W
11C6:  BTFSC  FD8.2
11C8:  DECF   x61,F
11CA:  DECF   x60,F
11CC:  MOVFF  261,FEA
11D0:  MOVFF  260,FE9
11D4:  MOVFF  FEF,264
11D8:  MOVFF  25F,FEA
11DC:  MOVFF  25E,FE9
11E0:  MOVFF  264,FEF
11E4:  MOVF   x5C,W
11E6:  BTFSC  FD8.2
11E8:  DECF   x5D,F
11EA:  DECF   x5C,F
11EC:  BRA    11AA
11EE:  BRA    1230
....................    else
....................       for(;0<n;--n)
11F0:  MOVF   x5D,F
11F2:  BNZ   11FA
11F4:  MOVF   x5C,W
11F6:  SUBLW  00
11F8:  BC    1230
....................          *sc1++=*sc2++;
11FA:  MOVFF  25F,263
11FE:  MOVF   x5E,W
1200:  INCF   x5E,F
1202:  BTFSC  FD8.2
1204:  INCF   x5F,F
1206:  MOVWF  x62
1208:  MOVFF  261,FEA
120C:  MOVF   x60,W
120E:  INCF   x60,F
1210:  BTFSC  FD8.2
1212:  INCF   x61,F
1214:  MOVWF  FE9
1216:  MOVFF  FEF,264
121A:  MOVFF  263,FEA
121E:  MOVFF  262,FE9
1222:  MOVFF  264,FEF
1226:  MOVF   x5C,W
1228:  BTFSC  FD8.2
122A:  DECF   x5D,F
122C:  DECF   x5C,F
122E:  BRA    11F0
....................   return s1;
1230:  MOVFF  258,01
1234:  MOVFF  259,02
1238:  MOVLB  0
123A:  RETURN 0
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... void usb_cdc_flush_tx_buffer(void) 
.................... {
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE
....................    usb_cdc_tx_t n;
....................   #endif
....................   
....................    if (usb_cdc_put_buffer_nextin != 0)
123C:  MOVF   xB4,F
123E:  BZ    12AC
....................    {
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE))
....................       {
....................          usb_cdc_put_buffer_nextin = 0;
....................       }
....................      #else
....................       n = usb_cdc_put_buffer_nextin;
1240:  MOVFF  B4,254
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets
1244:  MOVLB  2
1246:  MOVF   x54,W
1248:  SUBLW  3F
124A:  BC    1250
....................          n = USB_CDC_DATA_IN_SIZE-1;
124C:  MOVLW  3F
124E:  MOVWF  x54
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE))
1250:  MOVLW  02
1252:  MOVWF  x55
1254:  CLRF   x57
1256:  MOVLW  34
1258:  MOVWF  x56
125A:  CLRF   x59
125C:  MOVFF  254,258
1260:  MOVLW  02
1262:  MOVWF  x5A
1264:  MOVLB  0
1266:  RCALL  10C2
1268:  MOVF   01,F
126A:  BZ    12AC
....................       {
....................          //pull the buffer back
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n);
126C:  CLRF   03
126E:  MOVLB  2
1270:  MOVF   x54,W
1272:  ADDLW  34
1274:  MOVWF  01
1276:  MOVLW  00
1278:  ADDWFC 03,F
127A:  MOVFF  01,255
127E:  MOVFF  03,256
1282:  MOVF   x54,W
1284:  MOVLB  0
1286:  SUBWF  xB4,W
1288:  MOVLB  2
128A:  MOVWF  x57
128C:  CLRF   x59
128E:  MOVLW  34
1290:  MOVWF  x58
1292:  MOVFF  03,25B
1296:  MOVFF  01,25A
129A:  CLRF   x5D
129C:  MOVFF  257,25C
12A0:  MOVLB  0
12A2:  RCALL  1160
....................          usb_cdc_put_buffer_nextin -= n;
12A4:  MOVLB  2
12A6:  MOVF   x54,W
12A8:  MOVLB  0
12AA:  SUBWF  xB4,F
....................       }      
....................      #endif
....................    }
12AC:  RETURN 0
.................... }
.................... 
.................... void usb_cdc_init(void) 
.................... {
....................    usb_cdc_line_coding.dwDTERrate = 9600;
*
0546:  MOVLB  2
0548:  CLRF   x55
054A:  CLRF   x54
054C:  MOVLW  25
054E:  MOVWF  x53
0550:  MOVLW  80
0552:  MOVWF  x52
0554:  MOVFF  252,2B
0558:  MOVFF  253,2C
055C:  CLRF   2D
055E:  CLRF   2E
....................    usb_cdc_line_coding.bCharFormat = 0;
0560:  CLRF   x52
0562:  MOVFF  252,2F
....................    usb_cdc_line_coding.bParityType = 0;
0566:  CLRF   x52
0568:  MOVFF  252,30
....................    usb_cdc_line_coding.bDataBits = 8;
056C:  MOVLW  08
056E:  MOVWF  x52
0570:  MOVFF  252,31
....................    (int8)usb_cdc_carrier = 0;
0574:  MOVLB  0
0576:  CLRF   xB6
....................    usb_cdc_got_set_line_coding = false;
0578:  BCF    xB5.0
....................    usb_cdc_break = 0;
057A:  CLRF   33
057C:  CLRF   32
....................    usb_cdc_put_buffer_nextin = 0;
057E:  CLRF   xB4
....................    usb_cdc_get_buffer_status.got = 0;
0580:  BCF    1E.0
....................    __usb_cdc_state = 0;
0582:  CLRF   xB7
0584:  RETURN 0
.................... }
.................... 
.................... ////////////////// END USB CONTROL HANDLING //////////////////////////////////
.................... 
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY /////////////////////////////
.................... 
.................... typedef struct
.................... {
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD.
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device.
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device. 
....................    unsigned int bFraming:1;   //A framing error has occurred.
....................    unsigned int bParity:1;    //A parity error has occurred.
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device.
....................    unsigned int reserved0:1;   //future use
....................    unsigned int reserved1:8;   //future use
.................... } cdc_serial_state_t;
.................... 
.................... /*
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring, 
....................    break signal and more (see cdc_serial_state_t).
....................    Some of these values are held by the host (meaning it's value only needs
....................    to be sent on change), but some values are one shot (meaning you continously
....................    need to send value to host while being held).
.................... */
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state)
.................... {
....................   #if __USB_PIC_PERIF__
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer
....................   #else
....................    unsigned int8 payload[10];
....................    #define CDC_EP1_NOTIFY_BUFFER payload
....................   #endif
.................... 
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT))
....................       return(false);
.................... 
....................    //bmRequestType
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001
....................    //bNotification
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE
....................    //wValue
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0;
....................    //wIndex
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0;
....................    //wLength
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t)
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0;
....................    //data
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state;
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8;
.................... 
....................   #if __USB_PIC_PERIF__
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE);
....................   #else
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE);
....................   #endif
....................    
....................    return(true);
.................... }
.................... 
.................... void usb_cdc_get_discard(void)
.................... {
....................    usb_cdc_get_buffer_status.got = false;
*
104E:  BCF    1E.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE);
1050:  MOVLW  02
1052:  MOVLB  2
1054:  MOVWF  x54
1056:  MOVWF  x55
1058:  MOVLB  0
105A:  RCALL  0D24
105C:  GOTO   1078 (RETURN)
.................... }
.................... 
.................... char usb_cdc_getc(void) 
.................... {
....................    char c;
.................... 
....................    while (!usb_cdc_kbhit()) 
....................    {
....................      #if defined(USB_ISR_POLLING)
....................       usb_task();
....................      #endif
....................    }
.................... 
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++];
.................... 
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len) 
....................    {
....................       usb_cdc_get_discard();
....................    }
.................... 
....................    return(c);
.................... }
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... #define __USB_PAUSE_ISR()
.................... #define __USB_RESTORE_ISR()
.................... #else
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1
.................... #endif
.................... 
.................... static void _usb_cdc_putc_fast_noflush(char c)
.................... {
....................    __USB_PAUSE_ISR();
*
1A7A:  MOVLB  2
1A7C:  BCF    x3B.0
1A7E:  BTFSC  FA0.5
1A80:  BSF    x3B.0
1A82:  BCF    FA0.5
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) 
1A84:  MOVLB  0
1A86:  MOVF   xB4,W
1A88:  SUBLW  7F
1A8A:  BC    1A9C
1A8C:  CLRF   19
1A8E:  BTFSC  FF2.7
1A90:  BSF    19.7
1A92:  BCF    FF2.7
....................    {
....................       usb_cdc_flush_tx_buffer();
1A94:  CALL   123C
1A98:  BTFSC  19.7
1A9A:  BSF    FF2.7
....................    }
....................   #endif
.................... 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) {
1A9C:  MOVF   xB4,W
1A9E:  SUBLW  7F
1AA0:  BC    1AA6
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer!
1AA2:  MOVLW  7F
1AA4:  MOVWF  xB4
....................    }
....................    
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c;
1AA6:  MOVF   xB4,W
1AA8:  INCF   xB4,F
1AAA:  CLRF   03
1AAC:  ADDLW  34
1AAE:  MOVWF  FE9
1AB0:  MOVLW  00
1AB2:  ADDWFC 03,W
1AB4:  MOVWF  FEA
1AB6:  MOVFF  23A,FEF
.................... 
....................    __USB_RESTORE_ISR();
1ABA:  MOVLB  2
1ABC:  BTFSS  x3B.0
1ABE:  BRA    1AC2
1AC0:  BSF    FA0.5
1AC2:  MOVLB  0
1AC4:  GOTO   1ACE (RETURN)
.................... }
.................... 
.................... void usb_cdc_putc_fast(char c)
.................... {
....................    _usb_cdc_putc_fast_noflush(c);
1AC8:  MOVFF  239,23A
1ACC:  BRA    1A7A
.................... 
....................   #if defined(USB_ISR_POLLING)
....................    // if interrupts are disabled, we should clear all activity isrs
....................    // before we attempt to put any data onto an endpoint.
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT))
....................       return;
....................    usb_task();
....................   #endif
....................   
....................   #if !defined(USB_CDC_DELAYED_FLUSH)
1ACE:  GOTO   1B0E (RETURN)
....................    //if (usb_cdc_put_buffer_free()) 
....................    {
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin);
....................       usb_cdc_flush_tx_buffer();
....................    }
....................   #endif
.................... 
....................    //putc('*');
.................... }
.................... 
.................... void usb_cdc_putc(char c)
.................... {
....................    while (!usb_cdc_putready()) 
1AD2:  MOVLW  80
1AD4:  BSF    FD8.0
1AD6:  SUBFWB xB4,W
1AD8:  BNZ   1B08
1ADA:  CLRF   19
1ADC:  BTFSC  FF2.7
1ADE:  BSF    19.7
1AE0:  BCF    FF2.7
....................    {
....................      #if 1
....................       if (usb_cdc_put_buffer_free()) 
1AE2:  MOVLW  02
1AE4:  MOVLB  2
1AE6:  MOVWF  x62
1AE8:  MOVLB  0
1AEA:  CALL   0E24
1AEE:  BTFSC  19.7
1AF0:  BSF    FF2.7
1AF2:  MOVF   01,F
1AF4:  BZ    1B06
1AF6:  CLRF   19
1AF8:  BTFSC  FF2.7
1AFA:  BSF    19.7
1AFC:  BCF    FF2.7
....................       {
....................          usb_cdc_flush_tx_buffer();
1AFE:  CALL   123C
1B02:  BTFSC  19.7
1B04:  BSF    FF2.7
....................       }
....................      #endif
.................... 
....................      #if defined(USB_ISR_POLLING)
1B06:  BRA    1AD2
....................       usb_task();
....................      #endif
....................    }
....................    usb_cdc_putc_fast(c);
1B08:  MOVFF  238,239
1B0C:  BRA    1AC8
1B0E:  GOTO   1B24 (RETURN)
.................... }
.................... 
.................... int1 usb_cdc_putd(char *ptr, unsigned int8 len)
.................... {
....................  #if USB_EP2_TX_SIZE>=0x100
....................    unsigned int16 i;
....................  #else
....................    unsigned int8 i;
....................  #endif
....................    char c;
....................    
....................    i = 0;
....................    
....................    if (!usb_cdc_put_buffer_free())
....................       return(false);
....................    
....................    while(len--)
....................    {
....................       c = *ptr++;
....................       _usb_cdc_putc_fast_noflush(c);
....................       if (++i >= USB_EP2_TX_SIZE)
....................          break;
....................    }
....................    
....................    usb_cdc_flush_tx_buffer();
....................    
....................    return(true);
.................... }
.................... 
.................... int1 usb_cdc_puts(char *ptr)
.................... {   
....................    unsigned int8 len;
.................... 
....................    len = strlen(ptr);
....................   
....................    return(usb_cdc_putd(ptr, len));
.................... }
.................... 
.................... #endif //__USB_CDC_HELPERS_ONLY__
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... char gethex1_usb() 
.................... {
....................    char digit;
.................... 
....................    digit = usb_cdc_getc();
.................... 
....................    usb_cdc_putc(digit);
.................... 
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((toupper(digit)-'A')+10);
.................... }
.................... 
.................... char gethex_usb() {
....................    unsigned int8 lo,hi;
.................... 
....................    hi = gethex1_usb();
....................    lo = gethex1_usb();
....................    if(lo==0xdd)
....................      return(hi);
....................    else
....................      return( hi*16+lo );
.................... }
.................... 
.................... void get_string_usb(char* s, unsigned int max) {
....................    unsigned int len;
....................    char c;
.................... 
....................    --max;
....................    len=0;
....................    do {
....................      c=usb_cdc_getc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           usb_cdc_putc(c);
....................           usb_cdc_putc(' ');
....................           usb_cdc_putc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<max) {
....................          s[len++]=c;
....................          usb_cdc_putc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... 
.................... 
.................... // stdlib.h is required for the ato_ conversions
.................... // in the following functions
.................... #ifdef _STDLIB
.................... 
.................... signed int get_int_usb() {
....................   char s[7];
....................   signed int i;
.................... 
....................   get_string_usb(s, 7);
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... 
.................... signed long get_long_usb() {
....................   char s[13];
....................   signed long l;
.................... 
....................   get_string_usb(s, 13);
....................   l=atol(s);
....................   return(l);
.................... }
.................... 
.................... float get_float_usb() {
....................   char s[20];
....................   float f;
.................... 
....................   get_string_usb(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... uint16_t globalMs;
.................... uint8_t globalSec;
.................... uint16_t globalMin;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #use spi (MASTER, SPI1, ENABLE=PIN_A5, BAUD=8000, MODE=0, BITS=8, STREAM=SPI_1)
.................... 
.................... #byte porta = 0xf80 // Identificador para el puerto A. 
.................... #byte portb = 0xf81 // Identificador para el puerto B. 
.................... #byte portc = 0xf82 // Identificador para el puerto C. 
.................... #byte portd = 0xf83 // Identificador para el puerto D. 
.................... #byte porte = 0xf84 // Identificador para el puerto E.
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlibm.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /*********************************************************************/
.................... #ifndef _STDLIBM
.................... #define _STDLIBM
.................... 
.................... /* Memory Management Functions*/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #if defined(__PCB__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int8 next; }node_t;
.................... #elif defined(__PCM__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCH__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCD__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #endif
.................... 
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY)
....................    #USE DYNAMIC_MEMORY
.................... #endif
.................... 
.................... #ifndef debug_stdlibm
....................    #define debug_stdlibm(s)
.................... #else
....................    #define __DO_DEBUG_STDLIBM
....................    
....................    char g_DebugStdlibmStr[50];
....................    
....................    #if defined(__PCD__)
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__))
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0))
....................       #else
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0))
....................       #endif
....................    #else
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM"))
....................    #endif
.................... #endif
.................... 
.................... #if defined(STDLIBM_TRACK_WORST_CASE)
....................    static size_t _g_StdlibmCurrentBytesUsed = 0;
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0;
....................    
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \
....................       _g_StdlibmCurrentBytesUsed += _x;   \
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed
....................    
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x
.................... #else
....................    #define _STDLIBM_TRACK_WORST_INC(_x)
....................    #define _STDLIBM_TRACK_WORST_DEC(_x)
.................... #endif
.................... 
.................... #include <memmgmt.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__PCH__)
....................  #define _MEMMGMT_CSIZE 32768
....................  #define _MEMMGMT_POS 15
.................... #elif defined(__PCD__)
....................    #define _MEMMGMT_CSIZE 32768
....................    #define _MEMMGMT_POS 15
.................... #else
....................    #define _MEMMGMT_CSIZE 127
....................    #define _MEMMGMT_POS 7
.................... #endif
.................... 
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location
.................... {
....................    node_t *result;
....................    result =ptr;
*
3062:  MOVFF  1ED,1EF
3066:  MOVFF  1EC,1EE
....................    result->size=size;
306A:  MOVLB  1
306C:  MOVFF  1EE,FE9
3070:  MOVFF  1EF,FEA
3074:  MOVFF  1EB,FEC
3078:  MOVF   FED,F
307A:  MOVFF  1EA,FEF
....................    result->next = NULL;
307E:  MOVLW  02
3080:  ADDWF  xEE,W
3082:  MOVWF  FE9
3084:  MOVLW  00
3086:  ADDWFC xEF,W
3088:  MOVWF  FEA
308A:  CLRF   FEC
308C:  MOVF   FED,F
308E:  CLRF   FEF
....................    return result;
3090:  MOVFF  1EE,01
3094:  MOVFF  1EF,02
3098:  MOVLB  0
309A:  GOTO   31EE (RETURN)
.................... }
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node
.................... {
....................    node->size=size;
*
3124:  MOVLB  1
3126:  MOVFF  1EB,FE9
312A:  MOVFF  1EC,FEA
312E:  MOVFF  1EE,FEC
3132:  MOVF   FED,F
3134:  MOVFF  1ED,FEF
3138:  MOVLB  0
313A:  RETURN 0
.................... }
.................... 
.................... /* Insert node immediately after place */ //old,new
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node
.................... {
....................     if (place->next==NULL)
*
309E:  MOVLW  02
30A0:  MOVLB  1
30A2:  ADDWF  xE6,W
30A4:  MOVWF  FE9
30A6:  MOVLW  00
30A8:  ADDWFC xE7,W
30AA:  MOVWF  FEA
30AC:  MOVFF  FEC,1EB
30B0:  MOVF   FED,F
30B2:  MOVFF  FEF,1EA
30B6:  MOVF   xEA,F
30B8:  BNZ   30D2
30BA:  MOVF   xEB,F
30BC:  BNZ   30D2
....................        node->next= NULL;
30BE:  MOVLW  02
30C0:  ADDWF  xE8,W
30C2:  MOVWF  FE9
30C4:  MOVLW  00
30C6:  ADDWFC xE9,W
30C8:  MOVWF  FEA
30CA:  CLRF   FEC
30CC:  MOVF   FED,F
30CE:  CLRF   FEF
30D0:  BRA    3108
....................     else
....................        node->next=place->next;
30D2:  MOVLW  02
30D4:  ADDWF  xE8,W
30D6:  MOVWF  01
30D8:  MOVLW  00
30DA:  ADDWFC xE9,W
30DC:  MOVWF  03
30DE:  MOVWF  xEB
30E0:  MOVLW  02
30E2:  ADDWF  xE6,W
30E4:  MOVWF  FE9
30E6:  MOVLW  00
30E8:  ADDWFC xE7,W
30EA:  MOVWF  FEA
30EC:  MOVFF  FEC,03
30F0:  MOVF   FED,F
30F2:  MOVFF  FEF,1EC
30F6:  MOVFF  1EB,FEA
30FA:  MOVFF  01,FE9
30FE:  MOVFF  03,FEC
3102:  MOVF   FED,F
3104:  MOVFF  1EC,FEF
....................     place->next=node;
3108:  MOVLW  02
310A:  ADDWF  xE6,W
310C:  MOVWF  FE9
310E:  MOVLW  00
3110:  ADDWFC xE7,W
3112:  MOVWF  FEA
3114:  MOVFF  1E9,FEC
3118:  MOVF   FED,F
311A:  MOVFF  1E8,FEF
311E:  MOVLB  0
3120:  GOTO   3208 (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void remove_node(node_t *node) {// remove the given node from the memlist
....................    node_t *ptr;
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next);
*
327E:  MOVFF  C0,1EE
3282:  MOVFF  BF,1ED
3286:  MOVLW  02
3288:  MOVLB  1
328A:  ADDWF  xED,W
328C:  MOVWF  FE9
328E:  MOVLW  00
3290:  ADDWFC xEE,W
3292:  MOVWF  FEA
3294:  MOVFF  FEC,1F0
3298:  MOVF   FED,F
329A:  MOVFF  FEF,1EF
329E:  MOVF   xEB,W
32A0:  SUBWF  xEF,W
32A2:  BNZ   32AA
32A4:  MOVF   xEC,W
32A6:  SUBWF  xF0,W
32A8:  BZ    32C6
32AA:  MOVLW  02
32AC:  ADDWF  xED,W
32AE:  MOVWF  FE9
32B0:  MOVLW  00
32B2:  ADDWFC xEE,W
32B4:  MOVWF  FEA
32B6:  MOVFF  FEC,1EE
32BA:  MOVF   FED,F
32BC:  MOVFF  FEF,1ED
32C0:  MOVLB  0
32C2:  BRA    3286
32C4:  MOVLB  1
....................    ptr->next=node->next;
32C6:  MOVLW  02
32C8:  ADDWF  xED,W
32CA:  MOVWF  01
32CC:  MOVLW  00
32CE:  ADDWFC xEE,W
32D0:  MOVWF  03
32D2:  MOVWF  xF0
32D4:  MOVLW  02
32D6:  ADDWF  xEB,W
32D8:  MOVWF  FE9
32DA:  MOVLW  00
32DC:  ADDWFC xEC,W
32DE:  MOVWF  FEA
32E0:  MOVFF  FEC,03
32E4:  MOVF   FED,F
32E6:  MOVFF  FEF,1F1
32EA:  MOVFF  1F0,FEA
32EE:  MOVFF  01,FE9
32F2:  MOVFF  03,FEC
32F6:  MOVF   FED,F
32F8:  MOVFF  1F1,FEF
....................    node=NULL;
32FC:  CLRF   xEC
32FE:  CLRF   xEB
3300:  MOVLB  0
3302:  GOTO   33C4 (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__DO_DEBUG_STDLIBM)
.................... void print_list() { // print the current memlist
....................     node_t *node;
....................     debug_stdlibm("\r\nThe list is \n\r");
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next)
....................     {
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next);
....................         debug_stdlibm(g_DebugStdlibmStr);
....................         if (INVALID_MEMORY_LOCATION(node->next))
....................         {
....................            debug_stdlibm("Breaking because of invalid next node\r\n");
....................            break;
....................         }   
....................     }
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t));
....................     debug_stdlibm(g_DebugStdlibmStr);
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void traverse()
.................... {
....................    node_t *node,*temp;
....................    unsigned int16 nsize,nextsize;
....................    node=__DYNAMIC_HEAD;
3306:  MOVFF  C0,1E4
330A:  MOVFF  BF,1E3
....................    while(node!=NULL)
330E:  MOVLB  1
3310:  MOVF   xE3,F
3312:  BNZ   331A
3314:  MOVF   xE4,F
3316:  BTFSC  FD8.2
3318:  BRA    3412
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          break;
....................       }   
....................      #endif
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free
331A:  MOVFF  1E3,FE9
331E:  MOVFF  1E4,FEA
3322:  MOVFF  FEC,1EC
3326:  MOVF   FED,F
3328:  MOVFF  FEF,1EB
332C:  BTFSC  xEC.7
332E:  BRA    33F6
....................       {
....................          nsize=node->size;
3330:  MOVFF  1E3,FE9
3334:  MOVFF  1E4,FEA
3338:  MOVFF  FEC,1E8
333C:  MOVF   FED,F
333E:  MOVFF  FEF,1E7
....................          temp=(unsigned int16)node->next;
3342:  MOVLW  02
3344:  ADDWF  xE3,W
3346:  MOVWF  FE9
3348:  MOVLW  00
334A:  ADDWFC xE4,W
334C:  MOVWF  FEA
334E:  MOVFF  FEC,1E6
3352:  MOVF   FED,F
3354:  MOVFF  FEF,1E5
....................         #if defined(__DO_DEBUG_STDLIBM)
....................          if (INVALID_MEMORY_LOCATION(temp))
....................          {
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node);
....................             debug_stdlibm(g_DebugStdlibmStr);
....................             break;
....................          }
....................         #endif
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine
3358:  MOVFF  1E5,FE9
335C:  MOVFF  1E6,FEA
3360:  MOVFF  FEC,1EC
3364:  MOVF   FED,F
3366:  MOVFF  FEF,1EB
336A:  BTFSC  xEC.7
336C:  BRA    33DA
336E:  MOVF   xE7,W
3370:  ADDWF  xE3,W
3372:  MOVWF  xED
3374:  MOVF   xE8,W
3376:  ADDWFC xE4,W
3378:  MOVWF  xEE
337A:  MOVLW  04
337C:  ADDWF  xED,W
337E:  MOVWF  01
3380:  MOVLW  00
3382:  ADDWFC xEE,W
3384:  MOVWF  03
3386:  MOVF   01,W
3388:  SUBWF  xE5,W
338A:  BNZ   33DA
338C:  MOVF   03,W
338E:  SUBWF  xE6,W
3390:  BNZ   33DA
....................          {
....................             nextsize=temp->size;
3392:  MOVFF  1E5,FE9
3396:  MOVFF  1E6,FEA
339A:  MOVFF  FEC,1EA
339E:  MOVF   FED,F
33A0:  MOVFF  FEF,1E9
....................             nsize+=nextsize+sizeof(node_t);
33A4:  MOVLW  04
33A6:  ADDWF  xE9,W
33A8:  MOVWF  01
33AA:  MOVLW  00
33AC:  ADDWFC xEA,W
33AE:  MOVWF  03
33B0:  MOVF   01,W
33B2:  ADDWF  xE7,F
33B4:  MOVF   03,W
33B6:  ADDWFC xE8,F
....................             remove_node(temp);
33B8:  MOVFF  1E6,1EC
33BC:  MOVFF  1E5,1EB
33C0:  MOVLB  0
33C2:  BRA    327E
....................             update_node(node,nsize);
33C4:  MOVFF  1E4,1EC
33C8:  MOVFF  1E3,1EB
33CC:  MOVFF  1E8,1EE
33D0:  MOVFF  1E7,1ED
33D4:  RCALL  3124
....................          }
33D6:  BRA    33F2
33D8:  MOVLB  1
....................          else
....................          node=node->next;
33DA:  MOVLW  02
33DC:  ADDWF  xE3,W
33DE:  MOVWF  FE9
33E0:  MOVLW  00
33E2:  ADDWFC xE4,W
33E4:  MOVWF  FEA
33E6:  MOVFF  FEC,1E4
33EA:  MOVF   FED,F
33EC:  MOVFF  FEF,1E3
33F0:  MOVLB  0
....................       }
33F2:  BRA    340E
33F4:  MOVLB  1
....................       else
....................       node=node->next;
33F6:  MOVLW  02
33F8:  ADDWF  xE3,W
33FA:  MOVWF  FE9
33FC:  MOVLW  00
33FE:  ADDWFC xE4,W
3400:  MOVWF  FEA
3402:  MOVFF  FEC,1E4
3406:  MOVF   FED,F
3408:  MOVFF  FEF,1E3
340C:  MOVLB  0
340E:  BRA    330E
3410:  MOVLB  1
....................    }
3412:  MOVLB  0
3414:  GOTO   348C (RETURN)
.................... }
.................... 
.................... char *malloc(size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize;
....................    #if defined(__PCD__)
....................    if (size % 2)
....................       size++;
....................    #endif
....................    node=__DYNAMIC_HEAD;
*
313C:  MOVFF  C0,1E1
3140:  MOVFF  BF,1E0
....................    
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
....................         
....................    while(node!=NULL) // chk until end of memlist
3144:  MOVLB  1
3146:  MOVF   xE0,F
3148:  BNZ   3150
314A:  MOVF   xE1,F
314C:  BTFSC  FD8.2
314E:  BRA    325A
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size
3150:  MOVFF  1E0,FE9
3154:  MOVFF  1E1,FEA
3158:  MOVFF  FEC,1E7
315C:  MOVF   FED,F
315E:  MOVFF  FEF,1E6
3162:  BTFSC  xE7.7
3164:  BRA    3242
3166:  MOVFF  1E0,FE9
316A:  MOVFF  1E1,FEA
316E:  MOVFF  FEC,1E9
3172:  MOVF   FED,F
3174:  MOVFF  FEF,1E8
3178:  MOVF   xDF,W
317A:  SUBWF  xE9,W
317C:  BNC   3242
317E:  BNZ   3186
3180:  MOVF   xDE,W
3182:  SUBWF  xE8,W
3184:  BNC   3242
....................       {
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at
3186:  MOVFF  1E0,FE9
318A:  MOVFF  1E1,FEA
318E:  MOVFF  FEC,1E5
3192:  MOVF   FED,F
3194:  MOVFF  FEF,1E4
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist
3198:  MOVLW  04
319A:  ADDWF  xDE,W
319C:  MOVWF  01
319E:  MOVLW  00
31A0:  ADDWFC xDF,W
31A2:  MOVWF  03
31A4:  MOVF   03,W
31A6:  SUBWF  xE5,W
31A8:  BNC   3226
31AA:  BNZ   31B2
31AC:  MOVF   xE4,W
31AE:  SUBWF  01,W
31B0:  BC    3226
....................          {
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
31B2:  MOVF   xDE,W
31B4:  SUBWF  xE4,W
31B6:  MOVWF  xE6
31B8:  MOVF   xDF,W
31BA:  SUBWFB xE5,W
31BC:  MOVWF  xE7
31BE:  MOVLW  04
31C0:  SUBWF  xE6,F
31C2:  MOVLW  00
31C4:  SUBWFB xE7,F
31C6:  MOVLW  04
31C8:  ADDWF  xE0,W
31CA:  MOVWF  xE8
31CC:  MOVLW  00
31CE:  ADDWFC xE1,W
31D0:  MOVWF  xE9
31D2:  MOVF   xDE,W
31D4:  ADDWF  xE8,F
31D6:  MOVF   xDF,W
31D8:  ADDWFC xE9,F
31DA:  MOVFF  1E7,1EB
31DE:  MOVFF  1E6,1EA
31E2:  MOVFF  1E9,1ED
31E6:  MOVFF  1E8,1EC
31EA:  MOVLB  0
31EC:  BRA    3062
31EE:  MOVFF  02,1E3
31F2:  MOVFF  01,1E2
....................             insert_node_after(node,new);
31F6:  MOVFF  1E1,1E7
31FA:  MOVFF  1E0,1E6
31FE:  MOVFF  1E3,1E9
3202:  MOVFF  1E2,1E8
3206:  BRA    309E
....................             update_node(node,size+_MEMMGMT_CSIZE);
3208:  MOVLB  1
320A:  MOVLW  80
320C:  ADDWF  xDF,W
320E:  MOVWF  xE7
3210:  MOVFF  1E1,1EC
3214:  MOVFF  1E0,1EB
3218:  MOVWF  xEE
321A:  MOVFF  1DE,1ED
321E:  MOVLB  0
3220:  RCALL  3124
....................          }
3222:  BRA    323E
3224:  MOVLB  1
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
3226:  MOVLW  80
3228:  ADDWF  xE5,W
322A:  MOVWF  xE7
322C:  MOVFF  1E1,1EC
3230:  MOVFF  1E0,1EB
3234:  MOVWF  xEE
3236:  MOVFF  1E4,1ED
323A:  MOVLB  0
323C:  RCALL  3124
....................          //end if
....................          break;
323E:  MOVLB  1
3240:  BRA    325A
....................       }//end if
....................       node=node->next;
3242:  MOVLW  02
3244:  ADDWF  xE0,W
3246:  MOVWF  FE9
3248:  MOVLW  00
324A:  ADDWFC xE1,W
324C:  MOVWF  FEA
324E:  MOVFF  FEC,1E1
3252:  MOVF   FED,F
3254:  MOVFF  FEF,1E0
3258:  BRA    3146
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
325A:  MOVF   xE0,F
325C:  BNZ   326C
325E:  MOVF   xE1,F
3260:  BNZ   326C
....................    {
....................       debug_stdlibm("Not enough memory for mallocation\r\n");
....................       return NULL;
3262:  MOVLW  00
3264:  MOVWF  01
3266:  MOVWF  02
3268:  BRA    327A
....................    }
326A:  BRA    327A
....................    else
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t));
....................       debug_stdlibm(g_DebugStdlibmStr);
....................      #endif
....................       _STDLIBM_TRACK_WORST_INC(size);
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space
326C:  MOVLW  04
326E:  ADDWF  xE0,W
3270:  MOVWF  01
3272:  MOVLW  00
3274:  ADDWFC xE1,W
3276:  MOVWF  03
3278:  MOVWF  02
....................    }
327A:  MOVLB  0
327C:  RETURN 0
.................... }
.................... 
.................... char *calloc(size_t nmemb,size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize,resize;
....................    node=__DYNAMIC_HEAD;
....................    resize=nmemb*size;
....................    #if defined(__PCD__)
....................    if(resize%2)
....................       resize++;
....................    #endif
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size
....................       {
....................          nsize=node->size;
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize);
....................             insert_node_after(node,new);
....................             update_node(node,resize+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for callocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0
....................       _STDLIBM_TRACK_WORST_INC(resize);
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space
....................    }
.................... }
.................... void free( void * ptr)
.................... {
....................    node_t *node;
....................    unsigned int16 nsize;
.................... 
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
.................... 
....................    if(ptr==NULL) // not a valid pounsigned int8er
*
3418:  MOVLB  1
341A:  MOVF   xDD,F
341C:  BNZ   3426
341E:  MOVF   xDE,F
3420:  BNZ   3426
....................       return;
3422:  BRA    348E
3424:  BRA    3488
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
3426:  MOVLW  04
3428:  SUBWF  xDD,W
342A:  MOVWF  xDF
342C:  MOVLW  00
342E:  SUBWFB xDE,W
3430:  MOVWF  xE0
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied
3432:  MOVFF  1DF,FE9
3436:  MOVFF  1E0,FEA
343A:  MOVFF  FEC,1E4
343E:  MOVF   FED,F
3440:  MOVFF  FEF,1E3
3444:  BTFSS  xE4.7
3446:  BRA    3482
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
3448:  MOVFF  1DF,FE9
344C:  MOVFF  1E0,FEA
3450:  MOVFF  FEC,1E4
3454:  MOVF   FED,F
3456:  MOVFF  FEF,1E3
345A:  MOVLW  00
345C:  SUBWF  xE3,W
345E:  MOVWF  xE1
3460:  MOVLW  80
3462:  SUBWFB xE4,W
3464:  MOVWF  xE2
....................          update_node(node,nsize);
3466:  MOVFF  1E0,1EC
346A:  MOVFF  1DF,1EB
346E:  MOVFF  1E2,1EE
3472:  MOVFF  1E1,1ED
3476:  MOVLB  0
3478:  RCALL  3124
....................          ptr=NULL;
347A:  MOVLB  1
347C:  CLRF   xDE
347E:  CLRF   xDD
....................          _STDLIBM_TRACK_WORST_DEC(nsize);
....................       }
3480:  BRA    3488
....................       else // wrong input, return
....................       {
....................          ptr=NULL;
3482:  CLRF   xDE
3484:  CLRF   xDD
....................          return;
3486:  BRA    348E
....................       }
....................    }
....................    traverse();
3488:  MOVLB  0
348A:  BRA    3306
348C:  MOVLB  1
348E:  MOVLB  0
3490:  RETURN 0
.................... }
.................... 
.................... char *realloc(void *ptr,size_t size)
.................... {
....................    node_t *node,*new,*temp;
....................    unsigned int16 nsize,nextsize;
....................    char *newptr;
....................    #if defined(__PCD__)
....................    if(size %2)
....................       size++;
....................    #endif
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory
....................       return(malloc(size));
....................    else if(size==0)
....................    {
....................       free(ptr);
....................       return(NULL);
....................    }
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          temp=(unsigned int16)node->next;
....................          if(nsize>size)// block > req size
....................          {
....................        
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   nextsize=temp->size;
....................                   remove_node(temp);
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t));
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else//not enough space for new node so use original size
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block
.................... 
....................          }
....................          else // block < req size
....................          {
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................             {
....................                nextsize=temp->size;
....................                if(nextsize>=size-nsize) // next block >=difference
....................                {
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist
....................                   {
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t));
....................                       insert_node_after(node,new);
....................                      _STDLIBM_TRACK_WORST_DEC(nsize);
....................                      _STDLIBM_TRACK_WORST_INC(size);
....................                   }
....................                   else//not enough space for new node in next node, so use original size
....................                   {
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                   }
....................                }
....................                else  //next block free but too small for new size
....................                {
....................                   newptr = malloc(size);  //use malloc to find new block
....................                   if(newptr == NULL)
....................                      return(NULL);        //return NULL if malloc was unable to find new block
....................                    
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                   free(ptr);                    //free original block
....................                   return(newptr);               //return new pointer
....................                }
....................             }
....................             else  //next block not free
....................             {
....................                newptr = malloc(size);  //use malloc to find new block
....................                if(newptr == NULL)      
....................                   return(NULL);        //return NULL if malloc was unable to find new block
....................                
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                free(ptr);                    //free original block
....................                return(newptr);               //return new pointer
....................             }
....................          }
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block
....................       }
....................       else // not allocated use malloc
....................       {
....................          return(malloc(size));
....................       }
....................    }
....................  }
....................  
.................... typedef struct
.................... {
....................    size_t bytesUsed;
....................    size_t largestUsedSeg;
....................    int segmentsUsed;
....................    size_t bytesFree;
....................    size_t largestFreeSeg;
....................    int segmentsFree;
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    size_t worstCaseBytesUsed;
....................   #endif
.................... } heap_status_t;
.................... 
.................... void GetHeapStatus(heap_status_t *pHeapStatus)
.................... {
....................    heap_status_t status;
....................    node_t *node;
....................    unsigned int16 nsize;
....................    
....................    node=__DYNAMIC_HEAD;
....................    
....................    memset(&status, 0, sizeof(status));
.................... 
....................    while(node!=NULL)
....................    {
....................       nsize = node->size;
....................       node = node->next;
....................       
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free
....................       {
....................          status.bytesFree += nsize;
....................          
....................          status.segmentsFree++;
....................          
....................          if (nsize > status.largestFreeSeg)
....................          {
....................             status.largestFreeSeg = nsize;
....................          }
....................       }
....................       else
....................       {
....................          bit_clear(nsize, _MEMMGMT_POS);
....................          
....................          status.bytesUsed += nsize;
....................          
....................          status.segmentsUsed++;
....................          
....................          if (nsize > status.largestUsedSeg)
....................          {
....................             status.largestUsedSeg = nsize;
....................          }
....................       }
....................    }
.................... 
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed;
....................   #endif
.................... 
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t));
.................... }
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include <adafruit_rfm69_registers.h>
.................... 
.................... //Internal constants:
.................... #define _REG_FIFO 0x00
.................... #define _REG_OP_MODE 0x01
.................... #define _REG_DATA_MOD 0x02
.................... #define _REG_BITRATE_MSB 0x03
.................... #define _REG_BITRATE_LSB 0x04
.................... #define _REG_FDEV_MSB 0x05
.................... #define _REG_FDEV_LSB 0x06
.................... #define _REG_FRF_MSB 0x07
.................... #define _REG_FRF_MID 0x08
.................... #define _REG_FRF_LSB 0x09
.................... #define _REG_VERSION 0x10
.................... #define _REG_PA_LEVEL 0x11
.................... #define _REG_RX_BW 0x19
.................... #define _REG_AFC_BW 0x1A
.................... #define _REG_RSSI_VALUE 0x24
.................... #define _REG_DIO_MAPPING1 0x25
.................... #define _REG_IRQ_FLAGS1 0x27
.................... #define _REG_IRQ_FLAGS2 0x28
.................... #define _REG_PREAMBLE_MSB 0x2C
.................... #define _REG_PREAMBLE_LSB 0x2D
.................... #define _REG_SYNC_CONFIG 0x2E
.................... #define _REG_SYNC_VALUE1 0x2F
.................... #define _REG_PACKET_CONFIG1 0x37
.................... #define _REG_FIFO_THRESH 0x3C
.................... #define _REG_PACKET_CONFIG2 0x3D
.................... #define _REG_AES_KEY1 0x3E
.................... #define _REG_TEMP1 0x4E
.................... #define _REG_TEMP2 0x4F
.................... #define _REG_TEST_PA1 0x5A
.................... #define _REG_TEST_PA2 0x5C
.................... #define _REG_TEST_DAGC 0x6F
.................... 
.................... #define _TEST_PA1_NORMAL 0x55
.................... #define _TEST_PA1_BOOST 0x5D
.................... #define _TEST_PA2_NORMAL 0x70
.................... #define _TEST_PA2_BOOST 0x7C
.................... 
.................... //The crystal oscillator frequency and frequency synthesizer step size.
.................... //See the datasheet for details of this calculation.
.................... 
.................... //        #define _FXOSC = 32000000.0
.................... //        #define _FSTEP = _FXOSC / 524288
.................... 
.................... //RadioHead specific compatibility constants.
.................... #define _RH_BROADCAST_ADDRESS 0xFF
.................... //The acknowledgement bit in the FLAGS
.................... //The top 4 bits of the flags are reserved for RadioHead. The lower 4 bits are reserved
.................... //for application layer use.
.................... #define _RH_FLAGS_ACK 0x80
.................... #define _RH_FLAGS_RETRY 0x40
.................... 
.................... //User facing constants:
.................... #define SLEEP_MODE 0b000
.................... #define STANDBY_MODE 0b001
.................... #define FS_MODE 0b010
.................... #define TX_MODE 0b011
.................... #define RX_MODE 0b100
.................... //supervisor.ticks_ms() contants
.................... //          #define _TICKS_PERIOD = const(1 << 29)
.................... //          #define _TICKS_MAX = const(_TICKS_PERIOD - 1)
.................... //          #define _TICKS_HALFPERIOD = const(_TICKS_PERIOD // 2)
.................... 
.................... #include <utils.h>
.................... //Global buffer for SPI commands
.................... uint8_t _BUFFER[4];
.................... 
.................... void setOutput(int pin, int value){
....................     output_bit(pin,value);
*
14EA:  MOVLB  2
14EC:  MOVF   x29,F
14EE:  BNZ   14F4
14F0:  MOVLW  00
14F2:  BRA    14F6
14F4:  MOVLW  01
14F6:  MOVFF  228,22A
14FA:  MOVWF  x2B
14FC:  MOVLW  0F
14FE:  MOVWF  x2D
1500:  MOVLW  89
1502:  MOVWF  x2C
1504:  MOVLB  0
1506:  RCALL  14A8
1508:  MOVFF  228,22A
150C:  MOVLB  2
150E:  CLRF   x2B
1510:  MOVLW  0F
1512:  MOVWF  x2D
1514:  MOVLW  92
1516:  MOVWF  x2C
1518:  MOVLB  0
151A:  RCALL  14A8
151C:  RETURN 0
.................... }
.................... void usbPrint(char* str){
....................       usb_task();  //Verifica la comunicacin USB
*
1B38:  RCALL  1582
....................       if(usb_enumerated()) {
1B3A:  RCALL  154E
1B3C:  MOVF   01,F
1B3E:  BZ    1B4A
....................          printf(usb_cdc_putc,str); 
1B40:  MOVFF  235,FEA
1B44:  MOVFF  234,FE9
1B48:  BRA    1B12
....................       }
1B4A:  RETURN 0
.................... }
.................... 
.................... void spiBegin(){
.................... //SPI.beginTransaction(SPISettings(SPIBAUD, MSBFIRST, SPI_MODE0));
.................... setOutput(SSPin, 0);
*
15F8:  MOVLW  05
15FA:  MOVLB  2
15FC:  MOVWF  x28
15FE:  CLRF   x29
1600:  MOVLB  0
1602:  RCALL  14EA
1604:  RETURN 0
.................... 
.................... }
.................... void spiEnd(){
.................... setOutput(SSPin, 1);    
*
162E:  MOVLW  05
1630:  MOVLB  2
1632:  MOVWF  x28
1634:  MOVLW  01
1636:  MOVWF  x29
1638:  MOVLB  0
163A:  RCALL  14EA
163C:  RETURN 0
.................... //SPI.endTransaction();
.................... }
.................... 
.................... void print(char* str){
....................     //Serial.print(str);
....................     usbPrint(str);
*
1C28:  MOVFF  221,235
1C2C:  MOVFF  220,234
1C30:  RCALL  1B38
1C32:  RETURN 0
.................... }
.................... 
.................... void print(int16 str, int format){
....................     char converted[11];
....................     int i;
....................     if (format == HEX) sprintf(converted,"0x%02X",str);
*
1EFE:  MOVLB  2
1F00:  MOVF   x27,W
1F02:  SUBLW  10
1F04:  BNZ   1F38
1F06:  MOVLW  02
1F08:  MOVLB  0
1F0A:  MOVWF  xC6
1F0C:  MOVLW  28
1F0E:  MOVWF  xC5
1F10:  MOVLW  30
1F12:  MOVLB  2
1F14:  MOVWF  x3D
1F16:  MOVLB  0
1F18:  RCALL  18AE
1F1A:  MOVLW  78
1F1C:  MOVLB  2
1F1E:  MOVWF  x3D
1F20:  MOVLB  0
1F22:  RCALL  18AE
1F24:  MOVFF  225,234
1F28:  MOVLW  37
1F2A:  MOVLB  2
1F2C:  MOVWF  x35
1F2E:  MOVLB  0
1F30:  BRA    1CEE
1F32:  MOVLB  0
1F34:  BRA    1FD0
1F36:  MOVLB  2
....................     else if (format == BIN){
1F38:  MOVF   x27,W
1F3A:  SUBLW  02
1F3C:  BNZ   1F90
....................     //Conversion manual
....................     converted[0] = '0';
1F3E:  MOVLW  30
1F40:  MOVWF  x28
....................     converted[1] = 'b';
1F42:  MOVLW  62
1F44:  MOVWF  x29
....................     for (i=0;i<8;i++){
1F46:  CLRF   x33
1F48:  MOVF   x33,W
1F4A:  SUBLW  07
1F4C:  BNC   1F8C
....................     converted[i+2] = ((str >> (7-i)) & 0x01) + '0';
1F4E:  MOVLW  02
1F50:  ADDWF  x33,W
1F52:  CLRF   03
1F54:  ADDLW  28
1F56:  MOVWF  FE9
1F58:  MOVLW  02
1F5A:  ADDWFC 03,W
1F5C:  MOVWF  FEA
1F5E:  MOVLW  07
1F60:  BSF    FD8.0
1F62:  SUBFWB x33,W
1F64:  MOVWF  00
1F66:  MOVFF  226,237
1F6A:  MOVFF  225,236
1F6E:  MOVF   00,F
1F70:  BZ    1F7C
1F72:  BCF    FD8.0
1F74:  RRCF   x37,F
1F76:  RRCF   x36,F
1F78:  DECFSZ 00,F
1F7A:  BRA    1F72
1F7C:  MOVLW  01
1F7E:  ANDWF  x36,F
1F80:  CLRF   x37
1F82:  MOVLW  30
1F84:  ADDWF  x36,W
1F86:  MOVWF  FEF
1F88:  INCF   x33,F
1F8A:  BRA    1F48
....................     }
....................     converted[10] = '\0';
1F8C:  CLRF   x32
....................     }
1F8E:  BRA    1FD2
....................     else if (format == DEC){
1F90:  MOVF   x27,W
1F92:  SUBLW  0A
1F94:  BNZ   1FB2
....................       sprintf(converted,"%Ld",str);
1F96:  MOVLW  02
1F98:  MOVLB  0
1F9A:  MOVWF  xC6
1F9C:  MOVLW  28
1F9E:  MOVWF  xC5
1FA0:  MOVLW  10
1FA2:  MOVWF  FE9
1FA4:  MOVFF  226,235
1FA8:  MOVFF  225,234
1FAC:  BRA    1D36
....................     }
1FAE:  BRA    1FD0
1FB0:  MOVLB  2
....................     else if (format == UDEC){
1FB2:  MOVF   x27,W
1FB4:  SUBLW  0B
1FB6:  BNZ   1FD2
....................       sprintf(converted,"%Lu",str);
1FB8:  MOVLW  02
1FBA:  MOVLB  0
1FBC:  MOVWF  xC6
1FBE:  MOVLW  28
1FC0:  MOVWF  xC5
1FC2:  MOVLW  10
1FC4:  MOVWF  FE9
1FC6:  MOVFF  226,235
1FCA:  MOVFF  225,234
1FCE:  BRA    1E36
1FD0:  MOVLB  2
....................     }
....................     usbPrint(converted);
1FD2:  MOVLW  02
1FD4:  MOVWF  x35
1FD6:  MOVLW  28
1FD8:  MOVWF  x34
1FDA:  MOVLB  0
1FDC:  RCALL  1B38
1FDE:  GOTO   1FF2 (RETURN)
....................     //Serial.print(str,format);
.................... }
.................... void println(char* str){
....................     usbPrint(str);
*
1BD6:  MOVFF  221,235
1BDA:  MOVFF  220,234
1BDE:  RCALL  1B38
....................     usbPrint((char*)"\n");
1BE0:  MOVLW  0A
1BE2:  MOVLB  2
1BE4:  MOVWF  x22
1BE6:  CLRF   x23
1BE8:  MOVLW  02
1BEA:  MOVWF  x35
1BEC:  MOVLW  22
1BEE:  MOVWF  x34
1BF0:  MOVLB  0
1BF2:  RCALL  1B38
1BF4:  RETURN 0
....................     //Serial.println(str);
.................... }
.................... void println(int str, int format){
....................     print(str,format);
*
1FE2:  MOVLB  2
1FE4:  CLRF   x26
1FE6:  MOVFF  220,225
1FEA:  MOVFF  221,227
1FEE:  MOVLB  0
1FF0:  BRA    1EFE
....................     usbPrint((char*)"\n");
1FF2:  MOVLW  0A
1FF4:  MOVLB  2
1FF6:  MOVWF  x22
1FF8:  CLRF   x23
1FFA:  MOVLW  02
1FFC:  MOVWF  x35
1FFE:  MOVLW  22
2000:  MOVWF  x34
2002:  MOVLB  0
2004:  RCALL  1B38
2006:  RETURN 0
....................     //Serial.println(str,format);
.................... }
.................... void print(float str){
....................  char converted[11];
....................  sprintf(converted,"%03f",str);
*
1B4C:  MOVLW  01
1B4E:  MOVWF  xC6
1B50:  MOVLW  98
1B52:  MOVWF  xC5
1B54:  MOVLW  C9
1B56:  MOVWF  FE9
1B58:  MOVFF  197,1A6
1B5C:  MOVFF  196,1A5
1B60:  MOVFF  195,1A4
1B64:  MOVFF  194,1A3
1B68:  MOVLW  06
1B6A:  MOVLB  1
1B6C:  MOVWF  xA7
1B6E:  MOVLB  0
1B70:  BRA    18CC
....................  usbPrint(converted);
1B72:  MOVLW  01
1B74:  MOVLB  2
1B76:  MOVWF  x35
1B78:  MOVLW  98
1B7A:  MOVWF  x34
1B7C:  MOVLB  0
1B7E:  RCALL  1B38
1B80:  GOTO   1BC0 (RETURN)
.................... }
.................... void println(float str){
....................     print(str);
....................     usbPrint((char*)"\n");
.................... }
.................... float timeSec(){
*
2DD2:  CLRF   19
2DD4:  BTFSC  FF2.7
2DD6:  BSF    19.7
2DD8:  BCF    FF2.7
....................    float t;
....................    t = (float)(60*globalMin);
2DDA:  MOVLB  2
2DDC:  CLRF   x64
2DDE:  MOVLW  3C
2DE0:  MOVWF  x63
2DE2:  MOVFF  BE,266
2DE6:  MOVFF  BD,265
2DEA:  MOVLB  0
2DEC:  CALL   0496
2DF0:  BTFSC  19.7
2DF2:  BSF    FF2.7
2DF4:  MOVFF  02,1E2
2DF8:  MOVFF  01,1E1
2DFC:  MOVLB  0
2DFE:  CALL   16AA
2E02:  MOVFF  03,1E0
2E06:  MOVFF  02,1DF
2E0A:  MOVFF  01,1DE
2E0E:  MOVFF  00,1DD
....................    t += (float)globalSec;
2E12:  MOVLB  1
2E14:  CLRF   xE2
2E16:  MOVFF  BC,1E1
2E1A:  MOVLB  0
2E1C:  CALL   16AA
2E20:  BCF    FD8.1
2E22:  MOVFF  1E0,1E6
2E26:  MOVFF  1DF,1E5
2E2A:  MOVFF  1DE,1E4
2E2E:  MOVFF  1DD,1E3
2E32:  MOVFF  03,1EA
2E36:  MOVFF  02,1E9
2E3A:  MOVFF  01,1E8
2E3E:  MOVFF  00,1E7
2E42:  CALL   2496
2E46:  MOVFF  03,1E0
2E4A:  MOVFF  02,1DF
2E4E:  MOVFF  01,1DE
2E52:  MOVFF  00,1DD
....................    t += (float)((float)globalMs*0.001);
2E56:  MOVFF  BB,1E2
2E5A:  MOVFF  BA,1E1
2E5E:  CALL   16AA
2E62:  MOVFF  03,1E4
2E66:  MOVFF  02,1E3
2E6A:  MOVFF  01,1E2
2E6E:  MOVFF  00,1E1
2E72:  MOVFF  03,1E8
2E76:  MOVFF  02,1E7
2E7A:  MOVFF  01,1E6
2E7E:  MOVFF  00,1E5
2E82:  MOVLW  6F
2E84:  MOVLB  1
2E86:  MOVWF  xEC
2E88:  MOVLW  12
2E8A:  MOVWF  xEB
2E8C:  MOVLW  03
2E8E:  MOVWF  xEA
2E90:  MOVLW  75
2E92:  MOVWF  xE9
2E94:  MOVLB  0
2E96:  CALL   16E0
2E9A:  BCF    FD8.1
2E9C:  MOVFF  1E0,1E6
2EA0:  MOVFF  1DF,1E5
2EA4:  MOVFF  1DE,1E4
2EA8:  MOVFF  1DD,1E3
2EAC:  MOVFF  03,1EA
2EB0:  MOVFF  02,1E9
2EB4:  MOVFF  01,1E8
2EB8:  MOVFF  00,1E7
2EBC:  CALL   2496
2EC0:  MOVFF  03,1E0
2EC4:  MOVFF  02,1DF
2EC8:  MOVFF  01,1DE
2ECC:  MOVFF  00,1DD
....................    //println(t);
....................    return t;
2ED0:  MOVFF  1DD,00
2ED4:  MOVFF  1DE,01
2ED8:  MOVFF  1DF,02
2EDC:  MOVFF  1E0,03
2EE0:  RETURN 0
.................... }
.................... void spi_read_into(uint8_t address,uint8_t* array, uint8_t length){
*
163E:  MOVLB  2
1640:  CLRF   x27
....................     int i=0;
....................     //Select
....................     spiBegin();
1642:  MOVLB  0
1644:  RCALL  15F8
....................     _BUFFER[0] = address & 0x7F; //Strip MSB byte to read
1646:  MOVLB  2
1648:  MOVF   x23,W
164A:  ANDLW  7F
164C:  MOVLB  0
164E:  MOVWF  xC1
....................     //Write address
....................     spi_write(_BUFFER[0]);
1650:  MOVF   FC9,W
1652:  MOVFF  C1,FC9
1656:  RRCF   FC7,W
1658:  BNC   1656
....................     delay_us(100);  // Tiempo para que el esclavo responda
165A:  MOVLW  64
165C:  MOVLB  2
165E:  MOVWF  x28
1660:  MOVLB  0
1662:  BRA    1606
....................     for (i=0;i<length;i++)
1664:  MOVLB  2
1666:  CLRF   x27
1668:  MOVF   x26,W
166A:  SUBWF  x27,W
166C:  BC    168A
....................         array[i] = spi_read(0xFF);
166E:  MOVF   x27,W
1670:  ADDWF  x24,W
1672:  MOVWF  FE9
1674:  MOVLW  00
1676:  ADDWFC x25,W
1678:  MOVWF  FEA
167A:  MOVF   FC9,W
167C:  SETF   FC9
167E:  RRCF   FC7,W
1680:  BNC   167E
1682:  MOVFF  FC9,FEF
1686:  INCF   x27,F
1688:  BRA    1668
....................     spiEnd();
168A:  MOVLB  0
168C:  RCALL  162E
168E:  RETURN 0
.................... 
.................... }
.................... void spi_write_from(uint8_t address,uint8_t* array, uint8_t length){
*
1C34:  MOVLB  2
1C36:  CLRF   x24
....................     int i=0;
....................     spiBegin();
1C38:  MOVLB  0
1C3A:  RCALL  15F8
....................     spi_write(address | 0b10000000);
1C3C:  MOVLB  2
1C3E:  MOVF   x20,W
1C40:  IORLW  80
1C42:  MOVWF  x25
1C44:  MOVF   FC9,W
1C46:  MOVFF  225,FC9
1C4A:  RRCF   FC7,W
1C4C:  BNC   1C4A
....................     //El address se aumenta en 1 automaticamente
....................    //Serial.println("Writing SPI");
....................     for (i=0;i<length;i++){
1C4E:  CLRF   x24
1C50:  MOVF   x23,W
1C52:  SUBWF  x24,W
1C54:  BC    1C74
....................       // Serial.println((char)array[i]);
....................       spi_write(array[i]);}
1C56:  MOVF   x24,W
1C58:  ADDWF  x21,W
1C5A:  MOVWF  FE9
1C5C:  MOVLW  00
1C5E:  ADDWFC x22,W
1C60:  MOVWF  FEA
1C62:  MOVFF  FEF,225
1C66:  MOVF   FC9,W
1C68:  MOVFF  225,FC9
1C6C:  RRCF   FC7,W
1C6E:  BNC   1C6C
1C70:  INCF   x24,F
1C72:  BRA    1C50
....................     spiEnd();    
1C74:  MOVLB  0
1C76:  RCALL  162E
1C78:  RETURN 0
.................... }
.................... uint8_t spi_read_u8(uint8_t address){
....................     spi_read_into(address,_BUFFER,1);
*
1690:  MOVFF  222,223
1694:  MOVLB  2
1696:  CLRF   x25
1698:  MOVLW  C1
169A:  MOVWF  x24
169C:  MOVLW  01
169E:  MOVWF  x26
16A0:  MOVLB  0
16A2:  RCALL  163E
....................     return _BUFFER[0];
16A4:  MOVFF  C1,01
16A8:  RETURN 0
.................... }
.................... uint8_t spi_write_u8(uint8_t address,uint8_t val){
....................     _BUFFER[0] = val;
*
1C7A:  MOVFF  21F,C1
....................     spi_write_from(address,_BUFFER,1);
1C7E:  MOVFF  21E,220
1C82:  MOVLB  2
1C84:  CLRF   x22
1C86:  MOVLW  C1
1C88:  MOVWF  x21
1C8A:  MOVLW  01
1C8C:  MOVWF  x23
1C8E:  MOVLB  0
1C90:  RCALL  1C34
....................     return _BUFFER[0];
1C92:  MOVFF  C1,01
1C96:  RETURN 0
.................... }
.................... void sleep_ms(int ms){
....................     delay_ms(ms);
*
15F0:  MOVFF  1B8,21E
15F4:  RCALL  15C6
15F6:  RETURN 0
.................... }
.................... 
.................... #include <afadruit_rfm69.h>
.................... 
.................... // # The crystal oscillator frequency and frequency synthesizer step size.
.................... // # See the datasheet for details of this calculation.
.................... const float _FXOSC = 32000000.0;
.................... const float _FSTEP = _FXOSC / 524288;
.................... 
.................... void readAllRegs();
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL);
.................... void reset();
.................... void set_boost(uint8_t setting);
.................... void idle();
.................... void rfm_sleep();
.................... void listen();
.................... void transmit();
.................... float temperature_get();
.................... uint8_t operation_mode_get();
.................... void operation_mode_set(uint8_t val);
.................... uint8_t* sync_word_get();
.................... void sync_word_set(uint8_t* wrd);
.................... uint16_t preamble_length_get();
.................... void preamble_length_set(uint16_t val);
.................... float frequency_mhz_get();
.................... void frequency_mhz_set();
.................... uint8_t* encryption_key_get();
.................... void encryption_key_set(uint8_t* val);
.................... int8_t tx_power_get();
.................... void tx_power_set(int8_t val);
.................... float rssi_get();
.................... float bitrate_get();
.................... void bitrate_set(float val);
.................... float frequency_deviation_get();
.................... void frequency_deviation_set(float val);
.................... bool packet_sent();
.................... bool payload_ready();
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256);
.................... bool send_with_ack(uint8_t* data,uint8_t len);
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false);
.................... 
.................... struct _RegisterBits{
.................... uint8_t address;
.................... uint8_t mask;
.................... uint8_t offset;
.................... };
.................... 
.................... void set(uint8_t val,struct _RegisterBits obj){
*
2216:  MOVFF  1DE,222
221A:  CALL   1690
221E:  MOVFF  01,1E1
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         regVal &= ~obj.mask;
2222:  MOVLB  1
2224:  MOVF   xDF,W
2226:  XORLW  FF
2228:  ANDWF  xE1,F
....................         regVal |= (val & 0xFF) << obj.offset;
222A:  MOVFF  1DD,00
222E:  MOVF   xE0,W
2230:  MOVWF  01
2232:  BZ    223C
2234:  BCF    FD8.0
2236:  RLCF   00,F
2238:  DECFSZ 01,F
223A:  BRA    2234
223C:  MOVF   00,W
223E:  IORWF  xE1,F
....................         spi_write_u8(obj.address,regVal);
2240:  MOVFF  1DE,21E
2244:  MOVFF  1E1,21F
2248:  MOVLB  0
224A:  RCALL  1C7A
224C:  RETURN 0
.................... }
.................... uint8_t get(struct _RegisterBits obj){
*
1CC6:  MOVFF  21E,222
1CCA:  RCALL  1690
1CCC:  MOVFF  01,221
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         return ((regVal & obj.mask) >> obj.offset);
1CD0:  MOVLB  2
1CD2:  MOVF   x21,W
1CD4:  ANDWF  x1F,W
1CD6:  MOVWF  00
1CD8:  MOVF   x20,W
1CDA:  MOVWF  01
1CDC:  BZ    1CE6
1CDE:  BCF    FD8.0
1CE0:  RRCF   00,F
1CE2:  DECFSZ 01,F
1CE4:  BRA    1CDE
1CE6:  MOVF   00,W
1CE8:  MOVWF  01
1CEA:  MOVLB  0
1CEC:  RETURN 0
....................     }
.................... uint8_t _debug_(struct _RegisterBits obj){
....................       print ((char*)"Mask: ");
....................       println(obj.mask,BIN);
....................       return obj.mask; 
.................... }
.................... 
.................... struct _RegisterBits _RegisterBits_(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
*
146A:  MOVLB  1
146C:  CLRF   x92
.................... 
....................         uint8_t i=0;
....................         struct _RegisterBits ret;
....................         ret.mask=0;
146E:  CLRF   x94
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         ret.address = _address;
1470:  MOVFF  18F,193
....................         for (i=0;i<bits;i++){
1474:  CLRF   x92
1476:  MOVF   x91,W
1478:  SUBWF  x92,W
147A:  BC    1486
....................             ret.mask<<=1;
147C:  BCF    FD8.0
147E:  RLCF   x94,F
....................             ret.mask|=1;
1480:  BSF    x94.0
1482:  INCF   x92,F
1484:  BRA    1476
....................         }
....................         ret.mask <<= _offset;
1486:  MOVF   x90,W
1488:  MOVWF  01
148A:  BZ    1494
148C:  BCF    FD8.0
148E:  RLCF   x94,F
1490:  DECFSZ 01,F
1492:  BRA    148C
....................         ret.offset = _offset;
1494:  MOVFF  190,195
....................         return ret;
1498:  MOVFF  193,01
149C:  MOVFF  194,02
14A0:  MOVFF  195,03
14A4:  MOVLB  0
14A6:  RETURN 0
....................  }
....................  
.................... /*
.................... class _RegisterBits{
....................     public:
....................     uint8_t address;
....................     uint8_t mask;
....................     uint8_t offset;
....................     _RegisterBits(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
....................         uint8_t i=0;
....................         mask=0;
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         address = _address;
....................         for (i=0;i<bits;i++){
....................             mask<<=1;
....................             mask|=1;
....................         }
....................         mask <<= _offset;
....................         offset = _offset;
....................         }
....................     void set(uint8_t val){
....................         uint8_t regVal = spi_read_u8(address);
....................         regVal &= ~mask;
....................         regVal |= (val & 0xFF) << offset;
....................         spi_write_u8(address,regVal);
....................     }
....................     uint8_t get(){
....................         uint8_t regVal = spi_read_u8(address);
....................         return ((regVal & mask) >> offset);
....................     }
....................    
....................   
....................     }
.................... };
.................... */
.................... 
....................     
.................... //Configuraciones que solo utilizan ciertos bits   
.................... struct _RegisterBits data_mode = _RegisterBits_(_REG_DATA_MOD, 5, 2);
.................... struct _RegisterBits modulation_type = _RegisterBits_(_REG_DATA_MOD, 3, 2);
.................... struct _RegisterBits modulation_shaping = _RegisterBits_(_REG_DATA_MOD, 0, 2);
.................... struct _RegisterBits temp_start = _RegisterBits_(_REG_TEMP1, 3);
.................... struct _RegisterBits temp_running = _RegisterBits_(_REG_TEMP1, 2);
.................... struct _RegisterBits sync_on = _RegisterBits_(_REG_SYNC_CONFIG, 7);
.................... struct _RegisterBits sync_size = _RegisterBits_(_REG_SYNC_CONFIG, 3, 3);
.................... struct _RegisterBits aes_on = _RegisterBits_(_REG_PACKET_CONFIG2, 0);
.................... struct _RegisterBits pa_0_on = _RegisterBits_(_REG_PA_LEVEL, 7);
.................... struct _RegisterBits pa_1_on = _RegisterBits_(_REG_PA_LEVEL, 6);
.................... struct _RegisterBits pa_2_on = _RegisterBits_(_REG_PA_LEVEL, 5);
.................... struct _RegisterBits output_power = _RegisterBits_(_REG_PA_LEVEL, 0, 5);
.................... struct _RegisterBits rx_bw_dcc_freq = _RegisterBits_(_REG_RX_BW, 5, 3);
.................... struct _RegisterBits rx_bw_mantissa = _RegisterBits_(_REG_RX_BW, 3, 2);
.................... struct _RegisterBits rx_bw_exponent = _RegisterBits_(_REG_RX_BW, 0, 3);
.................... struct _RegisterBits afc_bw_dcc_freq = _RegisterBits_(_REG_AFC_BW, 5, 3);
.................... struct _RegisterBits afc_bw_mantissa = _RegisterBits_(_REG_AFC_BW, 3, 2);
.................... struct _RegisterBits afc_bw_exponent = _RegisterBits_(_REG_AFC_BW, 0, 3);
.................... struct _RegisterBits packet_format = _RegisterBits_(_REG_PACKET_CONFIG1, 7, 1);
.................... struct _RegisterBits dc_free = _RegisterBits_(_REG_PACKET_CONFIG1, 5, 2);
.................... struct _RegisterBits crc_on = _RegisterBits_(_REG_PACKET_CONFIG1, 4, 1);
.................... struct _RegisterBits crc_auto_clear_off = _RegisterBits_(_REG_PACKET_CONFIG1, 3, 1);
.................... struct _RegisterBits address_filter = _RegisterBits_(_REG_PACKET_CONFIG1, 1, 2);
.................... struct _RegisterBits mode_ready = _RegisterBits_(_REG_IRQ_FLAGS1, 7);
.................... struct _RegisterBits dio_0_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 6, 2);
.................... struct _RegisterBits dio_1_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 4, 2);
.................... struct _RegisterBits dio_2_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 2, 2);
.................... struct _RegisterBits dio_3_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 0, 2);
.................... struct _RegisterBits dio_4_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 6, 2);
.................... struct _RegisterBits dio_5_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 4, 2);
.................... 
.................... //Extras
.................... int8_t _tx_power;
.................... int8_t tx_power;
.................... bool high_power;
.................... uint8_t* sync_word;
.................... uint16_t preamble_length;
.................... uint32_t frequency_mhz;
.................... float bitrate;
.................... float rssi;
.................... float last_rssi;
.................... float ack_wait;
.................... float receive_timeout;
.................... float xmit_timeout;
.................... uint8_t ack_retries;
.................... float ack_delay;
.................... uint8_t sequence_number;
.................... uint8_t seen_ids[8];
.................... uint8_t node;
.................... uint8_t destination;
.................... uint8_t identifier;
.................... uint8_t flags;
.................... uint8_t operation_mode;
.................... float temperature;
.................... uint8_t encryption_key[16];
.................... float frequency_deviation;
.................... int _reset_pin;
.................... 
.................... 
.................... void readAllRegs()
.................... {
....................   uint8_t regVal;
....................   
....................   println((char*)"Address - HEX - BIN");
....................   for (uint8_t regAddr = 1; regAddr <= 0x4F; regAddr++)
....................   {
....................     /*
....................     spiBegin();
....................     SPI.transfer(regAddr & 0x7F); // send address + r/w bit
....................     regVal = SPI.transfer(0);
....................     spiEnd();*/
....................     regVal = spi_read_u8(regAddr);
....................     print(regAddr, HEX);
....................     print((char*)" - ");
....................     print(regVal,HEX);
....................     print((char*)" - ");
....................     println(regVal,BIN);
....................   }
....................   spiEnd();
.................... }    
.................... 
.................... bool checkId(){
.................... uint8_t version;
.................... version = spi_read_u8(_REG_VERSION);
*
1B84:  MOVLW  10
1B86:  MOVLB  2
1B88:  MOVWF  x22
1B8A:  MOVLB  0
1B8C:  RCALL  1690
1B8E:  MOVFF  01,18F
.................... print(version);
1B92:  MOVLB  1
1B94:  CLRF   xE2
1B96:  MOVFF  18F,1E1
1B9A:  MOVLB  0
1B9C:  RCALL  16AA
1B9E:  MOVFF  03,193
1BA2:  MOVFF  02,192
1BA6:  MOVFF  01,191
1BAA:  MOVFF  00,190
1BAE:  MOVFF  03,197
1BB2:  MOVFF  02,196
1BB6:  MOVFF  01,195
1BBA:  MOVFF  00,194
1BBE:  BRA    1B4C
.................... return version==0x24;
1BC0:  MOVLB  1
1BC2:  MOVF   x8F,W
1BC4:  SUBLW  24
1BC6:  BZ    1BCC
1BC8:  MOVLW  00
1BCA:  BRA    1BCE
1BCC:  MOVLW  01
1BCE:  MOVWF  01
1BD0:  MOVLB  0
1BD2:  GOTO   403E (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL){
*
2942:  MOVLB  1
2944:  CLRF   x9A
....................     uint8_t version=0;
....................     println((char*)"Initial conf starts");
2946:  MOVLW  01
2948:  MOVWF  FEA
294A:  MOVLW  9B
294C:  MOVWF  FE9
294E:  MOVLW  14
2950:  MOVWF  01
2952:  CLRF   FF7
2954:  MOVLW  00
2956:  MOVLB  0
2958:  CALL   022A
295C:  TBLRD*-
295E:  TBLRD*+
2960:  MOVFF  FF5,FEE
2964:  DECFSZ 01,F
2966:  BRA    295E
2968:  MOVLW  01
296A:  MOVLB  2
296C:  MOVWF  x21
296E:  MOVLW  9B
2970:  MOVWF  x20
2972:  MOVLB  0
2974:  CALL   1BD6
....................     //Serial.println("HOLA 2");
....................     _tx_power = 13;
2978:  MOVLW  0D
297A:  MOVLB  1
297C:  MOVWF  x21
....................     _reset_pin = resetPin;
297E:  MOVFF  191,16E
....................     high_power = _high_power;
2982:  MOVLB  0
2984:  BCF    xB5.1
2986:  MOVLB  1
2988:  BTFSS  x93.0
298A:  BRA    2992
298C:  MOVLB  0
298E:  BSF    xB5.1
2990:  MOVLB  1
....................     reset();
2992:  MOVLB  0
2994:  GOTO   1BF6
....................     //readAllRegs();
....................     
....................     version = spi_read_u8(_REG_VERSION);
2998:  MOVLW  10
299A:  MOVLB  2
299C:  MOVWF  x22
299E:  MOVLB  0
29A0:  CALL   1690
29A4:  MOVFF  01,19A
....................     if (version != 0x24){
29A8:  MOVLB  1
29AA:  MOVF   x9A,W
29AC:  SUBLW  24
29AE:  BZ    2A1A
....................         println((char*)"Error: ID del RFM incorrecta");
29B0:  MOVLW  01
29B2:  MOVWF  FEA
29B4:  MOVLW  9B
29B6:  MOVWF  FE9
29B8:  MOVLW  1D
29BA:  MOVWF  01
29BC:  CLRF   FF7
29BE:  MOVLW  00
29C0:  MOVLB  0
29C2:  CALL   024E
29C6:  TBLRD*-
29C8:  TBLRD*+
29CA:  MOVFF  FF5,FEE
29CE:  DECFSZ 01,F
29D0:  BRA    29C8
29D2:  MOVLW  01
29D4:  MOVLB  2
29D6:  MOVWF  x21
29D8:  MOVLW  9B
29DA:  MOVWF  x20
29DC:  MOVLB  0
29DE:  CALL   1BD6
....................         while(1){
....................         println((char*)"ID Loop");
29E2:  MOVLW  01
29E4:  MOVWF  FEA
29E6:  MOVLW  9B
29E8:  MOVWF  FE9
29EA:  MOVLW  08
29EC:  MOVWF  01
29EE:  CLRF   FF7
29F0:  MOVLW  00
29F2:  CALL   027C
29F6:  TBLRD*-
29F8:  TBLRD*+
29FA:  MOVFF  FF5,FEE
29FE:  DECFSZ 01,F
2A00:  BRA    29F8
2A02:  MOVLW  01
2A04:  MOVLB  2
2A06:  MOVWF  x21
2A08:  MOVLW  9B
2A0A:  MOVWF  x20
2A0C:  MOVLB  0
2A0E:  CALL   1BD6
....................         usb_task();
2A12:  CALL   1582
2A16:  BRA    29E2
2A18:  MOVLB  1
....................         }
....................         //exit(-1);
....................     }
....................     print((char*)"Idle");
2A1A:  MOVLW  49
2A1C:  MOVWF  x9B
2A1E:  MOVLW  64
2A20:  MOVWF  x9C
2A22:  MOVLW  6C
2A24:  MOVWF  x9D
2A26:  MOVLW  65
2A28:  MOVWF  x9E
2A2A:  CLRF   x9F
2A2C:  MOVLW  01
2A2E:  MOVLB  2
2A30:  MOVWF  x21
2A32:  MOVLW  9B
2A34:  MOVWF  x20
2A36:  MOVLB  0
2A38:  CALL   1C28
....................     idle();
2A3C:  CALL   2200
....................     println((char*)"Ready");
2A40:  MOVLW  52
2A42:  MOVLB  1
2A44:  MOVWF  x9B
2A46:  MOVLW  65
2A48:  MOVWF  x9C
2A4A:  MOVLW  61
2A4C:  MOVWF  x9D
2A4E:  MOVLW  64
2A50:  MOVWF  x9E
2A52:  MOVLW  79
2A54:  MOVWF  x9F
2A56:  CLRF   xA0
2A58:  MOVLW  01
2A5A:  MOVLB  2
2A5C:  MOVWF  x21
2A5E:  MOVLW  9B
2A60:  MOVWF  x20
2A62:  MOVLB  0
2A64:  CALL   1BD6
....................     //Chip setup
....................     //Set FIFO TX condition to not empty and the default FIFO threshold to 15.
....................     spi_write_u8(_REG_FIFO_THRESH, 0b10001111);
2A68:  MOVLW  3C
2A6A:  MOVLB  2
2A6C:  MOVWF  x1E
2A6E:  MOVLW  8F
2A70:  MOVWF  x1F
2A72:  MOVLB  0
2A74:  CALL   1C7A
....................     //Configure low beta off.
....................     spi_write_u8(_REG_TEST_DAGC, 0x30);
2A78:  MOVLW  6F
2A7A:  MOVLB  2
2A7C:  MOVWF  x1E
2A7E:  MOVLW  30
2A80:  MOVWF  x1F
2A82:  MOVLB  0
2A84:  CALL   1C7A
....................     //Disable boost.
....................     spi_write_u8(_REG_TEST_PA1, _TEST_PA1_NORMAL);
2A88:  MOVLW  5A
2A8A:  MOVLB  2
2A8C:  MOVWF  x1E
2A8E:  MOVLW  55
2A90:  MOVWF  x1F
2A92:  MOVLB  0
2A94:  CALL   1C7A
....................     spi_write_u8(_REG_TEST_PA2, _TEST_PA2_NORMAL);
2A98:  MOVLW  5C
2A9A:  MOVLB  2
2A9C:  MOVWF  x1E
2A9E:  MOVLW  70
2AA0:  MOVWF  x1F
2AA2:  MOVLB  0
2AA4:  CALL   1C7A
....................     //set sync word
....................     //IMPORTANTE: Recuerda alocar el espacio para que no se sobreescriba
....................     print((char*)"Freq");
2AA8:  MOVLW  46
2AAA:  MOVLB  1
2AAC:  MOVWF  x9B
2AAE:  MOVLW  72
2AB0:  MOVWF  x9C
2AB2:  MOVLW  65
2AB4:  MOVWF  x9D
2AB6:  MOVLW  71
2AB8:  MOVWF  x9E
2ABA:  CLRF   x9F
2ABC:  MOVLW  01
2ABE:  MOVLB  2
2AC0:  MOVWF  x21
2AC2:  MOVLW  9B
2AC4:  MOVWF  x20
2AC6:  MOVLB  0
2AC8:  CALL   1C28
....................     sync_word_set( _sync_word); 
2ACC:  MOVFF  190,1B9
2AD0:  MOVFF  18F,1B8
2AD4:  GOTO   224E
....................     preamble_length_set(_preamble_length);
2AD8:  MOVLB  1
2ADA:  CLRF   xB9
2ADC:  MOVFF  192,1B8
2AE0:  MOVLB  0
2AE2:  GOTO   22D4
....................     frequency_mhz_set(); 
2AE6:  BRA    22FE
....................     println((char*)"Ready");
2AE8:  MOVLW  52
2AEA:  MOVLB  1
2AEC:  MOVWF  x9B
2AEE:  MOVLW  65
2AF0:  MOVWF  x9C
2AF2:  MOVLW  61
2AF4:  MOVWF  x9D
2AF6:  MOVLW  64
2AF8:  MOVWF  x9E
2AFA:  MOVLW  79
2AFC:  MOVWF  x9F
2AFE:  CLRF   xA0
2B00:  MOVLW  01
2B02:  MOVLB  2
2B04:  MOVWF  x21
2B06:  MOVLW  9B
2B08:  MOVWF  x20
2B0A:  MOVLB  0
2B0C:  CALL   1BD6
....................     //TODO: set encryption key
....................     //encryption_key = encrypt;
....................     //encryption_key_set(encrypt);
....................     
....................     //PARA USUARIOS AVANZADOS ----------------------------------------------------------------------------------------------
....................     // Configure modulation for RadioHead library GFSK_Rb250Fd250 mode
....................     // by default.  Users with advanced knowledge can manually reconfigure
....................     // for any other mode (consulting the datasheet is absolutely
....................     // necessary!).
....................     bitrate_set(250000);  // 250kbs
2B10:  MOVLB  1
2B12:  CLRF   xBB
2B14:  MOVLW  24
2B16:  MOVWF  xBA
2B18:  MOVLW  74
2B1A:  MOVWF  xB9
2B1C:  MOVLW  90
2B1E:  MOVWF  xB8
2B20:  MOVLB  0
2B22:  BRA    274A
....................     frequency_deviation_set(250000);  // 250khz
2B24:  MOVLB  1
2B26:  CLRF   xBB
2B28:  MOVLW  24
2B2A:  MOVWF  xBA
2B2C:  MOVLW  74
2B2E:  MOVWF  xB9
2B30:  MOVLW  90
2B32:  MOVWF  xB8
2B34:  MOVLB  0
2B36:  BRA    27EC
....................     set(0b01,modulation_shaping);  // Gaussian filter, BT=1.0
2B38:  MOVLW  01
2B3A:  MOVLB  1
2B3C:  MOVWF  xDD
2B3E:  MOVFF  CF,1E0
2B42:  MOVFF  CE,1DF
2B46:  MOVFF  CD,1DE
2B4A:  MOVLB  0
2B4C:  CALL   2216
....................     set(0b111,rx_bw_dcc_freq);  // RxBw register = 0xE0
2B50:  MOVLW  07
2B52:  MOVLB  1
2B54:  MOVWF  xDD
2B56:  MOVFF  ED,1E0
2B5A:  MOVFF  EC,1DF
2B5E:  MOVFF  EB,1DE
2B62:  MOVLB  0
2B64:  CALL   2216
....................     set(0b00,rx_bw_mantissa);
2B68:  MOVLB  1
2B6A:  CLRF   xDD
2B6C:  MOVFF  F0,1E0
2B70:  MOVFF  EF,1DF
2B74:  MOVFF  EE,1DE
2B78:  MOVLB  0
2B7A:  CALL   2216
....................     set(0b000,rx_bw_exponent);
2B7E:  MOVLB  1
2B80:  CLRF   xDD
2B82:  MOVFF  F3,1E0
2B86:  MOVFF  F2,1DF
2B8A:  MOVFF  F1,1DE
2B8E:  MOVLB  0
2B90:  CALL   2216
....................     set(0b111,afc_bw_dcc_freq); // AfcBw register = 0xE0
2B94:  MOVLW  07
2B96:  MOVLB  1
2B98:  MOVWF  xDD
2B9A:  MOVFF  F6,1E0
2B9E:  MOVFF  F5,1DF
2BA2:  MOVFF  F4,1DE
2BA6:  MOVLB  0
2BA8:  CALL   2216
....................     set(0b00,afc_bw_mantissa);
2BAC:  MOVLB  1
2BAE:  CLRF   xDD
2BB0:  MOVFF  F9,1E0
2BB4:  MOVFF  F8,1DF
2BB8:  MOVFF  F7,1DE
2BBC:  MOVLB  0
2BBE:  CALL   2216
....................     set(0b000,afc_bw_exponent);
2BC2:  MOVLB  1
2BC4:  CLRF   xDD
2BC6:  MOVFF  FC,1E0
2BCA:  MOVFF  FB,1DF
2BCE:  MOVFF  FA,1DE
2BD2:  MOVLB  0
2BD4:  CALL   2216
....................     set(1,packet_format);  // Variable length.
2BD8:  MOVLW  01
2BDA:  MOVLB  1
2BDC:  MOVWF  xDD
2BDE:  MOVFF  FF,1E0
2BE2:  MOVFF  FE,1DF
2BE6:  MOVFF  FD,1DE
2BEA:  MOVLB  0
2BEC:  CALL   2216
....................     set(0b10,dc_free);  // Whitening
2BF0:  MOVLW  02
2BF2:  MOVLB  1
2BF4:  MOVWF  xDD
2BF6:  MOVFF  102,1E0
2BFA:  MOVFF  101,1DF
2BFE:  MOVFF  100,1DE
2C02:  MOVLB  0
2C04:  CALL   2216
....................     //-----------------------------------------------------------------------------------------------------------------------
....................     // Set transmit power to 13 dBm, a safe value any module supports.
....................     tx_power_set(13);
2C08:  MOVLW  0D
2C0A:  MOVLB  1
2C0C:  MOVWF  xB8
2C0E:  MOVLB  0
2C10:  BRA    288E
....................     //
....................     // initialize last RSSI reading
....................     last_rssi = 0.0;
2C12:  MOVLB  1
2C14:  CLRF   x36
2C16:  CLRF   x35
2C18:  CLRF   x34
2C1A:  CLRF   x33
....................     // """The RSSI of the last received packet. Stored when the packet was received.
....................     //    This instantaneous RSSI value may not be accurate once the
....................     //    operating mode has been changed.
....................     // """
....................     // initialize timeouts and delays delays
....................     ack_wait = 0.5;
2C1C:  CLRF   x3A
2C1E:  CLRF   x39
2C20:  CLRF   x38
2C22:  MOVLW  7E
2C24:  MOVWF  x37
....................     // """The delay time before attempting a retry after not receiving an ACK"""
....................     receive_timeout = 0.5;
2C26:  CLRF   x3E
2C28:  CLRF   x3D
2C2A:  CLRF   x3C
2C2C:  MOVWF  x3B
....................     // """The amount of time to poll for a received packet.
....................     //    If no packet is received, the returned packet will be None
....................     // """
....................     xmit_timeout = 2.0;
2C2E:  CLRF   x42
2C30:  CLRF   x41
2C32:  CLRF   x40
2C34:  MOVLW  80
2C36:  MOVWF  x3F
....................     // """The amount of time to wait for the HW to transmit the packet.
....................     //    This is mainly used to prevent a hang due to a HW issue
....................     // """
....................     ack_retries = 5;
2C38:  MOVLW  05
2C3A:  MOVWF  x43
....................     // """The number of ACK retries before reporting a failure."""
....................     ack_delay = 0;
2C3C:  CLRF   x47
2C3E:  CLRF   x46
2C40:  CLRF   x45
2C42:  CLRF   x44
....................     // """The delay time before attemting to send an ACK.
....................     //    If ACKs are being missed try setting this to .1 or .2.
....................     // """
....................     //print("<------------------------------------------------------------------------------------------------------------------------------------------>")
....................     // initialize sequence number counter for reliabe datagram mode
....................     sequence_number = 0;
2C44:  CLRF   x48
....................     // create seen Ids list
....................     //seen_ids = {0};
....................     // initialize packet header
....................     // node address - default is broadcast
....................     node = _RH_BROADCAST_ADDRESS;
2C46:  SETF   x51
....................     // """The default address of this Node. (0-255).
....................     //    If not 255 (0xff) then only packets address to this node will be accepted.
....................     //    First byte of the RadioHead header.
....................     // """
....................     // destination address - default is broadcast
....................     destination = _RH_BROADCAST_ADDRESS;
2C48:  SETF   x52
....................     // """The default destination address for packet transmissions. (0-255).
....................     //    If 255 (0xff) then any receiving node should accept the packet.
....................     //    Second byte of the RadioHead header.
....................     // """
....................     // ID - contains seq count for reliable datagram mode
....................     identifier = 0;
2C4A:  CLRF   x53
....................     // """Automatically set to the sequence number when send_with_ack() used.
....................     //    Third byte of the RadioHead header.
....................     // """
....................     // flags - identifies ack/reetry packet for reliable datagram mode
....................     flags = 0;
2C4C:  CLRF   x54
....................     // """Upper 4 bits reserved for use by Reliable Datagram Mode.
....................     //    Lower 4 bits may be used to pass information.
....................     //    Fourth byte of the RadioHead header.
....................     // """
....................     //Extras: paara algunos registros que no coinciden con la libreria del micropython
....................     // RSSI_CONFIG: 0x2
....................     spi_write_u8(0x23,0x02);
2C4E:  MOVLW  23
2C50:  MOVLB  2
2C52:  MOVWF  x1E
2C54:  MOVLW  02
2C56:  MOVWF  x1F
2C58:  MOVLB  0
2C5A:  CALL   1C7A
....................     //_REG_DIO_MAPPING1
....................     spi_write_u8(_REG_DIO_MAPPING1,0x00);
2C5E:  MOVLW  25
2C60:  MOVLB  2
2C62:  MOVWF  x1E
2C64:  CLRF   x1F
2C66:  MOVLB  0
2C68:  CALL   1C7A
....................     //101  FXOSC / 32
....................     spi_write_u8(_REG_DIO_MAPPING1+1,0b101);
2C6C:  MOVLW  26
2C6E:  MOVLB  2
2C70:  MOVWF  x1E
2C72:  MOVLW  05
2C74:  MOVWF  x1F
2C76:  MOVLB  0
2C78:  CALL   1C7A
....................     //RSSI_THRESH
....................     spi_write_u8(0x29,0xFF);
2C7C:  MOVLW  29
2C7E:  MOVLB  2
2C80:  MOVWF  x1E
2C82:  SETF   x1F
2C84:  MOVLB  0
2C86:  CALL   1C7A
....................     //INIT payload length to 0
....................     spi_write_u8(0x38,0x40);
2C8A:  MOVLW  38
2C8C:  MOVLB  2
2C8E:  MOVWF  x1E
2C90:  MOVLW  40
2C92:  MOVWF  x1F
2C94:  MOVLB  0
2C96:  CALL   1C7A
....................     //AutoRxRestartOn
....................     spi_write_u8(_REG_PACKET_CONFIG2,0x02);
2C9A:  MOVLW  3D
2C9C:  MOVLB  2
2C9E:  MOVWF  x1E
2CA0:  MOVLW  02
2CA2:  MOVWF  x1F
2CA4:  MOVLB  0
2CA6:  CALL   1C7A
....................     //Con esto se puede colocar un LED en DIO2 y ver los datos que se reciben y se envian
....................     set(0b01,dio_2_mapping);
2CAA:  MOVLW  01
2CAC:  MOVLB  1
2CAE:  MOVWF  xDD
2CB0:  MOVFF  117,1E0
2CB4:  MOVFF  116,1DF
2CB8:  MOVFF  115,1DE
2CBC:  MOVLB  0
2CBE:  CALL   2216
....................     //Asi se puede saber si el buffer FIFO tiene algun dato
....................     set(0b10,dio_1_mapping);
2CC2:  MOVLW  02
2CC4:  MOVLB  1
2CC6:  MOVWF  xDD
2CC8:  MOVFF  114,1E0
2CCC:  MOVFF  113,1DF
2CD0:  MOVFF  112,1DE
2CD4:  MOVLB  0
2CD6:  CALL   2216
....................     //En modo rx, da informacion acerca del RSSI (Recieved Signal Strength Indicator)
....................     set(0b01,dio_3_mapping);
2CDA:  MOVLW  01
2CDC:  MOVLB  1
2CDE:  MOVWF  xDD
2CE0:  MOVFF  11A,1E0
2CE4:  MOVFF  119,1DF
2CE8:  MOVFF  118,1DE
2CEC:  MOVLB  0
2CEE:  CALL   2216
....................     print((char*)"Initial configuration end\n");
2CF2:  MOVLW  01
2CF4:  MOVWF  FEA
2CF6:  MOVLW  9B
2CF8:  MOVWF  FE9
2CFA:  MOVLW  1B
2CFC:  MOVWF  01
2CFE:  CLRF   FF7
2D00:  MOVLW  00
2D02:  CALL   0294
2D06:  TBLRD*-
2D08:  TBLRD*+
2D0A:  MOVFF  FF5,FEE
2D0E:  DECFSZ 01,F
2D10:  BRA    2D08
2D12:  MOVLW  01
2D14:  MOVLB  2
2D16:  MOVWF  x21
2D18:  MOVLW  9B
2D1A:  MOVWF  x20
2D1C:  MOVLB  0
2D1E:  CALL   1C28
2D22:  GOTO   40B6 (RETURN)
.................... }
.................... void reset(){
....................     setOutput(_reset_pin,1);
*
1BF6:  MOVFF  16E,228
1BFA:  MOVLW  01
1BFC:  MOVLB  2
1BFE:  MOVWF  x29
1C00:  MOVLB  0
1C02:  RCALL  14EA
....................     sleep_ms(1);
1C04:  MOVLW  01
1C06:  MOVLB  1
1C08:  MOVWF  xB8
1C0A:  MOVLB  0
1C0C:  RCALL  15F0
....................     setOutput(_reset_pin,0);
1C0E:  MOVFF  16E,228
1C12:  MOVLB  2
1C14:  CLRF   x29
1C16:  MOVLB  0
1C18:  RCALL  14EA
....................     sleep_ms(5);
1C1A:  MOVLW  05
1C1C:  MOVLB  1
1C1E:  MOVWF  xB8
1C20:  MOVLB  0
1C22:  RCALL  15F0
1C24:  GOTO   2998 (RETURN)
.................... }
.................... void set_boost(uint8_t setting){
....................     //Set preamp boost if needed.
....................     if (_tx_power >= 18){
*
1C98:  MOVLB  1
1C9A:  BTFSC  x21.7
1C9C:  BRA    1CC2
1C9E:  MOVF   x21,W
1CA0:  SUBLW  11
1CA2:  BC    1CC2
....................         spi_write_u8(_REG_TEST_PA1, setting);
1CA4:  MOVLW  5A
1CA6:  MOVLB  2
1CA8:  MOVWF  x1E
1CAA:  MOVFF  1DD,21F
1CAE:  MOVLB  0
1CB0:  RCALL  1C7A
....................         spi_write_u8(_REG_TEST_PA2, setting);
1CB2:  MOVLW  5C
1CB4:  MOVLB  2
1CB6:  MOVWF  x1E
1CB8:  MOVFF  1DD,21F
1CBC:  MOVLB  0
1CBE:  RCALL  1C7A
1CC0:  MOVLB  1
....................     }
1CC2:  MOVLB  0
1CC4:  RETURN 0
.................... }
.................... void idle(){
....................     //Enter idle standby mode (switching off high power amplifiers if necessary).
....................     //Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
*
2200:  MOVLW  55
2202:  MOVLB  1
2204:  MOVWF  xDD
2206:  MOVLB  0
2208:  RCALL  1C98
....................     operation_mode_set(STANDBY_MODE);
220A:  MOVLW  01
220C:  MOVLB  1
220E:  MOVWF  xDD
2210:  MOVLB  0
2212:  RCALL  2008
2214:  RETURN 0
....................            
.................... }
.................... void rfm_sleep(){
....................     operation_mode_set(SLEEP_MODE); 
.................... }
.................... void listen(){
....................     //Listen for packets to be received by the chip.  Use :py:func:`receive` to listen, wait
....................     //and retrieve packets as they're available.
....................     
....................     // Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
*
2DA0:  MOVLW  55
2DA2:  MOVLB  1
2DA4:  MOVWF  xDD
2DA6:  MOVLB  0
2DA8:  CALL   1C98
....................     // Enable payload ready interrupt for D0 line.
....................     set(0b01,dio_0_mapping);
2DAC:  MOVLW  01
2DAE:  MOVLB  1
2DB0:  MOVWF  xDD
2DB2:  MOVFF  111,1E0
2DB6:  MOVFF  110,1DF
2DBA:  MOVFF  10F,1DE
2DBE:  MOVLB  0
2DC0:  CALL   2216
....................     // Enter RX mode (will clear FIFO!).
....................           
....................     operation_mode_set(RX_MODE); 
2DC4:  MOVLW  04
2DC6:  MOVLB  1
2DC8:  MOVWF  xDD
2DCA:  MOVLB  0
2DCC:  CALL   2008
2DD0:  RETURN 0
.................... }
.................... void transmit(){
....................     // Transmit a packet which is queued in the FIFO.  This is a low level function for
....................     // entering transmit mode and more.  For generating and transmitting a packet of data use
....................     // :py:func:`send` instead.
....................     
....................     // # Like RadioHead library, turn on high power boost if enabled.
....................     set_boost(_TEST_PA1_BOOST);
*
3492:  MOVLW  5D
3494:  MOVLB  1
3496:  MOVWF  xDD
3498:  MOVLB  0
349A:  CALL   1C98
....................     // # Enable packet sent interrupt for D0 line.
....................     set(0b00,dio_0_mapping);
349E:  MOVLB  1
34A0:  CLRF   xDD
34A2:  MOVFF  111,1E0
34A6:  MOVFF  110,1DF
34AA:  MOVFF  10F,1DE
34AE:  MOVLB  0
34B0:  CALL   2216
....................     //readAllRegs(); 
....................     // # Enter TX mode (will clear FIFO!).
....................     operation_mode_set(TX_MODE);  
34B4:  MOVLW  03
34B6:  MOVLB  1
34B8:  MOVWF  xDD
34BA:  MOVLB  0
34BC:  CALL   2008
34C0:  GOTO   3672 (RETURN)
.................... }
.................... // .. warning:: Reading this will STOP any receiving/sending that might be happening!
.................... //WARNING:LOOP infinito
.................... float temperature_get(){
....................     // The internal temperature of the chip in degrees Celsius. Be warned this is not
....................     // calibrated or very accurate.
....................     // .. warning:: Reading this will STOP any receiving/sending that might be happening!
....................     // # Start a measurement then poll the measurement finished bit.
....................     set(1,temp_start);
....................     //WARNING:LOOP infinito
....................     while (get(temp_running) > 0){
....................     usb_task();
....................     
....................     }
....................     temperature = 166.0 - (float)spi_read_u8(_REG_TEMP2);
....................     return temperature;
.................... }
.................... uint8_t operation_mode_get(){
....................     // """The operation mode value.  Unless you're manually controlling the chip you shouldn't
....................     // change the operation_mode with this property as other side-effects are required for
....................     // changing logical modes--use :py:func:`idle`, :py:func:`sleep`, :py:func:`transmit`,
....................     // :py:func:`listen` instead to signal intent for explicit logical modes.
....................     // """
....................     operation_mode = (spi_read_u8(_REG_OP_MODE) >> 2) &0b111;
....................     return operation_mode;
.................... }
.................... void operation_mode_set(uint8_t val){
....................     //float start;
....................     uint16_t n;
....................     //TODO: assert 0 <= val <= 4
....................     n=0;
*
2008:  MOVLB  1
200A:  CLRF   xDF
200C:  CLRF   xDE
....................     
....................     while (!get(mode_ready)){
200E:  MOVFF  10E,220
2012:  MOVFF  10D,21F
2016:  MOVFF  10C,21E
201A:  MOVLB  0
201C:  RCALL  1CC6
201E:  MOVF   01,F
2020:  BNZ   20D8
....................       delay_ms(100);
2022:  MOVLW  64
2024:  MOVLB  2
2026:  MOVWF  x1E
2028:  MOVLB  0
202A:  CALL   15C6
....................       n+=100;
202E:  MOVLW  64
2030:  MOVLB  1
2032:  ADDWF  xDE,F
2034:  MOVLW  00
2036:  ADDWFC xDF,F
....................       usb_task();
2038:  MOVLB  0
203A:  CALL   1582
....................       println((char*)"OP Loop 1");
203E:  MOVLW  01
2040:  MOVWF  FEA
2042:  MOVLW  E0
2044:  MOVWF  FE9
2046:  MOVLW  0A
2048:  MOVWF  01
204A:  CLRF   FF7
204C:  MOVLW  00
204E:  CALL   02C0
2052:  TBLRD*-
2054:  TBLRD*+
2056:  MOVFF  FF5,FEE
205A:  DECFSZ 01,F
205C:  BRA    2054
205E:  MOVLW  01
2060:  MOVLB  2
2062:  MOVWF  x21
2064:  MOVLW  E0
2066:  MOVWF  x20
2068:  MOVLB  0
206A:  RCALL  1BD6
....................         if (n >= 3000){
206C:  MOVLB  1
206E:  MOVF   xDF,W
2070:  SUBLW  0A
2072:  BC    20D4
2074:  XORLW  FF
2076:  BNZ   207E
2078:  MOVF   xDE,W
207A:  SUBLW  B7
207C:  BC    20D4
....................                  
....................             print ((char*)"Operation Mode couldnt be set\n");
207E:  MOVLW  01
2080:  MOVWF  FEA
2082:  MOVLW  E0
2084:  MOVWF  FE9
2086:  MOVLW  1F
2088:  MOVWF  01
208A:  CLRF   FF7
208C:  MOVLW  00
208E:  MOVLB  0
2090:  CALL   02DA
2094:  TBLRD*-
2096:  TBLRD*+
2098:  MOVFF  FF5,FEE
209C:  DECFSZ 01,F
209E:  BRA    2096
20A0:  MOVLW  01
20A2:  MOVLB  2
20A4:  MOVWF  x21
20A6:  MOVLW  E0
20A8:  MOVWF  x20
20AA:  MOVLB  0
20AC:  RCALL  1C28
....................             println(spi_read_u8(0x27),BIN);
20AE:  MOVLW  27
20B0:  MOVLB  2
20B2:  MOVWF  x22
20B4:  MOVLB  0
20B6:  CALL   1690
20BA:  MOVFF  01,21E
20BE:  MOVFF  01,220
20C2:  MOVLW  02
20C4:  MOVLB  2
20C6:  MOVWF  x21
20C8:  MOVLB  0
20CA:  RCALL  1FE2
....................             while (1){ 
....................             usb_task();
20CC:  CALL   1582
20D0:  BRA    20CC
20D2:  MOVLB  1
....................             }
....................             
....................             //exit(-2);
....................         }
20D4:  BRA    200E
20D6:  MOVLB  0
....................     }      
....................     // Set the mode bits inside the operation mode register.
....................     operation_mode = spi_read_u8(_REG_OP_MODE);
20D8:  MOVLW  01
20DA:  MOVLB  2
20DC:  MOVWF  x22
20DE:  MOVLB  0
20E0:  CALL   1690
20E4:  MOVFF  01,155
....................     operation_mode &= 0b11100011;
20E8:  MOVLW  E3
20EA:  MOVLB  1
20EC:  ANDWF  x55,F
....................     operation_mode |= val << 2;
20EE:  RLCF   xDD,W
20F0:  MOVWF  00
20F2:  RLCF   00,F
20F4:  MOVLW  FC
20F6:  ANDWF  00,F
20F8:  MOVF   00,W
20FA:  IORWF  x55,F
....................     //Serial.println(operation_mode,BIN);
....................     spi_write_u8(_REG_OP_MODE,operation_mode);
20FC:  MOVLW  01
20FE:  MOVLB  2
2100:  MOVWF  x1E
2102:  MOVFF  155,21F
2106:  MOVLB  0
2108:  RCALL  1C7A
....................    
....................     // Wait for mode to change by polling interrupt bit.
....................     // start = timeSec();
....................     n=0;
210A:  MOVLB  1
210C:  CLRF   xDF
210E:  CLRF   xDE
....................     while (!get(mode_ready)){
2110:  MOVFF  10E,220
2114:  MOVFF  10D,21F
2118:  MOVFF  10C,21E
211C:  MOVLB  0
211E:  RCALL  1CC6
2120:  MOVF   01,F
2122:  BNZ   21FE
....................     usb_task();
2124:  CALL   1582
....................     delay_ms(100);
2128:  MOVLW  64
212A:  MOVLB  2
212C:  MOVWF  x1E
212E:  MOVLB  0
2130:  CALL   15C6
....................     n+=100;
2134:  MOVLW  64
2136:  MOVLB  1
2138:  ADDWF  xDE,F
213A:  MOVLW  00
213C:  ADDWFC xDF,F
....................     println((char*)"OP Loop 2");
213E:  MOVLW  01
2140:  MOVWF  FEA
2142:  SETF   FE9
2144:  MOVLW  0A
2146:  MOVWF  01
2148:  CLRF   FF7
214A:  MOVLW  00
214C:  MOVLB  0
214E:  CALL   030A
2152:  TBLRD*-
2154:  TBLRD*+
2156:  MOVFF  FF5,FEE
215A:  DECFSZ 01,F
215C:  BRA    2154
215E:  MOVLW  01
2160:  MOVLB  2
2162:  MOVWF  x21
2164:  SETF   x20
2166:  MOVLB  0
2168:  RCALL  1BD6
....................     println(spi_read_u8(_REG_OP_MODE),BIN)  ;  
216A:  MOVLW  01
216C:  MOVLB  2
216E:  MOVWF  x22
2170:  MOVLB  0
2172:  CALL   1690
2176:  MOVFF  01,21E
217A:  MOVFF  01,220
217E:  MOVLW  02
2180:  MOVLB  2
2182:  MOVWF  x21
2184:  MOVLB  0
2186:  RCALL  1FE2
....................     println(n,DEC);
2188:  MOVFF  1DE,220
218C:  MOVLW  0A
218E:  MOVLB  2
2190:  MOVWF  x21
2192:  MOVLB  0
2194:  RCALL  1FE2
....................         if (n >= 3000){
2196:  MOVLB  1
2198:  MOVF   xDF,W
219A:  SUBLW  0A
219C:  BC    21FA
219E:  XORLW  FF
21A0:  BNZ   21A8
21A2:  MOVF   xDE,W
21A4:  SUBLW  B7
21A6:  BC    21FA
....................             print ((char*)"Timeout on Operation Mode Set\n");
21A8:  MOVLW  01
21AA:  MOVWF  FEA
21AC:  SETF   FE9
21AE:  MOVLW  1F
21B0:  MOVWF  01
21B2:  CLRF   FF7
21B4:  MOVLW  00
21B6:  MOVLB  0
21B8:  CALL   0324
21BC:  TBLRD*-
21BE:  TBLRD*+
21C0:  MOVFF  FF5,FEE
21C4:  DECFSZ 01,F
21C6:  BRA    21BE
21C8:  MOVLW  01
21CA:  MOVLB  2
21CC:  MOVWF  x21
21CE:  SETF   x20
21D0:  MOVLB  0
21D2:  RCALL  1C28
....................             println(spi_read_u8(_REG_OP_MODE),BIN)  ;      
21D4:  MOVLW  01
21D6:  MOVLB  2
21D8:  MOVWF  x22
21DA:  MOVLB  0
21DC:  CALL   1690
21E0:  MOVFF  01,21E
21E4:  MOVFF  01,220
21E8:  MOVLW  02
21EA:  MOVLB  2
21EC:  MOVWF  x21
21EE:  MOVLB  0
21F0:  RCALL  1FE2
....................             while (1){
....................             usb_task();
21F2:  CALL   1582
21F6:  BRA    21F2
21F8:  MOVLB  1
....................             
....................             }
....................             //exit(-2);
....................         }
21FA:  BRA    2110
21FC:  MOVLB  0
....................     }
21FE:  RETURN 0
.................... }
.................... //WARNING must free allocated memory after using
.................... uint8_t* sync_word_get(){
....................     
....................     // """The synchronization word value.  This is a byte string up to 8 bytes long (64 bits)
....................     // which indicates the synchronization word for transmitted and received packets. Any
....................     // received packet which does not include this sync word will be ignored. The default value
....................     // is 0x2D, 0xD4 which matches the RadioHead RFM69 library. Setting a value of None will
....................     // disable synchronization word matching entirely.
....................     // """
....................     // # Handle when sync word is disabled..
....................     if (!get(sync_on))return NULL;
....................     //WARNING must free allocated memory after using
....................     sync_word = (uint8_t*)malloc(get(sync_size)+2);
....................     sync_word[0] = get(sync_size)+1;
....................     spi_read_into(_REG_SYNC_VALUE1,sync_word+1,get(sync_size)+1);
....................     return sync_word;
.................... }
.................... void sync_word_set(uint8_t* wrd){
*
224E:  MOVLB  1
2250:  MOVFF  1B8,FE9
2254:  MOVFF  1B9,FEA
2258:  MOVFF  FEF,1BA
....................   uint8_t len = wrd[0];
....................     if (len == 0 || wrd == NULL)set(0,sync_on);
225C:  MOVF   xBA,F
225E:  BZ    2268
2260:  MOVF   xB8,F
2262:  BNZ   227E
2264:  MOVF   xB9,F
2266:  BNZ   227E
2268:  CLRF   xDD
226A:  MOVFF  D8,1E0
226E:  MOVFF  D7,1DF
2272:  MOVFF  D6,1DE
2276:  MOVLB  0
2278:  RCALL  2216
227A:  BRA    22D0
227C:  MOVLB  1
....................     
....................     else{
....................         //TODO: assert 1 <= len(val) <= 8
....................         spi_write_from(_REG_SYNC_VALUE1,wrd+1,len);
227E:  MOVLW  01
2280:  ADDWF  xB8,W
2282:  MOVWF  xBB
2284:  MOVLW  00
2286:  ADDWFC xB9,W
2288:  MOVWF  xBC
228A:  MOVLW  2F
228C:  MOVLB  2
228E:  MOVWF  x20
2290:  MOVFF  1BC,222
2294:  MOVFF  1BB,221
2298:  MOVFF  1BA,223
229C:  MOVLB  0
229E:  RCALL  1C34
....................         //Sync_size: len(SYNC_WORD) - 1
....................         set(len-1,sync_size);
22A0:  MOVLW  01
22A2:  MOVLB  1
22A4:  SUBWF  xBA,W
22A6:  MOVWF  xBB
22A8:  MOVWF  xDD
22AA:  MOVFF  DB,1E0
22AE:  MOVFF  DA,1DF
22B2:  MOVFF  D9,1DE
22B6:  MOVLB  0
22B8:  RCALL  2216
....................         set(1,sync_on);
22BA:  MOVLW  01
22BC:  MOVLB  1
22BE:  MOVWF  xDD
22C0:  MOVFF  D8,1E0
22C4:  MOVFF  D7,1DF
22C8:  MOVFF  D6,1DE
22CC:  MOVLB  0
22CE:  RCALL  2216
....................     }
22D0:  GOTO   2AD8 (RETURN)
.................... }
.................... uint16_t preamble_length_get(){
....................     // The length of the preamble for sent and received packets, an unsigned 16-bit value.
....................     // Received packets must match this length or they are ignored! Set to 4 to match the
....................     // RadioHead RFM69 library.
....................     uint8_t msb = spi_read_u8(_REG_PREAMBLE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_PREAMBLE_LSB);
....................     return ((msb << 8) | lsb) & 0xFFFF;
.................... }
.................... void preamble_length_set(uint16_t val){
....................     spi_write_u8(_REG_PREAMBLE_MSB, (val >> 8) & 0xFF);
22D4:  MOVLB  1
22D6:  CLRF   xBB
22D8:  CLRF   xBB
22DA:  MOVLW  2C
22DC:  MOVLB  2
22DE:  MOVWF  x1E
22E0:  MOVFF  1B9,21F
22E4:  MOVLB  0
22E6:  RCALL  1C7A
....................     spi_write_u8(_REG_PREAMBLE_LSB, val & 0xFF);
22E8:  MOVLB  1
22EA:  CLRF   xBB
22EC:  MOVLW  2D
22EE:  MOVLB  2
22F0:  MOVWF  x1E
22F2:  MOVFF  1B8,21F
22F6:  MOVLB  0
22F8:  RCALL  1C7A
22FA:  GOTO   2AE6 (RETURN)
.................... }
.................... float frequency_mhz_get(){
....................     // """The frequency of the radio in Megahertz. Only the allowed values for your radio must be
....................     // specified (i.e. 433 vs. 915 mhz)!
....................     // """
....................     // # FRF register is computed from the frequency following the datasheet.
....................     // # See section 6.2 and FRF register description.
....................     // # Read bytes of FRF register and assemble into a 24-bit unsigned value.
....................     uint8_t msb = spi_read_u8(_REG_FRF_MSB);
....................     uint8_t mid = spi_read_u8(_REG_FRF_MID);
....................     uint8_t lsb = spi_read_u8(_REG_FRF_LSB);
....................     uint32_t frf = ((msb << 16) | (mid << 8) | lsb) & 0xFFFFFF;
....................     float frequency = (frf * _FSTEP) / 1000000.0;
....................     return frequency;
.................... }
.................... //WARNING: No funciona en micros porque requiere de enteros de 32 bits    
.................... void frequency_mhz_set(){
....................     //FRF = int((freq/_FSTEP)*1,000,000) & 0xFFFFFF
....................     uint8_t msb,lsb,mid;
....................     #ifdef FREQ_433
....................     msb = 0x6C;
22FE:  MOVLW  6C
2300:  MOVLB  1
2302:  MOVWF  xB8
....................     mid = 0x40;
2304:  MOVLW  40
2306:  MOVWF  xBA
....................     lsb = 0x00;
2308:  CLRF   xB9
....................     #endif
....................     //TODO: aadir soporte para otras frecuencias
....................     
....................     //TODO: assert 290 <= val <= 1020
....................     // Calculate FRF register 24-bit value using section 6.2 of the datasheet.
....................     // unsigned long frf = int((val/_FSTEP)* 1000000.0) ;
....................     // Serial.print("FRF: ");
....................     // Serial.println(frf);
....................     
....................     // frf &=  0xFFFFFF;
....................     // // Extract byte values and update registers.
....................     // uint8_t msb = frf >> 16;
....................     // uint8_t mid = (frf >> 8) & 0xFF;
....................     // uint8_t lsb = frf & 0xFF;
....................     spi_write_u8(_REG_FRF_MSB, msb);
230A:  MOVLW  07
230C:  MOVLB  2
230E:  MOVWF  x1E
2310:  MOVFF  1B8,21F
2314:  MOVLB  0
2316:  RCALL  1C7A
....................     spi_write_u8(_REG_FRF_MID, mid);
2318:  MOVLW  08
231A:  MOVLB  2
231C:  MOVWF  x1E
231E:  MOVFF  1BA,21F
2322:  MOVLB  0
2324:  RCALL  1C7A
....................     spi_write_u8(_REG_FRF_LSB, lsb);
2326:  MOVLW  09
2328:  MOVLB  2
232A:  MOVWF  x1E
232C:  MOVFF  1B9,21F
2330:  MOVLB  0
2332:  RCALL  1C7A
2334:  GOTO   2AE8 (RETURN)
.................... }
.................... uint8_t* encryption_key_get(){
....................     // """The AES encryption key used to encrypt and decrypt packets by the chip. This can be set
....................     // to None to disable encryption (the default), otherwise it must be a 16 byte long byte
....................     // string which defines the key (both the transmitter and receiver must use the same key
....................     // value).
....................     // """
....................     // # Handle if encryption is disabled.
....................     if(get(aes_on)==0)return NULL;
....................     spi_read_into(_REG_AES_KEY1,encryption_key,16);
....................     return encryption_key;
.................... }
.................... void encryption_key_set(uint8_t* val){
....................     if (val==0)set(0,aes_on);
....................     else{
....................         // Set the encryption key and enable encryption.
....................         //TODO: assert len(val) == 16
....................         spi_write_from(_REG_AES_KEY1,val,16);
....................         set(1,aes_on);
....................     }
.................... }
.................... int8_t tx_power_get(){
....................     // The transmit power in dBm. Can be set to a value from -2 to 20 for high power devices
....................     // (RFM69HCW, high_power=True) or -18 to 13 for low power devices. Only integer power
....................     // levels are actually set (i.e. 12.5 will result in a value of 12 dBm).
....................     // """
....................     // # Follow table 10 truth table from the datasheet for determining power
....................     // # level from the individual PA level bits and output power register.
....................     uint8_t pa0 = get(pa_0_on);
....................     uint8_t pa1 = get(pa_1_on);
....................     uint8_t pa2 = get(pa_2_on);
....................     uint8_t current_output_power = get(output_power);
....................     if (pa0 &&  !pa1 &&  !pa2)
....................         //# -18 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && !pa2)
....................         //# -2 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && !high_power)
....................         //# 2 to 17 dBm range
....................         return -14 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && high_power)
....................         //# 5 to 20 dBm range
....................         return -11 + current_output_power;
....................     print((char*)"Tx power power amps state unknown!");
....................     while (1){
....................     usb_task();
....................     }
....................     //exit(-3);
.................... }
.................... void tx_power_set(int8_t val){
*
288E:  MOVLB  1
2890:  CLRF   xB9
2892:  CLRF   xBA
2894:  CLRF   xBB
2896:  CLRF   xBC
....................     // Determine power amplifier and output power values depending on
....................     // high power state and requested power.
....................     uint8_t _pa_0_on = 0;
....................     uint8_t _pa_1_on = 0;
....................     uint8_t _pa_2_on = 0;
....................     uint8_t _output_power = 0;
....................     if (high_power){
2898:  MOVLB  0
289A:  BTFSS  xB5.1
289C:  BRA    28E4
....................         // Handle high power mode.
....................         //TODO: assert -2 <= val <= 20
....................         _pa_1_on = 1;
289E:  MOVLW  01
28A0:  MOVLB  1
28A2:  MOVWF  xBA
....................         if (val <= 13)
28A4:  BTFSC  xB8.7
28A6:  BRA    28AE
28A8:  MOVF   xB8,W
28AA:  SUBLW  0D
28AC:  BNC   28B6
....................             _output_power = val + 18;
28AE:  MOVLW  12
28B0:  ADDWF  xB8,W
28B2:  MOVWF  xBC
28B4:  BRA    28E0
....................         else if (13 < val && val <= 17){
28B6:  BTFSC  xB8.7
28B8:  BRA    28D6
28BA:  MOVF   xB8,W
28BC:  SUBLW  0D
28BE:  BC    28D6
28C0:  BTFSC  xB8.7
28C2:  BRA    28CA
28C4:  MOVF   xB8,W
28C6:  SUBLW  11
28C8:  BNC   28D6
....................             _pa_2_on = 1;
28CA:  MOVLW  01
28CC:  MOVWF  xBB
....................             _output_power = val + 14;
28CE:  MOVLW  0E
28D0:  ADDWF  xB8,W
28D2:  MOVWF  xBC
....................             }
28D4:  BRA    28E0
....................         else{
....................             //  # power >= 18 dBm
....................             //# Note this also needs PA boost enabled separately!
....................             _pa_2_on = 1;
28D6:  MOVLW  01
28D8:  MOVWF  xBB
....................             _output_power = val + 11;
28DA:  MOVLW  0B
28DC:  ADDWF  xB8,W
28DE:  MOVWF  xBC
....................             }
....................     }
28E0:  BRA    28F0
28E2:  MOVLB  0
....................     else{
....................         //Handle non-high power mode.
....................         //TODO: assert -18 <= val <= 13
....................         // Enable only power amplifier 0 and set output power.
....................         _pa_0_on = 1;
28E4:  MOVLW  01
28E6:  MOVLB  1
28E8:  MOVWF  xB9
....................         _output_power = (val+ 18);
28EA:  MOVLW  12
28EC:  ADDWF  xB8,W
28EE:  MOVWF  xBC
....................     }
....................     //# Set power amplifiers and output power as computed above.
....................     set(_pa_0_on,pa_0_on);
28F0:  MOVFF  1B9,1DD
28F4:  MOVFF  E1,1E0
28F8:  MOVFF  E0,1DF
28FC:  MOVFF  DF,1DE
2900:  MOVLB  0
2902:  RCALL  2216
....................     set(_pa_1_on,pa_1_on);
2904:  MOVFF  1BA,1DD
2908:  MOVFF  E4,1E0
290C:  MOVFF  E3,1DF
2910:  MOVFF  E2,1DE
2914:  RCALL  2216
....................     set(_pa_2_on,pa_2_on);
2916:  MOVFF  1BB,1DD
291A:  MOVFF  E7,1E0
291E:  MOVFF  E6,1DF
2922:  MOVFF  E5,1DE
2926:  RCALL  2216
....................     set(_output_power,output_power);
2928:  MOVFF  1BC,1DD
292C:  MOVFF  EA,1E0
2930:  MOVFF  E9,1DF
2934:  MOVFF  E8,1DE
2938:  RCALL  2216
....................     _tx_power = val;
293A:  MOVFF  1B8,121
293E:  GOTO   2C12 (RETURN)
.................... }
.................... float rssi_get(){
....................     // ""The received strength indicator (in dBm).
....................     // May be inaccuate if not read immediatey. last_rssi contains the value read immediately
....................     // receipt of the last packet.
....................     // """
....................     // # Read RSSI register and convert to value using formula in datasheet.
....................     rssi = -spi_read_u8(_REG_RSSI_VALUE) / 2.0;
*
2F0C:  MOVLW  24
2F0E:  MOVLB  2
2F10:  MOVWF  x22
2F12:  MOVLB  0
2F14:  CALL   1690
2F18:  MOVLW  00
2F1A:  BSF    FD8.0
2F1C:  SUBFWB 01,W
2F1E:  MOVLB  1
2F20:  CLRF   xE2
2F22:  MOVWF  xE1
2F24:  MOVLB  0
2F26:  CALL   16AA
2F2A:  MOVFF  03,1C3
2F2E:  MOVFF  02,1C2
2F32:  MOVFF  01,1C1
2F36:  MOVFF  00,1C0
2F3A:  MOVLB  1
2F3C:  CLRF   xC7
2F3E:  CLRF   xC6
2F40:  CLRF   xC5
2F42:  MOVLW  80
2F44:  MOVWF  xC4
2F46:  MOVLB  0
2F48:  CALL   2338
2F4C:  MOVFF  03,132
2F50:  MOVFF  02,131
2F54:  MOVFF  01,130
2F58:  MOVFF  00,12F
....................     return rssi;
2F5C:  MOVFF  12F,00
2F60:  MOVFF  130,01
2F64:  MOVFF  131,02
2F68:  MOVFF  132,03
2F6C:  GOTO   38A4 (RETURN)
.................... }
.................... float bitrate_get(){
....................     //         """The modulation bitrate in bits/second (or chip rate if Manchester encoding is enabled).
....................     // Can be a value from ~489 to 32mbit/s, but see the datasheet for the exact supported
....................     // values.
....................     // """
....................     uint8_t msb = spi_read_u8(_REG_BITRATE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_BITRATE_LSB);
....................     bitrate = _FXOSC / ((msb << 8) | lsb);
....................     return bitrate;
.................... }
.................... void bitrate_set(float val){
*
274A:  MOVLB  1
274C:  CLRF   xC3
274E:  MOVLW  24
2750:  MOVWF  xC2
2752:  MOVLW  74
2754:  MOVWF  xC1
2756:  MOVLW  97
2758:  MOVWF  xC0
275A:  MOVFF  1BB,1C7
275E:  MOVFF  1BA,1C6
2762:  MOVFF  1B9,1C5
2766:  MOVFF  1B8,1C4
276A:  MOVLB  0
276C:  RCALL  2338
276E:  MOVFF  03,1C3
2772:  MOVFF  02,1C2
2776:  MOVFF  01,1C1
277A:  MOVFF  00,1C0
277E:  BCF    FD8.1
2780:  MOVFF  03,1E6
2784:  MOVFF  02,1E5
2788:  MOVFF  01,1E4
278C:  MOVFF  00,1E3
2790:  MOVLB  1
2792:  CLRF   xEA
2794:  CLRF   xE9
2796:  CLRF   xE8
2798:  MOVLW  7E
279A:  MOVWF  xE7
279C:  MOVLB  0
279E:  RCALL  2496
27A0:  MOVFF  03,1C3
27A4:  MOVFF  02,1C2
27A8:  MOVFF  01,1C1
27AC:  MOVFF  00,1C0
27B0:  RCALL  270E
27B2:  MOVFF  01,1BC
27B6:  MOVLB  1
27B8:  CLRF   xBD
27BA:  CLRF   xBE
27BC:  CLRF   xBF
....................     //TODO: assert (_FXOSC / 65535) <= val <= 32000000.0
....................     //# Round up to the next closest bit-rate value with addition of 0.5.
....................     uint32_t _bitrate = (int)((_FXOSC/val)+0.5) & 0xFFF;
....................     spi_write_u8(_REG_BITRATE_MSB, _bitrate >> 8);
27BE:  CLRF   xC4
27C0:  MOVLW  03
27C2:  MOVLB  2
27C4:  MOVWF  x1E
27C6:  MOVFF  1BD,21F
27CA:  MOVLB  0
27CC:  CALL   1C7A
....................     spi_write_u8(_REG_BITRATE_LSB, _bitrate & 0xFF);
27D0:  MOVLB  1
27D2:  CLRF   xC1
27D4:  CLRF   xC2
27D6:  CLRF   xC3
27D8:  MOVLW  04
27DA:  MOVLB  2
27DC:  MOVWF  x1E
27DE:  MOVFF  1BC,21F
27E2:  MOVLB  0
27E4:  CALL   1C7A
27E8:  GOTO   2B24 (RETURN)
.................... }
.................... float frequency_deviation_get(){
....................     //"""The frequency deviation in Hertz."""
....................     uint8_t msb = spi_read_u8(_REG_FDEV_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_FDEV_LSB);
....................     frequency_deviation = _FSTEP * ((msb << 8) | lsb);
....................     return frequency_deviation;
.................... }
.................... void frequency_deviation_set(float val){
27EC:  MOVFF  1BB,1C3
27F0:  MOVFF  1BA,1C2
27F4:  MOVFF  1B9,1C1
27F8:  MOVFF  1B8,1C0
27FC:  MOVLB  1
27FE:  CLRF   xC7
2800:  MOVLW  24
2802:  MOVWF  xC6
2804:  MOVLW  74
2806:  MOVWF  xC5
2808:  MOVLW  84
280A:  MOVWF  xC4
280C:  MOVLB  0
280E:  RCALL  2338
2810:  MOVFF  03,1C3
2814:  MOVFF  02,1C2
2818:  MOVFF  01,1C1
281C:  MOVFF  00,1C0
2820:  BCF    FD8.1
2822:  MOVFF  03,1E6
2826:  MOVFF  02,1E5
282A:  MOVFF  01,1E4
282E:  MOVFF  00,1E3
2832:  MOVLB  1
2834:  CLRF   xEA
2836:  CLRF   xE9
2838:  CLRF   xE8
283A:  MOVLW  7E
283C:  MOVWF  xE7
283E:  MOVLB  0
2840:  RCALL  2496
2842:  MOVFF  03,1C3
2846:  MOVFF  02,1C2
284A:  MOVFF  01,1C1
284E:  MOVFF  00,1C0
2852:  RCALL  270E
2854:  MOVFF  01,1BC
2858:  MOVLB  1
285A:  CLRF   xBD
285C:  CLRF   xBE
285E:  CLRF   xBF
....................     //TODO: assert 0 <= val <= (_FSTEP * 16383)  # fdev is a 14-bit unsigned value
....................     // # Round up to the next closest integer value with addition of 0.5.
....................     uint32_t fdev = (int)((val / _FSTEP) + 0.5) & 0x3FFF;
....................     spi_write_u8(_REG_FDEV_MSB, fdev >> 8);
2860:  CLRF   xC4
2862:  MOVLW  05
2864:  MOVLB  2
2866:  MOVWF  x1E
2868:  MOVFF  1BD,21F
286C:  MOVLB  0
286E:  CALL   1C7A
....................     spi_write_u8(_REG_FDEV_LSB, fdev & 0xFF);
2872:  MOVLB  1
2874:  CLRF   xC1
2876:  CLRF   xC2
2878:  CLRF   xC3
287A:  MOVLW  06
287C:  MOVLB  2
287E:  MOVWF  x1E
2880:  MOVFF  1BC,21F
2884:  MOVLB  0
2886:  CALL   1C7A
288A:  GOTO   2B38 (RETURN)
.................... }
.................... bool packet_sent(){
....................     //Transmit status
....................     return (spi_read_u8(_REG_IRQ_FLAGS2) & 0x8) >> 3;
*
34C4:  MOVLW  28
34C6:  MOVLB  2
34C8:  MOVWF  x22
34CA:  MOVLB  0
34CC:  CALL   1690
34D0:  MOVF   01,W
34D2:  ANDLW  08
34D4:  MOVWF  00
34D6:  RRCF   00,F
34D8:  RRCF   00,F
34DA:  RRCF   00,F
34DC:  MOVLW  1F
34DE:  ANDWF  00,F
34E0:  MOVFF  00,01
34E4:  GOTO   3692 (RETURN)
.................... }
.................... bool payload_ready(){
*
2EE2:  MOVLW  28
2EE4:  MOVLB  2
2EE6:  MOVWF  x22
2EE8:  MOVLB  0
2EEA:  CALL   1690
2EEE:  MOVFF  01,1B7
....................             // """Receive status"""
....................     uint8_t p = spi_read_u8(_REG_IRQ_FLAGS2);
....................     //Serial.println(p,BIN);
....................     return (p & 0x4) >> 2;
2EF2:  MOVLB  1
2EF4:  MOVF   xB7,W
2EF6:  ANDLW  04
2EF8:  MOVWF  00
2EFA:  RRCF   00,F
2EFC:  RRCF   00,F
2EFE:  MOVLW  3F
2F00:  ANDWF  00,F
2F02:  MOVFF  00,01
2F06:  MOVLB  0
2F08:  GOTO   37DA (RETURN)
.................... }
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256){
....................     // """Send a string of data using the transmitter.
....................     // You can only send 60 bytes at a time
....................     // (limited by chip's FIFO size and appended headers).
....................     // This appends a 4 byte header to be compatible with the RadioHead library.
....................     // The header defaults to using the initialized attributes:
....................     // (destination,node,identifier,flags)
....................     // It may be temporarily overidden via the kwargs - destination,node,identifier,flags.
....................     // Values passed via kwargs do not alter the attribute settings.
....................     // The keep_listening argument should be set to True if you want to start listening
....................     // automatically after the packet is sent. The default setting is False.
....................     // Returns: True if success or False if the send timed out.
....................     // """
....................     // # Disable pylint warning to not use length as a check for zero.
....................     // # This is a puzzling warning as the below code is clearly the most
....................     // # efficient and proper way to ensure a precondition that the provided
....................     // # buffer be within an expected range of bounds.  Disable this check.
....................     // # pylint: disable=len-as-condition
....................     // TODO: assert 0 < len(data) <= 60
....................     // # pylint: enable=len-as-condition
....................     idle(); //# Stop receiving to clear FIFO and keep it clear.
*
34E8:  CALL   2200
....................     // # Fill the FIFO with a packet to send.
....................     // # Combine header and data to form payload
....................     uint32_t i=0;
....................     char* payload = (char*)malloc(5 + len + 1);
34EC:  MOVLB  1
34EE:  CLRF   xCB
34F0:  CLRF   xCA
34F2:  CLRF   xC9
34F4:  CLRF   xC8
34F6:  MOVLW  05
34F8:  ADDWF  xBE,W
34FA:  ADDLW  01
34FC:  MOVWF  xDD
34FE:  CLRF   xDF
3500:  MOVWF  xDE
3502:  MOVLB  0
3504:  RCALL  313C
3506:  MOVFF  02,1CD
350A:  MOVFF  01,1CC
....................     
....................     payload[0] = 4 + len;
350E:  MOVLB  1
3510:  MOVFF  1CC,FE9
3514:  MOVFF  1CD,FEA
3518:  MOVLW  04
351A:  ADDWF  xBE,W
351C:  MOVWF  FEF
....................     if (_destination >=256 )  // use attribute
351E:  MOVF   xC1,W
3520:  SUBLW  00
3522:  BC    3536
....................         payload[1] = destination;
3524:  MOVLW  01
3526:  ADDWF  xCC,W
3528:  MOVWF  FE9
352A:  MOVLW  00
352C:  ADDWFC xCD,W
352E:  MOVWF  FEA
3530:  MOVFF  152,FEF
3534:  BRA    3546
....................     else//  # use kwarg
....................         payload[1] = _destination;
3536:  MOVLW  01
3538:  ADDWF  xCC,W
353A:  MOVWF  FE9
353C:  MOVLW  00
353E:  ADDWFC xCD,W
3540:  MOVWF  FEA
3542:  MOVFF  1C0,FEF
....................     if (_node >= 256) // use attribute
3546:  MOVF   xC3,W
3548:  SUBLW  00
354A:  BC    355E
....................         payload[2] = node;
354C:  MOVLW  02
354E:  ADDWF  xCC,W
3550:  MOVWF  FE9
3552:  MOVLW  00
3554:  ADDWFC xCD,W
3556:  MOVWF  FEA
3558:  MOVFF  151,FEF
355C:  BRA    356E
....................     else  //# use kwarg
....................         payload[2] = _node;
355E:  MOVLW  02
3560:  ADDWF  xCC,W
3562:  MOVWF  FE9
3564:  MOVLW  00
3566:  ADDWFC xCD,W
3568:  MOVWF  FEA
356A:  MOVFF  1C2,FEF
....................     if (identifier >=256)  // use attribute
....................         payload[3] = identifier;
....................     else  //# use kwarg
....................         payload[3] = _identifier;
356E:  MOVLW  03
3570:  ADDWF  xCC,W
3572:  MOVWF  FE9
3574:  MOVLW  00
3576:  ADDWFC xCD,W
3578:  MOVWF  FEA
357A:  MOVFF  1C4,FEF
....................     if (flags >=256)  // use attribute
....................         payload[4] = flags;
....................     else  // use kwarg
....................         payload[4] = _flags;
357E:  MOVLW  04
3580:  ADDWF  xCC,W
3582:  MOVWF  FE9
3584:  MOVLW  00
3586:  ADDWFC xCD,W
3588:  MOVWF  FEA
358A:  MOVFF  1C6,FEF
....................     for (i=0;i<= len;i++)
358E:  CLRF   xCB
3590:  CLRF   xCA
3592:  CLRF   xC9
3594:  CLRF   xC8
3596:  MOVF   xCB,F
3598:  BNZ   3600
359A:  MOVF   xCA,F
359C:  BNZ   3600
359E:  MOVF   xC9,F
35A0:  BNZ   3600
35A2:  MOVF   xC8,W
35A4:  SUBWF  xBE,W
35A6:  BNC   3600
....................         payload[5+i] = data[i];
35A8:  MOVLW  05
35AA:  ADDWF  xC8,W
35AC:  MOVWF  xDD
35AE:  MOVLW  00
35B0:  ADDWFC xC9,W
35B2:  MOVWF  xDE
35B4:  MOVLW  00
35B6:  ADDWFC xCA,W
35B8:  MOVWF  xDF
35BA:  MOVLW  00
35BC:  ADDWFC xCB,W
35BE:  MOVWF  xE0
35C0:  MOVF   xCC,W
35C2:  ADDWF  xDD,W
35C4:  MOVWF  01
35C6:  MOVF   xCD,W
35C8:  ADDWFC xDE,W
35CA:  MOVWF  03
35CC:  MOVFF  01,1E1
35D0:  MOVWF  xE2
35D2:  MOVF   xBC,W
35D4:  ADDWF  xC8,W
35D6:  MOVWF  FE9
35D8:  MOVF   xBD,W
35DA:  ADDWFC xC9,W
35DC:  MOVWF  FEA
35DE:  MOVFF  FEF,1E3
35E2:  MOVFF  03,FEA
35E6:  MOVFF  01,FE9
35EA:  MOVFF  1E3,FEF
35EE:  MOVLW  01
35F0:  ADDWF  xC8,F
35F2:  BTFSC  FD8.0
35F4:  INCF   xC9,F
35F6:  BTFSC  FD8.2
35F8:  INCF   xCA,F
35FA:  BTFSC  FD8.2
35FC:  INCF   xCB,F
35FE:  BRA    3596
....................        
....................     // # Write payload to transmit fifo
....................     spi_write_from(_REG_FIFO, payload,5+len);
3600:  MOVLW  05
3602:  ADDWF  xBE,W
3604:  MOVWF  xDD
3606:  MOVLB  2
3608:  CLRF   x20
360A:  MOVFF  1CD,222
360E:  MOVFF  1CC,221
3612:  MOVWF  x23
3614:  MOVLB  0
3616:  CALL   1C34
....................     print((char*)"Payload: ");
361A:  MOVLW  01
361C:  MOVWF  FEA
361E:  MOVLW  CE
3620:  MOVWF  FE9
3622:  MOVLW  0A
3624:  MOVWF  01
3626:  CLRF   FF7
3628:  MOVLW  00
362A:  CALL   0354
362E:  TBLRD*-
3630:  TBLRD*+
3632:  MOVFF  FF5,FEE
3636:  DECFSZ 01,F
3638:  BRA    3630
363A:  MOVLW  01
363C:  MOVLB  2
363E:  MOVWF  x21
3640:  MOVLW  CE
3642:  MOVWF  x20
3644:  MOVLB  0
3646:  CALL   1C28
....................     println(payload+5);
364A:  MOVLW  05
364C:  MOVLB  1
364E:  ADDWF  xCC,W
3650:  MOVWF  xDD
3652:  MOVLW  00
3654:  ADDWFC xCD,W
3656:  MOVWF  xDE
3658:  MOVFF  FE8,221
365C:  MOVFF  1DD,220
3660:  MOVLB  0
3662:  CALL   1BD6
....................     // Serial.println((char)spi_read_u8(_REG_FIFO));              
.................... 
....................     free(payload);
3666:  MOVFF  1CD,1DE
366A:  MOVFF  1CC,1DD
366E:  RCALL  3418
....................     // # Turn on transmit mode to send out the packet.       
....................     transmit();
3670:  BRA    3492
....................    
....................     // # Wait for packet sent interrupt with explicit polling (not ideal but
....................     // # best that can be done right now without interrupts).
....................     
....................     float start = timeSec();
....................     bool timed_out = false;
3672:  CALL   2DD2
3676:  MOVFF  03,1DB
367A:  MOVFF  02,1DA
367E:  MOVFF  01,1D9
3682:  MOVFF  00,1D8
3686:  MOVLB  1
3688:  BCF    xDC.0
....................     while (!timed_out && !packet_sent()){
368A:  BTFSC  xDC.0
368C:  BRA    372A
368E:  MOVLB  0
3690:  BRA    34C4
3692:  MOVF   01,F
3694:  BTFSC  FD8.2
3696:  BRA    369C
3698:  MOVLB  1
369A:  BRA    372A
....................     usb_task();
369C:  CALL   1582
....................         if ((timeSec() - start) >= xmit_timeout)
36A0:  CALL   2DD2
36A4:  MOVFF  03,1E0
36A8:  MOVFF  02,1DF
36AC:  MOVFF  01,1DE
36B0:  MOVFF  00,1DD
36B4:  MOVFF  FEA,1E2
36B8:  MOVFF  FE9,1E1
36BC:  BSF    FD8.1
36BE:  MOVFF  03,1E6
36C2:  MOVFF  02,1E5
36C6:  MOVFF  01,1E4
36CA:  MOVFF  00,1E3
36CE:  MOVFF  1DB,1EA
36D2:  MOVFF  1DA,1E9
36D6:  MOVFF  1D9,1E8
36DA:  MOVFF  1D8,1E7
36DE:  CALL   2496
36E2:  MOVFF  1E2,FEA
36E6:  MOVFF  1E1,FE9
36EA:  MOVFF  03,1E0
36EE:  MOVFF  02,1DF
36F2:  MOVFF  01,1DE
36F6:  MOVFF  00,1DD
36FA:  MOVFF  142,1E6
36FE:  MOVFF  141,1E5
3702:  MOVFF  140,1E4
3706:  MOVFF  13F,1E3
370A:  MOVFF  03,1EA
370E:  MOVFF  02,1E9
3712:  MOVFF  01,1E8
3716:  MOVFF  00,1E7
371A:  CALL   2D26
371E:  BC    3722
3720:  BNZ   3726
....................             timed_out = true;
3722:  MOVLB  1
3724:  BSF    xDC.0
3726:  MOVLB  1
3728:  BRA    368A
....................     }
....................     // # Listen again if requested.
....................     if (keep_listening)
372A:  MOVF   xBF,F
372C:  BZ    3738
....................         listen();
372E:  MOVLB  0
3730:  CALL   2DA0
3734:  BRA    373E
3736:  MOVLB  1
....................     else  //# Enter idle mode to stop receiving other packets.
....................   
....................         idle();
3738:  MOVLB  0
373A:  CALL   2200
....................     return !timed_out;
373E:  MOVLW  00
3740:  MOVLB  1
3742:  BTFSS  xDC.0
3744:  MOVLW  01
3746:  MOVWF  01
3748:  MOVLB  0
374A:  GOTO   3AC2 (RETURN)
.................... }
.................... bool send_with_ack(uint8_t* data,uint8_t len){
....................     // Reliable Datagram mode:
....................     // Send a packet with data and wait for an ACK response.
....................     // The packet header is automatically generated.
....................     // If enabled, the packet transmission will be retried on failure
....................     int retries_remaining = 0;
....................     bool got_ack = false;
....................     uint8_t* ack_packet;
....................     if (ack_retries)retries_remaining = ack_retries;
....................     else retries_remaining=1;
....................     sequence_number = (sequence_number+1) & 0xFF;
....................     while (!got_ack && retries_remaining){
....................         identifier = sequence_number;
....................         send(data,len,true);
....................         // Don't look for ACK from Broadcast message
....................         if (destination == _RH_BROADCAST_ADDRESS)got_ack = true;
....................         else{
....................             ack_packet = receive(true,false,ack_wait,true);
....................             if(ack_packet != NULL){
....................                 if (ack_packet[4] & _RH_FLAGS_ACK){
....................                     //Check id:
....................                     if (ack_packet[3] == identifier){
....................                         got_ack = true;
....................                         break;
....................                     }
....................                 }
....................             }
....................             
....................         }
....................         //# pause before next retry -- random delay
....................         if (!got_ack){
....................             sleep_ms(ack_wait * (1.5));
....................         }
....................         retries_remaining -= 1;
....................         //# set retry flag in packet header
....................         flags |= _RH_FLAGS_RETRY;
....................     }
....................     flags = 0;  //# clear flags
....................     return got_ack;
.................... }
.................... //IMPORTANTE: La funcion es igual a la de adafruit, excepto porque retorna un array donde el primer valor es la longitud del array
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false){
374E:  MOVLB  1
3750:  BCF    x96.0
3752:  CLRF   x97
3754:  CLRF   x98
3756:  CLRF   x9D
3758:  CLRF   x9C
....................     // Wait to receive a packet from the receiver. If a packet is found the payload bytes
....................     // are returned, otherwise None is returned (which indicates the timeout elapsed with no
....................     // reception).
....................     // If keep_listening is True (the default) the chip will immediately enter listening mode
....................     // after reception of a packet, otherwise it will fall back to idle mode and ignore any
....................     // future reception.
....................     // All packets must have a 4 byte header for compatibilty with the
....................     // RadioHead library.
....................     // The header consists of 4 bytes (To,From,ID,Flags). The default setting will  strip
....................     // the header before returning the packet to the caller.
....................     // If with_header is True then the 4 byte header will be returned with the packet.
....................     // The payload then begins at packet[4].
....................     // If with_ack is True, send an ACK after receipt (Reliable Datagram mode)
....................     // """
....................     bool timed_out = false;
....................     int start = 0;
....................     int i=0;
....................     uint16_t n;
....................     uint8_t fifo_length;
....................     uint8_t* packet= NULL;
....................     char fifo_len_str [4];
....................     if (timeout == 0)timeout = receive_timeout;
375A:  MOVFF  194,1E6
375E:  MOVFF  193,1E5
3762:  MOVFF  192,1E4
3766:  MOVFF  191,1E3
376A:  CLRF   xEA
376C:  CLRF   xE9
376E:  CLRF   xE8
3770:  CLRF   xE7
3772:  MOVLB  0
3774:  CALL   2D26
3778:  BNZ   378A
377A:  MOVFF  13E,194
377E:  MOVFF  13D,193
3782:  MOVFF  13C,192
3786:  MOVFF  13B,191
....................     if (timeout!=0){
378A:  MOVFF  194,1E6
378E:  MOVFF  193,1E5
3792:  MOVFF  192,1E4
3796:  MOVFF  191,1E3
379A:  MOVLB  1
379C:  CLRF   xEA
379E:  CLRF   xE9
37A0:  CLRF   xE8
37A2:  CLRF   xE7
37A4:  MOVLB  0
37A6:  CALL   2D26
37AA:  BTFSC  FD8.2
37AC:  BRA    389C
....................         //readAllRegs();
....................         //while(1){}
....................         listen();
37AE:  CALL   2DA0
....................         start = timeSec();
37B2:  CALL   2DD2
37B6:  MOVFF  03,1C3
37BA:  MOVFF  02,1C2
37BE:  MOVFF  01,1C1
37C2:  MOVFF  00,1C0
37C6:  CALL   270E
37CA:  MOVFF  01,197
....................         while (!timed_out && !payload_ready()){
37CE:  MOVLB  1
37D0:  BTFSC  x96.0
37D2:  BRA    389E
37D4:  MOVLB  0
37D6:  GOTO   2EE2
37DA:  MOVF   01,F
37DC:  BTFSC  FD8.2
37DE:  BRA    37E4
37E0:  MOVLB  1
37E2:  BRA    389E
....................         usb_task();
37E4:  CALL   1582
....................         delay_ms(100);
37E8:  MOVLW  64
37EA:  MOVLB  2
37EC:  MOVWF  x1E
37EE:  MOVLB  0
37F0:  CALL   15C6
....................         n+=100;
37F4:  MOVLW  64
37F6:  MOVLB  1
37F8:  ADDWF  x99,F
37FA:  MOVLW  00
37FC:  ADDWFC x9A,F
....................             //delay(20);
....................             if ((n) >= (1000*xmit_timeout)){
37FE:  CLRF   xE8
3800:  CLRF   xE7
3802:  MOVLW  7A
3804:  MOVWF  xE6
3806:  MOVLW  88
3808:  MOVWF  xE5
380A:  MOVFF  142,1EC
380E:  MOVFF  141,1EB
3812:  MOVFF  140,1EA
3816:  MOVFF  13F,1E9
381A:  MOVLB  0
381C:  CALL   16E0
3820:  MOVFF  03,1BA
3824:  MOVFF  02,1B9
3828:  MOVFF  01,1B8
382C:  MOVFF  00,1B7
3830:  MOVFF  19A,1E2
3834:  MOVFF  199,1E1
3838:  CALL   16AA
383C:  MOVFF  1BA,1E6
3840:  MOVFF  1B9,1E5
3844:  MOVFF  1B8,1E4
3848:  MOVFF  1B7,1E3
384C:  MOVFF  03,1EA
3850:  MOVFF  02,1E9
3854:  MOVFF  01,1E8
3858:  MOVFF  00,1E7
385C:  CALL   2D26
3860:  BC    3864
3862:  BNZ   389A
....................                 println((char*)"Timed out");
3864:  MOVLW  01
3866:  MOVWF  FEA
3868:  MOVLW  A2
386A:  MOVWF  FE9
386C:  MOVLW  0A
386E:  MOVWF  01
3870:  CLRF   FF7
3872:  MOVLW  00
3874:  CALL   036E
3878:  TBLRD*-
387A:  TBLRD*+
387C:  MOVFF  FF5,FEE
3880:  DECFSZ 01,F
3882:  BRA    387A
3884:  MOVLW  01
3886:  MOVLB  2
3888:  MOVWF  x21
388A:  MOVLW  A2
388C:  MOVWF  x20
388E:  MOVLB  0
3890:  CALL   1BD6
....................                 timed_out = true;
3894:  MOVLB  1
3896:  BSF    x96.0
3898:  MOVLB  0
....................                 }
389A:  BRA    37CE
389C:  MOVLB  1
....................         }
....................     }
....................    
....................     last_rssi = rssi_get();
389E:  MOVLB  0
38A0:  GOTO   2F0C
38A4:  MOVFF  03,136
38A8:  MOVFF  02,135
38AC:  MOVFF  01,134
38B0:  MOVFF  00,133
....................     // Enter idle mode to stop receiving other packets.
....................     idle();
38B4:  CALL   2200
....................      
....................     if (!timed_out){
38B8:  MOVLB  1
38BA:  BTFSC  x96.0
38BC:  BRA    3BA0
....................         fifo_length = spi_read_u8(_REG_FIFO);
38BE:  MOVLB  2
38C0:  CLRF   x22
38C2:  MOVLB  0
38C4:  CALL   1690
38C8:  MOVFF  01,19B
....................         print((char*)"FIFO LEN: ");
38CC:  MOVLW  01
38CE:  MOVWF  FEA
38D0:  MOVLW  AC
38D2:  MOVWF  FE9
38D4:  MOVLW  0B
38D6:  MOVWF  01
38D8:  CLRF   FF7
38DA:  MOVLW  00
38DC:  CALL   0388
38E0:  TBLRD*-
38E2:  TBLRD*+
38E4:  MOVFF  FF5,FEE
38E8:  DECFSZ 01,F
38EA:  BRA    38E2
38EC:  MOVLW  01
38EE:  MOVLB  2
38F0:  MOVWF  x21
38F2:  MOVLW  AC
38F4:  MOVWF  x20
38F6:  MOVLB  0
38F8:  CALL   1C28
....................         sprintf(fifo_len_str,"%d",fifo_length);
38FC:  MOVLW  01
38FE:  MOVWF  xC6
3900:  MOVLW  9E
3902:  MOVWF  xC5
3904:  MOVFF  19B,1B7
3908:  MOVLW  18
390A:  MOVLB  1
390C:  MOVWF  xB8
390E:  MOVLB  0
3910:  GOTO   2F9C
....................         println(fifo_len_str);
3914:  MOVLW  01
3916:  MOVLB  2
3918:  MOVWF  x21
391A:  MOVLW  9E
391C:  MOVWF  x20
391E:  MOVLB  0
3920:  CALL   1BD6
....................         //  # Handle if the received packet is too small to include the 4 byte
....................         // # RadioHead header and at least one byte of data --reject this packet and ignore it.
....................         if (fifo_length > 0){
3924:  MOVLB  1
3926:  MOVF   x9B,F
3928:  BZ    3980
....................             packet = (uint8_t*)malloc(fifo_length+2);
392A:  MOVLW  02
392C:  ADDWF  x9B,W
392E:  MOVWF  xB7
3930:  CLRF   xDF
3932:  MOVWF  xDE
3934:  MOVLB  0
3936:  RCALL  313C
3938:  MOVFF  02,19D
393C:  MOVFF  01,19C
....................             packet[0] = fifo_length;
3940:  MOVLB  1
3942:  MOVFF  19C,FE9
3946:  MOVFF  19D,FEA
394A:  MOVFF  19B,FEF
....................             packet[fifo_length+1] = '\0';
394E:  MOVLW  01
3950:  ADDWF  x9B,W
3952:  ADDWF  x9C,W
3954:  MOVWF  FE9
3956:  MOVLW  00
3958:  ADDWFC x9D,W
395A:  MOVWF  FEA
395C:  CLRF   FEF
....................             spi_read_into(_REG_FIFO,packet+1,fifo_length);
395E:  MOVLW  01
3960:  ADDWF  x9C,W
3962:  MOVWF  xB7
3964:  MOVLW  00
3966:  ADDWFC x9D,W
3968:  MOVWF  xB8
396A:  MOVLB  2
396C:  CLRF   x23
396E:  MOVWF  x25
3970:  MOVFF  1B7,224
3974:  MOVFF  19B,226
3978:  MOVLB  0
397A:  CALL   163E
397E:  MOVLB  1
....................             //print(packet);
....................         }
....................         if (fifo_length < 5){
3980:  MOVF   x9B,W
3982:  SUBLW  04
3984:  BNC   398C
....................             packet = NULL;
3986:  CLRF   x9D
3988:  CLRF   x9C
....................         }
398A:  BRA    3BA0
....................         else{
....................             if (node != _RH_BROADCAST_ADDRESS && packet[1] != _RH_BROADCAST_ADDRESS && packet[1] != node){
398C:  INCFSZ x51,W
398E:  BRA    3992
3990:  BRA    39CA
3992:  MOVLW  01
3994:  ADDWF  x9C,W
3996:  MOVWF  FE9
3998:  MOVLW  00
399A:  ADDWFC x9D,W
399C:  MOVWF  FEA
399E:  INCFSZ FEF,W
39A0:  BRA    39A4
39A2:  BRA    39CA
39A4:  MOVLW  01
39A6:  ADDWF  x9C,W
39A8:  MOVWF  FE9
39AA:  MOVLW  00
39AC:  ADDWFC x9D,W
39AE:  MOVWF  FEA
39B0:  MOVF   x51,W
39B2:  SUBWF  FEF,W
39B4:  BZ    39CA
....................                 free(packet);
39B6:  MOVFF  19D,1DE
39BA:  MOVFF  19C,1DD
39BE:  MOVLB  0
39C0:  RCALL  3418
....................                 packet = NULL;
39C2:  MOVLB  1
39C4:  CLRF   x9D
39C6:  CLRF   x9C
....................             }
39C8:  BRA    3B4C
....................             //# send ACK unless this was an ACK or a broadcast
....................             else if (with_ack && (packet[4]&_RH_FLAGS_ACK)==0 && packet[1] != _RH_BROADCAST_ADDRESS){
39CA:  MOVF   x90,F
39CC:  BTFSC  FD8.2
39CE:  BRA    3B4C
39D0:  MOVLW  04
39D2:  ADDWF  x9C,W
39D4:  MOVWF  FE9
39D6:  MOVLW  00
39D8:  ADDWFC x9D,W
39DA:  MOVWF  FEA
39DC:  MOVF   FEF,W
39DE:  ANDLW  80
39E0:  BTFSS  FD8.2
39E2:  BRA    3B4C
39E4:  MOVLW  01
39E6:  ADDWF  x9C,W
39E8:  MOVWF  FE9
39EA:  MOVLW  00
39EC:  ADDWFC x9D,W
39EE:  MOVWF  FEA
39F0:  INCFSZ FEF,W
39F2:  BRA    39F6
39F4:  BRA    3B4C
....................                 if (ack_delay != 0)sleep_ms((int)(ack_delay/1000));
39F6:  MOVFF  147,1E6
39FA:  MOVFF  146,1E5
39FE:  MOVFF  145,1E4
3A02:  MOVFF  144,1E3
3A06:  CLRF   xEA
3A08:  CLRF   xE9
3A0A:  CLRF   xE8
3A0C:  CLRF   xE7
3A0E:  MOVLB  0
3A10:  CALL   2D26
3A14:  BZ    3A5A
3A16:  MOVFF  147,1C3
3A1A:  MOVFF  146,1C2
3A1E:  MOVFF  145,1C1
3A22:  MOVFF  144,1C0
3A26:  MOVLB  1
3A28:  CLRF   xC7
3A2A:  CLRF   xC6
3A2C:  MOVLW  7A
3A2E:  MOVWF  xC5
3A30:  MOVLW  88
3A32:  MOVWF  xC4
3A34:  MOVLB  0
3A36:  CALL   2338
3A3A:  MOVFF  03,1C3
3A3E:  MOVFF  02,1C2
3A42:  MOVFF  01,1C1
3A46:  MOVFF  00,1C0
3A4A:  CALL   270E
3A4E:  MOVFF  01,1B7
3A52:  MOVFF  01,1B8
3A56:  CALL   15F0
....................                 //# send ACK packet to sender (data is b'!')
....................                 send((char*)"!",false,packet[2],packet[1],packet[3],packet[4]|_RH_FLAGS_ACK);
3A5A:  MOVLW  21
3A5C:  MOVLB  1
3A5E:  MOVWF  xAC
3A60:  CLRF   xAD
3A62:  MOVLW  02
3A64:  ADDWF  x9C,W
3A66:  MOVWF  FE9
3A68:  MOVLW  00
3A6A:  ADDWFC x9D,W
3A6C:  MOVWF  FEA
3A6E:  MOVFF  FEF,1BF
3A72:  MOVLW  01
3A74:  ADDWF  x9C,W
3A76:  MOVWF  FE9
3A78:  MOVLW  00
3A7A:  ADDWFC x9D,W
3A7C:  MOVWF  FEA
3A7E:  MOVFF  FEF,1C0
3A82:  MOVLW  03
3A84:  ADDWF  x9C,W
3A86:  MOVWF  FE9
3A88:  MOVLW  00
3A8A:  ADDWFC x9D,W
3A8C:  MOVWF  FEA
3A8E:  MOVFF  FEF,1C2
3A92:  MOVLW  04
3A94:  ADDWF  x9C,W
3A96:  MOVWF  FE9
3A98:  MOVLW  00
3A9A:  ADDWFC x9D,W
3A9C:  MOVWF  FEA
3A9E:  MOVF   FEF,W
3AA0:  IORLW  80
3AA2:  MOVWF  xBB
3AA4:  MOVLW  01
3AA6:  MOVWF  xBD
3AA8:  MOVLW  AC
3AAA:  MOVWF  xBC
3AAC:  CLRF   xBE
3AAE:  CLRF   xC1
3AB0:  CLRF   xC3
3AB2:  CLRF   xC5
3AB4:  MOVFF  1BB,1C4
3AB8:  MOVLW  01
3ABA:  MOVWF  xC7
3ABC:  CLRF   xC6
3ABE:  MOVLB  0
3AC0:  BRA    34E8
....................                 // # reject Retries if we have seen this idetifier from this source before
....................                 if (seen_ids[packet[2]] == packet[3] && packet[4]&_RH_FLAGS_RETRY){
3AC2:  MOVLW  02
3AC4:  MOVLB  1
3AC6:  ADDWF  x9C,W
3AC8:  MOVWF  FE9
3ACA:  MOVLW  00
3ACC:  ADDWFC x9D,W
3ACE:  MOVWF  FEA
3AD0:  CLRF   03
3AD2:  MOVF   FEF,W
3AD4:  ADDLW  49
3AD6:  MOVWF  FE9
3AD8:  MOVLW  01
3ADA:  ADDWFC 03,W
3ADC:  MOVWF  FEA
3ADE:  MOVFF  FEF,1B7
3AE2:  MOVLW  03
3AE4:  ADDWF  x9C,W
3AE6:  MOVWF  FE9
3AE8:  MOVLW  00
3AEA:  ADDWFC x9D,W
3AEC:  MOVWF  FEA
3AEE:  MOVF   FEF,W
3AF0:  SUBWF  xB7,W
3AF2:  BNZ   3B18
3AF4:  MOVLW  04
3AF6:  ADDWF  x9C,W
3AF8:  MOVWF  FE9
3AFA:  MOVLW  00
3AFC:  ADDWFC x9D,W
3AFE:  MOVWF  FEA
3B00:  BTFSS  FEF.6
3B02:  BRA    3B18
....................                     free(packet);
3B04:  MOVFF  19D,1DE
3B08:  MOVFF  19C,1DD
3B0C:  MOVLB  0
3B0E:  RCALL  3418
....................                     packet= NULL;
3B10:  MOVLB  1
3B12:  CLRF   x9D
3B14:  CLRF   x9C
....................                 }
3B16:  BRA    3B4C
....................                 else{ //Save identifier from source
....................                     seen_ids[packet[2]] = packet[3];
3B18:  MOVLW  02
3B1A:  ADDWF  x9C,W
3B1C:  MOVWF  FE9
3B1E:  MOVLW  00
3B20:  ADDWFC x9D,W
3B22:  MOVWF  FEA
3B24:  CLRF   03
3B26:  MOVF   FEF,W
3B28:  ADDLW  49
3B2A:  MOVWF  01
3B2C:  MOVLW  01
3B2E:  ADDWFC 03,F
3B30:  MOVLW  03
3B32:  ADDWF  x9C,W
3B34:  MOVWF  FE9
3B36:  MOVLW  00
3B38:  ADDWFC x9D,W
3B3A:  MOVWF  FEA
3B3C:  MOVFF  FEF,1B9
3B40:  MOVFF  03,FEA
3B44:  MOVFF  01,FE9
3B48:  MOVFF  1B9,FEF
....................                 }
....................             }
....................             if (!with_header && packet != NULL){
3B4C:  MOVF   x95,F
3B4E:  BNZ   3BA0
3B50:  MOVF   x9C,F
3B52:  BNZ   3B58
3B54:  MOVF   x9D,F
3B56:  BZ    3BA0
....................                  //skip the header if not wanted
....................                  for (i=1; i< fifo_length-4;i++){
3B58:  MOVLW  01
3B5A:  MOVWF  x98
3B5C:  MOVLW  04
3B5E:  SUBWF  x9B,W
3B60:  SUBWF  x98,W
3B62:  BC    3B92
....................                     packet[i] = packet[i+4];
3B64:  MOVF   x98,W
3B66:  ADDWF  x9C,W
3B68:  MOVWF  01
3B6A:  MOVLW  00
3B6C:  ADDWFC x9D,W
3B6E:  MOVWF  03
3B70:  MOVLW  04
3B72:  ADDWF  x98,W
3B74:  ADDWF  x9C,W
3B76:  MOVWF  FE9
3B78:  MOVLW  00
3B7A:  ADDWFC x9D,W
3B7C:  MOVWF  FEA
3B7E:  MOVFF  FEF,1B9
3B82:  MOVFF  03,FEA
3B86:  MOVFF  01,FE9
3B8A:  MOVFF  1B9,FEF
3B8E:  INCF   x98,F
3B90:  BRA    3B5C
....................                  }
....................                  //reduce indicated length
....................                  packet[0] -= 4;
3B92:  MOVFF  19C,FE9
3B96:  MOVFF  19D,FEA
3B9A:  MOVLW  04
3B9C:  SUBWF  FEF,W
3B9E:  MOVWF  FEF
....................             }
....................         }
....................     }
....................     
....................     if (keep_listening)listen();        
3BA0:  MOVF   x8F,F
3BA2:  BZ    3BAC
3BA4:  MOVLB  0
3BA6:  CALL   2DA0
3BAA:  BRA    3BB2
....................     else idle();
3BAC:  MOVLB  0
3BAE:  CALL   2200
....................     return (char*)packet;
3BB2:  MOVLB  1
3BB4:  MOVFF  19C,01
3BB8:  MOVFF  19D,02
3BBC:  MOVLB  0
3BBE:  GOTO   40FE (RETURN)
.................... }
.................... 
.................... 
.................... #ZERO_RAM
.................... 
.................... 
.................... //Define la interrupcin por recepcin Serial
.................... static void RDA_isr(void)
.................... {  
*
13DE:  GOTO   1462 (RETURN)
....................  
.................... }
.................... 
.................... 
.................... /* TODO: Use usb_cdc_putc() to transmit data to the USB
.................... virtual COM port. Use usb_cdc_kbhit() and usb_cdc_getc() to
.................... receive data from the USB virtual COM port. usb_enumerated()
.................... can be used to see if connected to a host and ready to
.................... communicate. */
.................... 
.................... /*
.................... Conexiones
.................... MOSI: RX (23)
.................... MISO: B0 (00) (SDI)
.................... CLK: B1 (01) (SCK)
.................... CS: A5 (13)
.................... Reset: E0
.................... */
.................... 
.................... void main()
*
3BC2:  CLRF   FF8
3BC4:  BCF    FD0.7
3BC6:  BSF    07.7
3BC8:  MOVLW  FE
3BCA:  MOVWF  00
3BCC:  MOVLW  04
3BCE:  MOVWF  01
3BD0:  MOVLW  02
3BD2:  MOVWF  FE9
3BD4:  MOVLW  00
3BD6:  MOVWF  FEA
3BD8:  CLRF   FEE
3BDA:  DECFSZ 00,F
3BDC:  BRA    3BD8
3BDE:  DECFSZ 01,F
3BE0:  BRA    3BD8
3BE2:  MOVLW  DD
3BE4:  MOVWF  00
3BE6:  MOVLW  03
3BE8:  MOVWF  01
3BEA:  MOVLW  23
3BEC:  MOVWF  FE9
3BEE:  MOVLW  05
3BF0:  MOVWF  FEA
3BF2:  CLRF   FEE
3BF4:  DECFSZ 00,F
3BF6:  BRA    3BF2
3BF8:  DECFSZ 01,F
3BFA:  BRA    3BF2
3BFC:  BCF    FC6.5
3BFE:  MOVLW  40
3C00:  MOVWF  FC7
3C02:  MOVLW  22
3C04:  MOVWF  FC6
3C06:  BCF    F94.7
3C08:  BSF    F93.0
3C0A:  BSF    F89.5
3C0C:  MOVLW  EF
3C0E:  MOVWF  F92
3C10:  BCF    F93.1
3C12:  CLRF   xC6
3C14:  CLRF   xC5
3C16:  MOVLW  02
3C18:  MOVLB  1
3C1A:  MOVWF  x8F
3C1C:  MOVLW  05
3C1E:  MOVWF  x90
3C20:  MOVLW  02
3C22:  MOVWF  x91
3C24:  MOVLB  0
3C26:  CALL   146A
3C2A:  MOVFF  03,C9
3C2E:  MOVFF  02,C8
3C32:  MOVFF  01,C7
3C36:  MOVLW  02
3C38:  MOVLB  1
3C3A:  MOVWF  x8F
3C3C:  MOVLW  03
3C3E:  MOVWF  x90
3C40:  MOVLW  02
3C42:  MOVWF  x91
3C44:  MOVLB  0
3C46:  CALL   146A
3C4A:  MOVFF  03,CC
3C4E:  MOVFF  02,CB
3C52:  MOVFF  01,CA
3C56:  MOVLW  02
3C58:  MOVLB  1
3C5A:  MOVWF  x8F
3C5C:  CLRF   x90
3C5E:  MOVWF  x91
3C60:  MOVLB  0
3C62:  CALL   146A
3C66:  MOVFF  03,CF
3C6A:  MOVFF  02,CE
3C6E:  MOVFF  01,CD
3C72:  MOVLW  4E
3C74:  MOVLB  1
3C76:  MOVWF  x8F
3C78:  MOVLW  03
3C7A:  MOVWF  x90
3C7C:  MOVLW  01
3C7E:  MOVWF  x91
3C80:  MOVLB  0
3C82:  CALL   146A
3C86:  MOVFF  03,D2
3C8A:  MOVFF  02,D1
3C8E:  MOVFF  01,D0
3C92:  MOVLW  4E
3C94:  MOVLB  1
3C96:  MOVWF  x8F
3C98:  MOVLW  02
3C9A:  MOVWF  x90
3C9C:  MOVLW  01
3C9E:  MOVWF  x91
3CA0:  MOVLB  0
3CA2:  CALL   146A
3CA6:  MOVFF  03,D5
3CAA:  MOVFF  02,D4
3CAE:  MOVFF  01,D3
3CB2:  MOVLW  2E
3CB4:  MOVLB  1
3CB6:  MOVWF  x8F
3CB8:  MOVLW  07
3CBA:  MOVWF  x90
3CBC:  MOVLW  01
3CBE:  MOVWF  x91
3CC0:  MOVLB  0
3CC2:  CALL   146A
3CC6:  MOVFF  03,D8
3CCA:  MOVFF  02,D7
3CCE:  MOVFF  01,D6
3CD2:  MOVLW  2E
3CD4:  MOVLB  1
3CD6:  MOVWF  x8F
3CD8:  MOVLW  03
3CDA:  MOVWF  x90
3CDC:  MOVWF  x91
3CDE:  MOVLB  0
3CE0:  CALL   146A
3CE4:  MOVFF  03,DB
3CE8:  MOVFF  02,DA
3CEC:  MOVFF  01,D9
3CF0:  MOVLW  3D
3CF2:  MOVLB  1
3CF4:  MOVWF  x8F
3CF6:  CLRF   x90
3CF8:  MOVLW  01
3CFA:  MOVWF  x91
3CFC:  MOVLB  0
3CFE:  CALL   146A
3D02:  MOVFF  03,DE
3D06:  MOVFF  02,DD
3D0A:  MOVFF  01,DC
3D0E:  MOVLW  11
3D10:  MOVLB  1
3D12:  MOVWF  x8F
3D14:  MOVLW  07
3D16:  MOVWF  x90
3D18:  MOVLW  01
3D1A:  MOVWF  x91
3D1C:  MOVLB  0
3D1E:  CALL   146A
3D22:  MOVFF  03,E1
3D26:  MOVFF  02,E0
3D2A:  MOVFF  01,DF
3D2E:  MOVLW  11
3D30:  MOVLB  1
3D32:  MOVWF  x8F
3D34:  MOVLW  06
3D36:  MOVWF  x90
3D38:  MOVLW  01
3D3A:  MOVWF  x91
3D3C:  MOVLB  0
3D3E:  CALL   146A
3D42:  MOVFF  03,E4
3D46:  MOVFF  02,E3
3D4A:  MOVFF  01,E2
3D4E:  MOVLW  11
3D50:  MOVLB  1
3D52:  MOVWF  x8F
3D54:  MOVLW  05
3D56:  MOVWF  x90
3D58:  MOVLW  01
3D5A:  MOVWF  x91
3D5C:  MOVLB  0
3D5E:  CALL   146A
3D62:  MOVFF  03,E7
3D66:  MOVFF  02,E6
3D6A:  MOVFF  01,E5
3D6E:  MOVLW  11
3D70:  MOVLB  1
3D72:  MOVWF  x8F
3D74:  CLRF   x90
3D76:  MOVLW  05
3D78:  MOVWF  x91
3D7A:  MOVLB  0
3D7C:  CALL   146A
3D80:  MOVFF  03,EA
3D84:  MOVFF  02,E9
3D88:  MOVFF  01,E8
3D8C:  MOVLW  19
3D8E:  MOVLB  1
3D90:  MOVWF  x8F
3D92:  MOVLW  05
3D94:  MOVWF  x90
3D96:  MOVLW  03
3D98:  MOVWF  x91
3D9A:  MOVLB  0
3D9C:  CALL   146A
3DA0:  MOVFF  03,ED
3DA4:  MOVFF  02,EC
3DA8:  MOVFF  01,EB
3DAC:  MOVLW  19
3DAE:  MOVLB  1
3DB0:  MOVWF  x8F
3DB2:  MOVLW  03
3DB4:  MOVWF  x90
3DB6:  MOVLW  02
3DB8:  MOVWF  x91
3DBA:  MOVLB  0
3DBC:  CALL   146A
3DC0:  MOVFF  03,F0
3DC4:  MOVFF  02,EF
3DC8:  MOVFF  01,EE
3DCC:  MOVLW  19
3DCE:  MOVLB  1
3DD0:  MOVWF  x8F
3DD2:  CLRF   x90
3DD4:  MOVLW  03
3DD6:  MOVWF  x91
3DD8:  MOVLB  0
3DDA:  CALL   146A
3DDE:  MOVFF  03,F3
3DE2:  MOVFF  02,F2
3DE6:  MOVFF  01,F1
3DEA:  MOVLW  1A
3DEC:  MOVLB  1
3DEE:  MOVWF  x8F
3DF0:  MOVLW  05
3DF2:  MOVWF  x90
3DF4:  MOVLW  03
3DF6:  MOVWF  x91
3DF8:  MOVLB  0
3DFA:  CALL   146A
3DFE:  MOVFF  03,F6
3E02:  MOVFF  02,F5
3E06:  MOVFF  01,F4
3E0A:  MOVLW  1A
3E0C:  MOVLB  1
3E0E:  MOVWF  x8F
3E10:  MOVLW  03
3E12:  MOVWF  x90
3E14:  MOVLW  02
3E16:  MOVWF  x91
3E18:  MOVLB  0
3E1A:  CALL   146A
3E1E:  MOVFF  03,F9
3E22:  MOVFF  02,F8
3E26:  MOVFF  01,F7
3E2A:  MOVLW  1A
3E2C:  MOVLB  1
3E2E:  MOVWF  x8F
3E30:  CLRF   x90
3E32:  MOVLW  03
3E34:  MOVWF  x91
3E36:  MOVLB  0
3E38:  CALL   146A
3E3C:  MOVFF  03,FC
3E40:  MOVFF  02,FB
3E44:  MOVFF  01,FA
3E48:  MOVLW  37
3E4A:  MOVLB  1
3E4C:  MOVWF  x8F
3E4E:  MOVLW  07
3E50:  MOVWF  x90
3E52:  MOVLW  01
3E54:  MOVWF  x91
3E56:  MOVLB  0
3E58:  CALL   146A
3E5C:  MOVFF  03,FF
3E60:  MOVFF  02,FE
3E64:  MOVFF  01,FD
3E68:  MOVLW  37
3E6A:  MOVLB  1
3E6C:  MOVWF  x8F
3E6E:  MOVLW  05
3E70:  MOVWF  x90
3E72:  MOVLW  02
3E74:  MOVWF  x91
3E76:  MOVLB  0
3E78:  CALL   146A
3E7C:  MOVFF  03,102
3E80:  MOVFF  02,101
3E84:  MOVFF  01,100
3E88:  MOVLW  37
3E8A:  MOVLB  1
3E8C:  MOVWF  x8F
3E8E:  MOVLW  04
3E90:  MOVWF  x90
3E92:  MOVLW  01
3E94:  MOVWF  x91
3E96:  MOVLB  0
3E98:  CALL   146A
3E9C:  MOVFF  03,105
3EA0:  MOVFF  02,104
3EA4:  MOVFF  01,103
3EA8:  MOVLW  37
3EAA:  MOVLB  1
3EAC:  MOVWF  x8F
3EAE:  MOVLW  03
3EB0:  MOVWF  x90
3EB2:  MOVLW  01
3EB4:  MOVWF  x91
3EB6:  MOVLB  0
3EB8:  CALL   146A
3EBC:  MOVFF  03,108
3EC0:  MOVFF  02,107
3EC4:  MOVFF  01,106
3EC8:  MOVLW  37
3ECA:  MOVLB  1
3ECC:  MOVWF  x8F
3ECE:  MOVLW  01
3ED0:  MOVWF  x90
3ED2:  MOVLW  02
3ED4:  MOVWF  x91
3ED6:  MOVLB  0
3ED8:  CALL   146A
3EDC:  MOVFF  03,10B
3EE0:  MOVFF  02,10A
3EE4:  MOVFF  01,109
3EE8:  MOVLW  27
3EEA:  MOVLB  1
3EEC:  MOVWF  x8F
3EEE:  MOVLW  07
3EF0:  MOVWF  x90
3EF2:  MOVLW  01
3EF4:  MOVWF  x91
3EF6:  MOVLB  0
3EF8:  CALL   146A
3EFC:  MOVFF  03,10E
3F00:  MOVFF  02,10D
3F04:  MOVFF  01,10C
3F08:  MOVLW  25
3F0A:  MOVLB  1
3F0C:  MOVWF  x8F
3F0E:  MOVLW  06
3F10:  MOVWF  x90
3F12:  MOVLW  02
3F14:  MOVWF  x91
3F16:  MOVLB  0
3F18:  CALL   146A
3F1C:  MOVFF  03,111
3F20:  MOVFF  02,110
3F24:  MOVFF  01,10F
3F28:  MOVLW  25
3F2A:  MOVLB  1
3F2C:  MOVWF  x8F
3F2E:  MOVLW  04
3F30:  MOVWF  x90
3F32:  MOVLW  02
3F34:  MOVWF  x91
3F36:  MOVLB  0
3F38:  CALL   146A
3F3C:  MOVFF  03,114
3F40:  MOVFF  02,113
3F44:  MOVFF  01,112
3F48:  MOVLW  25
3F4A:  MOVLB  1
3F4C:  MOVWF  x8F
3F4E:  MOVLW  02
3F50:  MOVWF  x90
3F52:  MOVWF  x91
3F54:  MOVLB  0
3F56:  CALL   146A
3F5A:  MOVFF  03,117
3F5E:  MOVFF  02,116
3F62:  MOVFF  01,115
3F66:  MOVLW  25
3F68:  MOVLB  1
3F6A:  MOVWF  x8F
3F6C:  CLRF   x90
3F6E:  MOVLW  02
3F70:  MOVWF  x91
3F72:  MOVLB  0
3F74:  CALL   146A
3F78:  MOVFF  03,11A
3F7C:  MOVFF  02,119
3F80:  MOVFF  01,118
3F84:  MOVLW  26
3F86:  MOVLB  1
3F88:  MOVWF  x8F
3F8A:  MOVLW  06
3F8C:  MOVWF  x90
3F8E:  MOVLW  02
3F90:  MOVWF  x91
3F92:  MOVLB  0
3F94:  CALL   146A
3F98:  MOVFF  03,11D
3F9C:  MOVFF  02,11C
3FA0:  MOVFF  01,11B
3FA4:  MOVLW  26
3FA6:  MOVLB  1
3FA8:  MOVWF  x8F
3FAA:  MOVLW  04
3FAC:  MOVWF  x90
3FAE:  MOVLW  02
3FB0:  MOVWF  x91
3FB2:  MOVLB  0
3FB4:  CALL   146A
3FB8:  MOVFF  03,120
3FBC:  MOVFF  02,11F
3FC0:  MOVFF  01,11E
3FC4:  MOVF   FC1,W
3FC6:  ANDLW  C0
3FC8:  IORLW  0F
3FCA:  MOVWF  FC1
3FCC:  MOVLW  07
3FCE:  MOVWF  FB4
3FD0:  MOVLW  02
3FD2:  MOVWF  xC0
3FD4:  MOVLW  68
3FD6:  MOVWF  xBF
3FD8:  MOVLW  01
3FDA:  MOVLB  2
3FDC:  MOVWF  x69
3FDE:  MOVLW  94
3FE0:  MOVWF  x68
3FE2:  MOVLW  05
3FE4:  MOVWF  x6B
3FE6:  MOVLW  23
3FE8:  MOVWF  x6A
3FEA:  MOVLW  02
3FEC:  MOVLB  5
3FEE:  MOVWF  x24
3FF0:  MOVLW  D9
3FF2:  MOVWF  x23
3FF4:  CLRF   x26
3FF6:  CLRF   x25
3FF8:  MOVLB  0
3FFA:  CLRF   xB8
3FFC:  CLRF   xB9
*
4010:  MOVLW  20
4012:  MOVWF  x73
.................... {
.................... 
.................... /*
....................    //Timer de 8 bits
.................... //timer0 (RTCC_INTERNAL), Preescaler de 256, timer de 8 bits
.................... setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256 | RTCC_8_bit); 
.................... //el timer se va a desbordar dependiendo de la formula:
.................... //tiempo_desbordamiento =  (Valor_maximo_del_timer * (4*Preescaler))/Freq
.................... 
.................... //EJEMPLO, 
.................... //para un divisor de 64, reloj de 48 MHZ y tiempo de 1ms
.................... //Dado que el oscilador funciona a 48 Mhz, la formula es:
.................... //t = 256*4*64 / 48000000 = 1.365 ms (aprox. 1ms),
.................... //Para hacerlo mas preciso, es posible inicializar el timer a un valor mayor a 0, por lo que el desbordamiento ocurriria antes:
.................... //con un valor de inicio de 67 (contando el 0, esto es 68 pasos) (256-68 = 180), el valor da 1.0026ms
.................... 
.................... 
.................... set_rtcc(TIMER_START);
.................... //Interrupciones del timer
.................... enable_interrupts(INT_RTCC);
.................... enable_interrupts(GLOBAL);
.................... 
.................... */
....................    //RFM69 radio;
....................    //PRIMER BYTE es el tamao del array 
....................    uint8_t synch[] = {3,0xAA,0x2D,0xD4};
*
3FFE:  MOVLW  03
4000:  MOVLB  1
4002:  MOVWF  x6F
4004:  MOVLW  AA
4006:  MOVWF  x70
4008:  MOVLW  2D
400A:  MOVWF  x71
400C:  MOVLW  D4
400E:  MOVWF  x72
....................    int ResetPin = RF_Reset;
....................    setOutput(INDICATOR_LED,0);
*
4014:  MOVLW  04
4016:  MOVLB  2
4018:  MOVWF  x28
401A:  CLRF   x29
401C:  MOVLB  0
401E:  CALL   14EA
....................    //radio.init(synch,ResetPin);
....................    
....................    setup_adc_ports(NO_ANALOGS, VSS_VDD);
4022:  MOVF   FC1,W
4024:  ANDLW  C0
4026:  IORLW  0F
4028:  MOVWF  FC1
....................    usb_init();
402A:  GOTO   15B8
....................    
....................    //Esperar un segundo antes de iniciar
....................    sleep_ms(1000);
402E:  MOVLW  E8
4030:  MOVLB  1
4032:  MOVWF  xB8
4034:  MOVLB  0
4036:  CALL   15F0
....................    while (!checkId()){
403A:  GOTO   1B84
403E:  MOVF   01,F
4040:  BNZ   4078
....................    usb_task();
4042:  CALL   1582
....................    println((char*)"Id incorrecto");
4046:  MOVLW  01
4048:  MOVWF  FEA
404A:  MOVLW  74
404C:  MOVWF  FE9
404E:  MOVLW  0E
4050:  MOVWF  01
4052:  CLRF   FF7
4054:  MOVLW  00
4056:  CALL   03A4
405A:  TBLRD*-
405C:  TBLRD*+
405E:  MOVFF  FF5,FEE
4062:  DECFSZ 01,F
4064:  BRA    405C
4066:  MOVLW  01
4068:  MOVLB  2
406A:  MOVWF  x21
406C:  MOVLW  74
406E:  MOVWF  x20
4070:  MOVLB  0
4072:  CALL   1BD6
4076:  BRA    403A
....................    }
....................    setOutput(INDICATOR_LED,1);
4078:  MOVLW  04
407A:  MOVLB  2
407C:  MOVWF  x28
407E:  MOVLW  01
4080:  MOVWF  x29
4082:  MOVLB  0
4084:  CALL   14EA
....................    
....................    init(synch,ResetPin);
4088:  MOVLW  01
408A:  MOVLB  1
408C:  MOVWF  x90
408E:  MOVLW  6F
4090:  MOVWF  x8F
4092:  MOVFF  173,191
4096:  MOVLW  04
4098:  MOVWF  x92
409A:  MOVLW  01
409C:  MOVWF  x93
409E:  CLRF   x97
40A0:  MOVLW  1E
40A2:  MOVWF  x96
40A4:  MOVLW  84
40A6:  MOVWF  x95
40A8:  MOVLW  80
40AA:  MOVWF  x94
40AC:  CLRF   x99
40AE:  CLRF   x98
40B0:  MOVLB  0
40B2:  GOTO   2942
....................    println((char*)"INIT DONE");
40B6:  MOVLW  01
40B8:  MOVWF  FEA
40BA:  MOVLW  82
40BC:  MOVWF  FE9
40BE:  MOVLW  0A
40C0:  MOVWF  01
40C2:  CLRF   FF7
40C4:  MOVLW  00
40C6:  CALL   03C2
40CA:  TBLRD*-
40CC:  TBLRD*+
40CE:  MOVFF  FF5,FEE
40D2:  DECFSZ 01,F
40D4:  BRA    40CC
40D6:  MOVLW  01
40D8:  MOVLB  2
40DA:  MOVWF  x21
40DC:  MOVLW  82
40DE:  MOVWF  x20
40E0:  MOVLB  0
40E2:  CALL   1BD6
.................... //!   readAllRegs();
.................... //!   while(1){}
....................    while(TRUE)
....................    {
....................    char* packet = receive(1,0,0,0);
40E6:  MOVLW  01
40E8:  MOVLB  1
40EA:  MOVWF  x8F
40EC:  CLRF   x90
40EE:  CLRF   x94
40F0:  CLRF   x93
40F2:  CLRF   x92
40F4:  CLRF   x91
40F6:  CLRF   x95
40F8:  MOVLB  0
40FA:  GOTO   374E
40FE:  MOVFF  02,18D
4102:  MOVFF  01,18C
....................    if (!(packet == NULL || packet[0] == 0)){
4106:  MOVLB  1
4108:  MOVF   x8C,F
410A:  BNZ   4110
410C:  MOVF   x8D,F
410E:  BZ    416A
4110:  MOVFF  18C,FE9
4114:  MOVFF  18D,FEA
4118:  MOVF   FEF,F
411A:  BZ    416A
....................     for (int i=0;i<packet[0];i++){
411C:  CLRF   x8E
411E:  MOVFF  18C,FE9
4122:  MOVFF  18D,FEA
4126:  MOVF   FEF,W
4128:  SUBWF  x8E,W
412A:  BC    4154
....................       print((char*)packet[i+1]);
412C:  MOVLW  01
412E:  ADDWF  x8E,W
4130:  ADDWF  x8C,W
4132:  MOVWF  FE9
4134:  MOVLW  00
4136:  ADDWFC x8D,W
4138:  MOVWF  FEA
413A:  MOVF   FEF,W
413C:  CLRF   x90
413E:  MOVWF  x8F
4140:  MOVLB  2
4142:  CLRF   x21
4144:  MOVFF  FE8,220
4148:  MOVLB  0
414A:  CALL   1C28
414E:  MOVLB  1
4150:  INCF   x8E,F
4152:  BRA    411E
....................       }
....................   println((char*)"");
4154:  CLRF   x82
4156:  MOVLW  01
4158:  MOVLB  2
415A:  MOVWF  x21
415C:  MOVLW  82
415E:  MOVWF  x20
4160:  MOVLB  0
4162:  CALL   1BD6
....................    }
4166:  BRA    419C
4168:  MOVLB  1
....................    else println((char*) "Esperando");
416A:  MOVLW  01
416C:  MOVWF  FEA
416E:  MOVLW  82
4170:  MOVWF  FE9
4172:  MOVLW  0A
4174:  MOVWF  01
4176:  CLRF   FF7
4178:  MOVLW  00
417A:  MOVLB  0
417C:  CALL   03DC
4180:  TBLRD*-
4182:  TBLRD*+
4184:  MOVFF  FF5,FEE
4188:  DECFSZ 01,F
418A:  BRA    4182
418C:  MOVLW  01
418E:  MOVLB  2
4190:  MOVWF  x21
4192:  MOVLW  82
4194:  MOVWF  x20
4196:  MOVLB  0
4198:  CALL   1BD6
....................   //radio.readAllRegs();
....................   free(packet);
419C:  MOVFF  18D,1DE
41A0:  MOVFF  18C,1DD
41A4:  CALL   3418
....................    //println(globalSec,DEC);
....................    
....................    //readAllRegs();
....................    //print((char*)"RFM ");
....................    
....................    //if (!checkId())println((char*)"incorrecto");
....................    //else println((char*)"Correcto");
....................    //radio.readAllRegs();
.................... //!   println((char*)"HOLA USB");
.................... //!   println(134,HEX);
.................... //!   println(47,BIN);
....................    delay_ms(100);
41A8:  MOVLW  64
41AA:  MOVLB  2
41AC:  MOVWF  x1E
41AE:  MOVLB  0
41B0:  CALL   15C6
41B4:  BRA    40E6
....................       //TODO: User Code
....................    }
.................... 
.................... }
.................... 
41B6:  SLEEP 
.................... /*
.................... 
.................... //Interrupcion del timer
.................... #INT_RTCC  //TIMER0
.................... void timer0(void){
....................    set_rtcc(TIMER_START); //Timer0
....................    //println((char*)"Timer INT");
....................    globalMs += TIMER_STEP_MS ;       
....................    if (globalMs >= 1000){
....................    globalSec ++;
....................    globalMs -= 1000;
....................    }
....................    if (globalSec >= 60){
....................    globalMin ++;
....................    globalSec -= 60;
....................    }
....................    //Inicializar todo al llegar a 60 minutos
....................    //Puede introducir un bug rarisimo en el que una diferencia entre tiempos de negativa, pero es muy poco probable
....................    //Y aun asi el bug ocurrira cuando gloabalMin desborde
....................    if (globalMin >= 60){
....................    globalMs = 0;
....................    globalSec= 0;
....................    globalMin = 0;
....................    }
.................... }
.................... 
.................... */

Configuration Fuses:
   Word  1: CE23   PLL4 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
