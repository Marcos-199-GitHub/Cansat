CCS PCH C Compiler, Version 5.112, 29001               01-jul.-23 18:41

               Filename:   I:\CanSat\Cansat\Assets\RFM69\Receptor\ArduPort\Receptor.lst

               ROM used:   16330 bytes (50%)
                           Largest free fragment is 16438
               RAM used:   695 (34%) at main() level
                           915 (45%) worst case
               Stack used: 18 locations (11 in main + 7 for interrupts)
               Stack size: 31

*
0000:  GOTO   398E
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.5
0056:  GOTO   0060
005A:  BTFSC  FA1.5
005C:  GOTO   13FA
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #define HEX 16
.................... #define BIN 2
.................... #define DEC 10
.................... #define UDEC 11
.................... #define SSPin PIN_A5
.................... #define TIMER_START 114
.................... #define TIMER_STEP_MS 3
.................... #define FREQ_433
.................... 
.................... #include <Receptor.h>
.................... #include <18LF4550.h>
.................... //////////// Standard Header file for the PIC18LF4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18LF4550
00AE:  CLRF   FF7
00B0:  ADDLW  BE
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  RETURN 0
00BE:  DATA 00,03
00C0:  DATA 02,FF
00C2:  DATA FF,FF
00C4:  DATA FF,FF
00C6:  DATA FF,FF
00C8:  DATA FF,FF
00CA:  DATA FF,FF
00CC:  DATA FF,FF
00CE:  CLRF   FF7
00D0:  ADDLW  DE
00D2:  MOVWF  FF6
00D4:  MOVLW  00
00D6:  ADDWFC FF7,F
00D8:  TBLRD*+
00DA:  MOVF   FF5,W
00DC:  RETURN 0
00DE:  DATA 00,FF
00E0:  DATA 02,FF
00E2:  DATA FF,FF
00E4:  DATA FF,FF
00E6:  DATA FF,FF
00E8:  DATA FF,FF
00EA:  DATA FF,FF
00EC:  DATA FF,FF
00EE:  CLRF   FF7
00F0:  ADDLW  FE
00F2:  MOVWF  FF6
00F4:  MOVLW  00
00F6:  ADDWFC FF7,F
00F8:  TBLRD*+
00FA:  MOVF   FF5,W
00FC:  RETURN 0
00FE:  DATA 40,00
0100:  DATA 0B,00
0102:  DATA 40,00
0104:  DATA 00,00
0106:  DATA 00,00
0108:  DATA 00,00
010A:  DATA 00,00
010C:  DATA 00,00
010E:  DATA 00,00
0110:  DATA 00,00
0112:  DATA 00,00
0114:  DATA 00,00
0116:  DATA 00,00
0118:  DATA 00,00
011A:  DATA 00,00
011C:  DATA 00,00
011E:  CLRF   FF7
0120:  ADDLW  2E
0122:  MOVWF  FF6
0124:  MOVLW  01
0126:  ADDWFC FF7,F
0128:  TBLRD*+
012A:  MOVF   FF5,W
012C:  RETURN 0
012E:  DATA 40,00
0130:  DATA 00,00
0132:  DATA 40,00
0134:  DATA 00,00
0136:  DATA 00,00
0138:  DATA 00,00
013A:  DATA 00,00
013C:  DATA 00,00
013E:  DATA 00,00
0140:  DATA 00,00
0142:  DATA 00,00
0144:  DATA 00,00
0146:  DATA 00,00
0148:  DATA 00,00
014A:  DATA 00,00
014C:  DATA 00,00
014E:  CLRF   FF7
0150:  ADDLW  5E
0152:  MOVWF  FF6
0154:  MOVLW  01
0156:  ADDWFC FF7,F
0158:  TBLRD*+
015A:  MOVF   FF5,W
015C:  RETURN 0
015E:  DATA 09,02
0160:  DATA 43,00
0162:  DATA 02,01
0164:  DATA 00,80
0166:  DATA FA,09
0168:  DATA 04,00
016A:  DATA 00,01
016C:  DATA 02,02
016E:  DATA 01,00
0170:  DATA 05,24
0172:  DATA 00,10
0174:  DATA 01,04
0176:  DATA 24,02
0178:  DATA 02,05
017A:  DATA 24,06
017C:  DATA 00,01
017E:  DATA 05,24
0180:  DATA 01,00
0182:  DATA 01,07
0184:  DATA 05,81
0186:  DATA 03,0B
0188:  DATA 00,FA
018A:  DATA 09,04
018C:  DATA 01,00
018E:  DATA 02,0A
0190:  DATA 00,00
0192:  DATA 00,07
0194:  DATA 05,02
0196:  DATA 02,40
0198:  DATA 00,01
019A:  DATA 07,05
019C:  DATA 82,02
019E:  DATA 40,00
01A0:  DATA 01,00
01A2:  CLRF   FF7
01A4:  ADDLW  B2
01A6:  MOVWF  FF6
01A8:  MOVLW  01
01AA:  ADDWFC FF7,F
01AC:  TBLRD*+
01AE:  MOVF   FF5,W
01B0:  RETURN 0
01B2:  DATA 02,00
01B4:  CLRF   FF7
01B6:  ADDLW  C4
01B8:  MOVWF  FF6
01BA:  MOVLW  01
01BC:  ADDWFC FF7,F
01BE:  TBLRD*+
01C0:  MOVF   FF5,W
01C2:  RETURN 0
01C4:  DATA 12,17
01C6:  DATA 1B,20
01C8:  DATA FF,FF
01CA:  DATA FF,FF
01CC:  CLRF   FF7
01CE:  ADDLW  DC
01D0:  MOVWF  FF6
01D2:  MOVLW  01
01D4:  ADDWFC FF7,F
01D6:  TBLRD*+
01D8:  MOVF   FF5,W
01DA:  RETURN 0
01DC:  DATA 12,01
01DE:  DATA 10,01
01E0:  DATA 02,00
01E2:  DATA 00,40
01E4:  DATA 05,24
01E6:  DATA 0B,00
01E8:  DATA 00,01
01EA:  DATA 01,02
01EC:  DATA 00,01
01EE:  CLRF   FF7
01F0:  ADDLW  FE
01F2:  MOVWF  FF6
01F4:  MOVLW  01
01F6:  ADDWFC FF7,F
01F8:  TBLRD*+
01FA:  MOVF   FF5,W
01FC:  RETURN 0
01FE:  DATA 04,03
0200:  DATA 09,04
0202:  DATA 08,03
0204:  DATA 43,00
0206:  DATA 43,00
0208:  DATA 53,00
020A:  DATA 20,03
020C:  DATA 43,00
020E:  DATA 43,00
0210:  DATA 53,00
0212:  DATA 20,00
0214:  DATA 55,00
0216:  DATA 53,00
0218:  DATA 42,00
021A:  DATA 20,00
021C:  DATA 74,00
021E:  DATA 6F,00
0220:  DATA 20,00
0222:  DATA 55,00
0224:  DATA 41,00
0226:  DATA 52,00
0228:  DATA 54,00
022A:  CLRF   FF7
022C:  ADDLW  3A
022E:  MOVWF  FF6
0230:  MOVLW  02
0232:  ADDWFC FF7,F
0234:  TBLRD*+
0236:  MOVF   FF5,W
0238:  RETURN 0
023A:  DATA 49,6E
023C:  DATA 69,74
023E:  DATA 69,61
0240:  DATA 6C,20
0242:  DATA 63,6F
0244:  DATA 6E,66
0246:  DATA 20,73
0248:  DATA 74,61
024A:  DATA 72,74
024C:  DATA 73,00
024E:  CLRF   FF7
0250:  ADDLW  5E
0252:  MOVWF  FF6
0254:  MOVLW  02
0256:  ADDWFC FF7,F
0258:  TBLRD*+
025A:  MOVF   FF5,W
025C:  RETURN 0
025E:  DATA 45,72
0260:  DATA 72,6F
0262:  DATA 72,3A
0264:  DATA 20,49
0266:  DATA 44,20
0268:  DATA 64,65
026A:  DATA 6C,20
026C:  DATA 52,46
026E:  DATA 4D,20
0270:  DATA 69,6E
0272:  DATA 63,6F
0274:  DATA 72,72
0276:  DATA 65,63
0278:  DATA 74,61
027A:  DATA 00,00
027C:  CLRF   FF7
027E:  ADDLW  8C
0280:  MOVWF  FF6
0282:  MOVLW  02
0284:  ADDWFC FF7,F
0286:  TBLRD*+
0288:  MOVF   FF5,W
028A:  RETURN 0
028C:  DATA 49,44
028E:  DATA 20,4C
0290:  DATA 6F,6F
0292:  DATA 70,00
0294:  CLRF   FF7
0296:  ADDLW  A4
0298:  MOVWF  FF6
029A:  MOVLW  02
029C:  ADDWFC FF7,F
029E:  TBLRD*+
02A0:  MOVF   FF5,W
02A2:  RETURN 0
02A4:  DATA 49,6E
02A6:  DATA 69,74
02A8:  DATA 69,61
02AA:  DATA 6C,20
02AC:  DATA 63,6F
02AE:  DATA 6E,66
02B0:  DATA 69,67
02B2:  DATA 75,72
02B4:  DATA 61,74
02B6:  DATA 69,6F
02B8:  DATA 6E,20
02BA:  DATA 65,6E
02BC:  DATA 64,0A
02BE:  DATA 00,00
02C0:  CLRF   FF7
02C2:  ADDLW  D0
02C4:  MOVWF  FF6
02C6:  MOVLW  02
02C8:  ADDWFC FF7,F
02CA:  TBLRD*+
02CC:  MOVF   FF5,W
02CE:  RETURN 0
02D0:  DATA 4F,50
02D2:  DATA 20,4C
02D4:  DATA 6F,6F
02D6:  DATA 70,20
02D8:  DATA 31,00
02DA:  CLRF   FF7
02DC:  ADDLW  EA
02DE:  MOVWF  FF6
02E0:  MOVLW  02
02E2:  ADDWFC FF7,F
02E4:  TBLRD*+
02E6:  MOVF   FF5,W
02E8:  RETURN 0
02EA:  DATA 4F,70
02EC:  DATA 65,72
02EE:  DATA 61,74
02F0:  DATA 69,6F
02F2:  DATA 6E,20
02F4:  DATA 4D,6F
02F6:  DATA 64,65
02F8:  DATA 20,63
02FA:  DATA 6F,75
02FC:  DATA 6C,64
02FE:  DATA 6E,74
0300:  DATA 20,62
0302:  DATA 65,20
0304:  DATA 73,65
0306:  DATA 74,0A
0308:  DATA 00,00
030A:  CLRF   FF7
030C:  ADDLW  1A
030E:  MOVWF  FF6
0310:  MOVLW  03
0312:  ADDWFC FF7,F
0314:  TBLRD*+
0316:  MOVF   FF5,W
0318:  RETURN 0
031A:  DATA 4F,50
031C:  DATA 20,4C
031E:  DATA 6F,6F
0320:  DATA 70,20
0322:  DATA 32,00
0324:  CLRF   FF7
0326:  ADDLW  34
0328:  MOVWF  FF6
032A:  MOVLW  03
032C:  ADDWFC FF7,F
032E:  TBLRD*+
0330:  MOVF   FF5,W
0332:  RETURN 0
0334:  DATA 54,69
0336:  DATA 6D,65
0338:  DATA 6F,75
033A:  DATA 74,20
033C:  DATA 6F,6E
033E:  DATA 20,4F
0340:  DATA 70,65
0342:  DATA 72,61
0344:  DATA 74,69
0346:  DATA 6F,6E
0348:  DATA 20,4D
034A:  DATA 6F,64
034C:  DATA 65,20
034E:  DATA 53,65
0350:  DATA 74,0A
0352:  DATA 00,00
0354:  CLRF   FF7
0356:  ADDLW  64
0358:  MOVWF  FF6
035A:  MOVLW  03
035C:  ADDWFC FF7,F
035E:  TBLRD*+
0360:  MOVF   FF5,W
0362:  RETURN 0
0364:  DATA 50,61
0366:  DATA 79,6C
0368:  DATA 6F,61
036A:  DATA 64,3A
036C:  DATA 20,00
036E:  CLRF   FF7
0370:  ADDLW  7E
0372:  MOVWF  FF6
0374:  MOVLW  03
0376:  ADDWFC FF7,F
0378:  TBLRD*+
037A:  MOVF   FF5,W
037C:  RETURN 0
037E:  DATA 54,69
0380:  DATA 6D,65
0382:  DATA 64,20
0384:  DATA 6F,75
0386:  DATA 74,00
0388:  CLRF   FF7
038A:  ADDLW  98
038C:  MOVWF  FF6
038E:  MOVLW  03
0390:  ADDWFC FF7,F
0392:  TBLRD*+
0394:  MOVF   FF5,W
0396:  RETURN 0
0398:  DATA 46,49
039A:  DATA 46,4F
039C:  DATA 20,4C
039E:  DATA 45,4E
03A0:  DATA 3A,20
03A2:  DATA 00,00
03A4:  CLRF   FF7
03A6:  ADDLW  B4
03A8:  MOVWF  FF6
03AA:  MOVLW  03
03AC:  ADDWFC FF7,F
03AE:  TBLRD*+
03B0:  MOVF   FF5,W
03B2:  RETURN 0
03B4:  DATA 49,64
03B6:  DATA 20,69
03B8:  DATA 6E,63
03BA:  DATA 6F,72
03BC:  DATA 72,65
03BE:  DATA 63,74
03C0:  DATA 6F,00
03C2:  CLRF   FF7
03C4:  ADDLW  D2
03C6:  MOVWF  FF6
03C8:  MOVLW  03
03CA:  ADDWFC FF7,F
03CC:  TBLRD*+
03CE:  MOVF   FF5,W
03D0:  RETURN 0
03D2:  DATA 49,4E
03D4:  DATA 49,54
03D6:  DATA 20,44
03D8:  DATA 4F,4E
03DA:  DATA 45,00
03DC:  CLRF   FF7
03DE:  ADDLW  EC
03E0:  MOVWF  FF6
03E2:  MOVLW  03
03E4:  ADDWFC FF7,F
03E6:  TBLRD*+
03E8:  MOVF   FF5,W
03EA:  RETURN 0
03EC:  DATA 50,61
03EE:  DATA 63,6B
03F0:  DATA 65,74
03F2:  DATA 00,00
03F4:  CLRF   FF7
03F6:  ADDLW  04
03F8:  MOVWF  FF6
03FA:  MOVLW  04
03FC:  ADDWFC FF7,F
03FE:  TBLRD*+
0400:  MOVF   FF5,W
0402:  RETURN 0
0404:  DATA 45,73
0406:  DATA 70,65
0408:  DATA 72,61
040A:  DATA 6E,64
040C:  DATA 6F,00
*
04AE:  MOVLB  2
04B0:  MOVF   x6B,W
04B2:  MULWF  x6D
04B4:  MOVFF  FF3,01
04B8:  MOVFF  FF4,00
04BC:  MULWF  x6E
04BE:  MOVF   FF3,W
04C0:  ADDWF  00,F
04C2:  MOVF   x6C,W
04C4:  MULWF  x6D
04C6:  MOVF   FF3,W
04C8:  ADDWFC 00,W
04CA:  MOVWF  02
04CC:  MOVLB  0
04CE:  RETURN 0
*
14C0:  MOVLB  2
14C2:  MOVF   x2C,W
14C4:  ANDLW  07
14C6:  MOVWF  00
14C8:  RRCF   x2C,W
14CA:  MOVWF  01
14CC:  RRCF   01,F
14CE:  RRCF   01,F
14D0:  MOVLW  1F
14D2:  ANDWF  01,F
14D4:  MOVF   01,W
14D6:  ADDWF  x2E,W
14D8:  MOVWF  FE9
14DA:  MOVLW  00
14DC:  ADDWFC x2F,W
14DE:  MOVWF  FEA
14E0:  CLRF   01
14E2:  INCF   01,F
14E4:  INCF   00,F
14E6:  BRA    14EA
14E8:  RLCF   01,F
14EA:  DECFSZ 00,F
14EC:  BRA    14E8
14EE:  MOVF   x2D,F
14F0:  BZ    14F8
14F2:  MOVF   01,W
14F4:  IORWF  FEF,F
14F6:  BRA    14FE
14F8:  COMF   01,F
14FA:  MOVF   01,W
14FC:  ANDWF  FEF,F
14FE:  MOVLB  0
1500:  RETURN 0
*
16C2:  MOVFF  C7,FEA
16C6:  MOVFF  C6,FE9
16CA:  MOVFF  242,FEF
16CE:  INCF   FE9,F
16D0:  BTFSC  FD8.2
16D2:  INCF   FEA,F
16D4:  CLRF   FEF
16D6:  MOVLB  0
16D8:  INCF   xC6,F
16DA:  BTFSC  FD8.2
16DC:  INCF   xC7,F
16DE:  RETURN 0
16E0:  MOVLB  2
16E2:  BTFSC  x3A.7
16E4:  BRA    1708
16E6:  MOVLW  0F
16E8:  MOVWF  00
16EA:  SWAPF  x39,W
16EC:  ANDWF  00,F
16EE:  MOVLW  0A
16F0:  SUBWF  00,W
16F2:  BC    16FA
16F4:  MOVLW  30
16F6:  ADDWF  00,F
16F8:  BRA    16FE
16FA:  MOVF   x3A,W
16FC:  ADDWF  00,F
16FE:  MOVFF  00,242
1702:  MOVLB  0
1704:  RCALL  16C2
1706:  MOVLB  2
1708:  MOVLW  0F
170A:  ANDWF  x39,F
170C:  MOVLW  0A
170E:  SUBWF  x39,W
1710:  BC    1716
1712:  MOVLW  30
1714:  BRA    171A
1716:  BCF    x3A.7
1718:  MOVF   x3A,W
171A:  ADDWF  x39,F
171C:  MOVFF  239,242
1720:  MOVLB  0
1722:  RCALL  16C2
1724:  GOTO   1A98 (RETURN)
1728:  MOVFF  FEA,241
172C:  MOVFF  FE9,240
1730:  MOVLB  2
1732:  BTFSS  x3A.7
1734:  BRA    1746
1736:  BSF    x40.7
1738:  BTFSS  x40.4
173A:  INCF   x40,F
173C:  COMF   x39,F
173E:  COMF   x3A,F
1740:  INCF   x39,F
1742:  BTFSC  FD8.2
1744:  INCF   x3A,F
1746:  SWAPF  x3A,W
1748:  IORLW  F0
174A:  MOVWF  x3C
174C:  ADDWF  x3C,F
174E:  ADDLW  E2
1750:  MOVWF  x3D
1752:  ADDLW  32
1754:  MOVWF  x3F
1756:  MOVF   x3A,W
1758:  ANDLW  0F
175A:  ADDWF  x3D,F
175C:  ADDWF  x3D,F
175E:  ADDWF  x3F,F
1760:  ADDLW  E9
1762:  MOVWF  x3E
1764:  ADDWF  x3E,F
1766:  ADDWF  x3E,F
1768:  SWAPF  x39,W
176A:  ANDLW  0F
176C:  ADDWF  x3E,F
176E:  ADDWF  x3F,F
1770:  RLCF   x3E,F
1772:  RLCF   x3F,F
1774:  COMF   x3F,F
1776:  RLCF   x3F,F
1778:  MOVF   x39,W
177A:  ANDLW  0F
177C:  ADDWF  x3F,F
177E:  RLCF   x3C,F
1780:  MOVLW  07
1782:  MOVWF  x3B
1784:  MOVLW  0A
1786:  DECF   x3E,F
1788:  ADDWF  x3F,F
178A:  BNC   1786
178C:  DECF   x3D,F
178E:  ADDWF  x3E,F
1790:  BNC   178C
1792:  DECF   x3C,F
1794:  ADDWF  x3D,F
1796:  BNC   1792
1798:  DECF   x3B,F
179A:  ADDWF  x3C,F
179C:  BNC   1798
179E:  MOVLW  02
17A0:  MOVWF  FEA
17A2:  MOVLW  3B
17A4:  MOVWF  FE9
17A6:  MOVLW  07
17A8:  ANDWF  x40,W
17AA:  BCF    x40.6
17AC:  MOVF   FED,F
17AE:  ANDWF  x40,W
17B0:  BNZ   17C0
17B2:  BTFSC  x40.4
17B4:  MOVF   FEE,F
17B6:  BTFSC  x40.4
17B8:  BRA    17C0
17BA:  MOVLW  20
17BC:  MOVWF  00
17BE:  BRA    1802
17C0:  ADDWF  FE9,F
17C2:  MOVLW  00
17C4:  ADDWFC FEA,F
17C6:  MOVF   FE9,W
17C8:  SUBLW  3F
17CA:  BNZ   17D4
17CC:  MOVF   FEA,W
17CE:  SUBLW  02
17D0:  BNZ   17D4
17D2:  BSF    x40.6
17D4:  MOVF   FEF,W
17D6:  MOVWF  00
17D8:  BNZ   17EA
17DA:  BTFSC  x40.6
17DC:  BRA    17EA
17DE:  BTFSC  x40.4
17E0:  BRA    181C
17E2:  BTFSC  x40.3
17E4:  BRA    17EA
17E6:  MOVLW  20
17E8:  BRA    1800
17EA:  BTFSS  x40.7
17EC:  BRA    17FA
17EE:  MOVLW  2D
17F0:  MOVWF  00
17F2:  MOVF   FED,W
17F4:  BCF    x40.6
17F6:  BCF    x40.7
17F8:  BRA    1802
17FA:  BSF    x40.3
17FC:  BCF    x40.4
17FE:  MOVLW  30
1800:  ADDWF  00,F
1802:  MOVFF  FEA,23A
1806:  MOVFF  FE9,239
180A:  MOVFF  00,242
180E:  MOVLB  0
1810:  RCALL  16C2
1812:  MOVFF  23A,FEA
1816:  MOVFF  239,FE9
181A:  MOVLB  2
181C:  MOVF   FEE,W
181E:  BTFSS  x40.6
1820:  BRA    17C6
1822:  MOVLB  0
1824:  GOTO   1A76 (RETURN)
1828:  MOVFF  FEA,241
182C:  MOVFF  FE9,240
1830:  MOVLB  2
1832:  SWAPF  x3A,W
1834:  IORLW  F0
1836:  MOVWF  x3C
1838:  ADDWF  x3C,F
183A:  ADDLW  E2
183C:  MOVWF  x3D
183E:  ADDLW  32
1840:  MOVWF  x3F
1842:  MOVF   x3A,W
1844:  ANDLW  0F
1846:  ADDWF  x3D,F
1848:  ADDWF  x3D,F
184A:  ADDWF  x3F,F
184C:  ADDLW  E9
184E:  MOVWF  x3E
1850:  ADDWF  x3E,F
1852:  ADDWF  x3E,F
1854:  SWAPF  x39,W
1856:  ANDLW  0F
1858:  ADDWF  x3E,F
185A:  ADDWF  x3F,F
185C:  RLCF   x3E,F
185E:  RLCF   x3F,F
1860:  COMF   x3F,F
1862:  RLCF   x3F,F
1864:  MOVF   x39,W
1866:  ANDLW  0F
1868:  ADDWF  x3F,F
186A:  RLCF   x3C,F
186C:  MOVLW  07
186E:  MOVWF  x3B
1870:  MOVLW  0A
1872:  DECF   x3E,F
1874:  ADDWF  x3F,F
1876:  BNC   1872
1878:  DECF   x3D,F
187A:  ADDWF  x3E,F
187C:  BNC   1878
187E:  DECF   x3C,F
1880:  ADDWF  x3D,F
1882:  BNC   187E
1884:  DECF   x3B,F
1886:  ADDWF  x3C,F
1888:  BNC   1884
188A:  MOVLW  02
188C:  MOVWF  FEA
188E:  MOVLW  3B
1890:  MOVWF  FE9
1892:  MOVLW  07
1894:  ANDWF  x40,W
1896:  BCF    x40.6
1898:  ADDWF  FE9,F
189A:  MOVLW  00
189C:  ADDWFC FEA,F
189E:  MOVF   FE9,W
18A0:  SUBLW  3F
18A2:  BNZ   18AC
18A4:  MOVF   FEA,W
18A6:  SUBLW  02
18A8:  BNZ   18AC
18AA:  BSF    x40.6
18AC:  MOVF   FEF,W
18AE:  MOVWF  00
18B0:  BNZ   18C2
18B2:  BTFSC  x40.6
18B4:  BRA    18C2
18B6:  BTFSC  x40.4
18B8:  BRA    18E4
18BA:  BTFSC  x40.3
18BC:  BRA    18C2
18BE:  MOVLW  20
18C0:  BRA    18C8
18C2:  BSF    x40.3
18C4:  BCF    x40.4
18C6:  MOVLW  30
18C8:  ADDWF  00,F
18CA:  MOVFF  FEA,23A
18CE:  MOVFF  FE9,239
18D2:  MOVFF  00,242
18D6:  MOVLB  0
18D8:  RCALL  16C2
18DA:  MOVFF  23A,FEA
18DE:  MOVFF  239,FE9
18E2:  MOVLB  2
18E4:  MOVF   FEE,W
18E6:  BTFSS  x40.6
18E8:  BRA    189E
18EA:  MOVLB  0
18EC:  GOTO   1A98 (RETURN)
*
1982:  MOVF   FEF,F
1984:  BZ    19A4
1986:  MOVFF  FEA,23F
198A:  MOVFF  FE9,23E
198E:  MOVFF  FEF,240
1992:  RCALL  1946
1994:  MOVFF  23F,FEA
1998:  MOVFF  23E,FE9
199C:  INCF   FE9,F
199E:  BTFSC  FD8.2
19A0:  INCF   FEA,F
19A2:  BRA    1982
19A4:  GOTO   19C4 (RETURN)
*
1F74:  MOVLB  1
1F76:  MOVF   xC2,W
1F78:  BTFSC  FD8.2
1F7A:  BRA    20C6
1F7C:  MOVWF  xCE
1F7E:  MOVF   xC6,W
1F80:  BTFSC  FD8.2
1F82:  BRA    20C6
1F84:  SUBWF  xCE,F
1F86:  BNC   1F92
1F88:  MOVLW  7F
1F8A:  ADDWF  xCE,F
1F8C:  BTFSC  FD8.0
1F8E:  BRA    20C6
1F90:  BRA    1F9E
1F92:  MOVLW  81
1F94:  SUBWF  xCE,F
1F96:  BTFSS  FD8.0
1F98:  BRA    20C6
1F9A:  BTFSC  FD8.2
1F9C:  BRA    20C6
1F9E:  MOVFF  1CE,00
1FA2:  CLRF   01
1FA4:  CLRF   02
1FA6:  CLRF   03
1FA8:  CLRF   xCD
1FAA:  MOVFF  1C3,1CC
1FAE:  BSF    xCC.7
1FB0:  MOVFF  1C4,1CB
1FB4:  MOVFF  1C5,1CA
1FB8:  MOVLW  19
1FBA:  MOVWF  xCE
1FBC:  MOVF   xC9,W
1FBE:  SUBWF  xCA,F
1FC0:  BC    1FDC
1FC2:  MOVLW  01
1FC4:  SUBWF  xCB,F
1FC6:  BC    1FDC
1FC8:  SUBWF  xCC,F
1FCA:  BC    1FDC
1FCC:  SUBWF  xCD,F
1FCE:  BC    1FDC
1FD0:  INCF   xCD,F
1FD2:  INCF   xCC,F
1FD4:  INCF   xCB,F
1FD6:  MOVF   xC9,W
1FD8:  ADDWF  xCA,F
1FDA:  BRA    202C
1FDC:  MOVF   xC8,W
1FDE:  SUBWF  xCB,F
1FE0:  BC    2006
1FE2:  MOVLW  01
1FE4:  SUBWF  xCC,F
1FE6:  BC    2006
1FE8:  SUBWF  xCD,F
1FEA:  BC    2006
1FEC:  INCF   xCD,F
1FEE:  INCF   xCC,F
1FF0:  MOVF   xC8,W
1FF2:  ADDWF  xCB,F
1FF4:  MOVF   xC9,W
1FF6:  ADDWF  xCA,F
1FF8:  BNC   202C
1FFA:  INCF   xCB,F
1FFC:  BNZ   202C
1FFE:  INCF   xCC,F
2000:  BNZ   202C
2002:  INCF   xCD,F
2004:  BRA    202C
2006:  MOVF   xC7,W
2008:  IORLW  80
200A:  SUBWF  xCC,F
200C:  BC    202A
200E:  MOVLW  01
2010:  SUBWF  xCD,F
2012:  BC    202A
2014:  INCF   xCD,F
2016:  MOVF   xC7,W
2018:  IORLW  80
201A:  ADDWF  xCC,F
201C:  MOVF   xC8,W
201E:  ADDWF  xCB,F
2020:  BNC   1FF4
2022:  INCF   xCC,F
2024:  BNZ   1FF4
2026:  INCF   xCD,F
2028:  BRA    1FF4
202A:  BSF    03.0
202C:  DECFSZ xCE,F
202E:  BRA    2032
2030:  BRA    2048
2032:  BCF    FD8.0
2034:  RLCF   xCA,F
2036:  RLCF   xCB,F
2038:  RLCF   xCC,F
203A:  RLCF   xCD,F
203C:  BCF    FD8.0
203E:  RLCF   03,F
2040:  RLCF   02,F
2042:  RLCF   01,F
2044:  RLCF   xCF,F
2046:  BRA    1FBC
2048:  BTFSS  xCF.0
204A:  BRA    2058
204C:  BCF    FD8.0
204E:  RRCF   01,F
2050:  RRCF   02,F
2052:  RRCF   03,F
2054:  RRCF   xCF,F
2056:  BRA    205C
2058:  DECF   00,F
205A:  BZ    20C6
205C:  BTFSC  xCF.7
205E:  BRA    209C
2060:  BCF    FD8.0
2062:  RLCF   xCA,F
2064:  RLCF   xCB,F
2066:  RLCF   xCC,F
2068:  RLCF   xCD,F
206A:  MOVF   xC9,W
206C:  SUBWF  xCA,F
206E:  BC    207E
2070:  MOVLW  01
2072:  SUBWF  xCB,F
2074:  BC    207E
2076:  SUBWF  xCC,F
2078:  BC    207E
207A:  SUBWF  xCD,F
207C:  BNC   20B2
207E:  MOVF   xC8,W
2080:  SUBWF  xCB,F
2082:  BC    208E
2084:  MOVLW  01
2086:  SUBWF  xCC,F
2088:  BC    208E
208A:  SUBWF  xCD,F
208C:  BNC   20B2
208E:  MOVF   xC7,W
2090:  IORLW  80
2092:  SUBWF  xCC,F
2094:  BC    209C
2096:  MOVLW  01
2098:  SUBWF  xCD,F
209A:  BNC   20B2
209C:  INCF   03,F
209E:  BNZ   20B2
20A0:  INCF   02,F
20A2:  BNZ   20B2
20A4:  INCF   01,F
20A6:  BNZ   20B2
20A8:  INCF   00,F
20AA:  BZ    20C6
20AC:  RRCF   01,F
20AE:  RRCF   02,F
20B0:  RRCF   03,F
20B2:  MOVFF  1C3,1CE
20B6:  MOVF   xC7,W
20B8:  XORWF  xCE,F
20BA:  BTFSS  xCE.7
20BC:  BRA    20C2
20BE:  BSF    01.7
20C0:  BRA    20CE
20C2:  BCF    01.7
20C4:  BRA    20CE
20C6:  CLRF   00
20C8:  CLRF   01
20CA:  CLRF   02
20CC:  CLRF   03
20CE:  MOVLB  0
20D0:  RETURN 0
20D2:  MOVLW  80
20D4:  BTFSS  FD8.1
20D6:  BRA    20DC
20D8:  MOVLB  1
20DA:  XORWF  xEA,F
20DC:  MOVLB  1
20DE:  CLRF   xEF
20E0:  CLRF   xF0
20E2:  MOVFF  1E6,1EE
20E6:  MOVF   xEA,W
20E8:  XORWF  xEE,F
20EA:  MOVF   xE5,W
20EC:  BTFSC  FD8.2
20EE:  BRA    22AE
20F0:  MOVWF  xED
20F2:  MOVWF  00
20F4:  MOVF   xE9,W
20F6:  BTFSC  FD8.2
20F8:  BRA    22C0
20FA:  SUBWF  xED,F
20FC:  BTFSC  FD8.2
20FE:  BRA    2206
2100:  BNC   217E
2102:  MOVFF  1EA,1F3
2106:  BSF    xF3.7
2108:  MOVFF  1EB,1F2
210C:  MOVFF  1EC,1F1
2110:  CLRF   xF0
2112:  BCF    FD8.0
2114:  RRCF   xF3,F
2116:  RRCF   xF2,F
2118:  RRCF   xF1,F
211A:  RRCF   xF0,F
211C:  DECFSZ xED,F
211E:  BRA    2110
2120:  BTFSS  xEE.7
2122:  BRA    212A
2124:  BSF    xEF.0
2126:  BRA    22E8
2128:  BCF    xEF.0
212A:  BCF    xED.0
212C:  BSF    xEF.4
212E:  MOVLW  01
2130:  MOVWF  FEA
2132:  MOVLW  E8
2134:  MOVWF  FE9
2136:  BRA    230E
2138:  BCF    xEF.4
213A:  BTFSC  xEE.7
213C:  BRA    2152
213E:  BTFSS  xED.0
2140:  BRA    2168
2142:  RRCF   xF3,F
2144:  RRCF   xF2,F
2146:  RRCF   xF1,F
2148:  RRCF   xF0,F
214A:  INCF   00,F
214C:  BTFSC  FD8.2
214E:  BRA    22DE
2150:  BRA    2168
2152:  BTFSC  xF3.7
2154:  BRA    216E
2156:  BCF    FD8.0
2158:  RLCF   xF0,F
215A:  RLCF   xF1,F
215C:  RLCF   xF2,F
215E:  RLCF   xF3,F
2160:  DECF   00,F
2162:  BTFSC  FD8.2
2164:  BRA    22DE
2166:  BRA    2152
2168:  BSF    xEF.6
216A:  BRA    2246
216C:  BCF    xEF.6
216E:  MOVFF  1E6,1EE
2172:  BTFSS  xE6.7
2174:  BRA    217A
2176:  BSF    xF3.7
2178:  BRA    22D0
217A:  BCF    xF3.7
217C:  BRA    22D0
217E:  MOVFF  1E9,1ED
2182:  MOVFF  1E9,00
2186:  MOVF   xE5,W
2188:  SUBWF  xED,F
218A:  MOVFF  1E6,1F3
218E:  BSF    xF3.7
2190:  MOVFF  1E7,1F2
2194:  MOVFF  1E8,1F1
2198:  CLRF   xF0
219A:  BCF    FD8.0
219C:  RRCF   xF3,F
219E:  RRCF   xF2,F
21A0:  RRCF   xF1,F
21A2:  RRCF   xF0,F
21A4:  DECFSZ xED,F
21A6:  BRA    2198
21A8:  BTFSS  xEE.7
21AA:  BRA    21B2
21AC:  BSF    xEF.1
21AE:  BRA    22E8
21B0:  BCF    xEF.1
21B2:  BCF    xED.0
21B4:  BSF    xEF.5
21B6:  MOVLW  01
21B8:  MOVWF  FEA
21BA:  MOVLW  EC
21BC:  MOVWF  FE9
21BE:  BRA    230E
21C0:  BCF    xEF.5
21C2:  BTFSC  xEE.7
21C4:  BRA    21DA
21C6:  BTFSS  xED.0
21C8:  BRA    21F0
21CA:  RRCF   xF3,F
21CC:  RRCF   xF2,F
21CE:  RRCF   xF1,F
21D0:  RRCF   xF0,F
21D2:  INCF   00,F
21D4:  BTFSC  FD8.2
21D6:  BRA    22DE
21D8:  BRA    21F0
21DA:  BTFSC  xF3.7
21DC:  BRA    21F6
21DE:  BCF    FD8.0
21E0:  RLCF   xF0,F
21E2:  RLCF   xF1,F
21E4:  RLCF   xF2,F
21E6:  RLCF   xF3,F
21E8:  DECF   00,F
21EA:  BTFSC  FD8.2
21EC:  BRA    22DE
21EE:  BRA    21DA
21F0:  BSF    xEF.7
21F2:  BRA    2246
21F4:  BCF    xEF.7
21F6:  MOVFF  1EA,1EE
21FA:  BTFSS  xEA.7
21FC:  BRA    2202
21FE:  BSF    xF3.7
2200:  BRA    22D0
2202:  BCF    xF3.7
2204:  BRA    22D0
2206:  MOVFF  1EA,1F3
220A:  BSF    xF3.7
220C:  MOVFF  1EB,1F2
2210:  MOVFF  1EC,1F1
2214:  BTFSS  xEE.7
2216:  BRA    2220
2218:  BCF    xF3.7
221A:  BSF    xEF.2
221C:  BRA    22E8
221E:  BCF    xEF.2
2220:  CLRF   xF0
2222:  BCF    xED.0
2224:  MOVLW  01
2226:  MOVWF  FEA
2228:  MOVLW  E8
222A:  MOVWF  FE9
222C:  BRA    230E
222E:  BTFSC  xEE.7
2230:  BRA    226A
2232:  MOVFF  1E6,1EE
2236:  BTFSS  xED.0
2238:  BRA    2246
223A:  RRCF   xF3,F
223C:  RRCF   xF2,F
223E:  RRCF   xF1,F
2240:  RRCF   xF0,F
2242:  INCF   00,F
2244:  BZ    22DE
2246:  BTFSS  xF0.7
2248:  BRA    2260
224A:  INCF   xF1,F
224C:  BNZ   2260
224E:  INCF   xF2,F
2250:  BNZ   2260
2252:  INCF   xF3,F
2254:  BNZ   2260
2256:  RRCF   xF3,F
2258:  RRCF   xF2,F
225A:  RRCF   xF1,F
225C:  INCF   00,F
225E:  BZ    22DE
2260:  BTFSC  xEF.6
2262:  BRA    216C
2264:  BTFSC  xEF.7
2266:  BRA    21F4
2268:  BRA    22A2
226A:  MOVLW  80
226C:  XORWF  xF3,F
226E:  BTFSS  xF3.7
2270:  BRA    227A
2272:  BRA    22E8
2274:  MOVFF  1EA,1EE
2278:  BRA    228E
227A:  MOVFF  1E6,1EE
227E:  MOVF   xF3,F
2280:  BNZ   228E
2282:  MOVF   xF2,F
2284:  BNZ   228E
2286:  MOVF   xF1,F
2288:  BNZ   228E
228A:  CLRF   00
228C:  BRA    22D0
228E:  BTFSC  xF3.7
2290:  BRA    22A2
2292:  BCF    FD8.0
2294:  RLCF   xF0,F
2296:  RLCF   xF1,F
2298:  RLCF   xF2,F
229A:  RLCF   xF3,F
229C:  DECFSZ 00,F
229E:  BRA    228E
22A0:  BRA    22DE
22A2:  BTFSS  xEE.7
22A4:  BRA    22AA
22A6:  BSF    xF3.7
22A8:  BRA    22D0
22AA:  BCF    xF3.7
22AC:  BRA    22D0
22AE:  MOVFF  1E9,00
22B2:  MOVFF  1EA,1F3
22B6:  MOVFF  1EB,1F2
22BA:  MOVFF  1EC,1F1
22BE:  BRA    22D0
22C0:  MOVFF  1E5,00
22C4:  MOVFF  1E6,1F3
22C8:  MOVFF  1E7,1F2
22CC:  MOVFF  1E8,1F1
22D0:  MOVFF  1F3,01
22D4:  MOVFF  1F2,02
22D8:  MOVFF  1F1,03
22DC:  BRA    2346
22DE:  CLRF   00
22E0:  CLRF   01
22E2:  CLRF   02
22E4:  CLRF   03
22E6:  BRA    2346
22E8:  CLRF   xF0
22EA:  COMF   xF1,F
22EC:  COMF   xF2,F
22EE:  COMF   xF3,F
22F0:  COMF   xF0,F
22F2:  INCF   xF0,F
22F4:  BNZ   2300
22F6:  INCF   xF1,F
22F8:  BNZ   2300
22FA:  INCF   xF2,F
22FC:  BNZ   2300
22FE:  INCF   xF3,F
2300:  BTFSC  xEF.0
2302:  BRA    2128
2304:  BTFSC  xEF.1
2306:  BRA    21B0
2308:  BTFSC  xEF.2
230A:  BRA    221E
230C:  BRA    2274
230E:  MOVF   FEF,W
2310:  ADDWF  xF1,F
2312:  BNC   231E
2314:  INCF   xF2,F
2316:  BNZ   231E
2318:  INCF   xF3,F
231A:  BTFSC  FD8.2
231C:  BSF    xED.0
231E:  MOVF   FED,F
2320:  MOVF   FEF,W
2322:  ADDWF  xF2,F
2324:  BNC   232C
2326:  INCF   xF3,F
2328:  BTFSC  FD8.2
232A:  BSF    xED.0
232C:  MOVF   FED,F
232E:  MOVF   FEF,W
2330:  BTFSC  FEF.7
2332:  BRA    2336
2334:  XORLW  80
2336:  ADDWF  xF3,F
2338:  BTFSC  FD8.0
233A:  BSF    xED.0
233C:  BTFSC  xEF.4
233E:  BRA    2138
2340:  BTFSC  xEF.5
2342:  BRA    21C0
2344:  BRA    222E
2346:  MOVLB  0
2348:  RETURN 0
234A:  MOVLW  8E
234C:  MOVWF  00
234E:  MOVLB  1
2350:  MOVF   xC2,W
2352:  SUBWF  00,F
2354:  MOVFF  1C3,02
2358:  MOVFF  1C4,01
235C:  BSF    02.7
235E:  MOVF   00,F
2360:  BZ    2374
2362:  BCF    FD8.0
2364:  MOVF   02,F
2366:  BNZ   236C
2368:  MOVF   01,F
236A:  BZ    2374
236C:  RRCF   02,F
236E:  RRCF   01,F
2370:  DECFSZ 00,F
2372:  BRA    2362
2374:  BTFSS  xC3.7
2376:  BRA    2382
2378:  COMF   01,F
237A:  COMF   02,F
237C:  INCF   01,F
237E:  BTFSC  FD8.2
2380:  INCF   02,F
2382:  MOVLB  0
2384:  RETURN 0
*
2984:  MOVFF  1E6,1ED
2988:  MOVLB  1
298A:  MOVF   xEA,W
298C:  XORWF  xED,F
298E:  BTFSS  xED.7
2990:  BRA    299C
2992:  BCF    FD8.2
2994:  BCF    FD8.0
2996:  BTFSC  xE6.7
2998:  BSF    FD8.0
299A:  BRA    29FA
299C:  MOVFF  1E6,1ED
29A0:  MOVFF  1E9,1EE
29A4:  MOVF   xE5,W
29A6:  SUBWF  xEE,F
29A8:  BZ    29B6
29AA:  BTFSS  xED.7
29AC:  BRA    29FA
29AE:  MOVF   FD8,W
29B0:  XORLW  01
29B2:  MOVWF  FD8
29B4:  BRA    29FA
29B6:  MOVFF  1EA,1EE
29BA:  MOVF   xE6,W
29BC:  SUBWF  xEE,F
29BE:  BZ    29CC
29C0:  BTFSS  xED.7
29C2:  BRA    29FA
29C4:  MOVF   FD8,W
29C6:  XORLW  01
29C8:  MOVWF  FD8
29CA:  BRA    29FA
29CC:  MOVFF  1EB,1EE
29D0:  MOVF   xE7,W
29D2:  SUBWF  xEE,F
29D4:  BZ    29E2
29D6:  BTFSS  xED.7
29D8:  BRA    29FA
29DA:  MOVF   FD8,W
29DC:  XORLW  01
29DE:  MOVWF  FD8
29E0:  BRA    29FA
29E2:  MOVFF  1EC,1EE
29E6:  MOVF   xE8,W
29E8:  SUBWF  xEE,F
29EA:  BZ    29F8
29EC:  BTFSS  xED.7
29EE:  BRA    29FA
29F0:  MOVF   FD8,W
29F2:  XORLW  01
29F4:  MOVWF  FD8
29F6:  BRA    29FA
29F8:  BCF    FD8.0
29FA:  MOVLB  0
29FC:  RETURN 0
*
2A30:  MOVLW  8E
2A32:  MOVWF  00
2A34:  MOVFF  1E4,01
2A38:  MOVFF  1E3,02
2A3C:  CLRF   03
2A3E:  MOVF   01,F
2A40:  BNZ   2A54
2A42:  MOVFF  02,01
2A46:  CLRF   02
2A48:  MOVLW  08
2A4A:  SUBWF  00,F
2A4C:  MOVF   01,F
2A4E:  BNZ   2A54
2A50:  CLRF   00
2A52:  BRA    2A64
2A54:  BCF    FD8.0
2A56:  BTFSC  01.7
2A58:  BRA    2A62
2A5A:  RLCF   02,F
2A5C:  RLCF   01,F
2A5E:  DECF   00,F
2A60:  BRA    2A54
2A62:  BCF    01.7
2A64:  RETURN 0
2A66:  MOVLB  1
2A68:  MOVF   xE7,W
2A6A:  BTFSC  FD8.2
2A6C:  BRA    2B50
2A6E:  MOVWF  00
2A70:  MOVF   xEB,W
2A72:  BTFSC  FD8.2
2A74:  BRA    2B50
2A76:  ADDWF  00,F
2A78:  BNC   2A82
2A7A:  MOVLW  81
2A7C:  ADDWF  00,F
2A7E:  BC    2B50
2A80:  BRA    2A8A
2A82:  MOVLW  7F
2A84:  SUBWF  00,F
2A86:  BNC   2B50
2A88:  BZ    2B50
2A8A:  MOVFF  1E8,1EF
2A8E:  MOVF   xEC,W
2A90:  XORWF  xEF,F
2A92:  BSF    xE8.7
2A94:  BSF    xEC.7
2A96:  MOVF   xEA,W
2A98:  MULWF  xEE
2A9A:  MOVFF  FF4,1F1
2A9E:  MOVF   xE9,W
2AA0:  MULWF  xED
2AA2:  MOVFF  FF4,03
2AA6:  MOVFF  FF3,1F0
2AAA:  MULWF  xEE
2AAC:  MOVF   FF3,W
2AAE:  ADDWF  xF1,F
2AB0:  MOVF   FF4,W
2AB2:  ADDWFC xF0,F
2AB4:  MOVLW  00
2AB6:  ADDWFC 03,F
2AB8:  MOVF   xEA,W
2ABA:  MULWF  xED
2ABC:  MOVF   FF3,W
2ABE:  ADDWF  xF1,F
2AC0:  MOVF   FF4,W
2AC2:  ADDWFC xF0,F
2AC4:  MOVLW  00
2AC6:  CLRF   02
2AC8:  ADDWFC 03,F
2ACA:  ADDWFC 02,F
2ACC:  MOVF   xE8,W
2ACE:  MULWF  xEE
2AD0:  MOVF   FF3,W
2AD2:  ADDWF  xF0,F
2AD4:  MOVF   FF4,W
2AD6:  ADDWFC 03,F
2AD8:  MOVLW  00
2ADA:  ADDWFC 02,F
2ADC:  MOVF   xE8,W
2ADE:  MULWF  xED
2AE0:  MOVF   FF3,W
2AE2:  ADDWF  03,F
2AE4:  MOVF   FF4,W
2AE6:  ADDWFC 02,F
2AE8:  MOVLW  00
2AEA:  CLRF   01
2AEC:  ADDWFC 01,F
2AEE:  MOVF   xEA,W
2AF0:  MULWF  xEC
2AF2:  MOVF   FF3,W
2AF4:  ADDWF  xF0,F
2AF6:  MOVF   FF4,W
2AF8:  ADDWFC 03,F
2AFA:  MOVLW  00
2AFC:  ADDWFC 02,F
2AFE:  ADDWFC 01,F
2B00:  MOVF   xE9,W
2B02:  MULWF  xEC
2B04:  MOVF   FF3,W
2B06:  ADDWF  03,F
2B08:  MOVF   FF4,W
2B0A:  ADDWFC 02,F
2B0C:  MOVLW  00
2B0E:  ADDWFC 01,F
2B10:  MOVF   xE8,W
2B12:  MULWF  xEC
2B14:  MOVF   FF3,W
2B16:  ADDWF  02,F
2B18:  MOVF   FF4,W
2B1A:  ADDWFC 01,F
2B1C:  INCF   00,F
2B1E:  BTFSC  01.7
2B20:  BRA    2B2C
2B22:  RLCF   xF0,F
2B24:  RLCF   03,F
2B26:  RLCF   02,F
2B28:  RLCF   01,F
2B2A:  DECF   00,F
2B2C:  MOVLW  00
2B2E:  BTFSS  xF0.7
2B30:  BRA    2B46
2B32:  INCF   03,F
2B34:  ADDWFC 02,F
2B36:  ADDWFC 01,F
2B38:  MOVF   01,W
2B3A:  BNZ   2B46
2B3C:  MOVF   02,W
2B3E:  BNZ   2B46
2B40:  MOVF   03,W
2B42:  BNZ   2B46
2B44:  INCF   00,F
2B46:  BTFSC  xEF.7
2B48:  BSF    01.7
2B4A:  BTFSS  xEF.7
2B4C:  BCF    01.7
2B4E:  BRA    2B58
2B50:  CLRF   00
2B52:  CLRF   01
2B54:  CLRF   02
2B56:  CLRF   03
2B58:  MOVLB  0
2B5A:  RETURN 0
*
2CF0:  MOVLB  1
2CF2:  MOVF   xC0,W
2CF4:  CLRF   01
2CF6:  SUBWF  xBF,W
2CF8:  BC    2D00
2CFA:  MOVFF  1BF,00
2CFE:  BRA    2D18
2D00:  CLRF   00
2D02:  MOVLW  08
2D04:  MOVWF  xC1
2D06:  RLCF   xBF,F
2D08:  RLCF   00,F
2D0A:  MOVF   xC0,W
2D0C:  SUBWF  00,W
2D0E:  BTFSC  FD8.0
2D10:  MOVWF  00
2D12:  RLCF   01,F
2D14:  DECFSZ xC1,F
2D16:  BRA    2D06
2D18:  MOVLB  0
2D1A:  RETURN 0
2D1C:  MOVLW  20
2D1E:  MOVLB  1
2D20:  BTFSS  xBA.4
2D22:  MOVLW  30
2D24:  MOVWF  xBB
2D26:  MOVFF  1B9,00
2D2A:  BTFSS  00.7
2D2C:  BRA    2D3E
2D2E:  COMF   00,F
2D30:  INCF   00,F
2D32:  MOVFF  00,1B9
2D36:  MOVLW  2D
2D38:  MOVWF  xBB
2D3A:  BSF    xBA.7
2D3C:  BSF    xBA.0
2D3E:  MOVF   01,W
2D40:  MOVFF  1B9,1BF
2D44:  MOVLW  64
2D46:  MOVWF  xC0
2D48:  MOVLB  0
2D4A:  RCALL  2CF0
2D4C:  MOVFF  00,1B9
2D50:  MOVLW  30
2D52:  ADDWF  01,W
2D54:  MOVLB  1
2D56:  MOVWF  xBC
2D58:  MOVFF  1B9,1BF
2D5C:  MOVLW  0A
2D5E:  MOVWF  xC0
2D60:  MOVLB  0
2D62:  RCALL  2CF0
2D64:  MOVLW  30
2D66:  ADDWF  00,W
2D68:  MOVLB  1
2D6A:  MOVWF  xBE
2D6C:  MOVLW  30
2D6E:  ADDWF  01,W
2D70:  MOVWF  xBD
2D72:  MOVFF  1BB,00
2D76:  MOVLW  30
2D78:  SUBWF  xBC,W
2D7A:  BZ    2D84
2D7C:  BSF    xBA.1
2D7E:  BTFSC  xBA.7
2D80:  BSF    xBA.2
2D82:  BRA    2DA8
2D84:  MOVFF  1BB,1BC
2D88:  MOVLW  20
2D8A:  MOVWF  xBB
2D8C:  MOVLW  30
2D8E:  SUBWF  xBD,W
2D90:  BZ    2D9A
2D92:  BSF    xBA.0
2D94:  BTFSC  xBA.7
2D96:  BSF    xBA.1
2D98:  BRA    2DA8
2D9A:  BTFSS  FD8.2
2D9C:  BSF    xBA.0
2D9E:  BNZ   2DA8
2DA0:  MOVFF  1BC,1BD
2DA4:  MOVLW  20
2DA6:  MOVWF  xBC
2DA8:  BTFSC  xBA.2
2DAA:  BRA    2DB6
2DAC:  BTFSC  xBA.1
2DAE:  BRA    2DC0
2DB0:  BTFSC  xBA.0
2DB2:  BRA    2DCA
2DB4:  BRA    2DD4
2DB6:  MOVFF  1BB,242
2DBA:  MOVLB  0
2DBC:  CALL   16C2
2DC0:  MOVFF  1BC,242
2DC4:  MOVLB  0
2DC6:  CALL   16C2
2DCA:  MOVFF  1BD,242
2DCE:  MOVLB  0
2DD0:  CALL   16C2
2DD4:  MOVFF  1BE,242
2DD8:  MOVLB  0
2DDA:  CALL   16C2
2DDE:  GOTO   36AA (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... //IMPORTANTE: el fuse PLL5 es un predivisor del reloj, que tiene valores 1,2,3,4,5,6,10,12
.................... //Dependiendo del cristal, se debe elegir el PLL para que al dividirlo
.................... //de una frecuencia de 4MHz
.................... #fuses HSPLL, NOWDT, NOPROTECT, NODEBUG, USBDIV, PLL5, CPUDIV1, VREGEN
.................... 
.................... #use delay(clock=48MHz,crystal=20MHz,USB_FULL)
*
15DE:  MOVLW  02
15E0:  MOVWF  FEA
15E2:  MOVLW  20
15E4:  MOVWF  FE9
15E6:  MOVF   FEF,W
15E8:  BZ    1606
15EA:  MOVLW  0F
15EC:  MOVWF  01
15EE:  CLRF   00
15F0:  DECFSZ 00,F
15F2:  BRA    15F0
15F4:  DECFSZ 01,F
15F6:  BRA    15EE
15F8:  MOVLW  8F
15FA:  MOVWF  00
15FC:  DECFSZ 00,F
15FE:  BRA    15FC
1600:  NOP   
1602:  DECFSZ FEF,F
1604:  BRA    15EA
1606:  RETURN 0
*
161E:  MOVLW  01
1620:  MOVLB  2
1622:  SUBWF  x2A,F
1624:  BNC   1640
1626:  MOVLW  02
1628:  MOVWF  FEA
162A:  MOVLW  2A
162C:  MOVWF  FE9
162E:  MOVF   FEF,W
1630:  BZ    1640
1632:  MOVLW  02
1634:  MOVWF  00
1636:  DECFSZ 00,F
1638:  BRA    1636
163A:  BRA    163C
163C:  DECFSZ FEF,F
163E:  BRA    1632
1640:  MOVLB  0
1642:  GOTO   167C (RETURN)
.................... #use FIXED_IO( E_outputs=PIN_E0 )
.................... #use FIXED_IO( A_outputs=PIN_A4 )
.................... #define RF_RESET   PIN_E0
.................... #define INDICATOR_LED PIN_A4
.................... 
.................... 
.................... //#define USB_CABLE_IS_ATTACHED()  input(PIN_B2)
.................... #define USB_CONFIG_VID 0x2405
.................... #define USB_CONFIG_PID 0x000B
.................... #define USB_CONFIG_BUS_POWER 500
.................... 
.................... // if USB_CDC_ISR is defined, then this function will be called
.................... // by the USB ISR when there incoming CDC (virtual com port) data.
.................... // this is useful if you want to port old RS232 code that was use
.................... // #int_rda to CDC.
.................... #define USB_CDC_ISR() RDA_isr()
.................... 
.................... // in order for handle_incoming_usb() to be able to transmit the entire
.................... // USB message in one pass, we need to increase the CDC buffer size from
.................... // the normal size and use the USB_CDC_DELAYED_FLUSH option.
.................... // failure to do this would cause some loss of data.
.................... #define USB_CDC_DELAYED_FLUSH
.................... #define USB_CDC_DATA_LOCAL_SIZE  128
.................... 
.................... 
.................... static void RDA_isr(void);
.................... 
.................... #include <usb_cdc.h>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... ////                            usb_cdc.h                            ////
.................... ////                                                                 ////
.................... //// Library for adding a virtual COM port on your PC over USB using ////
.................... //// the standard Communication Device Class (CDC) specification.    ////
.................... //// Including this file in your code will add all USB code,         ////
.................... //// interrupts, descriptors and handlers required.  No other        ////
.................... //// modifications need to be made.                                  ////
.................... ////                                                                 ////
.................... //// This library creates a virtual RS232 link between the PC and    ////
.................... //// the PIC, therefore the library provided will be familiar to     ////
.................... //// anyone with standard UART stream I/O:                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          ////
.................... ////      character received and waiting in the receive buffer.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  ////
.................... ////      there is no data in the receive buffer it will wait until  ////
.................... ////      there is data in the receive buffer.  If you do not want   ////
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   ////
.................... ////      check if there is data before calling usb_cdc_getc().      ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       ////
.................... ////      buffer.  If the transmit buffer is full it will wait until ////
.................... ////      the transmit buffer is not full before putting the char    ////
.................... ////      into the transmit buffer.  The transmit buffer is read by  ////
.................... ////      the PC very quickly, and therefore the buffer should only  ////
.................... ////      be full for a few milli-seconds.  If you are concerned     ////
.................... ////      and don't want to be stuck in a long or infinite loop,     ////
.................... ////      use usb_cdc_putready() to see if there is space in the     ////
.................... ////      transmit buffer before putting data into the transmit      ////
.................... ////      buffer.                                                    ////
.................... ////                                                                 ////
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    ////
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'ptr' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    ////
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  ////
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    ////
.................... ////     one packet (whereas the other functions will flush the      ////
.................... ////     buffer as soon as the endpoint is free).                    ////
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    ////
.................... ////     was still in use.                                           ////
.................... ////     Will stop copying characters from ptr to the endpoint       ////
.................... ////     buffer once it is full (but it will still return TRUE).     ////
.................... ////     'len' needs to be smaller than the transmit buffer.         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putready() - Returns the number of bytes available      ////
.................... ////     in the TX buffer for storing characters.  If this returns   ////
.................... ////     0 then the buffer is full and waiting for the host (PC)     ////
.................... ////     to read the buffer.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   ////
.................... ////     empty and fully flushed/transmitted to host (PC).           ////
.................... ////                                                                 ////
.................... //// usb_cdc_connected() - Returns TRUE if we received a             ////
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   ////
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        ////
.................... ////      message when the program starts and it opens the virtual   ////
.................... ////      COM port.  This is a simple way to determine if the PC     ////
.................... ////      is ready to display data on a serial terminal program,     ////
.................... ////      but is not garaunteed to work all the time or on other     ////
.................... ////      terminal programs.                                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   ////
.................... ////      if the transmit buffer is full it will skip the char.      ////
.................... ////                                                                 ////
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  ////
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   ////
.................... ////                                                                 ////
.................... //// usb_cdc_break - If the PC has sent a break command, this will   ////
.................... ////       hold the break time (in milli-seconds).  If the PC sends  ////
.................... ////       a value of 0xFFFF the device is supposed to hold the      ////
.................... ////       break until it sends a value of 0                         ////
.................... ////                                                                 ////
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. ////
.................... ////       Of most relevance is the field dte_present, which is the  ////
.................... ////       DTR setting.                                              ////
.................... ////                                                                 ////
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          ////
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   ////
.................... ////       ring, break and more.  See the documentation above        ////
.................... ////       usb_cdc_serial_state() for more information, including    ////
.................... ////       format of state structure.                                ////
.................... ////                                                                 ////
.................... //// The following functions are also provided, and are ports of the ////
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   ////
.................... //// documentation:                                                  ////
.................... ////   get_float_usb() - Read a float number from the user           ////
.................... ////   get_long_usb() - Read a long number from the user             ////
.................... ////   get_int_usb() - Read an integer number from the user          ////
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. ////
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             ////
.................... ////   gethex1_usb() - Read a HEX character                          ////
.................... ////                                                                 ////
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  ////
.................... //// be called when there is incoming CDC (virtual com port) data.   ////
.................... //// This is useful if you want to update legacy RS232 code that     ////
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    ////
.................... //// However, see the INTERRUPT LIMITATIONS section below.           ////
.................... ////                                                                 ////
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    ////
.................... ////  to flush the data as soon as possible.  However at times       ////
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   ////
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         ////
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     ////
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       ////
.................... ////  also attempt to flush the packet on each call to usb_task().   ////
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     ////
.................... ////  if you have a main loop that periodically calls usb_task().    ////
.................... ////                                                                 ////
.................... //// This driver will load all the rest of the USB code, and a set   ////
.................... //// of descriptors that will properly describe a CDC device for a   ////
.................... //// virtual COM port (usb_desc_cdc.h)                               ////
.................... ////                                                                 ////
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      ////
.................... //// standard CDC drivers for a virtual COM port in Windows          ////
.................... //// NT/2000/XP and above.                                           ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// Encapsuated Messages: (USB_CDC_USE_ENCAPSULATED)                ////
.................... //// -------------------------------------------------------------   ////
.................... ////                                                                 ////
.................... //// If USB_CDC_USE_ENCAPSULATED is defined, then the user must      ////
.................... //// provide the following callbacks in their application to provide ////
.................... //// encapsuated message support (SendEncapsulatedCommand and        ////
.................... ////  GetEncapsulatedResponse):                                      ////
.................... ////                                                                 ////
.................... //// usb_cdc_SendEncapsulatedCommand(byte *ptr, unsigned int16 num)  ////
.................... ////     PIC receives encapsulated command from host (PC), 'num'     ////
.................... ////     bytes of message stored in 'ptr'.                           ////
.................... ////                                                                 ////
.................... //// usb_cdc_GetEncapsulatedResponse(byte *ptr, unsigned int16 num)  ////
.................... ////     Host (PC) is asking for 'num' bytes response from the PIC,  ////
.................... ////     PIC should store up to 'num' bytes to 'ptr' as the          ////
.................... ////     response.                                                   ////
.................... ////                                                                 ////
.................... //// Due to the design of the USB stack, all encapsulated messages   ////
.................... //// must be smaller than one endpoint 0 packet.  They cannot be     ////
.................... //// equal in size or larger than the endpoint 0 size.  See          ////
.................... //// USB_MAX_EP0_PACKET_LENGTH.                                      ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// BUFFER SIZES                                                    ////
.................... //// -------------------------------------------------------------   ////
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     ////
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        ////
.................... ////  Full speed devices limit this value to be 64.  To increase     ////
.................... ////  the size of the local PIC buffer you can also define           ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        ////
.................... ////  defined then the total PIC->PC buffer size would be            ////
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  ////
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      ////
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      ////
.................... ////  then this option isn't used.                                   ////
.................... ////                                                                 ////
.................... ////                                                                 ////
.................... //// INTERRUPT LIMITATIONS                                           ////
.................... //// -------------------------------------------------------------   ////
.................... //// This section is only relevant if you are using USB interrupts   ////
.................... ////  and not the USB_ISR_POLLING option.                            ////
.................... ////                                                                 ////
.................... //// USB handling is complex, often requiring several packet         ////
.................... ////  transmissions to accomplish transfer of one block of data.     ////
.................... ////  Most of this processing is done in the USB ISR.  Because       ////
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the ////
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   ////
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  ////
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  ////
.................... ////  overflow the TX buffer than data will be lost.                 ////
.................... ////                                                                 ////
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB ////
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      ////
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           ////
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    ////
.................... ////                                                                 ////
.................... //// ex_usb_serial3.c shows an example of working around these       ////
.................... ////  ISR limitations.  Failure to follow these limitations can      ////
.................... ////  cause the PIC to lockup.  These limtations only need to be     ////
.................... ////  followed in the conditions listed above (writing code in the   ////
.................... ////  ISR or interrupts are disabled).                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// VERSION HISTORY                                                 ////
.................... ////                                                                 ////
.................... //// Nov 20th, 2014:                                                 ////
.................... ////  While usb_cdc_putc() waits for local buffer to be free, also   ////
.................... ////     check the endpoint buffer in case there was a situation     ////
.................... ////     that the ISR for this event was missed.                     ////
.................... ////                                                                 ////
.................... //// Dec 16th, 2013:                                                 ////
.................... ////  Added encapsulated message support.  See                       ////
.................... ////     USB_CDC_USE_ENCAPSULATED above for documentation.           ////
.................... ////                                                                 ////
.................... //// May 31st, 2013:                                                 ////
.................... ////  usb_cdc_putready() now returns the number of bytes available.  ////
.................... ////                                                                 ////
.................... //// May 23rd, 2013:                                                 ////
.................... ////  Added usb_cdc_putd().                                          ////
.................... ////                                                                 ////
.................... //// February 18th, 2013:                                            ////
.................... ////  Enhanced PIC16 support added.                                  ////
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 ////
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    ////
.................... ////                                                                 ////
.................... //// September 13th, 2012:                                           ////
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     ////
.................... ////     (PIC24, dsPIC33).                                           ////
.................... ////  Added usb_cdc_putempty().                                      ////
.................... ////                                                                 ////
.................... //// December 16th, 2011:                                            ////
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will ////
.................... ////     only include the get string helper functions.  This is      ////
.................... ////     a rarely used option, used only if you already wrote your   ////
.................... ////     own getc() and putc() routines.                             ////
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  ////
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      ////
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  ////
.................... ////                                                                 ////
.................... //// Oct 27th, 2011:                                                 ////
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    ////
.................... ////     documentation.  In order for this to work,                  ////
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   ////
.................... ////                                                                 ////
.................... //// Jan 28, 2010:                                                   ////
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    ////
.................... ////     one packet.                                                 ////
.................... ////                                                                 ////
.................... //// Jan 25, 2010:                                                   ////
.................... ////  Ignore incoming 0 length packets.                              ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// April 7th, 2009:                                                ////
.................... ////   Vista 'code 10' issues resolved.                              ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 26th, 2007:                                                 ////
.................... ////              usb_cdc_put_buffer_free() should be more stable.   ////
.................... ////              Fixed a hang-up that would happen if you sent      ////
.................... ////                 exactly 64 bytes.                               ////
.................... ////                                                                 ////
.................... //// Nov 6th, 2007:                                                  ////
.................... ////              Compatabible with latest pic18_usb.h, which        ////
.................... ////                 reduces RAM footprint of USB driver.            ////
.................... ////              This driver now fits on 18F4450/2450 PICs.         ////
.................... ////                                                                 ////
.................... //// October 27th, 2005: Changed the way incoming packets are        ////
.................... ////               handled in that CDC driver will not flush         ////
.................... ////               endpoint until user has handled all data.  This   ////
.................... ////               will prevent overflows as the USB will NAK        ////
.................... ////               incoming packets until it is ready to receive     ////
.................... ////               more.                                             ////
.................... ////            When using 18F4550 family, the RX buffer is          ////
.................... ////               mapped directly to the endpoint buffer - this     ////
.................... ////               saves a chunk of RAM.                             ////
.................... ////            When using the 18F4550 family, you can increase      ////
.................... ////               the TX and RX size over 64 bytes.                 ////
.................... ////            No longer send 0len packets in the TBE interrupt.    ////
.................... ////            Hopefully fixed bugs that caused random crashes      ////
.................... ////               if you tried sending more than 64 bytes.          ////
.................... ////                                                                 ////
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   ////
.................... ////                   buffer.                                       ////
.................... ////                                                                 ////
.................... //// July 1st, 2005: Initial Release.                                ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... //input.c ported to use CDC:
.................... float get_float_usb();
.................... signed long get_long_usb();
.................... signed int get_int_usb();
.................... void get_string_usb(char* s, unsigned int max);
.................... char gethex_usb();
.................... char gethex1_usb();
.................... 
.................... #if !defined(__USB_CDC_HELPERS_ONLY__)
.................... 
.................... //api for the user:
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got)
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free())
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin)
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding)
.................... void usb_cdc_putc_fast(char c);
.................... char usb_cdc_getc(void);
.................... void usb_cdc_putc(char c);
.................... void usb_cdc_get_discard(void);
.................... 
.................... //functions automatically called by USB handler code
.................... void usb_isr_tkn_cdc(void);
.................... void usb_cdc_init(void);
.................... void usb_isr_tok_out_cdc_control_dne(void);
.................... void usb_isr_tok_in_cdc_data_dne(void);
.................... void usb_isr_tok_out_cdc_data_dne(void);
.................... 
.................... void usb_cdc_flush_tx_buffer(void);
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //
.................... // Include the CCS USB Libraries.  See the comments at the top of these
.................... // files for more information
.................... //
.................... /////////////////////////////////////////////////////////////////////////////
.................... #ifndef __USB_PIC_PERIF__
.................... #define __USB_PIC_PERIF__   1
.................... #endif
.................... 
.................... #if __USB_PIC_PERIF__
....................    #if defined(__PCM__)
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c
....................    #elif defined(__PCH__)
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.h                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  This hardware layer      ////
.................... //// supports the USB peripheral on the PIC18 family chips.  Current ////
.................... //// supported families are:                                         ////
.................... ////     PIC18F2455/2550/4455/4550                                   ////
.................... ////     PIC18F2450/4450                                             ////
.................... ////     PIC18F2458/2553/4458/4553                                   ////
.................... ////     PIC18F13K50/14K50                                           ////
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     ////
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       ////
.................... ////     PIC18FxxK50                                                 ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      ////
.................... //// that are specific to only this HW peripheral that you may       ////
.................... //// find useful to use in your application.                         ////
.................... ////                                                                 ////
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    ////
.................... ////  Due to the limited USB RAM of this family, a limitation of     ////
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   ////
.................... ////  The HW actually supports more endpoints, but to simplify       ////
.................... ////  driver development this driver will only support the first 3   ////
.................... ////  so there is an easier memory block to work with.               ////
.................... ////                                                                 ////
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     ////
.................... ////  of USB speed, to save RAM.                                     ////
.................... ////                                                                 ////
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    ////
.................... ////  If you are not using internal pullups, you will need to put    ////
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    ////
.................... ////  want to use slow speed or full speed.  This code configures    ////
.................... ////  the device to use internal pullups, see usb_init() if you      ////
.................... ////  want to change that.                                           ////
.................... ////                                                                 ////
.................... ////  You need approximately 470nF cap on Vusb, even if you are      ////
.................... ////  using the internal 3.3V USB regulator.                         ////
.................... ////                                                                 ////
.................... ////  To run at full speed, you must use the oscillator              ////
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   ////
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     ////
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      ////
.................... ////  96MHz clock.  See the datasheet for details.                   ////
.................... ////                                                                 ////
.................... ////  To run at slow speed you must configure your MCU to run at     ////
.................... ////  24Mhz.  See the datasheet for details.                         ////
.................... ////                                                                 ////
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   ////
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the ////
.................... //// PIC when an event has happened on the USB Bus.  Therfore        ////
.................... //// this code enables interrupts.  A user modification can be made  ////
.................... //// to poll the USB interrupt flag instead of relying on an         ////
.................... //// interrupt.                                                      ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_H__
.................... #DEFINE __PIC18_USB_H__
.................... 
.................... #DEFINE __USB_HARDWARE__
.................... 
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral
.................... #DEFINE __PIC__   1
.................... 
.................... #ifndef USB_USE_FULL_SPEED
....................  #define USB_USE_FULL_SPEED   1
.................... #endif
.................... 
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................    //due to limited ram, force max packet length to 8 for this chip
....................    #define USB_MAX_EP0_PACKET_LENGTH   8
.................... #else
....................    #if USB_USE_FULL_SPEED==0
....................       //slow speed requires 8byte max packet size for endpoint 0
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8
....................    #else
....................       //for full speed you can still use 8bytes, but 64 will be faster
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64
....................    #endif
.................... #endif
.................... #endif
.................... 
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8))
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8
....................  #error Max Endpoint 0 length can't be less than 8!
.................... #endif
.................... 
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64
....................  #error Max Endpoint 0 length can't be greater than 64!
.................... #endif
.................... 
.................... #include <usb_hw_layer.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_hw_layer.h                            ////
.................... ////                                                                   ////
.................... //// HW Layer for the USB Stack.                                       ////
.................... ////                                                                   ////
.................... //// HW drivers for the USB stack must support this API.               ////
.................... ////                                                                   ////
.................... //// The HW driver must also have a token handler that will call       ////
.................... //// usb_token_reset() when the device is init/reset, will call        ////
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          ////
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    ////
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     ////
.................... //// See usb.h for documentation of these functions.                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __USB_HW_LAYER_H__
.................... #define __USB_HW_LAYER_H__
.................... 
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0,
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4};
.................... 
.................... 
.................... // USER LEVEL FUNCTIONS:
.................... 
.................... /*****************************************************************************
.................... /* usb_init()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_init_cs()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_cs(void);
.................... 
.................... /*****************************************************************************
.................... /* usb_task()
.................... /*
.................... /* Summary: See API section of USB.H for documentation.
.................... /*
.................... /*****************************************************************************/
.................... void usb_task(void);
.................... 
.................... /******************************************************************************
.................... /* usb_attach()
.................... /*
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral.
.................... /*
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt.
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_attach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_detach()
.................... /*
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB.
.................... /*
.................... /* Shouldn't be called by user, let usb_task() handle this.
.................... /*
.................... /* If the user does call this function while USB is connected, the USB 
.................... /* peripheral will be disabled only momentarily because usb_task() will
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB
.................... /* reset of the device.
.................... /*
.................... /* NOTE: If you are writing a new HW driver, this routine should call 
.................... /*       usb_token_reset() to reset the CH9 stack.
.................... /*
.................... /*****************************************************************************/
.................... void usb_detach(void);
.................... 
.................... /******************************************************************************
.................... /* usb_put_packet()
.................... /*
.................... /* Input: endpoint - endpoint to send packet to (0..15).
.................... /*        ptr - points to data to send.
.................... /*        len - amount of data to send.
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, 
.................... /*                 or toggle from the last DATAx pid.
.................... /*
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only 
.................... /*         reason it will return FALSE is if because the TX buffer is still full 
.................... /*         from the last time it tried to send a packet.
.................... /*
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a 
.................... /*          difference between a packet and a message.  If you wanted to send a 
.................... /*          512 byte message on an endpoint that only supported 64 byte packets,
.................... /*          this would be accomplished this by sending 8 64-byte packets, 
.................... /*          followed by a 0 length packet.  If the last (or only packet) being 
.................... /*          sent is less than the max packet size defined in your descriptor 
.................... /*          then you do not need to send a 0 length packet to identify
.................... /*          an end of message.
.................... /*
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message 
.................... /*          correctly and know if a 0 lenght packet needs to be sent.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl);
.................... 
.................... /*******************************************************************************
.................... /* usb_get_packet(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer and saved to ptr.
.................... /*
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS!
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()!
.................... /*
.................... /* Summary: Gets a packet of data from the USB endpoint buffer.
.................... /*          Until this is called, if there is data in the receive buffer the
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be
.................... /*          allowed to send a new packet.  Only receives one packet, if you need 
.................... /*          to receive multiple packets or handle 0-length terminator packets,
.................... /*          then use usb_gets().
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /********************************************************************************/
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max);
.................... 
.................... /****************************************************************************
.................... /* usb_kbhit(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check (0..15)
.................... /*
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not.
.................... /*
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers.
.................... /*          See API section of USB.H for more information.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_RX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_kbhit(unsigned int8 en);
.................... 
.................... /******************************************************************************
.................... /* usb_tbe(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last
.................... /*         transmit or if this endpoint is invalid.
.................... /*
.................... /* The result will be invalid if the specified input has not been configured for
.................... /* use by the API with USB_EPx_TX_SIZE
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_tbe(unsigned int8 en);
.................... 
.................... //////////////// END USER LEVEL FUNCTIONS /////////////////////////////////////
.................... 
.................... 
.................... ///
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by
.................... ///            the USB stack, and are not meant to be called by the 
.................... ///            user/application.
.................... ///
.................... 
.................... /*****************************************************************************
.................... /* usb_stall_ep()
.................... /*
.................... /* Input: endpoint - endpoint to stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will
.................... /*          send STALL packet if the host tries to access this endpoint's 
.................... /*          buffer.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_stall_ep(unsigned int8 endpoint);
.................... 
.................... 
.................... /*****************************************************************************
.................... /* usb_unstall_ep(endpoint, direction)
.................... /*
.................... /* Input: endpoint - endpoint to un-stall.
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Summary: Un-stalls endpoint.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... void usb_unstall_ep(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_endpoint_stalled()
.................... /*
.................... /* Input: endpoint - endpoint to check
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not.
.................... /*
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to
.................... /*          see if endpoint has been issued a STALL, just whether or not it is
.................... /*          configured to STALL on the next packet.  See Set_Feature and 
.................... /*          Clear_Feature Chapter 9 requests.
.................... /*
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE
.................... /*       CALLING THIS ROUTINE.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint);
.................... 
.................... /*****************************************************************************
.................... /* usb_set_address(address)
.................... /*
.................... /* Input: address - address the host specified that we use
.................... /*
.................... /* Summary: Configures the USB Peripheral for the specified device address.  
.................... /*          The host will now talk to use with the following address.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_address(unsigned int8 address);
.................... 
.................... /******************************************************************************
.................... /* usb_set_configured()
.................... /*
.................... /* Input: config - Configuration to use.  0 to uncofigure device.
.................... /*
.................... /* Summary: Configures or unconfigures device.  If configuring device it will
.................... /*          enable all the endpoints the user specified for this configuration.
.................... /*          If un-configuring device it will disable all endpoints.
.................... /*
.................... /*          NOTE: CCS only provides code to handle 1 configuration.
.................... /*
.................... /*****************************************************************************/
.................... void usb_set_configured(unsigned int8 config);
.................... 
.................... /******************************************************************************
.................... /* usb_disable_endpoints()
.................... /*
.................... /* Summary: Disables endpoints (all endpoints but 0)
.................... /*
.................... /*****************************************************************************/
.................... void usb_disable_endpoints(void);
.................... 
.................... 
.................... /*******************************************************************************
.................... /* usb_disable_endpoint()
.................... /*
.................... /* Input: Endpoint to disable (0..15)
.................... /*
.................... /* Summary: Disables specified endpoint
.................... /*
.................... /********************************************************************************/
.................... void usb_disable_endpoint(unsigned int8 en);
.................... 
.................... /**************************************************************
.................... /* usb_request_send_response(len)
.................... /* usb_request_get_data()
.................... /* usb_request_stall()
.................... /*
.................... /* Input: len - size of packet to send
.................... /*
.................... /* Summary: One of these 3 functions will be called by the USB stack after
.................... /*          handling a SETUP packet.
.................... /*          
.................... /*          After we process a SETUP request, we have 1 of three responses:
.................... /*            1.) send a response IN packet
.................... /*            2.) wait for followup OUT packet(s) with data
.................... /*            3.) stall because we don't support that SETUP request
.................... /*
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold
.................... /*          the response and the USB Request handler code will call
.................... /*          usb_request_send_response() to let us know how big the packet is.
.................... /*
.................... /*          If we are waiting for more data, usb_request_get_data() will
.................... /*          be called by the USB request handler code to configure the EP0 OUT
.................... /*          endpoint to be ready for more data
.................... /*
.................... /*          If we don't support a request, usb_request_stall() will be called
.................... /*          by the USB request handler code to stall the endpoint 0.
.................... /*
.................... /*          The operation of these functions depends on how SETUP packets
.................... /*          are handled in the hardware layer.
.................... /*
.................... /***************************************************************/
.................... void usb_request_send_response(unsigned int8 len);
.................... void usb_request_get_data(void);
.................... void usb_request_stall(void);
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... //////////////////////// EXTRA USER FUNCTIONS /////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_flush_in()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for transfer
.................... /*        len - length of data that is being tramsferred
.................... /*        tgl - Data toggle synchronization for this packet
.................... /*
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint)
.................... /*
.................... /* Summary: Marks the endpoint ready for transmission.  You must
.................... /*          have already loaded the endpoint buffer with data.
.................... /*          (IN is PIC -> PC).
.................... /*          This routine is useful if you want to setup an endpoint by
.................... /*          writing to the buffer directly.
.................... /*          This routine is not necessary if you use usb_put_packet().
.................... /***************************************************************/
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_flush_out()
.................... /*
.................... /* Input: endpoint - which endpoint to mark for release
.................... /*        tgl - Data toggle synchronization to expect in the next packet
.................... /*
.................... /* Output: NONE
.................... /*
.................... /* Summary: Clears the previously received packet, and then marks this
.................... /*          endpoint's receive buffer as ready for more data.
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not
.................... /*          want to use usb_get_packet(), instead you want to handle with
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size().
.................... /*          This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl);
.................... 
.................... /**************************************************************
.................... /* usb_rx_packet_size()
.................... /*
.................... /* Input: endpoint - which endpoint to mark to check
.................... /*
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer.
.................... /*
.................... /* Summary: Read the number of data stored in the receive buffer.  When you
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint.
.................... /*    This routine is not necessary if you use usb_get_packet().
.................... /***************************************************************/
.................... int16 usb_rx_packet_size(int8 endpoint);
.................... 
.................... #ENDIF
.................... 
....................    #else
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c
....................    #endif
.................... #else
....................    #include <usbn960x.h>
.................... #endif
.................... #ifndef __USB_DESCRIPTORS__
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                         usb_desc_cdc.h                            ////
.................... ////                                                                   ////
.................... //// An example set of device / configuration descriptors for use with ////
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// Oct 27th, 2011:                                                   ////
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     ////
.................... ////     send SERIAL_STATE messages in one packet.                     ////
.................... ////                                                                   ////
.................... //// April 7th, 2009:                                                  ////
.................... ////   Vista 'code 10' issues resolved.                                ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// 10/28/05:                                                         ////
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        ////
.................... ////    packets.                                                       ////
.................... ////    Changed device to USB 1.10                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
.................... #DEFINE __USB_DESCRIPTORS__
.................... 
.................... ///////// config options, although it's best to leave alone for this demo /////
.................... #ifndef  USB_CONFIG_PID
....................    #define  USB_CONFIG_PID       0x000b
.................... #endif
.................... #ifndef  USB_CONFIG_VID
....................    #define  USB_CONFIG_VID       0x2405
.................... #endif
.................... #ifndef  USB_CONFIG_BUS_POWER
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500)
.................... #endif
.................... #ifndef  USB_CONFIG_VERSION
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99
.................... #endif
.................... //////// end config ///////////////////////////////////////////////////////////
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #DEFINE USB_HID_DEVICE  false
.................... #DEFINE USB_CDC_DEVICE  true
.................... 
.................... #define USB_CDC_COMM_IN_ENDPOINT       1
.................... #ifndef USB_CDC_COMM_IN_SIZE
.................... #define USB_CDC_COMM_IN_SIZE           11
.................... #endif
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE
.................... 
.................... //pic to pc endpoint config
.................... #define USB_CDC_DATA_IN_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_IN_SIZE
.................... #define USB_CDC_DATA_IN_SIZE           64
.................... #endif
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE
.................... 
.................... //pc to pic endpoint config
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2
.................... #ifndef USB_CDC_DATA_OUT_SIZE
.................... #define USB_CDC_DATA_OUT_SIZE           64
.................... #endif
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start config descriptor
.................... ///   right now we only support one configuration descriptor.
.................... ///   the config, interface, class, and endpoint goes into this array.
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints)
.................... 
....................    const char USB_CONFIG_DESC[] = {
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE:
....................       //    config(s)
....................       //    interface(s)
....................       //    class(es)
....................       //    endpoint(s)
.................... 
....................    //config_descriptor for config index 1
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3
....................          2, //number of interfaces this device supports       ==4
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5
....................          0x00, //index of string descriptor for this configuration      ==6
....................         #if USB_CONFIG_BUS_POWER
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #else
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7
....................         #endif
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8
.................... 
.................... 
....................    //interface descriptor 0 (comm class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11
....................          0x00, //alternate setting     ==12
....................          1, //number of endpoints   ==13
....................          0x02, //class code, 02 = Comm Interface Class     ==14
....................          0x02, //subclass code, 2 = Abstract     ==15
....................          0x01, //protocol code, 1 = v.25ter      ==16
....................          0x00, //index of string descriptor for interface      ==17
.................... 
....................    //class descriptor [functional header]
....................          5, //length of descriptor    ==18
....................          0x24, //dscriptor type (0x24 == )      ==19
....................          0, //sub type (0=functional header) ==20
....................          0x10,0x01, //      ==21,22 //cdc version
.................... 
....................    //class descriptor [acm header]
....................          4, //length of descriptor    ==23
....................          0x24, //dscriptor type (0x24 == )      ==24
....................          2, //sub type (2=ACM)   ==25
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State.
.................... 
....................    //class descriptor [union header]
....................          5, //length of descriptor    ==27
....................          0x24, //dscriptor type (0x24 == )      ==28
....................          6, //sub type (6=union)    ==29
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union.
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. *
.................... 
....................    //class descriptor [call mgmt header]
....................          5, //length of descriptor    ==32
....................          0x24, //dscriptor type (0x24 == )      ==33
....................          1, //sub type (1=call mgmt)   ==34
....................          0, //capabilities          ==35  //device does not handle call management itself
....................          1, //data interface        ==36  //interface number of data class interface
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43
.................... 
....................    //interface descriptor 1 (data class interface)
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46
....................          0x00, //alternate setting     ==47
....................          2, //number of endpoints   ==48
....................          0x0A, //class code, 0A = Data Interface Class     ==49
....................          0x00, //subclass code      ==50
....................          0x00, //protocol code      ==51
....................          0x00, //index of string descriptor for interface      ==52
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55
....................          0x02, //transfer type supported (0x02 is bulk)         ==56
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58
....................          1,  //polling interval, in ms.   ==59
.................... 
....................    //endpoint descriptor
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62
....................          0x02, //transfer type supported (0x02 is bulk)         ==63
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67
....................          1  //polling interval, in ms.   ==68
....................    };
.................... 
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ********
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find
....................    //  a specific descriptor in the above table.
.................... 
....................    //the maximum number of interfaces seen on any config
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2
....................    #define USB_MAX_NUM_INTERFACES   2
.................... 
....................    //define how many interfaces there are per config.  [0] is the first config, etc.
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2};
.................... 
....................    //define where to find class descriptors
....................    //first dimension is the config number
....................    //second dimension specifies which interface
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface
....................    //if a class descriptor is not valid, set the value to 0xFFFF
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]=
....................    {
....................    //config 1
....................       //interface 0
....................          //class 1-4
....................          18,23,27,32,
....................       //interface 1
....................          //no classes for this interface
....................          0xFF,0xFF,0xFF,0xFF
....................    };
.................... 
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN)
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly
....................    #endif
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start device descriptors
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={
....................       //starts of with device configuration. only one possible
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1
....................          0x10,0x01, //usb version in bcd  ==2,3
....................          0x02, //class code. 0x02=Communication Device Class ==4
....................          0x00, //subclass code ==5
....................          0x00, //protocol code ==6
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14
....................          0x02, //index of string descriptor of the product  ==15
....................          0x00, //index of string descriptor of serial number  ==16
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17
....................    };
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////
.................... ///
.................... ///   start string descriptors
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone.
.................... ///
.................... ///   You must define the length else get_next_string_character() will not see the string
.................... ///   Current code only supports 10 strings (0 thru 9)
.................... ///
.................... //////////////////////////////////////////////////////////////////
.................... 
.................... #if !defined(USB_STRINGS_OVERWRITTEN)
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored.
.................... // Strings are saved as unicode.
.................... // These strings are mostly only displayed during the add hardware wizard.
.................... // Once the operating system drivers have been installed it will usually display
.................... // the name from the drivers .INF.
.................... char const USB_STRING_DESC[]={
....................    //string 0
....................          4, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          0x09,0x04,   //Microsoft Defined for US-English
....................    //string 1  - manufacturer
....................          8, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................    //string 2 - product
....................          32, //length of string index
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING)
....................          'C',0,
....................          'C',0,
....................          'S',0,
....................          ' ',0,
....................          'U',0,
....................          'S',0,
....................          'B',0,
....................          ' ',0,
....................          't',0,
....................          'o',0,
....................          ' ',0,
....................          'U',0,
....................          'A',0,
....................          'R',0,
....................          'T',0
.................... };
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN)
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... struct {
....................    int1 got;
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100
....................    unsigned int16 len;
....................    unsigned int16 index;
....................   #else
....................    unsigned int8 len;
....................    unsigned int8 index;
....................   #endif
.................... } usb_cdc_get_buffer_status;
.................... 
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             usb.c                                 ////
.................... ////                                                                   ////
.................... //// Standard USB request and token handler code.                      ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        ////
.................... //// for more documentation and a list of examples.                    ////
.................... ////                                                                   ////
.................... //// The majority of this code is called and used by the interrupt     ////
.................... //// generated by the hardware level, and therefore it is not meant    ////
.................... //// to be called by the user.  The functions that are meant to be     ////
.................... //// called by the user (init, put packet, get packet, etc) are        ////
.................... //// documented in USB.H.                                              ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////    This code will not create a multiple configuration device.     ////
.................... ////    If you wish to create a multiple configuration device then you ////
.................... ////    will have to modify these drivers.                             ////
.................... ////                                                                   ////
.................... ////   *************************  NOTE  **************************     ////
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    ////
.................... ////   requests.  These requests are optional.  If you want to support ////
.................... ////   these requests you must provide the code yourself.  See         ////
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      ////
.................... ////   support.                                                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// If you wish to provide your own USB peripheral hardware layer, it ////
.................... //// must must provide the API as described in usb_hw_layer.h.         ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... //// March 20, 2015                                                    ////
.................... ////     USB_STRING_DESC_OFFSET no longer used.                        ////
.................... ////                                                                   ////
.................... //// Feb 6th, 2015                                                     ////
.................... ////     Fixed 'len' not being intiailized in usb_gets()               ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// June 8th, 2011:                                                   ////
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  ////
.................... ////     (for no timeout) resolved.                                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// November 13th, 2009:                                              ////
.................... ////  usb_endpoint_is_valid() has an extra check.                      ////
.................... ////                                                                   ////
.................... //// June 9th, 2009:                                                   ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// Dec 14, 2007:                                                     ////
.................... ////  usb_kbhit() moved to device driver.                              ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    ////
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release.                                         ////
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     ////
.................... ////    layer.                                                         ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////  TODO: alot of indexing and length handling for descriptors is    ////
.................... ////   only 8bit, so make sure all descriptor tables are less than     ////
.................... ////   256 bytes long.                                                 ////
.................... ////                                                                   ////
.................... //// Apr 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     ////
.................... ////   usb_ep_tx_size[] defined in usb.h                               ////
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             ////
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  ////
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     ////
.................... ////   the endpoint buffer until you usb_get_packet(), which will      ////
.................... ////   then free the endpoint buffer for more data.  This affects      ////
.................... ////   routines such as usb_gets() and usb_kbhit().                    ////
.................... ////  usb_gets() no longer reads buffered data (see above note),       ////
.................... ////   now it reads multiple packets in the same way usb_puts()        ////
.................... ////   writes multiple packets                                         ////
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  ////
.................... ////   layer.                                                          ////
.................... ////                                                                   ////
.................... //// Nov 11th, 2004:                                                   ////
.................... ////  No longer includes wrong descriptor header.                      ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   ////
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      ////
.................... ////                                                                   ////
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    ////
.................... ////                     although it didn't cause any serious problems ////
.................... ////                                                                   ////
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  ////
.................... ////                     problems with multiple packet messages        ////
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   ////
.................... ////                     descriptors that require a 0 len packet to    ////
.................... ////                     end message.                                  ////
.................... ////                                                                   ////
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_DRIVER__
.................... #DEFINE __USB_DRIVER__
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #else
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) 
....................    {
....................       while(len--)
....................       {
....................          debug_usb_packet(debug_putc, "%02X", *ptr++);
....................       }
....................    }
.................... #endif
.................... 
.................... // legacy
.................... #ifndef debug_usb
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l)
.................... #endif
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #if defined(__PIC16F_USB_H__)
....................  #include <pic16f_usb.c>
.................... #endif
.................... 
.................... #if defined(__PIC18_USB_H__)
....................  #include <pic18_usb.c>
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                          pic18_usb.c                            ////
.................... ////                                                                 ////
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     ////
.................... //// documentation about the PIC18 hardware layer.                   ////
.................... ////                                                                 ////
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      ////
.................... //// for more documentation and a list of examples.                  ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////                                                                 ////
.................... //// Version History:                                                ////
.................... ////                                                                 ////
.................... //// Dec 12, 2016:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Mar 20, 2015:                                                   ////
.................... ////  When TXing a packet, set UOWN bit as a different instruction   ////
.................... ////     as the rest of the BDSTAT flags.  Doing it this way         ////
.................... ////     prevents PIC18F45K50 family USB from locking up.            ////
.................... ////                                                                 ////
.................... //// Mar 1, 2015:                                                    ////
.................... ////  Added __STALL_ON_UEP_ERRATA__ and __UIDLE_JAM_ERRATA__ from    ////
.................... ////     PIC24 USB library, in case those erratas found              ////
.................... ////     their way on the PIC18 USB parts.                           ////
.................... ////                                                                 ////
.................... //// Dec 17, 2013:                                                   ////
.................... ////  Added 18FxxJ9x family support.                                 ////
.................... ////                                                                 ////
.................... //// Dec 11, 2013:                                                   ////
.................... ////  Added some LF part support.                                    ////
.................... ////                                                                 ////
.................... //// Feb 22, 2013:                                                   ////
.................... ////  Added support for 18F45K50 family.                             ////
.................... ////                                                                 ////
.................... //// July 9th, 2012:                                                 ////
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     ////
.................... ////     for non-setup packets on endpoint 0 or all other            ////
.................... ////     endpoints.  This really only affects people using           ////
.................... ////     usb_put_packet() or usb_get_packet() inside of other        ////
.................... ////     interrupts.                                                 ////
.................... ////                                                                 ////
.................... //// Sep 22, 2011:                                                   ////
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   ////
.................... ////     primarily developed for users developing code where         ////
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   ////
.................... ////                                                                 ////
.................... //// Dec 16, 2010:                                                   ////
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           ////
.................... ////                                                                 ////
.................... //// Oct 15th, 2010:                                                 ////
.................... ////  Added initial 18F47J53 family support.                         ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     ////
.................... ////     will not be used.  usb_task() must be called periodically   ////
.................... ////     in your main loop.  If it is not called faster than once    ////
.................... ////     per millisecond, USB may not work.                          ////
.................... ////                                                                 ////
.................... //// Nov 13th, 2009:                                                 ////
.................... ////  usb_disable_endpoint() won't touch BD status registers for     ////
.................... ////     endpoints that aren't allocated.                            ////
.................... ////                                                                 ////
.................... //// June 9th, 2009:                                                 ////
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   ////
.................... ////                                                                 ////
.................... //// May 8th, 2009:                                                  ////
.................... ////  Problems with 18F14K50 fixed.                                  ////
.................... ////  Added 18F46J50 family.                                         ////
.................... ////                                                                 ////
.................... //// March 5th, 2009:                                                ////
.................... ////   18F14K50 family added.                                        ////
.................... ////   Cleanup for Wizard.                                           ////
.................... ////   PIC24 Initial release.                                        ////
.................... ////                                                                 ////
.................... //// Nov 3rd, 2008:                                                  ////
.................... ////  * 4553 family added.                                           ////
.................... ////                                                                 ////
.................... //// Dec 18, 2007:                                                   ////
.................... ////  * usb_kbhit() moved to device driver.                          ////
.................... ////  * USB Token handler changed to workaround a flaw in the USB    ////
.................... ////     peripheral to prevent the USB peripheral from               ////
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   ////
.................... ////     in bulk demo applications, especially CDC.                  ////
.................... ////                                                                 ////
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   ////
.................... ////                 too much RAM.                                   ////
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. //// 
.................... ////                 For the 18F4450/2450 family this should be 8    ////
.................... ////                 because of limited RAM.  Reducing this value    //// 
.................... ////                 frees RAM for application.                      ////
.................... ////             Based upon which endpoints have been configured for ////
.................... ////                 use, will free up unused USB data RAM for       ////
.................... ////                 application dynamically.  This should free up   ////
.................... ////                 at least 128 bytes of RAM.                      ////
.................... ////             CDC now fits on a 18F4450/2450                      ////
.................... ////                                                                 ////
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 ////
.................... ////                                                                 ////
.................... ////   07-17-07: Added 18F4450,2450 support                          ////
.................... ////                                                                 ////
.................... ////   07-13-07: Added 87J50 family support                          ////
.................... ////                                                                 ////
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////
.................... ////               changed for the better.                           ////
.................... ////                                                                 ////
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////
.................... ////                                                                 ////
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////
.................... ////             usb_set_configured() changed for 16bit packet sizes ////
.................... ////                                                                 ////
.................... ////   06-30-05: usb_tbe() added                                     ////
.................... ////             The way endpoint 0 DTS is set has been changed.     ////
.................... ////                                                                 ////
.................... ////   06-20-05: Initial Release                                     ////
.................... ////                                                                 ////
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////
.................... ////                                                                 ////
.................... ////   03-21-05: Initial Alpha Release                               ////
.................... ////                                                                 ////
.................... /////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         ////
.................... //// This source code may only be used by licensed users of the CCS  ////
.................... //// C compiler.  This source code may only be distributed to other  ////
.................... //// licensed users of the CCS C compiler.  No other use,            ////
.................... //// reproduction or distribution is permitted without written       ////
.................... //// permission.  Derivative programs created using this software    ////
.................... //// in object code form are not restricted in any way.              ////
.................... /////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __PIC18_USB_C__
.................... #DEFINE __PIC18_USB_C__
.................... 
.................... // i got these from PIC24 library, but maybe these bugs made their way
.................... // into PIC18 usb peripherals.
.................... // __STALL_ON_UEP_ERRATA__ looked wrong on the PIC24 library.
.................... #define __STALL_ON_UEP_ERRATA__
.................... #define __UIDLE_JAM_ERRATA__
.................... 
.................... #include <usb.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                              usb.h                                ////
.................... ////                                                                   ////
.................... //// Function protypes, defintions and globals used by CCS USB driver  ////
.................... ////                                                                   ////
.................... //// This file is part of CCS's USB driver code                        ////
.................... ////                                                                   ////
.................... //// The following USB examples are provided by CCS:                   ////
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   ////
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             ////
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         ////
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    ////
.................... ////                      interfaces.                                  ////
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   ////
.................... ////                      HID Reports.                                 ////
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          ////
.................... ////                    protocol requiring custom Windows drivers.     ////
.................... ////   ex_usb_serial.c -                                               ////
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     ////
.................... ////     a virtual COM port.                                           ////
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          ////
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     ////
.................... ////        compatible with ex_usb_mouse.c.                            ////
.................... ////                                                                   ////
.................... ////        ********************** API *********************           ////
.................... ////                                                                   ////
.................... //// These are the functions that are meant to be called by the user:  ////
.................... ////                                                                   ////
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    ////
.................... ////              attaches the unit to the usb bus.  Enables           ////
.................... ////              interrupts.  Will wait in an infinite loop until     ////
.................... ////              the device enumerates - if you are using             ////
.................... ////              connection sense or if the processor should run      ////
.................... ////              even if it's not connected to USB then use           ////
.................... ////              usb_init_cs() instead.                               ////
.................... ////                                                                   ////
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        ////
.................... ////              to usb bus or enable interrupts.  Since this does    ////
.................... ////              not attach to the USB, you must periodically call    ////
.................... ////              usb_task().  See usb_task() for more information.    ////
.................... ////                                                                   ////
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        ////
.................... ////        peripheral, usb_task() should then be called periodically  ////
.................... ////        to check the connection sense pin.  If the connection      ////
.................... ////        sense pin denotes USB is connected and the USB peripheral  ////
.................... ////        is not attached, this will attach the USB peripheral       ////
.................... ////        so the PC can start the enumeration process (and it        ////
.................... ////        will enable interrupts).  If the connection sense pin      ////
.................... ////        denotes USB is not attached and the USB peripheral is      ////
.................... ////        running, this will reset the USB peripheral and wait       ////
.................... ////        for USB to reconnect (and usb_enumerated() will start      ////
.................... ////        returning FALSE).  If connection sense macro               ////
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      //// 
.................... ////        assumes that USB is always connected.                      ////
.................... ////                                                                   ////
.................... //// usb_attached() - Returns TRUE if the device is attached to a      ////
.................... ////                  USB cable.  A macro that looks at the defined    ////
.................... ////                  connection sense pin.  If this returns TRUE      ////
.................... ////                  it does not mean the PC has connected to it,     ////
.................... ////                  you need to use usb_enumerated() to check this.  ////
.................... ////                                                                   ////
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     ////
.................... ////                    (configured) by host, FALSE if it has not.     ////
.................... ////                    Do not try to use the USB peripheral for       ////
.................... ////                    sending and receiving packets until you        ////
.................... ////                    are enumerated.                                ////
.................... ////                                                                   ////
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device ////
.................... ////                              is enumerated.                       ////
.................... ////                                                                   ////
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  ////
.................... ////     is free and ready to accept a new packet for transmission.    ////
.................... ////                                                                   ////
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the ////
.................... ////                    host.  If you need to send a message that      ////
.................... ////                    spans more than one packet then use            ////
.................... ////                    usb_puts().  Fore more detailed documentation  ////
.................... ////                    see usb_hw_layer.h                             ////
.................... ////                                                                   ////
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   ////
.................... ////     message to the host.  If you only need to send one packet,    ////
.................... ////     it is more effecient to use usb_put_packet().  This is        ////
.................... ////     documented in more detail above the prototype in USB.H.       ////
.................... ////                                                                   ////
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  ////
.................... ////               from host.  This will remain TRUE until             ////
.................... ////               usb_put_packet() or usb_flush_out() used.           ////
.................... ////               This function will return an invalid response       ////
.................... ////               if specified endpoint is not enabled for            ////
.................... ////               receiving data.                                     ////
.................... ////                                                                   ////
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   ////
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you ////
.................... ////        call this routine or your data may not be valid.  This     ////
.................... ////        only receives one packet, if you are trying to receive a   //// 
.................... ////        multi-packet message use usb_gets().  For more detailed    ////
.................... ////        documentation see usb_hw_layer.h.                          ////
.................... ////                                                                   ////
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       ////
.................... ////        packets from the host, you would use this instead          ////
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   ////
.................... ////        messages.  This is documented in more detail above the     ////
.................... ////        prototype in USB.H.                                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           ////
.................... ////                                                                   ////
.................... //// The following definitions are declared here, but can be           ////
.................... //// overwritten in your code.  Unless needed otherwise, leave         ////
.................... //// to default value.  If confused about a definition read the        ////
.................... //// comments at each defintion                                        ////
.................... ////                                                                   ////
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         ////
.................... ////                            Set_Idle HID class request.  Set to    ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Idle / Get_Idle command)   ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code.  See            ////
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  ////
.................... ////                            usb.c                                  ////
.................... ////                                                                   ////
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   ////
.................... ////                            Set_Protocl HID class request. Set to  ////
.................... ////                            False if you do not (device will       ////
.................... ////                            send a Wrong-state if computer         ////
.................... ////                            sends a Set_Protocl / Get_Protocol     ////
.................... ////                            command).                              ////
.................... ////                            NOTE: If you set to TRUE you must      ////
.................... ////                            provide your own code in the           ////
.................... ////                            application that properly send boot    ////
.................... ////                            or HID packets.                        ////
.................... ////                                                                   ////
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   ////
.................... ////                            The hardware level driver (ex          ////
.................... ////                            pic18_usb.h will define this value if  ////
.................... ////                            not already overwritten).  Increasing  ////
.................... ////                            this size will speed up the            ////
.................... ////                            enumeration process.                   ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this RX (PC to device) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for receiving    ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    ////
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      ////
.................... ////               endpoint.                                           ////
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          ////
.................... ////                         endpoint number. Change this define       ////
.................... ////                         to specify what kind of transfer method   ////
.................... ////                         this TX (device to PC) endpoint uses.     ////
.................... ////                       Here is the list of valid transfer methods: ////
.................... ////                             USB_ENABLE_CONTROL                    ////
.................... ////                             USB_ENABLE_ISOCHRONOUS                ////
.................... ////                             USB_ENABLE_BULK                       ////
.................... ////                             USB_ENABLE_INTERRUPT                  ////
.................... ////                             USB_ENABLE_DISABLED                   ////
.................... ////                        Don't forget that you must specify the     ////
.................... ////                        transfer method properly in your endpoint  ////
.................... ////                        descriptor, too.                           ////
.................... ////                                                                   ////
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   ////
.................... ////                       how much memory to reserve for transmitting ////
.................... ////                       packets.                                    ////
.................... ////                                                                   ////
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    ////
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      ////
.................... ////               endpoint.                                           ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  ////
.................... ////                         HID requests.  You can disable to save    ////
.................... ////                         ROM space if you are not using a HID      ////
.................... ////                         device.  If you are not using a HID       ////
.................... ////                         device you must provide your own O/S      ////
.................... ////                         (Windows) driver.                         ////
.................... ////                                                                   ////
.................... //// The other definitions should not be changed.                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// Version History:                                                  ////
.................... ////                                                                   ////
.................... ////  Feb 18th, 2013                                                   ////
.................... ////     Added some extra checks to make sure packet size are legal    ////
.................... ////        for USB speed.                                             ////
.................... ////                                                                   ////
.................... ////  April 2nd, 2012                                                  ////
.................... ////     Initial version of CDC+HID composite device support           ////
.................... ////                                                                   ////
.................... //// Oct 15th, 2010:                                                   ////
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    ////
.................... ////  Added initial 18F47J53 family support.                           ////
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       ////
.................... ////     will not be used.  usb_task() must be called periodically     ////
.................... ////     in your main loop.  If it is not called faster than once      ////
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     ////
.................... ////                                                                   ////
.................... //// September 24th, 2010:                                             ////
.................... ////  Many descriptor files had the self powered bit set incorrectly   ////
.................... ////     based on USB_CONFIG_BUS_POWER.                                ////
.................... ////                                                                   ////
.................... //// September 9th, 2010:                                              ////
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards ////
.................... ////     in HID report descriptor of usb_desc_hid.h                    ////
.................... ////                                                                   ////
.................... //// September 2nd, 2010:                                              ////
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    ////
.................... ////     (dsPIC, PIC24) resolved.                                      ////
.................... ////                                                                   ////
.................... //// August 31st, 2010:                                                ////
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             ////
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                ////
.................... ////                                                                   ////
.................... //// April 28th, 2010:                                                 ////
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          ////
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       ////
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          ////
.................... ////     compatibility).                                               ////
.................... ////                                                                   ////
.................... //// Nov 13th, 2009:                                                   ////
.................... ////  usb_endpoint_is_valid() prototyped.                              ////
.................... ////                                                                   ////
.................... //// March 5th, 2009:                                                  ////
.................... ////   Cleanup for Wizard.                                             ////
.................... ////   PIC24 Initial release.                                          ////
.................... ////                                                                   ////
.................... //// July 13th, 2005:                                                  ////
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          ////
.................... ////                                                                   ////
.................... //// June 20th, 2005:                                                  ////
.................... ////  Initial 18fxx5x release                                          ////
.................... ////                                                                   ////
.................... //// May 13th, 2005:                                                   ////
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            ////
.................... ////  Now supports multiple interfaces (many defines in descriptors    ////
.................... ////   will have to be changed, see examples)                          ////
.................... ////                                                                   ////
.................... //// Mar 21st, 2005:                                                   ////
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     ////
.................... ////   WITH 18F4550)                                                   ////
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    ////
.................... ////                                                                   ////
.................... //// June 24th, 2004:                                                  ////
.................... ////  Optimization and cleanup.                                        ////
.................... ////                The following definitions changed:                 ////
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  ////
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 ////
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               ////
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         ////
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 ////
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           ////
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              ////
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        ////
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                ////
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          ////
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         ////
.................... ////                                 USB_STRING_DESC_OFFSET[]          ////
.................... ////  dev_req, curr_config, status_device and getdesc_type global      ////
.................... ////        variables moved into struct USB_stack_status               ////
.................... ////                                                                   ////
.................... //// October 15th, 2003: Support for boot protocol added.              ////
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        ////
.................... ////         The array hid_protocol[] saves which protocol mode each   ////
.................... ////         interface is in.  It is your applications job to send     ////
.................... ////         data that either fit the boot protocol or HID protocol.   ////
.................... ////                                                                   ////
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         ////
.................... ////                                                                   ////
.................... //// October 29th, 2002: New definition added to USB_STATES            ////
.................... ////                                                                   ////
.................... //// August 2nd, 2002: Initial Public Release                          ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS    ////
.................... //// C compiler.  This source code may only be distributed to other    ////
.................... //// licensed users of the CCS C compiler.  No other use,              ////
.................... //// reproduction or distribution is permitted without written         ////
.................... //// permission.  Derivative programs created using this software      ////
.................... //// in object code form are not restricted in any way.                ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #IFNDEF __USB_PROTOTYPES__
.................... #DEFINE __USB_PROTOTYPES__
.................... 
.................... #include <stdbool.h>
.................... 
.................... //// CONFIGURATION ////////////////////////////////////////////////////////////
.................... 
.................... #if defined(USB_CON_SENSE_PIN)
....................  #undef USB_CABLE_IS_ATTACHED
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN)
.................... #endif
.................... 
.................... #IFNDEF USB_HID_BOOT_PROTOCOL
....................    #DEFINE USB_HID_BOOT_PROTOCOL false
.................... #ENDIF
.................... 
.................... #IFNDEF USB_HID_IDLE
....................    #DEFINE USB_HID_IDLE false
.................... #ENDIF
.................... 
.................... //should the compiler add the extra HID handler code?  Defaults to yes.
.................... #IFNDEF USB_HID_DEVICE
....................    #DEFINE USB_HID_DEVICE true
.................... #ENDIF
.................... 
.................... #IFNDEF USB_CDC_DEVICE
....................    #DEFINE USB_CDC_DEVICE false
.................... #ENDIF
.................... 
.................... //set to false to opt for less RAM, true to opt for less ROM
.................... #ifndef USB_OPT_FOR_ROM
....................    #define USB_OPT_FOR_ROM true
.................... #endif
.................... 
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8
.................... #ENDIF
.................... 
.................... 
.................... ////// USER-LEVEL API /////////////////////////////////////////////////////////
.................... 
.................... /**************************************************************
.................... /* usb_enumerated()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /* Returns: Returns a 1 if device is configured / enumerated,
.................... /*          Returns a 0 if device is un-configured / not enumerated.
.................... /*
.................... /* Summary: See API section of USB.H for more documentation.
.................... /***************************************************************/
.................... int1 usb_enumerated(void);
.................... 
.................... /**************************************************************
.................... /* usb_wait_for_enumeration()
.................... /*
.................... /* Input: Global variable USB_Curr_Config
.................... /*
.................... /* Summary: Waits in-definately until device is configured / enumerated.
.................... /*          See API section of USB.H for more information.
.................... /***************************************************************/
.................... void usb_wait_for_enumeration(void);
.................... 
.................... /****************************************************************************
.................... /* usb_gets(endpoint, ptr, max, timeout)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - place / array to store data to
.................... /*        max - max amount of data to get from USB and store into ptr
.................... /*         timeout - time in milliseconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Output: Amount of data returned.  It may be less than max.
.................... /*
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages
.................... /*          and finish when either it receives a 0-len packet or a packet
.................... /*          of less size than maximum.
.................... /*
.................... /*****************************************************************************/
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout);
.................... 
.................... /****************************************************************************
.................... /* usb_puts()
.................... /*
.................... /* Inputs: endpoint - endpoint to send data out
.................... /*         ptr - points to array of data to send
.................... /*         len - amount of data to send
.................... /*         timeout - time in milli-seconds, for each packet, to wait before 
.................... /*                   timeout.  set to 0 for no timeout.
.................... /*
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not
.................... /*    sent before timeout period expired.
.................... /*
.................... /* Summary: Used for sending multiple packets of data as one message.  This
.................... /*       function can still be used to send messages consiting of only one 
.................... /*       packet.  See usb_put_packet() documentation for the rules about when 
.................... /*       multiple packet messages or 0-lenght packets are needed.
.................... /*
.................... /*****************************************************************************/
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout);
.................... 
.................... /******************************************************************************
.................... /* usb_attached()
.................... /*
.................... /* Summary: Returns TRUE if the device is attached to a USB cable.
.................... /*          See the API section of USB.H for more documentation.
.................... /*
.................... /*****************************************************************************/
.................... #if defined(USB_CABLE_IS_ATTACHED)
....................  #define usb_attached() USB_CABLE_IS_ATTACHED()
.................... #else
....................  #define usb_attached() true
.................... #endif
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint);
.................... 
.................... 
.................... ////// END USER-LEVEL API /////////////////////////////////////////////////////
.................... 
.................... 
.................... ////// STACK-LEVEL API USED BY HW DRIVERS ////////////////////////////////////
.................... 
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0};
.................... 
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3};
.................... 
.................... #if USB_OPT_FOR_ROM
.................... typedef struct {
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #else
.................... typedef struct {
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS)
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling
.................... } TYPE_USB_STACK_STATUS;
.................... #endif
.................... 
.................... extern TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... /**************************************************************
.................... /* usb_token_reset()
.................... /*
.................... /* Output:  No output (but many global registers are modified)
.................... /*
.................... /* Summary: Resets the token handler to initial (unconfigured) state.
.................... /***************************************************************/
.................... void usb_token_reset(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_setup_dne()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet.
.................... /*
.................... /* Output: None (many globals are changed)
.................... /*
.................... /* Summary: This function is that handles the setup token.
.................... /*          We must handle all relevant requests, such as Set_Configuration, 
.................... /*          Get_Descriptor, etc.
.................... /*
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the 
.................... /*  following records:
.................... /*  -------------------------------------------------------------------------------------------
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes
.................... /*                              bit7   (0) host-to-device
.................... /*                                     (1) device-to-host
.................... /*                              bit6-5 (00) usb standard request;
.................... /*                                     (01) class request;
.................... /*                                     (10) vendor request
.................... /*                                     (11) reserved
.................... /*                              bit4-0 (0000) device
.................... /*                                     (0001) interface
.................... /*                                     (0010) endpoint
.................... /*                                     (0011) other element
.................... /*                                     (0100) to (1111) reserved
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint...
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet;
.................... /*    for host-to-device, this exactly how many bytes in data packet.
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet.
.................... /***************************************************************/
.................... void usb_isr_tok_setup_dne(void);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_out_dne()
.................... /*
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15)
.................... /*
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy 
.................... /*          incoming to the pic), but not out setup tokens.  Normally when
.................... /*          data is received it is left in the buffer (user would use
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain
.................... /*          libraries (like CDC) have to answer setup packets.
.................... /*          
.................... /***************************************************************/
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint);
.................... 
.................... /**************************************************************
.................... /* usb_isr_tok_in_dne(endpoint)
.................... /*
.................... /* Input: endpoint - which endpoint we are processing a setup token.
.................... /*
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if
.................... /*    if the buffer is ready for a new transmit packet (there are special cases,
.................... /*    like CDC which handles the CDC protocl).
.................... /*
.................... /***************************************************************/
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint);
.................... 
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS /////////////////////////////////
.................... 
.................... 
.................... //CCS only supports one configuration at this time
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE
.................... 
.................... //PID values for tokens (see page 48 of USB Complete ed.1)
.................... #define PID_IN       0x09  //device to host transactions
.................... #define PID_OUT      0x01  //host to device transactions
.................... #define PID_SETUP    0x0D  //host to device setup transaction
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet
.................... #define PID_DATA0    0x03  //data packet with even sync bit
.................... #define PID_SOF      0x05  //start of framer marker and frame number
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted
.................... 
.................... //Key which identifies descritpors
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22
.................... #define USB_DESC_IAD_TYPE        0x0b
.................... 
.................... //The length of each descriptor
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7
.................... #define USB_DESC_IAD_LEN         8
.................... 
.................... //Standard USB Setup bRequest Codes
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C
.................... 
.................... //HID Class Setup bRequest Codes
.................... #define USB_HID_REQUEST_GET_REPORT     0x01
.................... #define USB_HID_REQUEST_GET_IDLE       0x02
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03
.................... #define USB_HID_REQUEST_SET_REPORT     0x09
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B
.................... 
.................... //types of endpoints as defined in the descriptor
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01
.................... #define USB_ENDPOINT_TYPE_BULK         0x02
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03
.................... 
.................... //types of endpoints used internally in this api
.................... #define USB_ENABLE_DISABLED     -1
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL
.................... 
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS
.................... 
.................... //--------- endpoint 0 defines ----------
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #ifndef USB_EP1_TX_ENABLE
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP1_RX_ENABLE
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_RX_SIZE
....................   #undef USB_EP1_RX_SIZE
....................  #endif
....................  #define USB_EP1_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_RX_SIZE
....................   #error You enabled EP1 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP1_TX_SIZE
....................   #undef USB_EP1_TX_SIZE
....................  #endif
....................  #define USB_EP1_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP1_TX_SIZE
....................   #error You enabled EP1 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #ifndef USB_EP2_TX_ENABLE
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP2_RX_ENABLE
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_RX_SIZE
....................   #undef USB_EP2_RX_SIZE
....................  #endif
....................  #define USB_EP2_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_RX_SIZE
....................   #error You enabled EP2 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP2_TX_SIZE
....................   #undef USB_EP2_TX_SIZE
....................  #endif
....................  #define USB_EP2_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP2_TX_SIZE
....................   #error You enabled EP2 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #ifndef USB_EP3_TX_ENABLE
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP3_RX_ENABLE
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_RX_SIZE
....................   #undef USB_EP3_RX_SIZE
....................  #endif
....................  #define USB_EP3_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_RX_SIZE
....................   #error You enabled EP3 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP3_TX_SIZE
....................   #undef USB_EP3_TX_SIZE
....................  #endif
....................  #define USB_EP3_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP3_TX_SIZE
....................   #error You enabled EP3 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #ifndef USB_EP4_TX_ENABLE
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP4_RX_ENABLE
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_RX_SIZE
....................   #undef USB_EP4_RX_SIZE
....................  #endif
....................  #define USB_EP4_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_RX_SIZE
....................   #error You enabled EP4 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP4_TX_SIZE
....................   #undef USB_EP4_TX_SIZE
....................  #endif
....................  #define USB_EP4_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP4_TX_SIZE
....................   #error You enabled EP4 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #ifndef USB_EP5_TX_ENABLE
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP5_RX_ENABLE
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_RX_SIZE
....................   #undef USB_EP5_RX_SIZE
....................  #endif
....................  #define USB_EP5_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_RX_SIZE
....................   #error You enabled EP5 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP5_TX_SIZE
....................   #undef USB_EP5_TX_SIZE
....................  #endif
....................  #define USB_EP5_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP5_TX_SIZE
....................   #error You enabled EP5 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #ifndef USB_EP6_TX_ENABLE
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP6_RX_ENABLE
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_RX_SIZE
....................   #undef USB_EP6_RX_SIZE
....................  #endif
....................  #define USB_EP6_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_RX_SIZE
....................   #error You enabled EP6 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP6_TX_SIZE
....................   #undef USB_EP6_TX_SIZE
....................  #endif
....................  #define USB_EP6_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP6_TX_SIZE
....................   #error You enabled EP6 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #ifndef USB_EP7_TX_ENABLE
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP7_RX_ENABLE
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_RX_SIZE
....................   #undef USB_EP7_RX_SIZE
....................  #endif
....................  #define USB_EP7_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_RX_SIZE
....................   #error You enabled EP7 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP7_TX_SIZE
....................   #undef USB_EP7_TX_SIZE
....................  #endif
....................  #define USB_EP7_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP7_TX_SIZE
....................   #error You enabled EP7 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #ifndef USB_EP8_TX_ENABLE
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP8_RX_ENABLE
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_RX_SIZE
....................   #undef USB_EP8_RX_SIZE
....................  #endif
....................  #define USB_EP8_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_RX_SIZE
....................   #error You enabled EP8 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP8_TX_SIZE
....................   #undef USB_EP8_TX_SIZE
....................  #endif
....................  #define USB_EP8_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP8_TX_SIZE
....................   #error You enabled EP8 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #ifndef USB_EP9_TX_ENABLE
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP9_RX_ENABLE
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_RX_SIZE
....................   #undef USB_EP9_RX_SIZE
....................  #endif
....................  #define USB_EP9_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_RX_SIZE
....................   #error You enabled EP9 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP9_TX_SIZE
....................   #undef USB_EP9_TX_SIZE
....................  #endif
....................  #define USB_EP9_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP9_TX_SIZE
....................   #error You enabled EP9 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #ifndef USB_EP10_TX_ENABLE
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP10_RX_ENABLE
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_RX_SIZE
....................   #undef USB_EP10_RX_SIZE
....................  #endif
....................  #define USB_EP10_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_RX_SIZE
....................   #error You enabled EP10 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP10_TX_SIZE
....................   #undef USB_EP10_TX_SIZE
....................  #endif
....................  #define USB_EP10_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP10_TX_SIZE
....................   #error You enabled EP10 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #ifndef USB_EP11_TX_ENABLE
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP11_RX_ENABLE
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_RX_SIZE
....................   #undef USB_EP11_RX_SIZE
....................  #endif
....................  #define USB_EP11_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_RX_SIZE
....................   #error You enabled EP11 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP11_TX_SIZE
....................   #undef USB_EP11_TX_SIZE
....................  #endif
....................  #define USB_EP11_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP11_TX_SIZE
....................   #error You enabled EP11 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #ifndef USB_EP12_TX_ENABLE
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP12_RX_ENABLE
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_RX_SIZE
....................   #undef USB_EP12_RX_SIZE
....................  #endif
....................  #define USB_EP12_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_RX_SIZE
....................   #error You enabled EP12 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP12_TX_SIZE
....................   #undef USB_EP12_TX_SIZE
....................  #endif
....................  #define USB_EP12_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP12_TX_SIZE
....................   #error You enabled EP12 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #ifndef USB_EP13_TX_ENABLE
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP13_RX_ENABLE
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_RX_SIZE
....................   #undef USB_EP13_RX_SIZE
....................  #endif
....................  #define USB_EP13_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_RX_SIZE
....................   #error You enabled EP13 for RX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP13_TX_SIZE
....................   #undef USB_EP13_TX_SIZE
....................  #endif
....................  #define USB_EP13_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP13_TX_SIZE
....................   #error You enabled EP13 for TX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #ifndef USB_EP14_TX_ENABLE
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP14_RX_ENABLE
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_RX_SIZE
....................   #undef USB_EP14_RX_SIZE
....................  #endif
....................  #define USB_EP14_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_RX_SIZE
....................   #error You enabled EP14 for RX but didn't specify endpoint size
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP14_TX_SIZE
....................   #undef USB_EP14_TX_SIZE
....................  #endif
....................  #define USB_EP14_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP14_TX_SIZE
....................   #error You enabled EP14 for TX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #ifndef USB_EP15_TX_ENABLE
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... #ifndef USB_EP15_RX_ENABLE
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED
.................... #endif
.................... 
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_RX_SIZE
....................   #undef USB_EP15_RX_SIZE
....................  #endif
....................  #define USB_EP15_RX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_RX_SIZE
....................   #error You enabled EP15 for RX but didn't specify endpoint size
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED
....................  #ifdef USB_EP15_TX_SIZE
....................   #undef USB_EP15_TX_SIZE
....................  #endif
....................  #define USB_EP15_TX_SIZE 0
.................... #else
....................  #ifndef USB_EP15_TX_SIZE
....................   #error You enabled EP15 for TX but didn't specify endpoint size
....................  #endif  
.................... #endif
.................... 
.................... const unsigned int8 usb_ep_tx_type[16]={
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE,
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE,
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE,
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE,
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE,
....................   USB_EP15_TX_ENABLE
.................... };
.................... 
.................... const unsigned int8 usb_ep_rx_type[16]={
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE,
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE,
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE,
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE,
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE,
....................   USB_EP15_RX_ENABLE
.................... };
.................... 
.................... const unsigned int16 usb_ep_tx_size[16]={
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE,
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE,
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE,
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE,
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE,
....................   USB_EP15_TX_SIZE
.................... };
.................... 
.................... const unsigned int16 usb_ep_rx_size[16]={
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE,
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE,
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE,
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE,
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE,
....................   USB_EP15_RX_SIZE
.................... };
.................... 
.................... #ENDIF
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #ifndef debug_usb_control
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_token
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n)
.................... #endif
.................... 
.................... #ifndef debug_usb_packet
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
....................    #define debug_display_ram(len, ptr)
.................... #endif
.................... 
.................... #bit USBIE=getenv("BIT:USBIE")
.................... 
.................... //if you are worried that the PIC is not receiving packets because a bug in the
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on
.................... //receiving.
.................... #ifndef USB_IGNORE_RX_DTS
....................  #define USB_IGNORE_RX_DTS false
.................... #endif
.................... 
.................... #ifndef USB_IGNORE_TX_DTS
....................  #define USB_IGNORE_TX_DTS false
.................... #endif
.................... 
.................... // if only USB_BDT_START is defined, then BDT has a fixed location in RAM
.................... //    but endpoint memory can be anywhere on the PIC.
.................... // if only USB_RAM_START is defined, then both BDT and endpoint have a fixed
.................... //    location in RAM (BDT first, endpoint second).
.................... // if USB_BDT_START and USB_RAM_START are both defined, then BDT has a fixed
.................... //    location in RAM and the endpoint buffers have a different location
.................... //    in RAM.
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50"))
....................  #define __USB_87J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \
....................        (getenv("DEVICE")=="PIC18F24K50") || \
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \
....................        (getenv("DEVICE")=="PIC18LF24K50"))
....................  #define __USB_45K50__
....................  #define USB_TOTAL_RAM_SPACE  1024
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50"))
....................  #define __USB_46J50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || \
....................        (getenv("DEVICE")=="PIC18LF2450") || (getenv("DEVICE")=="PIC18LF4450"))
....................  #define __USB_4450__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50"))
....................  #define __USB_K50__ //backwards compatability
....................  #define __USB_14K50__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100)
....................  #define USB_RAM_START  0x200
....................  #define USB_NUM_UEP 8
....................  //technically this device supports 8 endpoints, but for RAM reasons you should
....................  //attempt to only use the first 3 endpoints.
....................  #define USB_LAST_ALLOWED_ENDPOINT  3
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") || \
....................        (getenv("DEVICE")=="PIC18LF2455") || (getenv("DEVICE")=="PIC18LF2550") || \
....................        (getenv("DEVICE")=="PIC18LF4455") || (getenv("DEVICE")=="PIC18LF4550") || \
....................        (getenv("DEVICE")=="PIC18LF2458") || (getenv("DEVICE")=="PIC18LF2553") || \
....................        (getenv("DEVICE")=="PIC18LF4458") || (getenv("DEVICE")=="PIC18LF4553") \
....................        )
....................  #define __USB_4550__
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400)
....................  #define USB_RAM_START  0x400
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") || \
....................        (getenv("DEVICE")=="PIC18LF26J53") || (getenv("DEVICE")=="PIC18LF27J53") || \ 
....................        (getenv("DEVICE")=="PIC18LF46J53") || (getenv("DEVICE")=="PIC18LF47J53") \       
....................        )
....................  #define __USB_18FJ53__
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use
....................  #define USB_BDT_START  0xD00
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16
.................... #elif ((getenv("DEVICE")=="PIC18F97J94") ||  \ 
....................        (getenv("DEVICE")=="PIC18F87J94") ||  \
....................        (getenv("DEVICE")=="PIC18F67J94") ||  \
....................        (getenv("DEVICE")=="PIC18F96J99") ||  \
....................        (getenv("DEVICE")=="PIC18F86J99") ||  \
....................        (getenv("DEVICE")=="PIC18F66J99") ||  \
....................        (getenv("DEVICE")=="PIC18F96J94") ||  \
....................        (getenv("DEVICE")=="PIC18F86J94") ||  \
....................        (getenv("DEVICE")=="PIC18F66J94") ||  \
....................        (getenv("DEVICE")=="PIC18F95J94") ||  \
....................        (getenv("DEVICE")=="PIC18F85J94") ||  \
....................        (getenv("DEVICE")=="PIC18F65J94"))
....................  #define __USB_18FJ94__
....................  #define USB_BDT_START  0x100
....................  #define USB_NUM_UEP 16
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library.
.................... #endif
.................... 
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  15
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  14
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  13
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  12
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  11
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  10
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  9
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  8
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  7
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  6
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  5
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  4
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  3
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  2
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE
....................  #define USB_LAST_DEFINED_ENDPOINT  1
.................... #else
....................  #define USB_LAST_DEFINED_ENDPOINT  0
.................... #endif
.................... 
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8)
.................... 
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)
.................... 
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT)
....................  #error You are trying to use an invalid endpoint for this hardware!
.................... #endif
.................... 
.................... typedef struct
.................... {
....................    unsigned int8 stat;
....................    unsigned int8 cnt;
....................    unsigned int16 addr;
.................... } STRUCT_BD;
.................... 
.................... #if defined(USB_RAM_START) && !defined(USB_BDT_START)
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       struct
....................       {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................       } bd[USB_LAST_DEFINED_ENDPOINT+1];
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM.buffer)
....................    
....................    #locate g_USBRAM=USB_RAM_START
....................    
....................    #define g_USBBDT g_USBRAM.bd
.................... #else
....................    #if defined(USB_TOTAL_RAM_SPACE)
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE)
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle
....................    #endif
....................    #endif
....................    
....................    struct
....................    {
....................       union
....................       {
....................          struct
....................          {
....................             unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];
....................             
....................             //these buffer definitions needed for CDC library
....................            #if USB_EP1_RX_SIZE
....................             unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE];
....................            #endif
....................            #if USB_EP1_TX_SIZE
....................             unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE];
....................            #endif
....................            #if USB_EP2_RX_SIZE
....................             unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE];
....................            #endif
....................            #if USB_EP2_TX_SIZE
....................             unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE];
....................            #endif
....................          };
....................          unsigned int8 general[USB_DATA_BUFFER_NEEDED];
....................       } buffer;
....................    } g_USBRAM;
....................    
....................    #if defined(USB_RAM_START)
....................       #locate g_USBRAM=USB_RAM_START
....................    #endif
....................    
....................    #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM)
....................    
....................    struct
....................    {
....................          STRUCT_BD out;    //pc -> pic
....................          STRUCT_BD in;     //pc <- pic
....................    } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1];
....................    
....................    #locate g_USBBDT=USB_BDT_START
.................... #endif
.................... 
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer
.................... 
.................... //these buffer definitions needed for CDC library
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer
.................... 
.................... //if you enable this it will keep a counter of the 6 possible errors the
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time.
.................... #if !defined(USB_USE_ERROR_COUNTER)
....................    #define USB_USE_ERROR_COUNTER false
.................... #endif
.................... 
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints
.................... 
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS!
.................... #if !defined(USB_PING_PONG_MODE)
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF
.................... #endif
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................    unsigned int ERROR_COUNTER[6];
.................... #endif
.................... 
.................... //---pic18fxx5x memory locations
.................... #if defined(__USB_4550__) || defined(__USB_4450__)
....................    #byte UFRML   =  0xF66
....................    #byte UFRMH   =  0xF67
....................    #byte UIR     =  0xF68
....................    #byte UIE     =  0xF69
....................    #byte UEIR    =  0xF6A
....................    #byte UEIE    =  0xF6B
....................    #byte U1STAT   =  0xF6C
....................    #byte UCON    =  0xF6D
....................    #byte UADDR   =  0xF6E
....................    #byte UCFG    =  0xF6F
....................    #define  UEP0_LOC 0xF70
.................... #elif defined(__USB_46J50__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #elif defined(__USB_14K50__)
....................    #byte UFRML   =  0xF5D
....................    #byte UFRMH   =  0xF5E
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF60
....................    #byte UEIR    =  0xF5F
....................    #byte UEIE    =  0xF5B
....................    #byte U1STAT   =  0xF63
....................    #byte UCON    =  0xF64
....................    #byte UADDR   =  0xF5C
....................    #byte UCFG    =  0xF61
....................    #define  UEP0_LOC 0xF53
.................... #elif defined(__USB_18FJ53__)
....................    #byte UFRML   =  0xF60
....................    #byte UFRMH   =  0xF61
....................    #byte UIR     =  0xF62
....................    #byte UIE     =  0xF36
....................    #byte UEIR    =  0xF63
....................    #byte UEIE    =  0xF37
....................    #byte U1STAT   =  0xF64
....................    #byte UCON    =  0xF65
....................    #byte UADDR   =  0xF38
....................    #byte UCFG    =  0xF39
....................    #define  UEP0_LOC 0xF26
.................... #else
....................    #byte UFRML = getenv("SFR:UFRML")
....................    #byte UFRMH = getenv("SFR:UFRMH")
....................    #byte UIR = getenv("SFR:UIR")
....................    #byte UIE = getenv("SFR:UIE")
....................    #byte UEIR = getenv("SFR:UEIR")
....................    #byte UEIE = getenv("SFR:UEIE")
....................    #byte U1STAT = getenv("SFR:USTAT")
....................    #byte UCON = getenv("SFR:UCON")
....................    #byte UADDR = getenv("SFR:UADDR")
....................    #byte UCFG = getenv("SFR:UCFG")
.................... #endif
.................... 
.................... unsigned int8 USTATCopy;
.................... 
.................... unsigned int8 g_UEP[USB_NUM_UEP];
.................... #if defined(UEP0_LOC)
.................... #locate g_UEP=UEP0_LOC
.................... #else
.................... #locate g_UEP=getenv("SFR:UEP0")
.................... #endif
.................... #define UEP(x) g_UEP[x]
.................... 
.................... #define BIT_SOF   6
.................... #define BIT_STALL 5
.................... #define BIT_IDLE  4
.................... #define BIT_TRN   3
.................... #define BIT_ACTV  2
.................... #define BIT_UERR  1
.................... #define BIT_URST  0
.................... 
.................... #BIT UIR_SOF = UIR.BIT_SOF
.................... #BIT UIR_STALL = UIR.BIT_STALL
.................... #BIT UIR_IDLE = UIR.BIT_IDLE
.................... #BIT UIR_TRN = UIR.BIT_TRN
.................... #BIT UIR_ACTV = UIR.BIT_ACTV
.................... #BIT UIR_UERR = UIR.BIT_UERR
.................... #BIT UIR_URST = UIR.BIT_URST
.................... 
.................... #BIT UIE_SOF = UIE.BIT_SOF
.................... #BIT UIE_STALL = UIE.BIT_STALL
.................... #BIT UIE_IDLE = UIE.BIT_IDLE
.................... #BIT UIE_TRN = UIE.BIT_TRN
.................... #BIT UIE_ACTV = UIE.BIT_ACTV
.................... #BIT UIE_UERR = UIE.BIT_UERR
.................... #BIT UIE_URST = UIE.BIT_URST
.................... 
.................... #if getenv("BIT_VALID:PPBRST")
....................    #bit UCON_PPBRST = getenv("BIT:PPBRST")
.................... #endif
.................... #bit UCON_SE0=UCON.5
.................... #bit UCON_PKTDIS=UCON.4
.................... #bit UCON_USBEN=UCON.3
.................... #bit UCON_RESUME=UCON.2
.................... #bit UCON_SUSPND=UCON.1
.................... 
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF)
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr
.................... #else
.................... #error Right now this driver only supports no ping pong
.................... #endif
.................... 
.................... //See UEPn (0xF70-0xF7F)
.................... #define ENDPT_DISABLED   0x00   //endpoint not used
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions
.................... 
.................... //Define the states that the USB interface can be in
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3,
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state;
.................... 
.................... //--BDendST has their PIDs upshifed 2
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction
.................... 
.................... #define USTAT_IN_E0        4
.................... #define USTAT_OUT_SETUP_E0 0
.................... 
.................... #define __USB_UIF_RESET    0x01
.................... #define __USB_UIF_ERROR    0x02
.................... #define __USB_UIF_ACTIVE   0x04
.................... #define __USB_UIF_TOKEN    0x08
.................... #define __USB_UIF_IDLE     0x10
.................... #define __USB_UIF_STALL    0x20
.................... #define __USB_UIF_SOF      0x40
.................... 
.................... #if USB_USE_ERROR_COUNTER
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET
.................... #else
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET
.................... #endif
.................... 
.................... #define __USB_UCFG_UTEYE   0x80
.................... #if defined(__USB_4550__)
....................  #define __USB_UCFG_UOEMON  0x40
.................... #endif
.................... #define __USB_UCFG_UPUEN   0x10
.................... #if !defined(__USB_14K50__)
....................  #define __USB_UCFG_UTRDIS  0x08
.................... #endif
.................... #define __USB_UCFG_FSEN    0x04
.................... 
.................... #if defined(USB_EXTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  0
.................... #endif
.................... 
.................... #if defined(USB_INTERNAL_PULLUPS)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if !defined(__USB_UCFG_MY_UPUEN)
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN
.................... #endif
.................... 
.................... #if USB_USE_FULL_SPEED
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE)
.................... #else
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE);
.................... #endif
.................... 
.................... #if defined(__USB_UCFG_UTRDIS)
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS
.................... #else
....................  #define __UCFG_VAL_DISABLED__   0
.................... #endif
.................... 
.................... 
.................... unsigned int8 __setup_0_tx_size;
.................... 
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only
.................... void usb_handle_interrupt();
.................... void usb_isr_rst();
.................... void usb_isr_uerr();
.................... void usb_isr_sof(void);
.................... void usb_isr_activity();
.................... void usb_isr_uidle();
.................... void usb_isr_tok_dne();
.................... void usb_isr_stall(void);
.................... void usb_init_ep0_setup(void);
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... void usb_isr(void);
.................... #endif
.................... 
.................... //// BEGIN User Functions:
.................... 
.................... // see usb_hw_layer.h for more documentation
.................... int1 usb_kbhit(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7)));
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_tbe(unsigned int8 en)
.................... {
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7)));
*
0E3C:  CLRF   03
0E3E:  MOVLB  2
0E40:  MOVF   x6A,W
0E42:  ADDLW  70
0E44:  MOVWF  FE9
0E46:  MOVLW  0F
0E48:  ADDWFC 03,W
0E4A:  MOVWF  FEA
0E4C:  MOVF   FEF,F
0E4E:  BZ    0E86
0E50:  CLRF   x6C
0E52:  MOVFF  26A,26B
0E56:  CLRF   x6E
0E58:  MOVLW  08
0E5A:  MOVWF  x6D
0E5C:  MOVLB  0
0E5E:  CALL   04AE
0E62:  MOVFF  02,26C
0E66:  MOVFF  01,26B
0E6A:  MOVLW  04
0E6C:  MOVLB  2
0E6E:  ADDWF  x6B,F
0E70:  MOVLW  00
0E72:  ADDWFC x6C,F
0E74:  MOVFF  26B,FE9
0E78:  MOVLW  04
0E7A:  ADDWF  x6C,W
0E7C:  MOVWF  FEA
0E7E:  MOVFF  FEF,26D
0E82:  BTFSS  x6D.7
0E84:  BRA    0E8A
0E86:  MOVLW  00
0E88:  BRA    0E8C
0E8A:  MOVLW  01
0E8C:  MOVWF  01
0E8E:  MOVLB  0
0E90:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_detach(void)
.................... {
....................    UCON_SUSPND = 0;
*
1536:  BCF    F6D.1
....................    UCON = 0;  //disable USB hardware
1538:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts
153A:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__;
153C:  MOVLW  08
153E:  MOVWF  F6F
.................... 
....................    // set D+/D- to inputs
....................   #if defined(__USB_87J50__)
....................    set_tris_f(get_tris_f() | 0x18);
....................   #elif defined(__USB_14K50__)
....................    set_tris_a(get_tris_a() | 0x3);
....................   #elif defined(__USB_18FJ94__)
....................    output_float(PIN_F4);
....................    output_float(PIN_F3);
....................   #elif !defined(USB_PIC_NO_USB_GPIO)
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5
1540:  MOVF   F94,W
1542:  IORLW  30
1544:  MOVLB  1
1546:  MOVWF  F94
....................   #endif
....................   
....................    usb_state = USB_STATE_DETACHED;
1548:  CLRF   22
154A:  CLRF   19
154C:  BTFSC  FF2.7
154E:  BSF    19.7
1550:  BCF    FF2.7
....................    
....................    usb_token_reset();              //clear the chapter9 stack
1552:  MOVLB  0
1554:  CALL   059E
1558:  BTFSC  19.7
155A:  BSF    FF2.7
155C:  GOTO   1562 (RETURN)
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_attach(void) 
*
156C:  CLRF   19
156E:  BTFSC  FF2.7
1570:  BSF    19.7
1572:  BCF    FF2.7
.................... {
....................    usb_token_reset();
1574:  CALL   059E
1578:  BTFSC  19.7
157A:  BSF    FF2.7
....................    UCON_SUSPND = 0;
157C:  BCF    F6D.1
....................    UCON = 0;
157E:  CLRF   F6D
....................   #if getenv("BIT_VALID:PPBRST")
....................    UCON_PPBRST = 1;
1580:  BSF    F6D.6
....................    delay_cycles(5);
1582:  BRA    1584
1584:  BRA    1586
1586:  NOP   
....................    UCON_PPBRST = 0;
1588:  BCF    F6D.6
....................   #endif
....................    UCFG = __UCFG_VAL_ENABLED__;
158A:  MOVLW  14
158C:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts
158E:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus
1590:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h
1592:  MOVLW  01
1594:  MOVWF  22
1596:  GOTO   15B4 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init_cs(void)
.................... {
....................    usb_detach();
*
1560:  BRA    1536
1562:  GOTO   15D2 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_task(void) 
.................... {
....................   #if defined(USB_ISR_POLLING)
....................    if (interrupt_active(INT_USB))
....................    {
....................       usb_isr();
....................    }
....................   #endif
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_enumerated())
*
159A:  RCALL  1566
159C:  MOVF   01,F
159E:  BZ    15AE
15A0:  CLRF   19
15A2:  BTFSC  FF2.7
15A4:  BSF    19.7
15A6:  BCF    FF2.7
....................    {
....................       usb_cdc_flush_tx_buffer();
15A8:  RCALL  1254
15AA:  BTFSC  19.7
15AC:  BSF    FF2.7
....................    }
....................   #endif
.................... 
....................    if (usb_attached()) 
....................    {
....................       if (UCON_USBEN==0) 
15AE:  BTFSC  F6D.3
15B0:  BRA    15B4
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: ATTACH");
....................          usb_attach();
15B2:  BRA    156C
....................       }
....................    }
....................    else 
....................    {
....................       if (UCON_USBEN==1)  
....................       {
....................          debug_usb_control(debug_putc, "\r\n\nUSB TASK: DE-ATTACH");
....................          usb_detach();
....................       }
....................    }
.................... 
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) 
15B4:  DECFSZ 22,W
15B6:  BRA    15CE
15B8:  BTFSC  F6D.5
15BA:  BRA    15CE
....................    {
....................       UIR = 0;
15BC:  CLRF   F68
....................       UIE = 0;
15BE:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING)
....................       enable_interrupts(INT_USB);
15C0:  BSF    FA0.5
....................       enable_interrupts(GLOBAL);
15C2:  MOVLW  C0
15C4:  IORWF  FF2,F
....................      #endif
....................       UIE = __USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR
15C6:  MOVLW  11
15C8:  MOVWF  F69
....................      #if USB_USE_ERROR_COUNTER
....................       UIE |= __USB_UIF_ERROR;
....................      #endif
....................       usb_state=USB_STATE_POWERED;
15CA:  MOVLW  02
15CC:  MOVWF  22
....................       debug_usb_control(debug_putc, "\r\n\nUSB TASK: POWERED");
....................    }
15CE:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_init(void) 
.................... {
....................    usb_init_cs();
15D0:  BRA    1560
.................... 
....................    do 
....................    {
....................       usb_task();
15D2:  RCALL  159A
....................    } while (usb_state != USB_STATE_POWERED);
15D4:  MOVF   22,W
15D6:  SUBLW  02
15D8:  BNZ   15D2
15DA:  GOTO   3DFE (RETURN)
.................... }
.................... 
.................... 
.................... // see pic18_usb.h for documentation
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
.................... 
....................    debug_usb_packet(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len);
.................... 
....................    if (usb_tbe(endpoint)) 
*
0E92:  MOVFF  265,26A
0E96:  RCALL  0E3C
0E98:  MOVF   01,F
0E9A:  BTFSC  FD8.2
0E9C:  BRA    0FD4
....................    {
....................       EP_BDxCNT_I(endpoint)=len;
0E9E:  MOVLB  2
0EA0:  CLRF   x6C
0EA2:  MOVFF  265,26B
0EA6:  CLRF   x6E
0EA8:  MOVLW  08
0EAA:  MOVWF  x6D
0EAC:  MOVLB  0
0EAE:  CALL   04AE
0EB2:  MOVFF  02,26B
0EB6:  MOVFF  01,26A
0EBA:  MOVLW  04
0EBC:  MOVLB  2
0EBE:  ADDWF  x6A,F
0EC0:  MOVLW  00
0EC2:  ADDWFC x6B,F
0EC4:  MOVLW  01
0EC6:  ADDWF  x6A,W
0EC8:  MOVWF  01
0ECA:  MOVLW  00
0ECC:  ADDWFC x6B,W
0ECE:  MOVWF  03
0ED0:  MOVFF  01,FE9
0ED4:  MOVLW  04
0ED6:  ADDWF  03,W
0ED8:  MOVWF  FEA
0EDA:  MOVFF  266,FEF
.................... 
....................       debug_display_ram(len, EP_BDxADR_I(endpoint));
.................... 
....................      #if USB_IGNORE_TX_DTS
....................       i=0x80;
....................      #else
....................       if (tgl == USB_DTS_TOGGLE) 
0EDE:  MOVF   x68,W
0EE0:  SUBLW  02
0EE2:  BNZ   0F24
....................       {
....................          i = EP_BDxST_I(endpoint);
0EE4:  CLRF   x6C
0EE6:  MOVFF  265,26B
0EEA:  CLRF   x6E
0EEC:  MOVLW  08
0EEE:  MOVWF  x6D
0EF0:  MOVLB  0
0EF2:  CALL   04AE
0EF6:  MOVFF  02,26B
0EFA:  MOVFF  01,26A
0EFE:  MOVLW  04
0F00:  MOVLB  2
0F02:  ADDWF  x6A,F
0F04:  MOVLW  00
0F06:  ADDWFC x6B,F
0F08:  MOVFF  26A,FE9
0F0C:  MOVLW  04
0F0E:  ADDWF  x6B,W
0F10:  MOVWF  FEA
0F12:  MOVFF  FEF,269
....................          if (bit_test(i,6))
0F16:  BTFSS  x69.6
0F18:  BRA    0F1E
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0F1A:  CLRF   x68
0F1C:  BRA    0F22
....................          else
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0F1E:  MOVLW  01
0F20:  MOVWF  x68
....................       }
0F22:  BRA    0F58
....................       else if (tgl == USB_DTS_USERX) 
0F24:  MOVF   x68,W
0F26:  SUBLW  04
0F28:  BNZ   0F58
....................       {
....................          i = EP_BDxST_O(endpoint);
0F2A:  CLRF   x6C
0F2C:  MOVFF  265,26B
0F30:  CLRF   x6E
0F32:  MOVLW  08
0F34:  MOVWF  x6D
0F36:  MOVLB  0
0F38:  CALL   04AE
0F3C:  MOVLB  2
0F3E:  MOVFF  01,FE9
0F42:  MOVLW  04
0F44:  ADDWF  02,W
0F46:  MOVWF  FEA
0F48:  MOVFF  FEF,269
....................          if (bit_test(i,6))
0F4C:  BTFSS  x69.6
0F4E:  BRA    0F56
....................             tgl = USB_DTS_DATA1;
0F50:  MOVLW  01
0F52:  MOVWF  x68
0F54:  BRA    0F58
....................          else
....................             tgl = USB_DTS_DATA0;
0F56:  CLRF   x68
....................       }
....................       if (tgl == USB_DTS_DATA1) 
0F58:  DECFSZ x68,W
0F5A:  BRA    0F62
....................          i=0x48;  //DATA1, UOWN  //change mar2015
0F5C:  MOVLW  48
0F5E:  MOVWF  x69
0F60:  BRA    0F66
....................       else //if (tgl == USB_DTS_DATA0) 
....................          i=0x08; //DATA0, UOWN   //change mar2015
0F62:  MOVLW  08
0F64:  MOVWF  x69
....................      #endif
.................... 
....................       //set BC8 and BC9
....................       //if (bit_test(len,8)) {bit_set(i,0);}
....................       //if (bit_test(len,9)) {bit_set(i,1);}
.................... 
....................       debug_usb_packet(debug_putc, " %X", i);
.................... 
....................       EP_BDxST_I(endpoint) = i;  //save changes
0F66:  CLRF   x6C
0F68:  MOVFF  265,26B
0F6C:  CLRF   x6E
0F6E:  MOVLW  08
0F70:  MOVWF  x6D
0F72:  MOVLB  0
0F74:  CALL   04AE
0F78:  MOVFF  02,26B
0F7C:  MOVFF  01,26A
0F80:  MOVLW  04
0F82:  MOVLB  2
0F84:  ADDWF  x6A,F
0F86:  MOVLW  00
0F88:  ADDWFC x6B,F
0F8A:  MOVFF  26A,FE9
0F8E:  MOVLW  04
0F90:  ADDWF  x6B,W
0F92:  MOVWF  FEA
0F94:  MOVFF  269,FEF
....................       
....................       EP_BDxST_I(endpoint) |= 0x80; //change mar2015
0F98:  CLRF   x6C
0F9A:  MOVFF  265,26B
0F9E:  CLRF   x6E
0FA0:  MOVLW  08
0FA2:  MOVWF  x6D
0FA4:  MOVLB  0
0FA6:  CALL   04AE
0FAA:  MOVFF  02,26B
0FAE:  MOVFF  01,26A
0FB2:  MOVLW  04
0FB4:  MOVLB  2
0FB6:  ADDWF  x6A,F
0FB8:  MOVLW  00
0FBA:  ADDWFC x6B,F
0FBC:  MOVFF  26A,FE9
0FC0:  MOVLW  04
0FC2:  ADDWF  x6B,W
0FC4:  MOVWF  FEA
0FC6:  MOVF   FEF,W
0FC8:  IORLW  80
0FCA:  MOVWF  FEF
....................       
....................       //putc('!');
....................       
....................       return(1);
0FCC:  MOVLW  01
0FCE:  MOVWF  01
0FD0:  BRA    0FDA
....................    }
0FD2:  MOVLB  0
....................    else 
....................    {
....................       //putc('_');
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
....................    return(0);
0FD4:  MOVLW  00
0FD6:  MOVWF  01
0FD8:  MOVLB  2
0FDA:  MOVLB  0
0FDC:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 * buff_add;    
.................... 
....................    if (usb_tbe(endpoint)) 
*
10DA:  MOVFF  25D,26A
10DE:  RCALL  0E3C
10E0:  MOVF   01,F
10E2:  BZ    1172
....................    {
....................       buff_add = EP_BDxADR_I(endpoint);
10E4:  MOVLB  2
10E6:  CLRF   x6C
10E8:  MOVFF  25D,26B
10EC:  CLRF   x6E
10EE:  MOVLW  08
10F0:  MOVWF  x6D
10F2:  MOVLB  0
10F4:  CALL   04AE
10F8:  MOVFF  02,266
10FC:  MOVFF  01,265
1100:  MOVLW  04
1102:  MOVLB  2
1104:  ADDWF  x65,F
1106:  MOVLW  00
1108:  ADDWFC x66,F
110A:  MOVLW  02
110C:  ADDWF  x65,W
110E:  MOVWF  01
1110:  MOVLW  00
1112:  ADDWFC x66,W
1114:  MOVWF  03
1116:  MOVFF  01,FE9
111A:  MOVLW  04
111C:  ADDWF  03,W
111E:  MOVWF  FEA
1120:  MOVFF  FEC,264
1124:  MOVF   FED,F
1126:  MOVFF  FEF,263
....................       memcpy(buff_add, ptr, len);     
112A:  MOVFF  264,FEA
112E:  MOVFF  263,FE9
1132:  MOVFF  25F,FE2
1136:  MOVFF  25E,FE1
113A:  MOVFF  261,02
113E:  MOVFF  260,01
1142:  MOVF   01,F
1144:  BZ    114A
1146:  INCF   02,F
1148:  BRA    114E
114A:  MOVF   02,F
114C:  BZ    115A
114E:  MOVFF  FE6,FEE
1152:  DECFSZ 01,F
1154:  BRA    114E
1156:  DECFSZ 02,F
1158:  BRA    114E
....................       
....................       return(usb_flush_in(endpoint, len, tgl));
115A:  MOVFF  25D,265
115E:  MOVFF  261,267
1162:  MOVFF  260,266
1166:  MOVFF  262,268
116A:  MOVLB  0
116C:  RCALL  0E92
116E:  MOVF   01,W
1170:  BRA    1176
....................    }
....................    else 
....................    {
....................       //putc('-');
....................       //printf("%X", EP_BDxST_I(endpoint));
....................       debug_usb_packet(debug_putc,"\r\nPUT ERR");
....................    }
.................... 
....................    return(0);
1172:  MOVLW  00
1174:  MOVWF  01
1176:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) 
.................... {
....................    unsigned int8 i;
....................    unsigned int16 len;
.................... 
....................   #if USB_IGNORE_RX_DTS
....................    if (tgl == USB_DTS_STALL) 
....................    {
....................       debug_usb_token(debug_putc, '*');
....................       EP_BDxCNT_O(endpoint) = 0x84;
....................       EP_BDxST_I(endpoint) = 0x84;
....................       return;
....................    }
....................    else
....................       i=0x80;
....................   #else
....................    i = EP_BDxST_O(endpoint);
*
0D3C:  MOVLB  2
0D3E:  CLRF   x6C
0D40:  MOVFF  25C,26B
0D44:  CLRF   x6E
0D46:  MOVLW  08
0D48:  MOVWF  x6D
0D4A:  MOVLB  0
0D4C:  CALL   04AE
0D50:  MOVLB  2
0D52:  MOVFF  01,FE9
0D56:  MOVLW  04
0D58:  ADDWF  02,W
0D5A:  MOVWF  FEA
0D5C:  MOVFF  FEF,25E
....................    if (tgl == USB_DTS_TOGGLE) 
0D60:  MOVF   x5D,W
0D62:  SUBLW  02
0D64:  BNZ   0D72
....................    {
....................       if (bit_test(i,6))
0D66:  BTFSS  x5E.6
0D68:  BRA    0D6E
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0
0D6A:  CLRF   x5D
0D6C:  BRA    0D72
....................       else
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1
0D6E:  MOVLW  01
0D70:  MOVWF  x5D
....................    }
....................    if (tgl == USB_DTS_STALL) 
0D72:  MOVF   x5D,W
0D74:  SUBLW  03
0D76:  BNZ   0DB0
....................    {
....................       i = 0x84;
0D78:  MOVLW  84
0D7A:  MOVWF  x5E
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints
0D7C:  CLRF   x6C
0D7E:  MOVFF  25C,26B
0D82:  CLRF   x6E
0D84:  MOVLW  08
0D86:  MOVWF  x6D
0D88:  MOVLB  0
0D8A:  CALL   04AE
0D8E:  MOVFF  02,262
0D92:  MOVFF  01,261
0D96:  MOVLW  04
0D98:  MOVLB  2
0D9A:  ADDWF  x61,F
0D9C:  MOVLW  00
0D9E:  ADDWFC x62,F
0DA0:  MOVFF  261,FE9
0DA4:  MOVLW  04
0DA6:  ADDWF  x62,W
0DA8:  MOVWF  FEA
0DAA:  MOVLW  84
0DAC:  MOVWF  FEF
....................    }
0DAE:  BRA    0DBE
....................    else if (tgl == USB_DTS_DATA1)
0DB0:  DECFSZ x5D,W
0DB2:  BRA    0DBA
....................       i = 0xC8;  //DATA1, UOWN
0DB4:  MOVLW  C8
0DB6:  MOVWF  x5E
0DB8:  BRA    0DBE
....................    else //if (tgl == USB_DTS_DATA0) 
....................       i = 0x88; //DATA0, UOWN
0DBA:  MOVLW  88
0DBC:  MOVWF  x5E
....................   #endif
.................... 
....................    //bit_clear(__usb_kbhit_status,endpoint);
.................... 
....................    len = usb_ep_rx_size[endpoint];
0DBE:  BCF    FD8.0
0DC0:  RLCF   x5C,W
0DC2:  CLRF   03
0DC4:  MOVLB  0
0DC6:  CALL   011E
0DCA:  TBLRD*+
0DCC:  MOVFF  FF5,03
0DD0:  MOVLB  2
0DD2:  MOVWF  x5F
0DD4:  MOVFF  03,260
....................    EP_BDxCNT_O(endpoint) = len;
0DD8:  CLRF   x6C
0DDA:  MOVFF  25C,26B
0DDE:  CLRF   x6E
0DE0:  MOVLW  08
0DE2:  MOVWF  x6D
0DE4:  MOVLB  0
0DE6:  CALL   04AE
0DEA:  MOVFF  01,261
0DEE:  MOVLW  01
0DF0:  MOVLB  2
0DF2:  ADDWF  01,W
0DF4:  MOVWF  01
0DF6:  MOVLW  00
0DF8:  ADDWFC 02,W
0DFA:  MOVWF  03
0DFC:  MOVFF  01,FE9
0E00:  MOVLW  04
0E02:  ADDWF  03,W
0E04:  MOVWF  FEA
0E06:  MOVFF  25F,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);}
0E0A:  BTFSS  x60.0
0E0C:  BRA    0E10
0E0E:  BSF    x5E.0
....................    if (bit_test(len,9)) {bit_set(i,1);}
0E10:  BTFSS  x60.1
0E12:  BRA    0E16
0E14:  BSF    x5E.1
.................... 
....................    EP_BDxST_O(endpoint) = i;
0E16:  CLRF   x6C
0E18:  MOVFF  25C,26B
0E1C:  CLRF   x6E
0E1E:  MOVLW  08
0E20:  MOVWF  x6D
0E22:  MOVLB  0
0E24:  CALL   04AE
0E28:  MOVLB  2
0E2A:  MOVFF  01,FE9
0E2E:  MOVLW  04
0E30:  ADDWF  02,W
0E32:  MOVWF  FEA
0E34:  MOVFF  25E,FEF
0E38:  MOVLB  0
0E3A:  RETURN 0
.................... }
.................... 
.................... // see pic18_usb.h for documentation
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint) 
.................... {
....................    return(EP_BDxCNT_O(endpoint));
*
1026:  MOVLB  2
1028:  CLRF   x6C
102A:  MOVFF  25C,26B
102E:  CLRF   x6E
1030:  MOVLW  08
1032:  MOVWF  x6D
1034:  MOVLB  0
1036:  CALL   04AE
103A:  MOVFF  02,25E
103E:  MOVFF  01,25D
1042:  MOVLW  01
1044:  MOVLB  2
1046:  ADDWF  01,W
1048:  MOVWF  01
104A:  MOVLW  00
104C:  ADDWFC 02,W
104E:  MOVWF  03
1050:  MOVFF  01,FE9
1054:  MOVLW  04
1056:  ADDWF  03,W
1058:  MOVWF  FEA
105A:  MOVFF  FEF,01
105E:  CLRF   02
1060:  MOVLB  0
1062:  GOTO   1086 (RETURN)
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN Hardware layer functions required by USB.
.................... 
.................... /*****************************************************************************
.................... /* usb_get_packet_buffer(endpoint, *ptr, max)
.................... /*
.................... /* Input: endpoint - endpoint to get data from
.................... /*        ptr - where to save data to local PIC RAM
.................... /*        max - max amount of data to receive from buffer
.................... /*
.................... /* Output: the amount of data taken from the buffer.
.................... /*
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC 
.................... /*          RAM.
.................... /*          Does not mark the endpoint as ready for more data.  Once you are
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready
.................... /*          to receive more data.
.................... /*
.................... /*****************************************************************************/
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) 
.................... {
....................    unsigned int8 * al;
....................    unsigned int8 st;
....................    unsigned int16 i;
.................... 
....................    al = EP_BDxADR_O(endpoint);
....................    i = EP_BDxCNT_O(endpoint);
....................    st = EP_BDxST_O(endpoint);
.................... 
....................    //read BC8 and BC9
....................    if (bit_test(st,0)) {bit_set(i,8);}
....................    if (bit_test(st,1)) {bit_set(i,9);}
.................... 
....................    if (i < max) {max = i;}
....................    
....................    memcpy(ptr, al ,max);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max)
.................... {
....................    max = usb_get_packet_buffer(endpoint, ptr, max);
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE);
.................... 
....................    return(max);
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_stall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=s%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0B22:  MOVLB  2
0B24:  BCF    x5C.0
0B26:  BTFSC  x5B.7
0B28:  BSF    x5C.0
....................    endpoint &= 0x7F;
0B2A:  BCF    x5B.7
....................    
....................    if (direction) 
0B2C:  BTFSS  x5C.0
0B2E:  BRA    0B62
....................    {
....................       EP_BDxST_I(endpoint) = 0x84;
0B30:  CLRF   x6C
0B32:  MOVFF  25B,26B
0B36:  CLRF   x6E
0B38:  MOVLW  08
0B3A:  MOVWF  x6D
0B3C:  MOVLB  0
0B3E:  RCALL  04AE
0B40:  MOVFF  02,25E
0B44:  MOVFF  01,25D
0B48:  MOVLW  04
0B4A:  MOVLB  2
0B4C:  ADDWF  x5D,F
0B4E:  MOVLW  00
0B50:  ADDWFC x5E,F
0B52:  MOVFF  25D,FE9
0B56:  MOVLW  04
0B58:  ADDWF  x5E,W
0B5A:  MOVWF  FEA
0B5C:  MOVLW  84
0B5E:  MOVWF  FEF
....................    }
0B60:  BRA    0B82
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x84;
0B62:  CLRF   x6C
0B64:  MOVFF  25B,26B
0B68:  CLRF   x6E
0B6A:  MOVLW  08
0B6C:  MOVWF  x6D
0B6E:  MOVLB  0
0B70:  RCALL  04AE
0B72:  MOVLB  2
0B74:  MOVFF  01,FE9
0B78:  MOVLW  04
0B7A:  ADDWF  02,W
0B7C:  MOVWF  FEA
0B7E:  MOVLW  84
0B80:  MOVWF  FEF
....................    }
0B82:  MOVLB  0
0B84:  GOTO   0C32 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_unstall_ep(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    debug_usb_control(debug_putc, "=u%X=", endpoint);
....................    
....................    direction = bit_test(endpoint,7);
*
0AA8:  MOVLB  2
0AAA:  BCF    x5C.0
0AAC:  BTFSC  x5B.7
0AAE:  BSF    x5C.0
....................    endpoint &= 0x7F;
0AB0:  BCF    x5B.7
....................    
....................    if (direction) 
0AB2:  BTFSS  x5C.0
0AB4:  BRA    0AE8
....................    {
....................      #if USB_IGNORE_RX_DTS
....................       EP_BDxST_I(endpoint) = 0x80;
....................      #else
....................       EP_BDxST_I(endpoint) = 0x88;
0AB6:  CLRF   x6C
0AB8:  MOVFF  25B,26B
0ABC:  CLRF   x6E
0ABE:  MOVLW  08
0AC0:  MOVWF  x6D
0AC2:  MOVLB  0
0AC4:  RCALL  04AE
0AC6:  MOVFF  02,25E
0ACA:  MOVFF  01,25D
0ACE:  MOVLW  04
0AD0:  MOVLB  2
0AD2:  ADDWF  x5D,F
0AD4:  MOVLW  00
0AD6:  ADDWFC x5E,F
0AD8:  MOVFF  25D,FE9
0ADC:  MOVLW  04
0ADE:  ADDWF  x5E,W
0AE0:  MOVWF  FEA
0AE2:  MOVLW  88
0AE4:  MOVWF  FEF
....................      #endif
....................    }
0AE6:  BRA    0B06
....................    else 
....................    {
....................       EP_BDxST_O(endpoint) = 0x00;
0AE8:  CLRF   x6C
0AEA:  MOVFF  25B,26B
0AEE:  CLRF   x6E
0AF0:  MOVLW  08
0AF2:  MOVWF  x6D
0AF4:  MOVLB  0
0AF6:  RCALL  04AE
0AF8:  MOVLB  2
0AFA:  MOVFF  01,FE9
0AFE:  MOVLW  04
0B00:  ADDWF  02,W
0B02:  MOVWF  FEA
0B04:  CLRF   FEF
....................    }
....................    
....................   #if defined(__STALL_ON_UEP_ERRATA__)
....................    bit_clear(UEP(endpoint), 0);
0B06:  CLRF   03
0B08:  MOVF   x5B,W
0B0A:  ADDLW  70
0B0C:  MOVWF  01
0B0E:  MOVLW  0F
0B10:  ADDWFC 03,F
0B12:  MOVFF  01,FE9
0B16:  MOVFF  03,FEA
0B1A:  BCF    FEF.0
....................   #endif
0B1C:  MOVLB  0
0B1E:  GOTO   0C22 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    unsigned int8 st;
....................    
....................    direction = bit_test(endpoint,7);
*
0B88:  MOVLB  2
0B8A:  BCF    x5C.0
0B8C:  BTFSC  x5B.7
0B8E:  BSF    x5C.0
....................    endpoint &= 0x7F;
0B90:  BCF    x5B.7
....................    
....................    if (direction) 
0B92:  BTFSS  x5C.0
0B94:  BRA    0BC8
....................    {
....................       st=EP_BDxST_I(endpoint);
0B96:  CLRF   x6C
0B98:  MOVFF  25B,26B
0B9C:  CLRF   x6E
0B9E:  MOVLW  08
0BA0:  MOVWF  x6D
0BA2:  MOVLB  0
0BA4:  RCALL  04AE
0BA6:  MOVFF  02,25F
0BAA:  MOVFF  01,25E
0BAE:  MOVLW  04
0BB0:  MOVLB  2
0BB2:  ADDWF  x5E,F
0BB4:  MOVLW  00
0BB6:  ADDWFC x5F,F
0BB8:  MOVFF  25E,FE9
0BBC:  MOVLW  04
0BBE:  ADDWF  x5F,W
0BC0:  MOVWF  FEA
0BC2:  MOVFF  FEF,25D
....................    }
0BC6:  BRA    0BE8
....................    else 
....................    {
....................       st=EP_BDxST_O(endpoint);
0BC8:  CLRF   x6C
0BCA:  MOVFF  25B,26B
0BCE:  CLRF   x6E
0BD0:  MOVLW  08
0BD2:  MOVWF  x6D
0BD4:  MOVLB  0
0BD6:  RCALL  04AE
0BD8:  MOVLB  2
0BDA:  MOVFF  01,FE9
0BDE:  MOVLW  04
0BE0:  ADDWF  02,W
0BE2:  MOVWF  FEA
0BE4:  MOVFF  FEF,25D
....................    }
....................    
....................    return(bit_test(st,7) && bit_test(st,2));
0BE8:  BTFSS  x5D.7
0BEA:  BRA    0BF0
0BEC:  BTFSC  x5D.2
0BEE:  BRA    0BF4
0BF0:  MOVLW  00
0BF2:  BRA    0BF6
0BF4:  MOVLW  01
0BF6:  MOVWF  01
0BF8:  MOVLB  0
0BFA:  GOTO   0C4A (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_address(unsigned int8 address) 
.................... {
....................    UADDR = address;
*
10B2:  MOVFF  25C,F6E
....................    
....................    if (address) 
10B6:  MOVLB  2
10B8:  MOVF   x5C,F
10BA:  BZ    10C2
....................    {
....................       usb_state = USB_STATE_ADDRESS;
10BC:  MOVLW  04
10BE:  MOVWF  22
....................    }
10C0:  BRA    10C6
....................    else 
....................    {
....................       usb_state = USB_STATE_POWERED;
10C2:  MOVLW  02
10C4:  MOVWF  22
....................    }
10C6:  MOVLB  0
10C8:  GOTO   10D6 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_set_configured(unsigned int8 config) 
.................... {
....................    unsigned int8 en;
....................    unsigned int16 addy;
....................    unsigned int8 new_uep;
....................    unsigned int16 len;
....................    unsigned int8 i;
....................    
....................    if (config == 0)
*
075E:  MOVLB  2
0760:  MOVF   x5B,F
0762:  BNZ   0770
....................    {
....................       // if config=0 then set addressed state
....................       usb_state = USB_STATE_ADDRESS;
0764:  MOVLW  04
0766:  MOVWF  22
....................       usb_disable_endpoints();
0768:  MOVLB  0
076A:  RCALL  0540
....................    }
076C:  BRA    0944
076E:  MOVLB  2
....................    else 
....................    {
....................       // else set configed state
....................       usb_state = USB_STATE_CONFIGURED; 
0770:  MOVLW  05
0772:  MOVWF  22
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH);
0774:  MOVLW  04
0776:  MOVWF  x5E
0778:  MOVLW  98
077A:  MOVWF  x5D
....................       for (en=1; en<USB_NUM_UEP; en++) 
077C:  MOVLW  01
077E:  MOVWF  x5C
0780:  MOVF   x5C,W
0782:  SUBLW  0F
0784:  BTFSS  FD8.0
0786:  BRA    0944
....................       {
....................          // enable and config endpoints based upon user configuration
....................          usb_disable_endpoint(en);
0788:  MOVFF  25C,264
078C:  MOVLB  0
078E:  RCALL  04D0
....................          new_uep = 0;
0790:  MOVLB  2
0792:  CLRF   x5F
....................          if (usb_ep_rx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
0794:  CLRF   03
0796:  MOVF   x5C,W
0798:  MOVLB  0
079A:  RCALL  00CE
079C:  SUBLW  FF
079E:  BZ    086E
....................          {
....................             new_uep = 0x04;
07A0:  MOVLW  04
07A2:  MOVLB  2
07A4:  MOVWF  x5F
....................             len = usb_ep_rx_size[en];
07A6:  BCF    FD8.0
07A8:  RLCF   x5C,W
07AA:  CLRF   03
07AC:  MOVLB  0
07AE:  RCALL  011E
07B0:  TBLRD*+
07B2:  MOVFF  FF5,03
07B6:  MOVLB  2
07B8:  MOVWF  x60
07BA:  MOVFF  03,261
....................             EP_BDxCNT_O(en) = len;
07BE:  CLRF   x6C
07C0:  MOVFF  25C,26B
07C4:  CLRF   x6E
07C6:  MOVLW  08
07C8:  MOVWF  x6D
07CA:  MOVLB  0
07CC:  RCALL  04AE
07CE:  MOVFF  01,263
07D2:  MOVLW  01
07D4:  MOVLB  2
07D6:  ADDWF  01,W
07D8:  MOVWF  01
07DA:  MOVLW  00
07DC:  ADDWFC 02,W
07DE:  MOVWF  03
07E0:  MOVFF  01,FE9
07E4:  MOVLW  04
07E6:  ADDWF  03,W
07E8:  MOVWF  FEA
07EA:  MOVFF  260,FEF
....................             EP_BDxADR_O(en) = addy;
07EE:  CLRF   x6C
07F0:  MOVFF  25C,26B
07F4:  CLRF   x6E
07F6:  MOVLW  08
07F8:  MOVWF  x6D
07FA:  MOVLB  0
07FC:  RCALL  04AE
07FE:  MOVFF  01,263
0802:  MOVLW  02
0804:  MOVLB  2
0806:  ADDWF  01,W
0808:  MOVWF  01
080A:  MOVLW  00
080C:  ADDWFC 02,W
080E:  MOVWF  03
0810:  MOVFF  01,FE9
0814:  MOVLW  04
0816:  ADDWF  03,W
0818:  MOVWF  FEA
081A:  MOVFF  25E,FEC
081E:  MOVF   FED,F
0820:  MOVFF  25D,FEF
....................             addy += usb_ep_rx_size[en];
0824:  BCF    FD8.0
0826:  RLCF   x5C,W
0828:  CLRF   03
082A:  MOVLB  0
082C:  RCALL  011E
082E:  TBLRD*+
0830:  MOVFF  FF5,03
0834:  MOVLB  2
0836:  ADDWF  x5D,F
0838:  MOVF   03,W
083A:  ADDWFC x5E,F
....................            #if USB_IGNORE_RX_DTS
....................             i = 0x80;
....................            #else
....................             i = 0x88;
083C:  MOVLW  88
083E:  MOVWF  x62
....................            #endif
....................             if (bit_test(len,8)) {bit_set(i,0);}
0840:  BTFSS  x61.0
0842:  BRA    0846
0844:  BSF    x62.0
....................             if (bit_test(len,9)) {bit_set(i,1);}
0846:  BTFSS  x61.1
0848:  BRA    084C
084A:  BSF    x62.1
....................             EP_BDxST_O(en) = i;
084C:  CLRF   x6C
084E:  MOVFF  25C,26B
0852:  CLRF   x6E
0854:  MOVLW  08
0856:  MOVWF  x6D
0858:  MOVLB  0
085A:  RCALL  04AE
085C:  MOVLB  2
085E:  MOVFF  01,FE9
0862:  MOVLW  04
0864:  ADDWF  02,W
0866:  MOVWF  FEA
0868:  MOVFF  262,FEF
086C:  MOVLB  0
....................          }
....................          if (usb_ep_tx_type[en] != (unsigned int8)USB_ENABLE_DISABLED) 
086E:  CLRF   03
0870:  MOVLB  2
0872:  MOVF   x5C,W
0874:  MOVLB  0
0876:  RCALL  00AE
0878:  SUBLW  FF
087A:  BZ    090C
....................          {
....................             new_uep |= 0x02;
087C:  MOVLB  2
087E:  BSF    x5F.1
....................             EP_BDxADR_I(en) = addy;
0880:  CLRF   x6C
0882:  MOVFF  25C,26B
0886:  CLRF   x6E
0888:  MOVLW  08
088A:  MOVWF  x6D
088C:  MOVLB  0
088E:  RCALL  04AE
0890:  MOVFF  02,264
0894:  MOVFF  01,263
0898:  MOVLW  04
089A:  MOVLB  2
089C:  ADDWF  x63,F
089E:  MOVLW  00
08A0:  ADDWFC x64,F
08A2:  MOVLW  02
08A4:  ADDWF  x63,W
08A6:  MOVWF  01
08A8:  MOVLW  00
08AA:  ADDWFC x64,W
08AC:  MOVWF  03
08AE:  MOVFF  01,FE9
08B2:  MOVLW  04
08B4:  ADDWF  03,W
08B6:  MOVWF  FEA
08B8:  MOVFF  25E,FEC
08BC:  MOVF   FED,F
08BE:  MOVFF  25D,FEF
....................             addy += usb_ep_tx_size[en];
08C2:  BCF    FD8.0
08C4:  RLCF   x5C,W
08C6:  CLRF   03
08C8:  MOVLB  0
08CA:  RCALL  00EE
08CC:  TBLRD*+
08CE:  MOVFF  FF5,03
08D2:  MOVLB  2
08D4:  ADDWF  x5D,F
08D6:  MOVF   03,W
08D8:  ADDWFC x5E,F
....................             EP_BDxST_I(en) = 0x40;
08DA:  CLRF   x6C
08DC:  MOVFF  25C,26B
08E0:  CLRF   x6E
08E2:  MOVLW  08
08E4:  MOVWF  x6D
08E6:  MOVLB  0
08E8:  RCALL  04AE
08EA:  MOVFF  02,264
08EE:  MOVFF  01,263
08F2:  MOVLW  04
08F4:  MOVLB  2
08F6:  ADDWF  x63,F
08F8:  MOVLW  00
08FA:  ADDWFC x64,F
08FC:  MOVFF  263,FE9
0900:  MOVLW  04
0902:  ADDWF  x64,W
0904:  MOVWF  FEA
0906:  MOVLW  40
0908:  MOVWF  FEF
090A:  MOVLB  0
....................          }
....................          if (new_uep == 0x06) {new_uep = 0x0E;}
090C:  MOVLB  2
090E:  MOVF   x5F,W
0910:  SUBLW  06
0912:  BNZ   0918
0914:  MOVLW  0E
0916:  MOVWF  x5F
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;}
0918:  CLRF   03
091A:  MOVF   x5C,W
091C:  MOVLB  0
091E:  CALL   00AE
0922:  SUBLW  01
0924:  BZ    092C
0926:  MOVLB  2
0928:  BSF    x5F.4
092A:  MOVLB  0
....................          
....................          UEP(en) = new_uep;
092C:  CLRF   03
092E:  MOVLB  2
0930:  MOVF   x5C,W
0932:  ADDLW  70
0934:  MOVWF  FE9
0936:  MOVLW  0F
0938:  ADDWFC 03,W
093A:  MOVWF  FEA
093C:  MOVFF  25F,FEF
0940:  INCF   x5C,F
0942:  BRA    0780
0944:  MOVLB  0
....................       }
....................    }
0946:  GOTO   09F2 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoint(unsigned int8 en) 
.................... {
....................    UEP(en) = ENDPT_DISABLED;
*
04D0:  CLRF   03
04D2:  MOVLB  2
04D4:  MOVF   x64,W
04D6:  ADDLW  70
04D8:  MOVWF  FE9
04DA:  MOVLW  0F
04DC:  ADDWFC 03,W
04DE:  MOVWF  FEA
04E0:  CLRF   FEF
....................    
....................    if (usb_endpoint_is_valid(en))
04E2:  MOVFF  264,265
04E6:  MOVLB  0
04E8:  RCALL  0460
04EA:  MOVF   01,F
04EC:  BZ    053E
....................    {
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary      
04EE:  MOVLB  2
04F0:  CLRF   x6C
04F2:  MOVFF  264,26B
04F6:  CLRF   x6E
04F8:  MOVLW  08
04FA:  MOVWF  x6D
04FC:  MOVLB  0
04FE:  RCALL  04AE
0500:  MOVLB  2
0502:  MOVFF  01,FE9
0506:  MOVLW  04
0508:  ADDWF  02,W
050A:  MOVWF  FEA
050C:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary
050E:  CLRF   x6C
0510:  MOVFF  264,26B
0514:  CLRF   x6E
0516:  MOVLW  08
0518:  MOVWF  x6D
051A:  MOVLB  0
051C:  RCALL  04AE
051E:  MOVFF  02,266
0522:  MOVFF  01,265
0526:  MOVLW  04
0528:  MOVLB  2
052A:  ADDWF  x65,F
052C:  MOVLW  00
052E:  ADDWFC x66,F
0530:  MOVFF  265,FE9
0534:  MOVLW  04
0536:  ADDWF  x66,W
0538:  MOVWF  FEA
053A:  CLRF   FEF
053C:  MOVLB  0
....................    }
053E:  RETURN 0
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_disable_endpoints(void) 
.................... {
....................    unsigned int8 i;
....................    
....................    for (i=1; i<USB_NUM_UEP; i++)
0540:  MOVLW  01
0542:  MOVLB  2
0544:  MOVWF  x63
0546:  MOVF   x63,W
0548:  SUBLW  0F
054A:  BNC   055A
....................       usb_disable_endpoint(i);
054C:  MOVFF  263,264
0550:  MOVLB  0
0552:  RCALL  04D0
0554:  MOVLB  2
0556:  INCF   x63,F
0558:  BRA    0546
055A:  MOVLB  0
055C:  RETURN 0
....................       
....................    //__usb_kbhit_status=0;
.................... }
.................... 
.................... /// END Hardware layer functions required by USB.C
.................... 
.................... 
.................... /// BEGIN USB Interrupt Service Routine
.................... 
.................... static void usb_clear_trn(void)
.................... {
....................    //UIR_TRN = 0;
....................    //delay_cycles(6);
....................    UIR &= ~(1 << BIT_TRN);
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_handle_interrupt()
.................... /*
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished
.................... /*          tokens is the majority of this code, and is handled by usb.c
.................... /*
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt 
.................... /*       method), then you must call this function rapidly.  If there is more 
.................... /*       than 10ms latency the PC may think the USB device is stalled and
.................... /*       disable it.
.................... /*       To switch to a polling method, remove the #int_usb line above this 
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the 
.................... /*       USB interrupt.
.................... /******************************************************************************/
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR)
.................... #int_usb NOCLEAR
.................... #endif
.................... void usb_isr(void)
.................... {
....................    unsigned int8 TRNAttempts;
....................    
....................    clear_interrupt(INT_USB);
*
13FA:  BCF    FA1.5
....................    
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though
13FC:  MOVF   22,F
13FE:  BTFSC  FD8.2
1400:  BRA    147A
....................    if (UIR) 
1402:  MOVF   F68,F
1404:  BTFSC  FD8.2
1406:  BRA    147A
....................    {
....................       //debug_usb(debug_putc,"\r\n\n[%X] ",UIR);
.................... 
....................       //activity detected.  (only enable after sleep)
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}
1408:  BTFSS  F68.2
140A:  BRA    1412
140C:  BTFSC  F69.2
140E:  GOTO   040E
.................... 
....................       if (UCON_SUSPND) return;
1412:  BTFSC  F6D.1
1414:  BRA    147A
.................... 
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent
1416:  BTFSS  F68.5
1418:  BRA    1420
141A:  BTFSC  F69.5
141C:  GOTO   044A
.................... 
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected
1420:  BTFSS  F68.1
1422:  BRA    142A
1424:  BTFSC  F69.1
1426:  GOTO   0458
.................... 
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected
142A:  BTFSS  F68.0
142C:  BRA    1434
142E:  BTFSC  F69.0
1430:  GOTO   05CE
.................... 
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep
1434:  BTFSS  F68.4
1436:  BRA    143E
1438:  BTFSC  F69.4
143A:  GOTO   05FE
....................       
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();}
143E:  BTFSS  F68.6
1440:  BRA    1448
1442:  BTFSC  F69.6
1444:  GOTO   0608
.................... 
....................       TRNAttempts = 0;
1448:  MOVLB  2
144A:  CLRF   x58
....................       do
....................       {
....................          if (UIR_TRN && UIE_TRN) 
144C:  BTFSS  F68.3
144E:  BRA    1464
1450:  BTFSS  F69.3
1452:  BRA    1464
....................          {
....................             USTATCopy = U1STAT;
1454:  MOVFF  F6C,21
....................             usb_clear_trn();
1458:  MOVLB  0
145A:  CALL   0004
....................             usb_isr_tok_dne();
145E:  BRA    12FE
....................          }
1460:  BRA    1468
1462:  MOVLB  2
....................          else
....................             break;
1464:  BRA    1472
1466:  MOVLB  0
....................       } while (TRNAttempts++ < 4);
1468:  MOVLB  2
146A:  MOVF   x58,W
146C:  INCF   x58,F
146E:  SUBLW  03
1470:  BC    144C
.................... 
....................      #if defined(USB_CDC_ISR)
....................       //has to be done here, can't be done until TRN is empty.
....................       if (usb_cdc_kbhit())
1472:  BTFSS  1E.0
1474:  BRA    147C
....................       {
....................          USB_CDC_ISR();
1476:  MOVLB  0
1478:  BRA    13F6
147A:  MOVLB  2
....................       }
....................      #endif
....................    }
147C:  MOVLB  0
147E:  GOTO   0060
.................... }
.................... 
.................... // SOF interrupt not handled.  user must add this depending on application
.................... void usb_isr_sof(void) 
.................... {
....................    //debug_usb(debug_putc, "\r\nSOF");
....................    
....................    //UIR_SOF = 0;
....................    UIR &= ~(1 << BIT_SOF);
*
0608:  BCF    F68.6
060A:  GOTO   1448 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_rst()
.................... /*
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device
.................... /*          and token handler code to initial state.
.................... /*
.................... /******************************************************************************/
.................... void usb_isr_rst(void) 
.................... {
....................    debug_usb_control(debug_putc,"-R-");
.................... 
....................    UEIE = 0;
*
05CE:  CLRF   F6B
....................    UIE = 0;
05D0:  CLRF   F69
....................    UEIR = 0;
05D2:  CLRF   F6A
....................    UIR = 0;
05D4:  CLRF   F68
.................... 
....................    UADDR = 0;
05D6:  CLRF   F6E
....................    
....................    UEP(0) = ENDPT_DISABLED;
05D8:  CLRF   F70
.................... 
....................    usb_disable_endpoints();
05DA:  RCALL  0540
....................    
....................    usb_token_reset();
05DC:  RCALL  059E
.................... 
....................    UEP(0) = ENDPT_CONTROL | 0x10;
05DE:  MOVLW  16
05E0:  MOVWF  F70
.................... 
....................    while (UIR_TRN) 
05E2:  BTFSS  F68.3
05E4:  BRA    05EA
....................    {
....................       usb_clear_trn();
05E6:  RCALL  0004
05E8:  BRA    05E2
....................    }
.................... 
.................... 
....................    UEIE = 0x9F;
05EA:  MOVLW  9F
05EC:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE;
05EE:  MOVLW  3D
05F0:  MOVWF  F69
.................... 
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled
05F2:  BCF    F6D.4
.................... 
....................    usb_init_ep0_setup();
05F4:  RCALL  0420
.................... 
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state
05F6:  MOVLW  03
05F8:  MOVWF  22
05FA:  GOTO   1434 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_init_ep0_setup()
.................... /*
.................... /* Summary: Configure EP0 to receive setup packets
.................... /*
.................... /*****************************************************************************/
.................... void usb_init_ep0_setup(void) 
.................... {
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH;
*
0420:  MOVLW  40
0422:  MOVLB  4
0424:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION;
0426:  MOVLW  04
0428:  MOVLB  2
042A:  MOVWF  x5A
042C:  MOVLW  18
042E:  MOVFF  25A,403
0432:  MOVFF  FE8,402
....................    #if USB_IGNORE_RX_DTS
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off
....................    #else
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on
0436:  MOVLW  88
0438:  MOVLB  4
043A:  MOVWF  x00
....................    #endif
.................... 
....................     EP_BDxST_I(0) = 0;
043C:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH;
043E:  MOVLW  04
0440:  MOVWF  x07
0442:  MOVLW  58
0444:  MOVWF  x06
0446:  MOVLB  0
0448:  RETURN 0
.................... }
.................... 
.................... /*******************************************************************************
.................... /* usb_isr_uerr()
.................... /*
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter
.................... /*          will incerement.  If having problems check the status of these 8 bytes.
.................... /*
.................... /* NOTE: This code is not enabled by default.
.................... /********************************************************************************/
.................... void usb_isr_uerr(void)
.................... {
....................   #if USB_USE_ERROR_COUNTER
....................    int ints;
....................   #endif
.................... 
....................    debug_usb_control(debug_putc,"-E%X-",UEIR);
.................... 
....................   #if USB_USE_ERROR_COUNTER
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled
.................... 
....................    if ( bit_test(ints,0) ) 
....................    { 
....................       //increment pid_error counter
....................       //debug_usb(debug_putc,"PID ");
....................       ERROR_COUNTER[0]++;
....................    }
.................... 
....................    if ( bit_test(ints,1) ) 
....................    {  
....................       //increment crc5 error counter
....................       //debug_usb(debug_putc,"CRC5 ");
....................       ERROR_COUNTER[1]++;
....................    }
.................... 
....................    if ( bit_test(ints,2) ) 
....................    {
....................       //increment crc16 error counter
....................       //debug_usb(debug_putc,"CRC16 ");
....................       ERROR_COUNTER[2]++;
....................    }
.................... 
....................    if ( bit_test(ints,3) ) 
....................    {  
....................       //increment dfn8 error counter
....................       //debug_usb(debug_putc,"DFN8 ");
....................       ERROR_COUNTER[3]++;
....................    }
.................... 
....................    if ( bit_test(ints,4) ) 
....................    {  
....................       //increment bto error counter
....................       //debug_usb(debug_putc,"BTO ");
....................       ERROR_COUNTER[4]++;
....................    }
.................... 
....................    if ( bit_test(ints,7) ) 
....................    { 
....................       //increment bts error counter
....................       //debug_usb(debug_putc,"BTS ");
....................       ERROR_COUNTER[5]++;
....................    }
....................   #endif
.................... 
....................    UEIR = 0;
*
0458:  CLRF   F6A
....................    
....................    //UIR_UERR = 0;
....................    UIR &= ~(1 << BIT_UERR);
045A:  BCF    F68.1
045C:  GOTO   142A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_uidle()
.................... /*
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_uidle(void)
.................... {
....................    debug_usb_control(debug_putc, "-I-");
.................... 
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice)
*
05FE:  BSF    F69.2
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
....................    // turn off isr instead of clearing flag
....................    UIE &= ~(unsigned int16)__USB_UIF_IDLE;
0600:  BCF    F69.4
....................   #else
....................    UIR &= ~(1 << BIT_IDLE);
....................   #endif
....................    
....................    UCON_SUSPND = 1; //set suspend. we are now suspended
0602:  BSF    F6D.1
0604:  GOTO   143E (RETURN)
.................... }
.................... 
.................... 
.................... /******************************************************************************
.................... /* usb_isr_activity()
.................... /*
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB
.................... /*          peripheral.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_activity(void)
.................... {
....................    debug_usb_control(debug_putc, "-A-");
.................... 
....................    UCON_SUSPND = 0; //turn off low power suspending
*
040E:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling
0410:  BCF    F69.2
....................    
....................    while(UIR_ACTV)
0412:  BTFSS  F68.2
0414:  BRA    041A
....................    {
....................       //UIR_ACTV = 0;
....................       UIR &= ~(1 << BIT_ACTV);
0416:  BCF    F68.2
....................    }
....................    
....................   #if defined(__UIDLE_JAM_ERRATA__)
0418:  BRA    0412
....................    // now it's safe to clear the flag
....................    UIR &= ~(1 << BIT_IDLE);
041A:  BCF    F68.4
....................   #endif   
041C:  GOTO   1412 (RETURN)
.................... }
.................... 
.................... /******************************************************************************
.................... /* usb_isr_stall()
.................... /*
.................... /* Summary: Stall handshake detected.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_stall(void) 
.................... {
....................    debug_usb_control(debug_putc, "-S-");
....................    
....................    
....................    if (bit_test(UEP(0),0)) 
*
044A:  BTFSS  F70.0
044C:  BRA    0452
....................    {
....................       usb_init_ep0_setup();
044E:  RCALL  0420
....................       bit_clear(UEP(0), 0);
0450:  BCF    F70.0
....................    }
....................    
....................    //UIR_STALL = 0;
....................    UIR &= ~(1 << BIT_STALL);
0452:  BCF    F68.5
0454:  GOTO   1420 (RETURN)
.................... }
.................... 
.................... // see usb_hw_layer.h for documentation
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;}
*
060E:  MOVFF  25E,23
0612:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;}
*
0C68:  MOVLW  FE
0C6A:  MOVWF  23
0C6C:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;}
*
0614:  SETF   23
0616:  RETURN 0
.................... 
.................... /*****************************************************************************
.................... /* usb_isr_tok_dne()
.................... /*
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral.
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and
.................... /*          handle the request.
.................... /*          If an IN token on EP0 was received, continue transmitting any
.................... /*          unfinished requests that may take more than one packet to transmit
.................... /*          (if necessary).
.................... /*          If an OUT token on any other EP was received, mark that EP as ready
.................... /*          for a usb_get_packet().
.................... /*          Does not handle any IN or OUT tokens on EP0.
.................... /*
.................... /*****************************************************************************/
.................... void usb_isr_tok_dne(void) 
.................... {
....................    unsigned int8 en;
.................... 
....................    en = USTATCopy>>3;
*
12FE:  RRCF   21,W
1300:  MOVLB  2
1302:  MOVWF  x59
1304:  RRCF   x59,F
1306:  RRCF   x59,F
1308:  MOVLW  1F
130A:  ANDWF  x59,F
.................... 
....................    debug_usb_control(debug_putc, "-T%X-", USTATCopy);
.................... 
....................    if (USTATCopy == USTAT_OUT_SETUP_E0) 
130C:  MOVF   21,F
130E:  BNZ   13AC
....................    {
....................       //new out or setup token in the buffer
....................       int8 pidKey;
....................       
....................       //debug_usb(debug_putc,"%X ", EP_BDxST_O(0));
....................       
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID
1310:  MOVLB  4
1312:  MOVF   x00,W
1314:  ANDLW  3C
1316:  MOVLB  2
1318:  MOVWF  x5A
....................       
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion
131A:  MOVLW  43
131C:  MOVLB  4
131E:  ANDWF  x00,F
....................       
....................       if (pidKey == USB_PIC_PID_SETUP) 
1320:  MOVLB  2
1322:  MOVF   x5A,W
1324:  SUBLW  34
1326:  BNZ   1372
....................       {
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00)
1328:  MOVLB  4
132A:  MOVF   x04,W
132C:  ANDLW  80
132E:  BZ    1332
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests)
1330:  CLRF   x04
.................... 
....................          //debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0));
....................          //debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer);
.................... 
....................          usb_isr_tok_setup_dne();
1332:  MOVLB  0
1334:  BRA    0D0A
.................... 
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
1336:  BCF    F6D.4
.................... 
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall())
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data())
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response())
....................          if (__setup_0_tx_size == 0xFF)
1338:  INCFSZ 23,W
133A:  BRA    134A
....................             usb_flush_out(0, USB_DTS_STALL);
133C:  MOVLB  2
133E:  CLRF   x5C
1340:  MOVLW  03
1342:  MOVWF  x5D
1344:  MOVLB  0
1346:  RCALL  0D3C
1348:  BRA    136E
....................          else 
....................          {
....................             usb_flush_out(0, USB_DTS_TOGGLE);
134A:  MOVLB  2
134C:  CLRF   x5C
134E:  MOVLW  02
1350:  MOVWF  x5D
1352:  MOVLB  0
1354:  RCALL  0D3C
....................             if (__setup_0_tx_size != 0xFE)
1356:  MOVF   23,W
1358:  SUBLW  FE
135A:  BZ    136E
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX);
135C:  MOVLB  2
135E:  CLRF   x65
1360:  CLRF   x67
1362:  MOVFF  23,266
1366:  MOVLW  04
1368:  MOVWF  x68
136A:  MOVLB  0
136C:  RCALL  0E92
....................          }
....................          //why was this here?
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit
....................       }
136E:  BRA    13A8
1370:  MOVLB  2
....................       else if (pidKey == USB_PIC_PID_OUT) 
1372:  MOVF   x5A,W
1374:  SUBLW  04
1376:  BNZ   13AA
....................       {
....................          usb_isr_tok_out_dne(0);
1378:  CLRF   x5B
137A:  MOVLB  0
137C:  RCALL  1094
....................          usb_flush_out(0, USB_DTS_TOGGLE);
137E:  MOVLB  2
1380:  CLRF   x5C
1382:  MOVLW  02
1384:  MOVWF  x5D
1386:  MOVLB  0
1388:  RCALL  0D3C
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF))
138A:  MOVF   23,W
138C:  SUBLW  FE
138E:  BZ    13A8
1390:  INCFSZ 23,W
1392:  BRA    1396
1394:  BRA    13A8
....................          {
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len)
1396:  MOVLB  2
1398:  CLRF   x65
139A:  CLRF   x67
139C:  MOVFF  23,266
13A0:  MOVLW  01
13A2:  MOVWF  x68
13A4:  MOVLB  0
13A6:  RCALL  0E92
13A8:  MOVLB  2
....................          }
....................       }
....................       //else
....................       //{
....................       //   debug_usb(debug_putc, "!!! ");
....................       //}
....................    }
13AA:  BRA    13F0
....................    else if (USTATCopy == USTAT_IN_E0) 
13AC:  MOVF   21,W
13AE:  SUBLW  04
13B0:  BNZ   13D6
....................    {   
....................       //pic -> host transfer completed
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion
....................       __setup_0_tx_size = 0xFF;
13B2:  SETF   23
....................       usb_isr_tok_in_dne(0);
13B4:  CLRF   x5B
13B6:  MOVLB  0
13B8:  RCALL  12CC
....................       if (__setup_0_tx_size!=0xFF)
13BA:  INCFSZ 23,W
13BC:  BRA    13C0
13BE:  BRA    13D2
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE);
13C0:  MOVLB  2
13C2:  CLRF   x65
13C4:  CLRF   x67
13C6:  MOVFF  23,266
13CA:  MOVLW  02
13CC:  MOVWF  x68
13CE:  MOVLB  0
13D0:  RCALL  0E92
....................       else
....................       {
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................       }  
....................    }
13D2:  BRA    13EE
13D4:  MOVLB  2
....................    else 
....................    {
....................       if (!bit_test(USTATCopy, 2)) 
13D6:  BTFSC  21.2
13D8:  BRA    13E6
....................       {
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_out_dne(en);
13DA:  MOVFF  259,25B
13DE:  MOVLB  0
13E0:  RCALL  1094
....................       }
13E2:  BRA    13EE
13E4:  MOVLB  2
....................       else 
....................       {
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion
....................          usb_isr_tok_in_dne(en);
13E6:  MOVFF  259,25B
13EA:  MOVLB  0
13EC:  RCALL  12CC
13EE:  MOVLB  2
....................       }
....................    }
13F0:  MOVLB  0
13F2:  GOTO   1460 (RETURN)
.................... }
.................... 
.................... /// END USB Interrupt Service Routine
.................... 
.................... #ENDIF
.................... 
.................... #endif
.................... 
.................... #if defined(__PIC24_USB_H__)
....................  #include <pic24_usb.c>
.................... #endif
.................... 
.................... #if defined(__USBN960X_H__)
....................  #include <usbn960x.c>
.................... #endif
.................... 
.................... 
.................... #IFNDEF __USB_HARDWARE__
....................    #ERROR You must include USB hardware driver.
.................... #ENDIF
.................... 
.................... #IFNDEF __USB_DESCRIPTORS__
....................    #ERROR You must include USB descriptors.
.................... #ENDIF
.................... 
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1))
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  64
.................... #else
....................    #define USB_ISO_PACKET_MAX_SIZE     1023
....................    #define USB_NONISO_PACKET_MAX_SIZE  8
.................... #endif
.................... 
.................... //--------- endpoint 1 defines ----------
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif
.................... #endif
.................... 
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 2 defines ----------
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 3 defines ----------
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 4 defines ----------
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 5 defines ----------
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 6 defines ----------
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 7 defines ----------
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 8 defines ----------
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 9 defines ----------
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 10 defines ----------
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 11 defines ----------
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 12 defines ----------
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 13 defines ----------
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 14 defines ----------
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif 
.................... #endif
.................... 
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... 
.................... //--------- endpoint 15 defines ----------
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif  
.................... #endif
.................... 
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE)))
....................    #error Packet size is too big
....................  #endif   
.................... #endif
.................... 
.................... TYPE_USB_STACK_STATUS USB_stack_status;
.................... 
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors
.................... 
.................... #IF USB_HID_BOOT_PROTOCOL
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES];
.................... #ENDIF
.................... 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size);
.................... 
.................... void usb_isr_tkn_setup_StandardEndpoint(void);
.................... void usb_isr_tkn_setup_StandardDevice(void);
.................... void usb_isr_tkn_setup_StandardInterface(void);
.................... #IF USB_HID_DEVICE
....................    void usb_isr_tkn_setup_ClassInterface(void);
.................... #ENDIF
.................... void usb_Get_Descriptor(void);
.................... void usb_copy_desc_seg_to_ep(void);
.................... void usb_finish_set_address(void);
.................... 
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors
.................... 
.................... /// BEGIN User Functions
.................... 
.................... // see usb.h for documentation
.................... int1 usb_enumerated(void)
.................... {
....................    return(USB_stack_status.curr_config);
*
1566:  MOVF   1B,W
1568:  MOVWF  01
156A:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_wait_for_enumeration(void) 
.................... {
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();}
.................... }
.................... 
.................... // see USB.H for documentation
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) {
....................    unsigned int16 i=0;
....................    int1 res;
....................    unsigned int16 this_packet_len;
....................    unsigned int16 packet_size;
....................    unsigned int32 timeout_1us;
.................... 
....................    packet_size = usb_ep_tx_size[endpoint];
....................    
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size);
.................... 
....................    //send data packets until timeout or no more packets to send
....................    while (i < len) 
....................    {
....................       timeout_1us = (int32)timeout*1000;
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;}
....................       else {this_packet_len = len-i;}
....................       //putc('*');
....................       do 
....................       {
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets
....................          //putc('.');
....................          if (!res)
....................          {
....................             delay_us(1);
....................             //delay_ms(500);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................       i += packet_size;
....................    }
.................... 
.................... 
....................    //send 0len packet if needed
....................    if (i==len) {
....................       timeout_1us=(int32)timeout*1000;
....................       do {
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message
....................          if (!res) {
....................             delay_us(1);
....................             timeout_1us--;
....................          }
....................       } while (!res && (!timeout || timeout_1us));
....................    }
.................... 
....................    return(res);
.................... }
.................... 
.................... // see usb.h for documentation
.................... unsigned int16 usb_gets(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max, unsigned int16 timeout) {
....................    unsigned int16 ret=0;
....................    unsigned int16 to;
....................    unsigned int16 len;
....................    unsigned int16 packet_size;
....................    unsigned int16 this_packet_max;
.................... 
....................    packet_size=usb_ep_rx_size[endpoint];
.................... 
....................    do {
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;}
....................       to=0;
....................       do {
....................          len = packet_size;
....................          if (usb_kbhit(endpoint)) {
....................             len=usb_get_packet(endpoint,ptr,this_packet_max);
....................             ptr+=len;
....................             max-=len;
....................             ret+=len;
....................             break;
....................          }
....................          else {
....................             to++;
....................             delay_ms(1);
....................          }
....................       } while (to!=timeout);
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max);
.................... 
....................    return(ret);
.................... }
.................... 
.................... /// END User Functions
.................... 
.................... 
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR)
.................... 
.................... // see usb.h for documentation
.................... void usb_token_reset(void) 
.................... {
....................    unsigned int i;
.................... 
....................    usb_getdesc_len = 0;
*
059E:  CLRF   28
05A0:  CLRF   27
....................    
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++) 
05A2:  MOVLB  2
05A4:  CLRF   x59
05A6:  MOVF   x59,W
05A8:  SUBLW  01
05AA:  BNC   05C0
....................       USB_Interface[i] = 0;   //reset each interface to default
05AC:  CLRF   03
05AE:  MOVF   x59,W
05B0:  ADDLW  29
05B2:  MOVWF  FE9
05B4:  MOVLW  00
05B6:  ADDWFC 03,W
05B8:  MOVWF  FEA
05BA:  CLRF   FEF
.................... 
....................   #IF USB_HID_BOOT_PROTOCOL
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++)
....................       hid_protocol[i] = 1;
....................   #endif
.................... 
....................   #if USB_CDC_DEVICE
05BC:  INCF   x59,F
05BE:  BRA    05A6
....................    usb_cdc_init();
05C0:  MOVLB  0
05C2:  RCALL  055E
....................   #endif
.................... 
....................    USB_stack_status.curr_config = 0;      //unconfigured device
05C4:  CLRF   1B
.................... 
....................    USB_stack_status.status_device = 1;    //previous state.  init at none
05C6:  MOVLW  01
05C8:  MOVWF  1C
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none
05CA:  CLRF   1A
05CC:  RETURN 0
.................... }
.................... 
.................... //send a 0len packet to endpoint 0 (optimization)
.................... //notice that this doesnt return the status
.................... #define usb_put_0len_0() usb_request_send_response(0)
.................... 
.................... /**************************************************************
.................... /* usb_endpoint_is_valid(endpoint)
.................... /*
.................... /* Input: endpoint - endpoint to check.
.................... /*                   bit 7 is direction (set is IN, clear is OUT)
.................... /*
.................... /* Output: TRUE if endpoint is valid, FALSE if not
.................... /*
.................... /* Summary: Checks the dynamic configuration to see if requested
.................... /*          endpoint is a valid endpoint.
.................... /***************************************************************/
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint) 
.................... {
....................    int1 direction;
....................    
....................    direction = bit_test(endpoint,7);
*
0460:  MOVLB  2
0462:  BCF    x66.0
0464:  BTFSC  x65.7
0466:  BSF    x66.0
....................    
....................    endpoint &= 0x7F;
0468:  BCF    x65.7
....................    
....................    if (endpoint > 16)
046A:  MOVF   x65,W
046C:  SUBLW  10
046E:  BC    0476
....................       return(false);
0470:  MOVLW  00
0472:  MOVWF  01
0474:  BRA    04AA
....................    
....................    if (direction) { //IN
0476:  BTFSS  x66.0
0478:  BRA    0494
....................       return(usb_ep_tx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
047A:  CLRF   03
047C:  MOVF   x65,W
047E:  MOVLB  0
0480:  RCALL  00AE
0482:  SUBLW  FF
0484:  BNZ   048A
0486:  MOVLW  00
0488:  BRA    048C
048A:  MOVLW  01
048C:  MOVWF  01
048E:  MOVLB  2
0490:  BRA    04AA
....................    }
0492:  BRA    04AA
....................    else {   //OUT
....................       return(usb_ep_rx_type[endpoint] != (unsigned int8)USB_ENABLE_DISABLED);
0494:  CLRF   03
0496:  MOVF   x65,W
0498:  MOVLB  0
049A:  RCALL  00CE
049C:  SUBLW  FF
049E:  BNZ   04A4
04A0:  MOVLW  00
04A2:  BRA    04A6
04A4:  MOVLW  01
04A6:  MOVWF  01
04A8:  MOVLB  2
....................    }
04AA:  MOVLB  0
04AC:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) {
....................    if (endpoint==0) {
*
12CC:  MOVLB  2
12CE:  MOVF   x5B,F
12D0:  BNZ   12EE
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor?
12D2:  DECFSZ 1A,W
12D4:  BRA    12E0
12D6:  MOVLB  0
12D8:  CALL   0618
12DC:  BRA    12EA
12DE:  MOVLB  2
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();}
12E0:  MOVF   1A,W
12E2:  SUBLW  02
12E4:  BNZ   12EC
12E6:  MOVLB  0
12E8:  BRA    10CC
12EA:  MOVLB  2
....................    }
....................   #if USB_CDC_DEVICE
12EC:  BRA    12FA
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
12EE:  MOVF   x5B,W
12F0:  SUBLW  02
12F2:  BNZ   12FA
....................       usb_isr_tok_in_cdc_data_dne();
12F4:  MOVLB  0
12F6:  BRA    12C6
12F8:  MOVLB  2
....................   }
....................   #endif
12FA:  MOVLB  0
12FC:  RETURN 0
.................... }
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint)
.................... {
....................    //TODO:
....................    if (endpoint==0) {
*
1094:  MOVLB  2
1096:  MOVF   x5B,F
1098:  BNZ   10A2
....................      debug_usb(debug_putc,"TOUT 0 ");
....................      #if USB_CDC_DEVICE
....................       usb_isr_tok_out_cdc_control_dne();
109A:  MOVLB  0
109C:  BRA    0FDE
....................      //#else   //REMOVED JUN/9/2009
....................      //usb_init_ep0_setup();
....................      #endif
....................    }
....................   #if USB_CDC_DEVICE
109E:  BRA    10AC
10A0:  MOVLB  2
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver
10A2:  MOVF   x5B,W
10A4:  SUBLW  02
10A6:  BNZ   10AE
....................       usb_isr_tok_out_cdc_data_dne();
10A8:  MOVLB  0
10AA:  BRA    1078
10AC:  MOVLB  2
....................    }
....................   #endif
10AE:  MOVLB  0
10B0:  RETURN 0
....................    //else {
....................    //   bit_set(__usb_kbhit_status,endpoint);
....................    //}
.................... }
.................... 
.................... 
.................... //---- process setup message stage -----------//
.................... 
.................... // see usb.h for documentation
.................... void usb_isr_tok_setup_dne(void) 
.................... {
....................    USB_stack_status.dev_req=NONE; // clear the device request..
*
0D0A:  CLRF   1A
.................... 
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) {
0D0C:  MOVLB  4
0D0E:  MOVF   x18,W
0D10:  ANDLW  7F
0D12:  XORLW  00
0D14:  MOVLB  0
0D16:  BZ    0D26
0D18:  XORLW  01
0D1A:  BZ    0D2A
0D1C:  XORLW  03
0D1E:  BZ    0D2E
0D20:  XORLW  23
0D22:  BZ    0D32
0D24:  BRA    0D36
.................... 
....................       case 0x00:  //standard to device
....................          debug_usb_token(debug_putc," d");
....................          usb_isr_tkn_setup_StandardDevice();
0D26:  BRA    094A
....................          break;
0D28:  BRA    0D38
.................... 
....................       case 0x01:  //standard to interface
....................          debug_usb_token(debug_putc," i");
....................          usb_isr_tkn_setup_StandardInterface();
0D2A:  BRA    0A06
....................          break;
0D2C:  BRA    0D38
.................... 
....................       case 0x02:  //standard to endpoint
....................          debug_usb_token(debug_putc," e");
....................          usb_isr_tkn_setup_StandardEndpoint();
0D2E:  BRA    0BFE
....................          break;
0D30:  BRA    0D38
....................          
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case 0x21:  //class specific request.  the only class this driver supports is HID
....................          debug_usb_token(debug_putc, " class");
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE)
....................          {
....................             usb_isr_tkn_setup_ClassInterface();
....................          }
....................          else
....................          {
....................             usb_isr_tkn_cdc();
....................          }
....................         #elif USB_HID_DEVICE
....................          usb_isr_tkn_setup_ClassInterface();
....................         #else
....................          usb_isr_tkn_cdc();
0D32:  BRA    0C6E
....................         #endif
....................          break;
0D34:  BRA    0D38
.................... #endif
.................... 
.................... 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE
.................... 
....................       default:
....................          usb_request_stall();
0D36:  RCALL  0614
....................          break;
....................    }
0D38:  GOTO   1336 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardDevice()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Device request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardDevice(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
*
094A:  MOVLB  4
094C:  MOVF   x19,W
094E:  XORLW  00
0950:  MOVLB  0
0952:  BZ    096E
0954:  XORLW  01
0956:  BZ    0982
0958:  XORLW  02
095A:  BZ    099E
095C:  XORLW  06
095E:  BZ    09B8
0960:  XORLW  03
0962:  BZ    09CA
0964:  XORLW  0E
0966:  BZ    09CE
0968:  XORLW  01
096A:  BZ    09DE
096C:  BRA    0A00
.................... 
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device;
096E:  MOVFF  1C,458
....................             usb_ep0_tx_buffer[1]=0;
0972:  MOVLB  4
0974:  CLRF   x59
....................             usb_request_send_response(2);
0976:  MOVLW  02
0978:  MOVLB  2
097A:  MOVWF  x5E
097C:  MOVLB  0
097E:  RCALL  060E
....................             break;
0980:  BRA    0A02
.................... 
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1
....................             if (usb_ep0_rx_buffer[2] == 1) {
0982:  MOVLB  4
0984:  DECFSZ x1A,W
0986:  BRA    0998
....................                debug_usb_token(debug_putc,"CF");
....................                USB_stack_status.status_device &= 1;
0988:  MOVLW  01
098A:  ANDWF  1C,F
....................                usb_put_0len_0();
098C:  MOVLB  2
098E:  CLRF   x5E
0990:  MOVLB  0
0992:  RCALL  060E
....................             }
0994:  BRA    099C
0996:  MOVLB  4
....................             else
....................                usb_request_stall();
0998:  MOVLB  0
099A:  RCALL  0614
....................             break;
099C:  BRA    0A02
.................... 
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3
....................             if (usb_ep0_rx_buffer[2] == 1) {
099E:  MOVLB  4
09A0:  DECFSZ x1A,W
09A2:  BRA    09B2
....................                debug_usb_token(debug_putc,"SF");
....................                USB_stack_status.status_device |= 2;
09A4:  BSF    1C.1
....................                usb_put_0len_0();
09A6:  MOVLB  2
09A8:  CLRF   x5E
09AA:  MOVLB  0
09AC:  RCALL  060E
....................             }
09AE:  BRA    09B6
09B0:  MOVLB  4
....................             else
....................                usb_request_stall();
09B2:  MOVLB  0
09B4:  RCALL  0614
....................             break;
09B6:  BRA    0A02
.................... 
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5
....................             debug_usb_token(debug_putc,"SA");
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request
09B8:  MOVLW  02
09BA:  MOVWF  1A
....................             USB_address_pending=usb_ep0_rx_buffer[2];
09BC:  MOVFF  41A,24
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request
....................             usb_set_address(USB_address_pending);
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0
....................             #endif
....................             usb_put_0len_0();
09C0:  MOVLB  2
09C2:  CLRF   x5E
09C4:  MOVLB  0
09C6:  RCALL  060E
....................             break;
09C8:  BRA    0A02
.................... 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6
....................             debug_usb_token(debug_putc,"GD");
....................             usb_Get_Descriptor();
09CA:  BRA    06A0
....................             break;
09CC:  BRA    0A02
.................... 
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8
....................             debug_usb_token(debug_putc,"GC");
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config;
09CE:  MOVFF  1B,458
....................             usb_request_send_response(1);
09D2:  MOVLW  01
09D4:  MOVLB  2
09D6:  MOVWF  x5E
09D8:  MOVLB  0
09DA:  RCALL  060E
....................             break;
09DC:  BRA    0A02
.................... 
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) {
09DE:  MOVLB  4
09E0:  MOVF   x1A,W
09E2:  SUBLW  01
09E4:  BNC   09FC
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2];
09E6:  MOVFF  41A,1B
....................                usb_set_configured(usb_ep0_rx_buffer[2]);
09EA:  MOVFF  41A,25B
09EE:  MOVLB  0
09F0:  BRA    075E
....................                debug_usb_token(debug_putc,"SC%U", USB_stack_status.curr_config);               
....................                usb_put_0len_0();
09F2:  MOVLB  2
09F4:  CLRF   x5E
09F6:  MOVLB  0
09F8:  RCALL  060E
09FA:  MOVLB  4
....................             }
....................             break;
09FC:  MOVLB  0
09FE:  BRA    0A02
.................... 
....................       default:
....................             usb_request_stall();
0A00:  RCALL  0614
....................             break;
....................    }
0A02:  GOTO   0D38 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Interface request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardInterface(void) {
....................    unsigned int8 curr_config;
.................... 
....................    curr_config=USB_stack_status.curr_config;
0A06:  MOVFF  1B,25B
.................... 
....................    switch (usb_ep0_rx_buffer[1]) {
0A0A:  MOVLB  4
0A0C:  MOVF   x19,W
0A0E:  XORLW  00
0A10:  MOVLB  0
0A12:  BZ    0A1E
0A14:  XORLW  0A
0A16:  BZ    0A30
0A18:  XORLW  01
0A1A:  BZ    0A76
0A1C:  BRA    0AA2
....................       case USB_STANDARD_REQUEST_GET_STATUS:
....................             debug_usb_token(debug_putc,"GS");
....................             usb_ep0_tx_buffer[0]=0;
0A1E:  MOVLB  4
0A20:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0;
0A22:  CLRF   x59
....................             usb_request_send_response(2);
0A24:  MOVLW  02
0A26:  MOVLB  2
0A28:  MOVWF  x5E
0A2A:  MOVLB  0
0A2C:  RCALL  060E
....................             break;
0A2E:  BRA    0AA4
.................... 
....................       case USB_STANDARD_REQUEST_GET_INTERFACE:
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state
0A30:  MOVLB  2
0A32:  MOVF   x5B,F
0A34:  BZ    0A70
0A36:  MOVLW  01
0A38:  SUBWF  x5B,W
0A3A:  CLRF   03
0A3C:  MOVLB  0
0A3E:  CALL   01A2
0A42:  MOVWF  01
0A44:  MOVLB  4
0A46:  SUBWF  x1C,W
0A48:  BTFSS  FD8.0
0A4A:  BRA    0A50
0A4C:  MOVLB  2
0A4E:  BRA    0A70
....................                debug_usb_token(debug_putc,"GI");
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte
0A50:  CLRF   03
0A52:  MOVF   x1C,W
0A54:  ADDLW  29
0A56:  MOVWF  FE9
0A58:  MOVLW  00
0A5A:  ADDWFC 03,W
0A5C:  MOVWF  FEA
0A5E:  MOVFF  FEF,458
....................                usb_request_send_response(1); //send byte back
0A62:  MOVLW  01
0A64:  MOVLB  2
0A66:  MOVWF  x5E
0A68:  MOVLB  0
0A6A:  RCALL  060E
....................             }
0A6C:  BRA    0A74
0A6E:  MOVLB  2
....................             else
....................                usb_request_stall();
0A70:  MOVLB  0
0A72:  RCALL  0614
....................             break;
0A74:  BRA    0AA4
.................... 
....................       case USB_STANDARD_REQUEST_SET_INTERFACE:
....................             if (curr_config) { //if configured state
0A76:  MOVLB  2
0A78:  MOVF   x5B,F
0A7A:  BZ    0A9C
....................                debug_usb_token(debug_putc,"SI");
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
0A7C:  CLRF   03
0A7E:  MOVLB  4
0A80:  MOVF   x1C,W
0A82:  ADDLW  29
0A84:  MOVWF  FE9
0A86:  MOVLW  00
0A88:  ADDWFC 03,W
0A8A:  MOVWF  FEA
0A8C:  MOVFF  41A,FEF
....................                usb_put_0len_0();
0A90:  MOVLB  2
0A92:  CLRF   x5E
0A94:  MOVLB  0
0A96:  RCALL  060E
....................             }
0A98:  BRA    0AA0
0A9A:  MOVLB  2
....................             else
....................                usb_request_stall();
0A9C:  MOVLB  0
0A9E:  RCALL  0614
....................             break;
0AA0:  BRA    0AA4
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR:
....................             debug_usb_token(debug_putc,"GDh");
....................             usb_Get_Descriptor();
....................             break;
.................... #endif
.................... 
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE:
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE:
.................... //                let default take care of these, goto wrongstate
....................       default:
....................             usb_request_stall();
0AA2:  RCALL  0614
....................             break;
....................    }
0AA4:  GOTO   0D38 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_StandardEndpoint()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_isr_tkn_setup_StandardEndpoint(void) {
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) {
*
0BFE:  MOVFF  41C,265
0C02:  RCALL  0460
0C04:  MOVF   01,F
0C06:  BZ    0C64
....................       switch(usb_ep0_rx_buffer[1]) {
0C08:  MOVLB  4
0C0A:  MOVF   x19,W
0C0C:  XORLW  01
0C0E:  MOVLB  0
0C10:  BZ    0C1C
0C12:  XORLW  02
0C14:  BZ    0C2C
0C16:  XORLW  03
0C18:  BZ    0C3C
0C1A:  BRA    0C62
.................... 
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE:
....................                debug_usb_token(debug_putc,"CF");
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]);
0C1C:  MOVFF  41C,25B
0C20:  BRA    0AA8
....................                usb_put_0len_0();
0C22:  MOVLB  2
0C24:  CLRF   x5E
0C26:  MOVLB  0
0C28:  RCALL  060E
....................                break;
0C2A:  BRA    0C64
.................... 
....................          case USB_STANDARD_REQUEST_SET_FEATURE:
....................                      debug_usb_token(debug_putc,"SF");
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]);
0C2C:  MOVFF  41C,25B
0C30:  BRA    0B22
....................                      usb_put_0len_0();
0C32:  MOVLB  2
0C34:  CLRF   x5E
0C36:  MOVLB  0
0C38:  RCALL  060E
....................                      break;
0C3A:  BRA    0C64
.................... 
....................          case USB_STANDARD_REQUEST_GET_STATUS:
....................                debug_usb_token(debug_putc,"GS");
....................                usb_ep0_tx_buffer[0]=0;
0C3C:  MOVLB  4
0C3E:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0;
0C40:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) {
0C42:  MOVFF  41C,25B
0C46:  MOVLB  0
0C48:  BRA    0B88
0C4A:  MOVF   01,F
0C4C:  BZ    0C56
....................                   usb_ep0_tx_buffer[0]=1;
0C4E:  MOVLW  01
0C50:  MOVLB  4
0C52:  MOVWF  x58
0C54:  MOVLB  0
....................                }
....................                usb_request_send_response(2);
0C56:  MOVLW  02
0C58:  MOVLB  2
0C5A:  MOVWF  x5E
0C5C:  MOVLB  0
0C5E:  RCALL  060E
....................                break;
0C60:  BRA    0C64
.................... 
....................          default:
....................             usb_request_stall();
0C62:  RCALL  0614
....................             break;
....................       }
....................    }
0C64:  GOTO   0D38 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_isr_tkn_setup_ClassInterface()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest
.................... /*
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID.
.................... /*          bRequest says which request.  Only certain requests are valid,
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE)
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /* Only compiled if HID_DEVICE is TRUE
.................... /***************************************************************/
.................... #IF USB_HID_DEVICE
.................... void usb_isr_tkn_setup_ClassInterface(void) {
....................    switch(usb_ep0_rx_buffer[1]) {
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03
....................             debug_usb_token(debug_putc,"GP");
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]];
....................             usb_request_send_response(1);
....................             break;
....................     #ENDIF
.................... 
....................     #IF USB_HID_BOOT_PROTOCOL
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b
....................             debug_usb_token(debug_putc,"SP");
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2];
....................             usb_put_0len_0(); //send 0len packet69
....................             break;
....................     #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_SET_IDLE:   //0a
....................          #error TODO: if you want to support SET_IDLE, add code here
....................    #ENDIF
.................... 
....................    #IF USB_HID_IDLE
....................       case USB_HID_REQUEST_GET_IDLE:   //02
....................          #error TODO: if you want to support GET_IDLE, add code here
....................    #ENDIF
.................... 
....................       default:
....................             usb_request_stall();
....................             break;
....................    }
.................... }
.................... #ENDIF
.................... 
.................... /**************************************************************
.................... /* usb_Get_Descriptor()
.................... /*
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept
.................... /*
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.),
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have
.................... /*          pointers to constants we must simulate or own by setting up global registers that say
.................... /*          which constant array to deal with, which position to start in this array, and the length.
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne()
.................... /*          which will send the rest of the data.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
.................... void usb_Get_Descriptor() {
*
06A0:  MOVLB  2
06A2:  CLRF   x5B
....................    unsigned int8 i = 0;
....................    usb_getdesc_ptr=0;
06A4:  CLRF   26
06A6:  CLRF   25
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE;
06A8:  CLRF   1D
.................... 
....................    switch(usb_ep0_rx_buffer[3]) {
06AA:  MOVLB  4
06AC:  MOVF   x1B,W
06AE:  XORLW  01
06B0:  MOVLB  0
06B2:  BZ    06C2
06B4:  XORLW  03
06B6:  BZ    06CE
06B8:  XORLW  01
06BA:  BZ    06D6
06BC:  XORLW  22
06BE:  BZ    070E
06C0:  BRA    0738
....................       case USB_DESC_DEVICE_TYPE:    //1
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN;
06C2:  CLRF   28
06C4:  MOVLW  12
06C6:  MOVWF  27
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE;
06C8:  MOVLW  03
06CA:  MOVWF  1D
....................             break;
06CC:  BRA    073C
.................... 
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually.
....................       case USB_DESC_CONFIG_TYPE:   //2
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN;
06CE:  CLRF   28
06D0:  MOVLW  43
06D2:  MOVWF  27
....................             break;
06D4:  BRA    073C
.................... 
....................       case USB_DESC_STRING_TYPE: //3
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE;
06D6:  MOVLW  02
06D8:  MOVWF  1D
....................             //usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]];
....................             for(i=0; i<usb_ep0_rx_buffer[2]; i++)
06DA:  MOVLB  2
06DC:  CLRF   x5B
06DE:  MOVLB  4
06E0:  MOVF   x1A,W
06E2:  MOVLB  2
06E4:  SUBWF  x5B,W
06E6:  BC    06FE
....................             {
....................                usb_getdesc_ptr += USB_STRING_DESC[usb_getdesc_ptr];
06E8:  MOVFF  26,03
06EC:  MOVF   25,W
06EE:  MOVLB  0
06F0:  RCALL  01EE
06F2:  ADDWF  25,F
06F4:  MOVLW  00
06F6:  ADDWFC 26,F
06F8:  MOVLB  2
06FA:  INCF   x5B,F
06FC:  BRA    06DE
....................             }
....................             usb_getdesc_len = USB_STRING_DESC[usb_getdesc_ptr];
06FE:  MOVFF  26,03
0702:  MOVF   25,W
0704:  MOVLB  0
0706:  RCALL  01EE
0708:  MOVWF  27
070A:  CLRF   28
....................             break;
070C:  BRA    073C
.................... 
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06
....................       // this is needed so host can find out about differences about this
....................       // devices ability to handle full speed verses fast speed.
....................       // since we don't support fast speed then we ignore this.
....................       //      break;
.................... 
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE
....................       case USB_DESC_CLASS_TYPE:  //0x21
....................             //TODO does this work for multiple interfaces or multiple languages?
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]];
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]];
070E:  CLRF   03
0710:  MOVLB  4
0712:  MOVF   x1A,W
0714:  MOVLB  0
0716:  RCALL  01B4
0718:  MOVWF  25
071A:  CLRF   26
....................             if (usb_getdesc_ptr!=0xFF) {
071C:  INCFSZ 25,W
071E:  BRA    0724
0720:  MOVF   26,F
0722:  BZ    0734
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr];
0724:  MOVFF  26,03
0728:  MOVF   25,W
072A:  RCALL  014E
072C:  MOVWF  27
072E:  CLRF   28
....................                break;
0730:  BRA    073C
....................             }
0732:  BRA    0738
....................             else {
....................                usb_request_stall();
0734:  RCALL  0614
....................                return;
0736:  BRA    075A
....................             }
.................... #endif
.................... 
.................... #IF USB_HID_DEVICE
....................       case USB_DESC_HIDREPORT_TYPE: //0x22
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]];
....................             if (usb_getdesc_ptr !=0xFF) {
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE;
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]];
....................                break;
....................             }
....................             else {
....................                usb_request_stall();
....................                return;
....................             }
.................... #endif
.................... 
....................       default:
....................             usb_request_stall();
0738:  RCALL  0614
....................             return;
073A:  BRA    075A
....................    }
....................    if (usb_ep0_rx_buffer[7]==0) {
073C:  MOVLB  4
073E:  MOVF   x1F,F
0740:  BNZ   0752
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6])
0742:  MOVF   28,F
0744:  BNZ   074C
0746:  MOVF   27,W
0748:  SUBWF  x1E,W
074A:  BC    0752
....................          usb_getdesc_len = usb_ep0_rx_buffer[6];
074C:  CLRF   28
074E:  MOVFF  41E,27
....................    }
....................    USB_stack_status.dev_req=GET_DESCRIPTOR;
0752:  MOVLW  01
0754:  MOVWF  1A
....................    usb_copy_desc_seg_to_ep();
0756:  MOVLB  0
0758:  RCALL  0618
075A:  GOTO   0A02 (RETURN)
.................... }
.................... 
.................... /**************************************************************
.................... /* usb_finish_set_address()
.................... /*
.................... /* Input: USB_address_pending holds the address we were asked to set to.
.................... /*
.................... /* Summary: Sets the address.
.................... /*
.................... /* This code should only be run on the PIC USB peripheral, and not the
.................... /* National peripheral.
.................... /*
.................... /* Part of usb_isr_tok_setup_dne()
.................... /***************************************************************/
....................  void usb_finish_set_address() {
....................    debug_usb_token(debug_putc," FSA ");
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0
*
10CC:  CLRF   1B
.................... 
....................    #ifdef __PIC__
....................    USB_stack_status.dev_req=NONE;  // no request pending
10CE:  CLRF   1A
....................    usb_set_address(USB_address_pending);
10D0:  MOVFF  24,25C
10D4:  BRA    10B2
....................    #endif
10D6:  GOTO   12EA (RETURN)
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... ///
.................... /// The following function retrieve data from constant arrays.  This may
.................... /// look un-optimized, but remember that you can't create a pointer to
.................... /// a constant array.
.................... ///
.................... ///////////////////////////////////////////////////////////////////////////
.................... void usb_copy_desc_seg_to_ep(void) {
*
0618:  MOVLB  2
061A:  CLRF   x5C
....................    unsigned int i=0;
....................    char c;
....................    
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]);
.................... 
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH))
061C:  MOVF   27,W
061E:  IORWF  28,W
0620:  BZ    0688
0622:  MOVF   x5C,W
0624:  SUBLW  3F
0626:  BNC   0688
....................    {
....................       switch(USB_stack_status.getdesc_type) {
0628:  MOVF   1D,W
062A:  XORLW  00
062C:  MOVLB  0
062E:  BZ    063A
0630:  XORLW  02
0632:  BZ    0648
0634:  XORLW  01
0636:  BZ    0656
0638:  BRA    0662
....................          case USB_GETDESC_CONFIG_TYPE:
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr];
063A:  MOVFF  26,03
063E:  MOVF   25,W
0640:  RCALL  014E
0642:  MOVFF  FE8,25D
....................             break;
0646:  BRA    0662
.................... 
....................         #IF USB_HID_DEVICE
....................          case USB_GETDESC_HIDREPORT_TYPE:
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr];
....................             break;
....................         #endif
.................... 
....................          case USB_GETDESC_STRING_TYPE:
....................             c=USB_STRING_DESC[usb_getdesc_ptr];
0648:  MOVFF  26,03
064C:  MOVF   25,W
064E:  RCALL  01EE
0650:  MOVFF  FE8,25D
....................             break;
0654:  BRA    0662
.................... 
....................          case USB_GETDESC_DEVICE_TYPE:
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr];
0656:  MOVFF  26,03
065A:  MOVF   25,W
065C:  RCALL  01CC
065E:  MOVFF  FE8,25D
....................             //debug_usb(debug_putc, "-%X- ", c);
....................             break;
....................       }
....................       usb_getdesc_ptr++;
0662:  INCF   25,F
0664:  BTFSC  FD8.2
0666:  INCF   26,F
....................       usb_getdesc_len--;
0668:  MOVF   27,W
066A:  BTFSC  FD8.2
066C:  DECF   28,F
066E:  DECF   27,F
....................       usb_ep0_tx_buffer[i++]=c;
0670:  MOVLB  2
0672:  MOVF   x5C,W
0674:  INCF   x5C,F
0676:  ADDLW  58
0678:  MOVWF  FE9
067A:  MOVLW  04
067C:  MOVWF  FEA
067E:  BTFSC  FD8.0
0680:  INCF   FEA,F
0682:  MOVFF  25D,FEF
0686:  BRA    061C
....................    }
.................... 
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) {
0688:  MOVF   27,W
068A:  IORWF  28,W
068C:  BNZ   0696
068E:  MOVF   x5C,W
0690:  SUBLW  40
0692:  BZ    0696
....................          USB_stack_status.dev_req = NONE;
0694:  CLRF   1A
....................    }
.................... 
....................    usb_request_send_response(i);
0696:  MOVFF  25C,25E
069A:  MOVLB  0
069C:  RCALL  060E
069E:  RETURN 0
.................... }
.................... 
.................... #ENDIF
.................... 
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... /*
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk
....................    transfer endpoints is not supported on slow speed devices per the USB
....................    specification.  You may be able to find unofficial drivers for your
....................    operating system that allows CDC to operate on a slow speed device,
....................    but CCS doesn't have any that they can recommend to you.
.................... */
.................... #if (USB_USE_FULL_SPEED==0)
....................    #error CDC and slow speed is not supported.  See comments above.
.................... #endif
.................... 
.................... struct {
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2)
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space)
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16)
.................... } __attribute__((__packed__)) usb_cdc_line_coding;
.................... 
.................... //length of time, in ms, of break signal as we received in a SendBreak message.
.................... //if ==0xFFFF, send break signal until we receive a 0x0000.
.................... unsigned int16 usb_cdc_break;
.................... 
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1];
.................... #else
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE];
.................... #endif
.................... 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT)
.................... #if sizeof(usb_cdc_put_buffer)>=0x100
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this.
....................  typedef unsigned int16 usb_cdc_tx_t;
.................... #else
....................  typedef unsigned int8 usb_cdc_tx_t;
.................... #endif
.................... 
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin;
.................... //#locate usb_cdc_put_buffer_nextin=0x1800
.................... 
.................... 
.................... #if defined(__PIC__)
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer
.................... #else
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE];
.................... #endif
.................... 
.................... int1 usb_cdc_got_set_line_coding;
.................... 
.................... struct  {
....................    int1 dte_present; //1=DTE present, 0=DTE not present
....................    int1 active;      //1=activate carrier, 0=deactivate carrier
....................    unsigned int reserved:6;
.................... } usb_cdc_carrier;
.................... 
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state;
.................... 
.................... /*
.................... #if defined(__PCH__)
....................  #byte INTCON=0xFF2
....................  #bit INT_GIE=INTCON.7
.................... #else
....................  #word SR=0x42
.................... #endif
.................... */
.................... 
.................... #if defined(USB_CDC_USE_ENCAPSULATED)
.................... unsigned int16 g_UsbCdcSendEncapsSize;
.................... #endif
.................... 
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data]
.................... void usb_isr_tok_out_cdc_control_dne(void) 
.................... {
....................    switch (__usb_cdc_state) {
*
0FDE:  MOVF   xB7,W
0FE0:  XORLW  01
0FE2:  BZ    0FEA
0FE4:  XORLW  03
0FE6:  BZ    0FF8
0FE8:  BRA    1020
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state);
....................       case USB_CDC_OUT_COMMAND:
....................         #if defined(USB_CDC_USE_ENCAPSULATED)
....................          usb_cdc_SendEncapsulatedCommand(usb_ep0_rx_buffer, g_UsbCdcSendEncapsSize);
....................         #endif
....................          usb_put_0len_0();
0FEA:  MOVLB  2
0FEC:  CLRF   x5E
0FEE:  MOVLB  0
0FF0:  CALL   060E
....................          __usb_cdc_state=0;
0FF4:  CLRF   xB7
....................          break;
0FF6:  BRA    1022
.................... 
....................     #if USB_MAX_EP0_PACKET_LENGTH==8
....................       case USB_CDC_WAIT_0LEN:
....................          usb_put_0len_0();
....................          __usb_cdc_state=0;
....................          break;
....................     #endif
.................... 
....................       case USB_CDC_OUT_LINECODING:
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7);
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n");
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7);
0FF8:  CLRF   FEA
0FFA:  MOVLW  2B
0FFC:  MOVWF  FE9
0FFE:  MOVLW  04
1000:  MOVWF  FE2
1002:  MOVLW  18
1004:  MOVWF  FE1
1006:  MOVLW  07
1008:  MOVWF  01
100A:  MOVFF  FE6,FEE
100E:  DECFSZ 01,F
1010:  BRA    100A
....................          __usb_cdc_state=0;
1012:  CLRF   xB7
....................          usb_put_0len_0();
1014:  MOVLB  2
1016:  CLRF   x5E
1018:  MOVLB  0
101A:  CALL   060E
....................          break;
101E:  BRA    1022
.................... 
....................       default:
....................          __usb_cdc_state=0;
1020:  CLRF   xB7
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009
....................          break;
....................    }
1022:  GOTO   109E (RETURN)
.................... }
.................... 
.................... //handle IN token on 0 (setup packet)
.................... void usb_isr_tkn_cdc(void) {
....................    unsigned int16 wLen;
....................    //make sure the request goes to a CDC interface
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) {
*
0C6E:  MOVLB  4
0C70:  DECFSZ x1C,W
0C72:  BRA    0C76
0C74:  BRA    0C7A
0C76:  MOVF   x1C,F
0C78:  BNZ   0D04
....................       wLen = make16(usb_ep0_rx_buffer[7], usb_ep0_rx_buffer[6]);
0C7A:  MOVFF  41F,25C
0C7E:  MOVFF  41E,25B
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]);
....................       switch(usb_ep0_rx_buffer[1]) {
0C82:  MOVF   x19,W
0C84:  XORLW  00
0C86:  MOVLB  0
0C88:  BZ    0CA0
0C8A:  XORLW  01
0C8C:  BZ    0CA8
0C8E:  XORLW  21
0C90:  BZ    0CB0
0C92:  XORLW  01
0C94:  BZ    0CBA
0C96:  XORLW  03
0C98:  BZ    0CE0
0C9A:  XORLW  01
0C9C:  BZ    0CEE
0C9E:  BRA    0D00
....................          case 0x00:  //send_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             g_UsbCdcSendEncapsSize = wLen;
....................            #endif
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND;
0CA0:  MOVLW  01
0CA2:  MOVWF  xB7
....................             usb_request_get_data();
0CA4:  RCALL  0C68
....................             break;
0CA6:  BRA    0D02
.................... 
....................          case 0x01:  //get_encapsulated_command
....................            #if defined(USB_CDC_USE_ENCAPSULATED)
....................             usb_cdc_GetEncapsulatedResponse(usb_ep0_tx_buffer, wLen);
....................            #endif
....................             usb_request_send_response(wLen);
0CA8:  MOVFF  25B,25E
0CAC:  RCALL  060E
....................             break;
0CAE:  BRA    0D02
.................... 
....................          case 0x20:  //set_line_coding
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING;
0CB0:  MOVLW  02
0CB2:  MOVWF  xB7
....................             usb_cdc_got_set_line_coding=true;
0CB4:  BSF    xB5.0
....................             usb_request_get_data();
0CB6:  RCALL  0C68
....................             break;
0CB8:  BRA    0D02
.................... 
....................          case 0x21:  //get_line_coding
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding));
0CBA:  MOVLW  04
0CBC:  MOVWF  FEA
0CBE:  MOVLW  58
0CC0:  MOVWF  FE9
0CC2:  CLRF   FE2
0CC4:  MOVLW  2B
0CC6:  MOVWF  FE1
0CC8:  MOVLW  07
0CCA:  MOVWF  01
0CCC:  MOVFF  FE6,FEE
0CD0:  DECFSZ 01,F
0CD2:  BRA    0CCC
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes
0CD4:  MOVLW  07
0CD6:  MOVLB  2
0CD8:  MOVWF  x5E
0CDA:  MOVLB  0
0CDC:  RCALL  060E
....................             break;
0CDE:  BRA    0D02
.................... 
....................          case 0x22:  //set_control_line_state
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2];
0CE0:  MOVFF  41A,B6
....................             usb_put_0len_0();
0CE4:  MOVLB  2
0CE6:  CLRF   x5E
0CE8:  MOVLB  0
0CEA:  RCALL  060E
....................             break;
0CEC:  BRA    0D02
.................... 
....................          case 0x23:  //send_break
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]);
0CEE:  MOVFF  41A,33
0CF2:  MOVFF  41B,32
....................             usb_put_0len_0();
0CF6:  MOVLB  2
0CF8:  CLRF   x5E
0CFA:  MOVLB  0
0CFC:  RCALL  060E
....................             break;
0CFE:  BRA    0D02
.................... 
....................          default:
....................             usb_request_stall();
0D00:  RCALL  0614
....................             break;
0D02:  MOVLB  4
....................       }
....................    }
0D04:  MOVLB  0
0D06:  GOTO   0D38 (RETURN)
.................... }
.................... 
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars]
.................... void usb_isr_tok_out_cdc_data_dne(void) {
....................    usb_cdc_get_buffer_status.got=true;
*
1078:  BSF    1E.0
....................    usb_cdc_get_buffer_status.index=0;
107A:  CLRF   20
.................... #if (defined(__PIC__) && __PIC__)
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT);
107C:  MOVLW  02
107E:  MOVLB  2
1080:  MOVWF  x5C
1082:  MOVLB  0
1084:  BRA    1026
1086:  MOVFF  01,1F
.................... #else
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer(
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE);
.................... #endif
....................    if (!usb_cdc_get_buffer_status.len)
108A:  MOVF   1F,F
108C:  BNZ   1090
....................    {
....................       usb_cdc_get_discard();
108E:  BRA    1066
....................    }
1090:  GOTO   10AC (RETURN)
....................    /*
....................   #if defined(USB_CDC_ISR)
....................    else
....................    {
....................       USB_CDC_ISR();
....................    }
....................   #endif
....................   */
.................... }
.................... 
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters]
.................... void usb_isr_tok_in_cdc_data_dne(void) 
.................... {
....................    usb_cdc_flush_tx_buffer();
*
12C6:  RCALL  1254
12C8:  GOTO   12F8 (RETURN)
.................... }
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
*
1178:  MOVFF  261,267
117C:  MOVFF  260,266
....................    sc2=s2;
1180:  MOVFF  263,269
1184:  MOVFF  262,268
....................    if(sc2<sc1 && sc1 <sc2 +n)
1188:  MOVLB  2
118A:  MOVF   x69,W
118C:  SUBWF  x67,W
118E:  BNC   1208
1190:  BNZ   1198
1192:  MOVF   x66,W
1194:  SUBWF  x68,W
1196:  BC    1208
1198:  MOVF   x64,W
119A:  ADDWF  x68,W
119C:  MOVWF  01
119E:  MOVF   x65,W
11A0:  ADDWFC x69,W
11A2:  MOVWF  03
11A4:  MOVF   x67,W
11A6:  SUBWF  03,W
11A8:  BNC   1208
11AA:  BNZ   11B2
11AC:  MOVF   01,W
11AE:  SUBWF  x66,W
11B0:  BC    1208
....................       for(sc1+=n,sc2+=n;0<n;--n)
11B2:  MOVF   x64,W
11B4:  ADDWF  x66,F
11B6:  MOVF   x65,W
11B8:  ADDWFC x67,F
11BA:  MOVF   x64,W
11BC:  ADDWF  x68,F
11BE:  MOVF   x65,W
11C0:  ADDWFC x69,F
11C2:  MOVF   x65,F
11C4:  BNZ   11CC
11C6:  MOVF   x64,W
11C8:  SUBLW  00
11CA:  BC    1206
....................          *--sc1=*--sc2;
11CC:  MOVF   x66,W
11CE:  BTFSC  FD8.2
11D0:  DECF   x67,F
11D2:  DECF   x66,F
11D4:  MOVFF  267,26B
11D8:  MOVFF  266,26A
11DC:  MOVF   x68,W
11DE:  BTFSC  FD8.2
11E0:  DECF   x69,F
11E2:  DECF   x68,F
11E4:  MOVFF  269,FEA
11E8:  MOVFF  268,FE9
11EC:  MOVFF  FEF,26C
11F0:  MOVFF  267,FEA
11F4:  MOVFF  266,FE9
11F8:  MOVFF  26C,FEF
11FC:  MOVF   x64,W
11FE:  BTFSC  FD8.2
1200:  DECF   x65,F
1202:  DECF   x64,F
1204:  BRA    11C2
1206:  BRA    1248
....................    else
....................       for(;0<n;--n)
1208:  MOVF   x65,F
120A:  BNZ   1212
120C:  MOVF   x64,W
120E:  SUBLW  00
1210:  BC    1248
....................          *sc1++=*sc2++;
1212:  MOVFF  267,26B
1216:  MOVF   x66,W
1218:  INCF   x66,F
121A:  BTFSC  FD8.2
121C:  INCF   x67,F
121E:  MOVWF  x6A
1220:  MOVFF  269,FEA
1224:  MOVF   x68,W
1226:  INCF   x68,F
1228:  BTFSC  FD8.2
122A:  INCF   x69,F
122C:  MOVWF  FE9
122E:  MOVFF  FEF,26C
1232:  MOVFF  26B,FEA
1236:  MOVFF  26A,FE9
123A:  MOVFF  26C,FEF
123E:  MOVF   x64,W
1240:  BTFSC  FD8.2
1242:  DECF   x65,F
1244:  DECF   x64,F
1246:  BRA    1208
....................   return s1;
1248:  MOVFF  260,01
124C:  MOVFF  261,02
1250:  MOVLB  0
1252:  RETURN 0
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... void usb_cdc_flush_tx_buffer(void) 
.................... {
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE
....................    usb_cdc_tx_t n;
....................   #endif
....................   
....................    if (usb_cdc_put_buffer_nextin != 0)
1254:  MOVF   xB4,F
1256:  BZ    12C4
....................    {
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE))
....................       {
....................          usb_cdc_put_buffer_nextin = 0;
....................       }
....................      #else
....................       n = usb_cdc_put_buffer_nextin;
1258:  MOVFF  B4,25C
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets
125C:  MOVLB  2
125E:  MOVF   x5C,W
1260:  SUBLW  3F
1262:  BC    1268
....................          n = USB_CDC_DATA_IN_SIZE-1;
1264:  MOVLW  3F
1266:  MOVWF  x5C
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE))
1268:  MOVLW  02
126A:  MOVWF  x5D
126C:  CLRF   x5F
126E:  MOVLW  34
1270:  MOVWF  x5E
1272:  CLRF   x61
1274:  MOVFF  25C,260
1278:  MOVLW  02
127A:  MOVWF  x62
127C:  MOVLB  0
127E:  RCALL  10DA
1280:  MOVF   01,F
1282:  BZ    12C4
....................       {
....................          //pull the buffer back
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n);
1284:  CLRF   03
1286:  MOVLB  2
1288:  MOVF   x5C,W
128A:  ADDLW  34
128C:  MOVWF  01
128E:  MOVLW  00
1290:  ADDWFC 03,F
1292:  MOVFF  01,25D
1296:  MOVFF  03,25E
129A:  MOVF   x5C,W
129C:  MOVLB  0
129E:  SUBWF  xB4,W
12A0:  MOVLB  2
12A2:  MOVWF  x5F
12A4:  CLRF   x61
12A6:  MOVLW  34
12A8:  MOVWF  x60
12AA:  MOVFF  03,263
12AE:  MOVFF  01,262
12B2:  CLRF   x65
12B4:  MOVFF  25F,264
12B8:  MOVLB  0
12BA:  RCALL  1178
....................          usb_cdc_put_buffer_nextin -= n;
12BC:  MOVLB  2
12BE:  MOVF   x5C,W
12C0:  MOVLB  0
12C2:  SUBWF  xB4,F
....................       }      
....................      #endif
....................    }
12C4:  RETURN 0
.................... }
.................... 
.................... void usb_cdc_init(void) 
.................... {
....................    usb_cdc_line_coding.dwDTERrate = 9600;
*
055E:  MOVLB  2
0560:  CLRF   x5D
0562:  CLRF   x5C
0564:  MOVLW  25
0566:  MOVWF  x5B
0568:  MOVLW  80
056A:  MOVWF  x5A
056C:  MOVFF  25A,2B
0570:  MOVFF  25B,2C
0574:  CLRF   2D
0576:  CLRF   2E
....................    usb_cdc_line_coding.bCharFormat = 0;
0578:  CLRF   x5A
057A:  MOVFF  25A,2F
....................    usb_cdc_line_coding.bParityType = 0;
057E:  CLRF   x5A
0580:  MOVFF  25A,30
....................    usb_cdc_line_coding.bDataBits = 8;
0584:  MOVLW  08
0586:  MOVWF  x5A
0588:  MOVFF  25A,31
....................    (int8)usb_cdc_carrier = 0;
058C:  MOVLB  0
058E:  CLRF   xB6
....................    usb_cdc_got_set_line_coding = false;
0590:  BCF    xB5.0
....................    usb_cdc_break = 0;
0592:  CLRF   33
0594:  CLRF   32
....................    usb_cdc_put_buffer_nextin = 0;
0596:  CLRF   xB4
....................    usb_cdc_get_buffer_status.got = 0;
0598:  BCF    1E.0
....................    __usb_cdc_state = 0;
059A:  CLRF   xB7
059C:  RETURN 0
.................... }
.................... 
.................... ////////////////// END USB CONTROL HANDLING //////////////////////////////////
.................... 
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY /////////////////////////////
.................... 
.................... typedef struct
.................... {
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD.
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device.
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device. 
....................    unsigned int bFraming:1;   //A framing error has occurred.
....................    unsigned int bParity:1;    //A parity error has occurred.
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device.
....................    unsigned int reserved0:1;   //future use
....................    unsigned int reserved1:8;   //future use
.................... } cdc_serial_state_t;
.................... 
.................... /*
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring, 
....................    break signal and more (see cdc_serial_state_t).
....................    Some of these values are held by the host (meaning it's value only needs
....................    to be sent on change), but some values are one shot (meaning you continously
....................    need to send value to host while being held).
.................... */
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state)
.................... {
....................   #if __USB_PIC_PERIF__
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer
....................   #else
....................    unsigned int8 payload[10];
....................    #define CDC_EP1_NOTIFY_BUFFER payload
....................   #endif
.................... 
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT))
....................       return(false);
.................... 
....................    //bmRequestType
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001
....................    //bNotification
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE
....................    //wValue
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0;
....................    //wIndex
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0;
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0;
....................    //wLength
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t)
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0;
....................    //data
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state;
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8;
.................... 
....................   #if __USB_PIC_PERIF__
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE);
....................   #else
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE);
....................   #endif
....................    
....................    return(true);
.................... }
.................... 
.................... void usb_cdc_get_discard(void)
.................... {
....................    usb_cdc_get_buffer_status.got = false;
*
1066:  BCF    1E.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE);
1068:  MOVLW  02
106A:  MOVLB  2
106C:  MOVWF  x5C
106E:  MOVWF  x5D
1070:  MOVLB  0
1072:  RCALL  0D3C
1074:  GOTO   1090 (RETURN)
.................... }
.................... 
.................... char usb_cdc_getc(void) 
.................... {
....................    char c;
.................... 
....................    while (!usb_cdc_kbhit()) 
....................    {
....................      #if defined(USB_ISR_POLLING)
....................       usb_task();
....................      #endif
....................    }
.................... 
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++];
.................... 
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len) 
....................    {
....................       usb_cdc_get_discard();
....................    }
.................... 
....................    return(c);
.................... }
.................... 
.................... #if defined(USB_ISR_POLLING)
.................... #define __USB_PAUSE_ISR()
.................... #define __USB_RESTORE_ISR()
.................... #else
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1
.................... #endif
.................... 
.................... static void _usb_cdc_putc_fast_noflush(char c)
.................... {
....................    __USB_PAUSE_ISR();
*
18F0:  MOVLB  2
18F2:  BCF    x43.0
18F4:  BTFSC  FA0.5
18F6:  BSF    x43.0
18F8:  BCF    FA0.5
.................... 
....................   #if defined(USB_CDC_DELAYED_FLUSH)
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) 
18FA:  MOVLB  0
18FC:  MOVF   xB4,W
18FE:  SUBLW  7F
1900:  BC    1910
1902:  CLRF   19
1904:  BTFSC  FF2.7
1906:  BSF    19.7
1908:  BCF    FF2.7
....................    {
....................       usb_cdc_flush_tx_buffer();
190A:  RCALL  1254
190C:  BTFSC  19.7
190E:  BSF    FF2.7
....................    }
....................   #endif
.................... 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) {
1910:  MOVF   xB4,W
1912:  SUBLW  7F
1914:  BC    191A
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer!
1916:  MOVLW  7F
1918:  MOVWF  xB4
....................    }
....................    
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c;
191A:  MOVF   xB4,W
191C:  INCF   xB4,F
191E:  CLRF   03
1920:  ADDLW  34
1922:  MOVWF  FE9
1924:  MOVLW  00
1926:  ADDWFC 03,W
1928:  MOVWF  FEA
192A:  MOVFF  242,FEF
.................... 
....................    __USB_RESTORE_ISR();
192E:  MOVLB  2
1930:  BTFSS  x43.0
1932:  BRA    1936
1934:  BSF    FA0.5
1936:  MOVLB  0
1938:  GOTO   1942 (RETURN)
.................... }
.................... 
.................... void usb_cdc_putc_fast(char c)
.................... {
....................    _usb_cdc_putc_fast_noflush(c);
193C:  MOVFF  241,242
1940:  BRA    18F0
.................... 
....................   #if defined(USB_ISR_POLLING)
....................    // if interrupts are disabled, we should clear all activity isrs
....................    // before we attempt to put any data onto an endpoint.
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT))
....................       return;
....................    usb_task();
....................   #endif
....................   
....................   #if !defined(USB_CDC_DELAYED_FLUSH)
1942:  GOTO   1980 (RETURN)
....................    //if (usb_cdc_put_buffer_free()) 
....................    {
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin);
....................       usb_cdc_flush_tx_buffer();
....................    }
....................   #endif
.................... 
....................    //putc('*');
.................... }
.................... 
.................... void usb_cdc_putc(char c)
.................... {
....................    while (!usb_cdc_putready()) 
1946:  MOVLW  80
1948:  BSF    FD8.0
194A:  SUBFWB xB4,W
194C:  BNZ   197A
194E:  CLRF   19
1950:  BTFSC  FF2.7
1952:  BSF    19.7
1954:  BCF    FF2.7
....................    {
....................      #if 1
....................       if (usb_cdc_put_buffer_free()) 
1956:  MOVLW  02
1958:  MOVLB  2
195A:  MOVWF  x6A
195C:  MOVLB  0
195E:  CALL   0E3C
1962:  BTFSC  19.7
1964:  BSF    FF2.7
1966:  MOVF   01,F
1968:  BZ    1978
196A:  CLRF   19
196C:  BTFSC  FF2.7
196E:  BSF    19.7
1970:  BCF    FF2.7
....................       {
....................          usb_cdc_flush_tx_buffer();
1972:  RCALL  1254
1974:  BTFSC  19.7
1976:  BSF    FF2.7
....................       }
....................      #endif
.................... 
....................      #if defined(USB_ISR_POLLING)
1978:  BRA    1946
....................       usb_task();
....................      #endif
....................    }
....................    usb_cdc_putc_fast(c);
197A:  MOVFF  240,241
197E:  BRA    193C
1980:  RETURN 0
.................... }
.................... 
.................... int1 usb_cdc_putd(char *ptr, unsigned int8 len)
.................... {
....................  #if USB_EP2_TX_SIZE>=0x100
....................    unsigned int16 i;
....................  #else
....................    unsigned int8 i;
....................  #endif
....................    char c;
....................    
....................    i = 0;
....................    
....................    if (!usb_cdc_put_buffer_free())
....................       return(false);
....................    
....................    while(len--)
....................    {
....................       c = *ptr++;
....................       _usb_cdc_putc_fast_noflush(c);
....................       if (++i >= USB_EP2_TX_SIZE)
....................          break;
....................    }
....................    
....................    usb_cdc_flush_tx_buffer();
....................    
....................    return(true);
.................... }
.................... 
.................... int1 usb_cdc_puts(char *ptr)
.................... {   
....................    unsigned int8 len;
.................... 
....................    len = strlen(ptr);
....................   
....................    return(usb_cdc_putd(ptr, len));
.................... }
.................... 
.................... #endif //__USB_CDC_HELPERS_ONLY__
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... char gethex1_usb() 
.................... {
....................    char digit;
.................... 
....................    digit = usb_cdc_getc();
.................... 
....................    usb_cdc_putc(digit);
.................... 
....................    if(digit<='9')
....................      return(digit-'0');
....................    else
....................      return((toupper(digit)-'A')+10);
.................... }
.................... 
.................... char gethex_usb() {
....................    unsigned int8 lo,hi;
.................... 
....................    hi = gethex1_usb();
....................    lo = gethex1_usb();
....................    if(lo==0xdd)
....................      return(hi);
....................    else
....................      return( hi*16+lo );
.................... }
.................... 
.................... void get_string_usb(char* s, unsigned int max) {
....................    unsigned int len;
....................    char c;
.................... 
....................    --max;
....................    len=0;
....................    do {
....................      c=usb_cdc_getc();
....................      if(c==8) {  // Backspace
....................         if(len>0) {
....................           len--;
....................           usb_cdc_putc(c);
....................           usb_cdc_putc(' ');
....................           usb_cdc_putc(c);
....................         }
....................      } else if ((c>=' ')&&(c<='~'))
....................        if(len<max) {
....................          s[len++]=c;
....................          usb_cdc_putc(c);
....................        }
....................    } while(c!=13);
....................    s[len]=0;
.................... }
.................... 
.................... 
.................... // stdlib.h is required for the ato_ conversions
.................... // in the following functions
.................... #ifdef _STDLIB
.................... 
.................... signed int get_int_usb() {
....................   char s[7];
....................   signed int i;
.................... 
....................   get_string_usb(s, 7);
.................... 
....................   i=atoi(s);
....................   return(i);
.................... }
.................... 
.................... signed long get_long_usb() {
....................   char s[13];
....................   signed long l;
.................... 
....................   get_string_usb(s, 13);
....................   l=atol(s);
....................   return(l);
.................... }
.................... 
.................... float get_float_usb() {
....................   char s[20];
....................   float f;
.................... 
....................   get_string_usb(s, 20);
....................   f = atof(s);
....................   return(f);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... uint16_t globalMs;
.................... uint8_t globalSec;
.................... uint16_t globalMin;
.................... 
.................... /*Para la cantidad de mensajes que se quieran leer:
.................... un debug level de 0 no contiene mensajes
.................... un debug level de 1 son solo los datos recibidos
.................... un debug level de 2 contiene errores
.................... un debug level de 3 contiene mas informacion util
.................... */
.................... int debugLevel = 1;
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #use spi (MASTER, SPI1, ENABLE=PIN_A5, BAUD=1000000, MODE=0, BITS=8, STREAM=SPI_1)
.................... 
.................... #byte porta = 0xf80 // Identificador para el puerto A. 
.................... #byte portb = 0xf81 // Identificador para el puerto B. 
.................... #byte portc = 0xf82 // Identificador para el puerto C. 
.................... #byte portd = 0xf83 // Identificador para el puerto D. 
.................... #byte porte = 0xf84 // Identificador para el puerto E.
.................... 
.................... 
.................... 
.................... 
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlibm.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... /*********************************************************************/
.................... #ifndef _STDLIBM
.................... #define _STDLIBM
.................... 
.................... /* Memory Management Functions*/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #if defined(__PCB__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int8 next; }node_t;
.................... #elif defined(__PCM__)
.................... typedef struct nodet {
....................    unsigned int8 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCH__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #elif defined(__PCD__)
.................... typedef struct nodet {
....................    unsigned int16 size;
....................    unsigned int16 next; }node_t;
.................... #endif
.................... 
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY)
....................    #USE DYNAMIC_MEMORY
.................... #endif
.................... 
.................... #ifndef debug_stdlibm
....................    #define debug_stdlibm(s)
.................... #else
....................    #define __DO_DEBUG_STDLIBM
....................    
....................    char g_DebugStdlibmStr[50];
....................    
....................    #if defined(__PCD__)
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__))
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0))
....................       #else
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0))
....................       #endif
....................    #else
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM"))
....................    #endif
.................... #endif
.................... 
.................... #if defined(STDLIBM_TRACK_WORST_CASE)
....................    static size_t _g_StdlibmCurrentBytesUsed = 0;
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0;
....................    
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \
....................       _g_StdlibmCurrentBytesUsed += _x;   \
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed
....................    
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x
.................... #else
....................    #define _STDLIBM_TRACK_WORST_INC(_x)
....................    #define _STDLIBM_TRACK_WORST_DEC(_x)
.................... #endif
.................... 
.................... #include <memmgmt.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__PCH__)
....................  #define _MEMMGMT_CSIZE 32768
....................  #define _MEMMGMT_POS 15
.................... #elif defined(__PCD__)
....................    #define _MEMMGMT_CSIZE 32768
....................    #define _MEMMGMT_POS 15
.................... #else
....................    #define _MEMMGMT_CSIZE 127
....................    #define _MEMMGMT_POS 7
.................... #endif
.................... 
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location
.................... {
....................    node_t *result;
....................    result =ptr;
*
2DE2:  MOVFF  1EF,1F1
2DE6:  MOVFF  1EE,1F0
....................    result->size=size;
2DEA:  MOVLB  1
2DEC:  MOVFF  1F0,FE9
2DF0:  MOVFF  1F1,FEA
2DF4:  MOVFF  1ED,FEC
2DF8:  MOVF   FED,F
2DFA:  MOVFF  1EC,FEF
....................    result->next = NULL;
2DFE:  MOVLW  02
2E00:  ADDWF  xF0,W
2E02:  MOVWF  FE9
2E04:  MOVLW  00
2E06:  ADDWFC xF1,W
2E08:  MOVWF  FEA
2E0A:  CLRF   FEC
2E0C:  MOVF   FED,F
2E0E:  CLRF   FEF
....................    return result;
2E10:  MOVFF  1F0,01
2E14:  MOVFF  1F1,02
2E18:  MOVLB  0
2E1A:  GOTO   2F6E (RETURN)
.................... }
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node
.................... {
....................    node->size=size;
*
2EA4:  MOVLB  1
2EA6:  MOVFF  1ED,FE9
2EAA:  MOVFF  1EE,FEA
2EAE:  MOVFF  1F0,FEC
2EB2:  MOVF   FED,F
2EB4:  MOVFF  1EF,FEF
2EB8:  MOVLB  0
2EBA:  RETURN 0
.................... }
.................... 
.................... /* Insert node immediately after place */ //old,new
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node
.................... {
....................     if (place->next==NULL)
*
2E1E:  MOVLW  02
2E20:  MOVLB  1
2E22:  ADDWF  xE8,W
2E24:  MOVWF  FE9
2E26:  MOVLW  00
2E28:  ADDWFC xE9,W
2E2A:  MOVWF  FEA
2E2C:  MOVFF  FEC,1ED
2E30:  MOVF   FED,F
2E32:  MOVFF  FEF,1EC
2E36:  MOVF   xEC,F
2E38:  BNZ   2E52
2E3A:  MOVF   xED,F
2E3C:  BNZ   2E52
....................        node->next= NULL;
2E3E:  MOVLW  02
2E40:  ADDWF  xEA,W
2E42:  MOVWF  FE9
2E44:  MOVLW  00
2E46:  ADDWFC xEB,W
2E48:  MOVWF  FEA
2E4A:  CLRF   FEC
2E4C:  MOVF   FED,F
2E4E:  CLRF   FEF
2E50:  BRA    2E88
....................     else
....................        node->next=place->next;
2E52:  MOVLW  02
2E54:  ADDWF  xEA,W
2E56:  MOVWF  01
2E58:  MOVLW  00
2E5A:  ADDWFC xEB,W
2E5C:  MOVWF  03
2E5E:  MOVWF  xED
2E60:  MOVLW  02
2E62:  ADDWF  xE8,W
2E64:  MOVWF  FE9
2E66:  MOVLW  00
2E68:  ADDWFC xE9,W
2E6A:  MOVWF  FEA
2E6C:  MOVFF  FEC,03
2E70:  MOVF   FED,F
2E72:  MOVFF  FEF,1EE
2E76:  MOVFF  1ED,FEA
2E7A:  MOVFF  01,FE9
2E7E:  MOVFF  03,FEC
2E82:  MOVF   FED,F
2E84:  MOVFF  1EE,FEF
....................     place->next=node;
2E88:  MOVLW  02
2E8A:  ADDWF  xE8,W
2E8C:  MOVWF  FE9
2E8E:  MOVLW  00
2E90:  ADDWFC xE9,W
2E92:  MOVWF  FEA
2E94:  MOVFF  1EB,FEC
2E98:  MOVF   FED,F
2E9A:  MOVFF  1EA,FEF
2E9E:  MOVLB  0
2EA0:  GOTO   2F88 (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... void remove_node(node_t *node) {// remove the given node from the memlist
....................    node_t *ptr;
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next);
*
2FFE:  MOVFF  C1,1F0
3002:  MOVFF  C0,1EF
3006:  MOVLW  02
3008:  MOVLB  1
300A:  ADDWF  xEF,W
300C:  MOVWF  FE9
300E:  MOVLW  00
3010:  ADDWFC xF0,W
3012:  MOVWF  FEA
3014:  MOVFF  FEC,1F2
3018:  MOVF   FED,F
301A:  MOVFF  FEF,1F1
301E:  MOVF   xED,W
3020:  SUBWF  xF1,W
3022:  BNZ   302A
3024:  MOVF   xEE,W
3026:  SUBWF  xF2,W
3028:  BZ    3046
302A:  MOVLW  02
302C:  ADDWF  xEF,W
302E:  MOVWF  FE9
3030:  MOVLW  00
3032:  ADDWFC xF0,W
3034:  MOVWF  FEA
3036:  MOVFF  FEC,1F0
303A:  MOVF   FED,F
303C:  MOVFF  FEF,1EF
3040:  MOVLB  0
3042:  BRA    3006
3044:  MOVLB  1
....................    ptr->next=node->next;
3046:  MOVLW  02
3048:  ADDWF  xEF,W
304A:  MOVWF  01
304C:  MOVLW  00
304E:  ADDWFC xF0,W
3050:  MOVWF  03
3052:  MOVWF  xF2
3054:  MOVLW  02
3056:  ADDWF  xED,W
3058:  MOVWF  FE9
305A:  MOVLW  00
305C:  ADDWFC xEE,W
305E:  MOVWF  FEA
3060:  MOVFF  FEC,03
3064:  MOVF   FED,F
3066:  MOVFF  FEF,1F3
306A:  MOVFF  1F2,FEA
306E:  MOVFF  01,FE9
3072:  MOVFF  03,FEC
3076:  MOVF   FED,F
3078:  MOVFF  1F3,FEF
....................    node=NULL;
307C:  CLRF   xEE
307E:  CLRF   xED
3080:  MOVLB  0
3082:  GOTO   3144 (RETURN)
.................... }
.................... 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if defined(__DO_DEBUG_STDLIBM)
.................... void print_list() { // print the current memlist
....................     node_t *node;
....................     debug_stdlibm("\r\nThe list is \n\r");
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next)
....................     {
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next);
....................         debug_stdlibm(g_DebugStdlibmStr);
....................         if (INVALID_MEMORY_LOCATION(node->next))
....................         {
....................            debug_stdlibm("Breaking because of invalid next node\r\n");
....................            break;
....................         }   
....................     }
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t));
....................     debug_stdlibm(g_DebugStdlibmStr);
.................... }
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... void traverse()
.................... {
....................    node_t *node,*temp;
....................    unsigned int16 nsize,nextsize;
....................    node=__DYNAMIC_HEAD;
3086:  MOVFF  C1,1E6
308A:  MOVFF  C0,1E5
....................    while(node!=NULL)
308E:  MOVLB  1
3090:  MOVF   xE5,F
3092:  BNZ   309A
3094:  MOVF   xE6,F
3096:  BTFSC  FD8.2
3098:  BRA    3192
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          break;
....................       }   
....................      #endif
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free
309A:  MOVFF  1E5,FE9
309E:  MOVFF  1E6,FEA
30A2:  MOVFF  FEC,1EE
30A6:  MOVF   FED,F
30A8:  MOVFF  FEF,1ED
30AC:  BTFSC  xEE.7
30AE:  BRA    3176
....................       {
....................          nsize=node->size;
30B0:  MOVFF  1E5,FE9
30B4:  MOVFF  1E6,FEA
30B8:  MOVFF  FEC,1EA
30BC:  MOVF   FED,F
30BE:  MOVFF  FEF,1E9
....................          temp=(unsigned int16)node->next;
30C2:  MOVLW  02
30C4:  ADDWF  xE5,W
30C6:  MOVWF  FE9
30C8:  MOVLW  00
30CA:  ADDWFC xE6,W
30CC:  MOVWF  FEA
30CE:  MOVFF  FEC,1E8
30D2:  MOVF   FED,F
30D4:  MOVFF  FEF,1E7
....................         #if defined(__DO_DEBUG_STDLIBM)
....................          if (INVALID_MEMORY_LOCATION(temp))
....................          {
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node);
....................             debug_stdlibm(g_DebugStdlibmStr);
....................             break;
....................          }
....................         #endif
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine
30D8:  MOVFF  1E7,FE9
30DC:  MOVFF  1E8,FEA
30E0:  MOVFF  FEC,1EE
30E4:  MOVF   FED,F
30E6:  MOVFF  FEF,1ED
30EA:  BTFSC  xEE.7
30EC:  BRA    315A
30EE:  MOVF   xE9,W
30F0:  ADDWF  xE5,W
30F2:  MOVWF  xEF
30F4:  MOVF   xEA,W
30F6:  ADDWFC xE6,W
30F8:  MOVWF  xF0
30FA:  MOVLW  04
30FC:  ADDWF  xEF,W
30FE:  MOVWF  01
3100:  MOVLW  00
3102:  ADDWFC xF0,W
3104:  MOVWF  03
3106:  MOVF   01,W
3108:  SUBWF  xE7,W
310A:  BNZ   315A
310C:  MOVF   03,W
310E:  SUBWF  xE8,W
3110:  BNZ   315A
....................          {
....................             nextsize=temp->size;
3112:  MOVFF  1E7,FE9
3116:  MOVFF  1E8,FEA
311A:  MOVFF  FEC,1EC
311E:  MOVF   FED,F
3120:  MOVFF  FEF,1EB
....................             nsize+=nextsize+sizeof(node_t);
3124:  MOVLW  04
3126:  ADDWF  xEB,W
3128:  MOVWF  01
312A:  MOVLW  00
312C:  ADDWFC xEC,W
312E:  MOVWF  03
3130:  MOVF   01,W
3132:  ADDWF  xE9,F
3134:  MOVF   03,W
3136:  ADDWFC xEA,F
....................             remove_node(temp);
3138:  MOVFF  1E8,1EE
313C:  MOVFF  1E7,1ED
3140:  MOVLB  0
3142:  BRA    2FFE
....................             update_node(node,nsize);
3144:  MOVFF  1E6,1EE
3148:  MOVFF  1E5,1ED
314C:  MOVFF  1EA,1F0
3150:  MOVFF  1E9,1EF
3154:  RCALL  2EA4
....................          }
3156:  BRA    3172
3158:  MOVLB  1
....................          else
....................          node=node->next;
315A:  MOVLW  02
315C:  ADDWF  xE5,W
315E:  MOVWF  FE9
3160:  MOVLW  00
3162:  ADDWFC xE6,W
3164:  MOVWF  FEA
3166:  MOVFF  FEC,1E6
316A:  MOVF   FED,F
316C:  MOVFF  FEF,1E5
3170:  MOVLB  0
....................       }
3172:  BRA    318E
3174:  MOVLB  1
....................       else
....................       node=node->next;
3176:  MOVLW  02
3178:  ADDWF  xE5,W
317A:  MOVWF  FE9
317C:  MOVLW  00
317E:  ADDWFC xE6,W
3180:  MOVWF  FEA
3182:  MOVFF  FEC,1E6
3186:  MOVF   FED,F
3188:  MOVFF  FEF,1E5
318C:  MOVLB  0
318E:  BRA    308E
3190:  MOVLB  1
....................    }
3192:  MOVLB  0
3194:  GOTO   320C (RETURN)
.................... }
.................... 
.................... char *malloc(size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize;
....................    #if defined(__PCD__)
....................    if (size % 2)
....................       size++;
....................    #endif
....................    node=__DYNAMIC_HEAD;
*
2EBC:  MOVFF  C1,1E3
2EC0:  MOVFF  C0,1E2
....................    
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
....................         
....................    while(node!=NULL) // chk until end of memlist
2EC4:  MOVLB  1
2EC6:  MOVF   xE2,F
2EC8:  BNZ   2ED0
2ECA:  MOVF   xE3,F
2ECC:  BTFSC  FD8.2
2ECE:  BRA    2FDA
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size
2ED0:  MOVFF  1E2,FE9
2ED4:  MOVFF  1E3,FEA
2ED8:  MOVFF  FEC,1E9
2EDC:  MOVF   FED,F
2EDE:  MOVFF  FEF,1E8
2EE2:  BTFSC  xE9.7
2EE4:  BRA    2FC2
2EE6:  MOVFF  1E2,FE9
2EEA:  MOVFF  1E3,FEA
2EEE:  MOVFF  FEC,1EB
2EF2:  MOVF   FED,F
2EF4:  MOVFF  FEF,1EA
2EF8:  MOVF   xE1,W
2EFA:  SUBWF  xEB,W
2EFC:  BNC   2FC2
2EFE:  BNZ   2F06
2F00:  MOVF   xE0,W
2F02:  SUBWF  xEA,W
2F04:  BNC   2FC2
....................       {
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at
2F06:  MOVFF  1E2,FE9
2F0A:  MOVFF  1E3,FEA
2F0E:  MOVFF  FEC,1E7
2F12:  MOVF   FED,F
2F14:  MOVFF  FEF,1E6
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist
2F18:  MOVLW  04
2F1A:  ADDWF  xE0,W
2F1C:  MOVWF  01
2F1E:  MOVLW  00
2F20:  ADDWFC xE1,W
2F22:  MOVWF  03
2F24:  MOVF   03,W
2F26:  SUBWF  xE7,W
2F28:  BNC   2FA6
2F2A:  BNZ   2F32
2F2C:  MOVF   xE6,W
2F2E:  SUBWF  01,W
2F30:  BC    2FA6
....................          {
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
2F32:  MOVF   xE0,W
2F34:  SUBWF  xE6,W
2F36:  MOVWF  xE8
2F38:  MOVF   xE1,W
2F3A:  SUBWFB xE7,W
2F3C:  MOVWF  xE9
2F3E:  MOVLW  04
2F40:  SUBWF  xE8,F
2F42:  MOVLW  00
2F44:  SUBWFB xE9,F
2F46:  MOVLW  04
2F48:  ADDWF  xE2,W
2F4A:  MOVWF  xEA
2F4C:  MOVLW  00
2F4E:  ADDWFC xE3,W
2F50:  MOVWF  xEB
2F52:  MOVF   xE0,W
2F54:  ADDWF  xEA,F
2F56:  MOVF   xE1,W
2F58:  ADDWFC xEB,F
2F5A:  MOVFF  1E9,1ED
2F5E:  MOVFF  1E8,1EC
2F62:  MOVFF  1EB,1EF
2F66:  MOVFF  1EA,1EE
2F6A:  MOVLB  0
2F6C:  BRA    2DE2
2F6E:  MOVFF  02,1E5
2F72:  MOVFF  01,1E4
....................             insert_node_after(node,new);
2F76:  MOVFF  1E3,1E9
2F7A:  MOVFF  1E2,1E8
2F7E:  MOVFF  1E5,1EB
2F82:  MOVFF  1E4,1EA
2F86:  BRA    2E1E
....................             update_node(node,size+_MEMMGMT_CSIZE);
2F88:  MOVLB  1
2F8A:  MOVLW  80
2F8C:  ADDWF  xE1,W
2F8E:  MOVWF  xE9
2F90:  MOVFF  1E3,1EE
2F94:  MOVFF  1E2,1ED
2F98:  MOVWF  xF0
2F9A:  MOVFF  1E0,1EF
2F9E:  MOVLB  0
2FA0:  RCALL  2EA4
....................          }
2FA2:  BRA    2FBE
2FA4:  MOVLB  1
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
2FA6:  MOVLW  80
2FA8:  ADDWF  xE7,W
2FAA:  MOVWF  xE9
2FAC:  MOVFF  1E3,1EE
2FB0:  MOVFF  1E2,1ED
2FB4:  MOVWF  xF0
2FB6:  MOVFF  1E6,1EF
2FBA:  MOVLB  0
2FBC:  RCALL  2EA4
....................          //end if
....................          break;
2FBE:  MOVLB  1
2FC0:  BRA    2FDA
....................       }//end if
....................       node=node->next;
2FC2:  MOVLW  02
2FC4:  ADDWF  xE2,W
2FC6:  MOVWF  FE9
2FC8:  MOVLW  00
2FCA:  ADDWFC xE3,W
2FCC:  MOVWF  FEA
2FCE:  MOVFF  FEC,1E3
2FD2:  MOVF   FED,F
2FD4:  MOVFF  FEF,1E2
2FD8:  BRA    2EC6
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
2FDA:  MOVF   xE2,F
2FDC:  BNZ   2FEC
2FDE:  MOVF   xE3,F
2FE0:  BNZ   2FEC
....................    {
....................       debug_stdlibm("Not enough memory for mallocation\r\n");
....................       return NULL;
2FE2:  MOVLW  00
2FE4:  MOVWF  01
2FE6:  MOVWF  02
2FE8:  BRA    2FFA
....................    }
2FEA:  BRA    2FFA
....................    else
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t));
....................       debug_stdlibm(g_DebugStdlibmStr);
....................      #endif
....................       _STDLIBM_TRACK_WORST_INC(size);
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space
2FEC:  MOVLW  04
2FEE:  ADDWF  xE2,W
2FF0:  MOVWF  01
2FF2:  MOVLW  00
2FF4:  ADDWFC xE3,W
2FF6:  MOVWF  03
2FF8:  MOVWF  02
....................    }
2FFA:  MOVLB  0
2FFC:  RETURN 0
.................... }
.................... 
.................... char *calloc(size_t nmemb,size_t size)
.................... {
....................    node_t *node,*new;
....................    unsigned int16 nsize,resize;
....................    node=__DYNAMIC_HEAD;
....................    resize=nmemb*size;
....................    #if defined(__PCD__)
....................    if(resize%2)
....................       resize++;
....................    #endif
....................    while(node!=NULL) // chk until end of memlist
....................    {
....................      #if defined(__DO_DEBUG_STDLIBM)
....................       if (INVALID_MEMORY_LOCATION(node))
....................       {
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node);
....................          debug_stdlibm(g_DebugStdlibmStr);
....................          print_list();
....................          return(0);
....................       }
....................      #endif
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size
....................       {
....................          nsize=node->size;
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist
....................          {
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize);
....................             insert_node_after(node,new);
....................             update_node(node,resize+_MEMMGMT_CSIZE);
....................          }
....................          else//not enough space for new node so use original size
....................          update_node(node,nsize+_MEMMGMT_CSIZE);
....................          //end if
....................          break;
....................       }//end if
....................       node=node->next;
....................    }//end while
....................    if(node==NULL)// reached end without finding an appropriate node
....................    {
....................       debug_stdlibm("Not enough memory for callocation\r\n");
....................       return NULL;
....................    }
....................    else
....................    {
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0
....................       _STDLIBM_TRACK_WORST_INC(resize);
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space
....................    }
.................... }
.................... void free( void * ptr)
.................... {
....................    node_t *node;
....................    unsigned int16 nsize;
.................... 
....................   #if defined(__DO_DEBUG_STDLIBM)
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr);
....................    debug_stdlibm(g_DebugStdlibmStr);
....................   #endif
.................... 
....................    if(ptr==NULL) // not a valid pounsigned int8er
*
3198:  MOVLB  1
319A:  MOVF   xDF,F
319C:  BNZ   31A6
319E:  MOVF   xE0,F
31A0:  BNZ   31A6
....................       return;
31A2:  BRA    320E
31A4:  BRA    3208
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
31A6:  MOVLW  04
31A8:  SUBWF  xDF,W
31AA:  MOVWF  xE1
31AC:  MOVLW  00
31AE:  SUBWFB xE0,W
31B0:  MOVWF  xE2
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied
31B2:  MOVFF  1E1,FE9
31B6:  MOVFF  1E2,FEA
31BA:  MOVFF  FEC,1E6
31BE:  MOVF   FED,F
31C0:  MOVFF  FEF,1E5
31C4:  BTFSS  xE6.7
31C6:  BRA    3202
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
31C8:  MOVFF  1E1,FE9
31CC:  MOVFF  1E2,FEA
31D0:  MOVFF  FEC,1E6
31D4:  MOVF   FED,F
31D6:  MOVFF  FEF,1E5
31DA:  MOVLW  00
31DC:  SUBWF  xE5,W
31DE:  MOVWF  xE3
31E0:  MOVLW  80
31E2:  SUBWFB xE6,W
31E4:  MOVWF  xE4
....................          update_node(node,nsize);
31E6:  MOVFF  1E2,1EE
31EA:  MOVFF  1E1,1ED
31EE:  MOVFF  1E4,1F0
31F2:  MOVFF  1E3,1EF
31F6:  MOVLB  0
31F8:  RCALL  2EA4
....................          ptr=NULL;
31FA:  MOVLB  1
31FC:  CLRF   xE0
31FE:  CLRF   xDF
....................          _STDLIBM_TRACK_WORST_DEC(nsize);
....................       }
3200:  BRA    3208
....................       else // wrong input, return
....................       {
....................          ptr=NULL;
3202:  CLRF   xE0
3204:  CLRF   xDF
....................          return;
3206:  BRA    320E
....................       }
....................    }
....................    traverse();
3208:  MOVLB  0
320A:  BRA    3086
320C:  MOVLB  1
320E:  MOVLB  0
3210:  RETURN 0
.................... }
.................... 
.................... char *realloc(void *ptr,size_t size)
.................... {
....................    node_t *node,*new,*temp;
....................    unsigned int16 nsize,nextsize;
....................    char *newptr;
....................    #if defined(__PCD__)
....................    if(size %2)
....................       size++;
....................    #endif
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory
....................       return(malloc(size));
....................    else if(size==0)
....................    {
....................       free(ptr);
....................       return(NULL);
....................    }
....................    else
....................    {
....................       node=ptr-sizeof(node_t);
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er
....................       {
....................          nsize=node->size-_MEMMGMT_CSIZE;
....................          temp=(unsigned int16)node->next;
....................          if(nsize>size)// block > req size
....................          {
....................        
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   nextsize=temp->size;
....................                   remove_node(temp);
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t));
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist
....................                {
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size);
....................                   insert_node_after(node,new);
....................                   _STDLIBM_TRACK_WORST_DEC(nsize);
....................                   _STDLIBM_TRACK_WORST_INC(size);
....................                }
....................                else//not enough space for new node so use original size
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block
.................... 
....................          }
....................          else // block < req size
....................          {
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive
....................             {
....................                nextsize=temp->size;
....................                if(nextsize>=size-nsize) // next block >=difference
....................                {
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist
....................                   {
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t));
....................                       insert_node_after(node,new);
....................                      _STDLIBM_TRACK_WORST_DEC(nsize);
....................                      _STDLIBM_TRACK_WORST_INC(size);
....................                   }
....................                   else//not enough space for new node in next node, so use original size
....................                   {
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block
....................                       remove_node(temp);
....................                   }
....................                }
....................                else  //next block free but too small for new size
....................                {
....................                   newptr = malloc(size);  //use malloc to find new block
....................                   if(newptr == NULL)
....................                      return(NULL);        //return NULL if malloc was unable to find new block
....................                    
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                   free(ptr);                    //free original block
....................                   return(newptr);               //return new pointer
....................                }
....................             }
....................             else  //next block not free
....................             {
....................                newptr = malloc(size);  //use malloc to find new block
....................                if(newptr == NULL)      
....................                   return(NULL);        //return NULL if malloc was unable to find new block
....................                
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block
....................                free(ptr);                    //free original block
....................                return(newptr);               //return new pointer
....................             }
....................          }
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block
....................       }
....................       else // not allocated use malloc
....................       {
....................          return(malloc(size));
....................       }
....................    }
....................  }
....................  
.................... typedef struct
.................... {
....................    size_t bytesUsed;
....................    size_t largestUsedSeg;
....................    int segmentsUsed;
....................    size_t bytesFree;
....................    size_t largestFreeSeg;
....................    int segmentsFree;
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    size_t worstCaseBytesUsed;
....................   #endif
.................... } heap_status_t;
.................... 
.................... void GetHeapStatus(heap_status_t *pHeapStatus)
.................... {
....................    heap_status_t status;
....................    node_t *node;
....................    unsigned int16 nsize;
....................    
....................    node=__DYNAMIC_HEAD;
....................    
....................    memset(&status, 0, sizeof(status));
.................... 
....................    while(node!=NULL)
....................    {
....................       nsize = node->size;
....................       node = node->next;
....................       
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free
....................       {
....................          status.bytesFree += nsize;
....................          
....................          status.segmentsFree++;
....................          
....................          if (nsize > status.largestFreeSeg)
....................          {
....................             status.largestFreeSeg = nsize;
....................          }
....................       }
....................       else
....................       {
....................          bit_clear(nsize, _MEMMGMT_POS);
....................          
....................          status.bytesUsed += nsize;
....................          
....................          status.segmentsUsed++;
....................          
....................          if (nsize > status.largestUsedSeg)
....................          {
....................             status.largestUsedSeg = nsize;
....................          }
....................       }
....................    }
.................... 
....................   #if defined(STDLIBM_TRACK_WORST_CASE)
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed;
....................   #endif
.................... 
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t));
.................... }
.................... #ENDIF
.................... 
.................... #include <stdint.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                           stdint.h                                ////
.................... ////                                                                   ////
.................... //// Standard integer definitions.                                     ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDINT
.................... 
.................... #define _STDINT
.................... 
.................... //////////// exact width
.................... 
.................... typedef signed int8 int8_t;
.................... typedef unsigned int8 uint8_t;
.................... typedef signed int16 int16_t;
.................... typedef unsigned int16 uint16_t;
.................... typedef signed int32 int32_t;
.................... typedef unsigned int32 uint32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int24_t;
.................... //typedef unsigned int24 uint24_t;
.................... typedef signed int64 int64_t;
.................... typedef unsigned int64 uint64_t;
.................... #endif
.................... 
.................... #define INT8_MAX  (127)
.................... #define INT8_MIN  (-128)
.................... #define UINT8_MAX (255)
.................... 
.................... #define INT16_MAX  (32767)
.................... #define INT16_MIN  (-32768)
.................... #define UINT16_MAX (65535)
.................... 
.................... #define INT32_MAX  (2147483647)
.................... #define INT32_MIN  (-2147483648)
.................... #define UINT32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT24_MAX  (8388607)
.................... //#define INT24_MIN  (-8388608)
.................... //#define UINT24_MAX (16777215)
.................... 
.................... #define INT64_MAX  (9223372036854775807)
.................... #define INT64_MIN  (-9223372036854775808)
.................... #define UINT64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// minimum width
.................... 
.................... typedef signed int8 int_least8_t;
.................... typedef unsigned int8 uint_least8_t;
.................... typedef signed int16 int_least16_t;
.................... typedef unsigned int16 uint_least16_t;
.................... typedef signed int32 int_least32_t;
.................... typedef unsigned int32 uint_least32_t;
.................... 
.................... #if defined(__PCD__)
.................... //typedef signed int24 int_least24_t;
.................... //typedef unsigned int24 uint_least24_t;
.................... typedef signed int64 int_least64_t;
.................... typedef unsigned int64 uint_least64_t;
.................... #endif
.................... 
.................... #define INT_LEAST8_MAX  (127)
.................... #define INT_LEAST8_MIN  (-128)
.................... #define UINT_LEAST8_MAX (255)
.................... 
.................... #define INT_LEAST16_MAX  (32767)
.................... #define INT_LEAST16_MIN  (-32768)
.................... #define UINT_LEAST16_MAX (65535)
.................... 
.................... #define INT_LEAST32_MAX  (2147483647)
.................... #define INT_LEAST32_MIN  (-2147483648)
.................... #define UINT_LEAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_LEAST24_MAX  (8388607)
.................... //#define INT_LEAST24_MIN  (-8388608)
.................... //#define UINT_LEAST24_MAX (16777215)
.................... 
.................... #define INT_LEAST64_MAX  (9223372036854775807)
.................... #define INT_LEAST64_MIN  (-9223372036854775808)
.................... #define UINT_LEAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... ///////// fastest width
.................... 
.................... #if defined(__PCD__)
.................... typedef signed int16 int_fast8_t;
.................... typedef unsigned int16 uint_fast8_t;
.................... #define INT_FAST8_MAX  (32767)
.................... #define INT_FAST8_MIN  (-32768)
.................... #define UINT_FAST8_MAX (65535)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... //typedef signed int24 int_fast24_t;
.................... //typedef unsigned int24 uint_fast24_t;
.................... typedef signed int64 int_fast64_t;
.................... typedef unsigned int64 uint_fast64_t;
.................... #else
.................... typedef signed int8 int_fast8_t;
.................... typedef unsigned int8 uint_fast8_t;
.................... #define INT_FAST8_MAX  (127)
.................... #define INT_FAST8_MIN  (-128)
.................... #define UINT_FAST8_MAX (255)
.................... typedef signed int16 int_fast16_t;
.................... typedef unsigned int16 uint_fast16_t;
.................... #endif
.................... 
.................... typedef signed int32 int_fast32_t;
.................... typedef unsigned int32 uint_fast32_t;
.................... 
.................... #define INT_FAST16_MAX  (32767)
.................... #define INT_FAST16_MIN  (-32768)
.................... #define UINT_FAST16_MAX (65535)
.................... 
.................... #define INT_FAST32_MAX  (2147483647)
.................... #define INT_FAST32_MIN  (-2147483648)
.................... #define UINT_FAST32_MAX (4294967295)
.................... 
.................... #if defined(__PCD__)
.................... //#define INT_FAST24_MAX  (8388607)
.................... //#define INT_FAST24_MIN  (-8388608)
.................... //#define UINT_FAST24_MAX (16777215)
.................... 
.................... #define INT_FAST64_MAX  (9223372036854775807)
.................... #define INT_FAST64_MIN  (-9223372036854775808)
.................... #define UINT_FAST64_MAX (18446744073709551615)
.................... #endif
.................... 
.................... //////////// big enough to hold pointers (OPTIONAL)
.................... 
.................... #if defined(__PCD__)
....................    typedef unsigned int32 uintptr_t;
....................    typedef signed int32 intptr_t;
.................... #else
....................    typedef unsigned int16 uintptr_t;
....................    typedef signed int16 intptr_t;
.................... #endif
.................... 
.................... #define INT8_C(val) ((int8_t)val)
.................... #define UINT8_C(val) ((uint8_t)val)
.................... #define INT16_C(val) ((int16_t)val)
.................... #define UINT16_C(val) ((uint16_t)val)
.................... #define INT32_C(val) ((int32_t)val)
.................... #define UINT32_C(val) ((uint32_t)val)
.................... 
.................... #if defined(__PCD__)
.................... #define INT64_C(val) ((int64_t)val)
.................... #define UINT64_C(val) ((uint64_t)val)
.................... #endif
.................... 
.................... /// TODO:
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX
.................... 
.................... 
.................... /////////// greatest width (OPTIONAL)
.................... 
.................... #ifdef __PCD__
....................    typedef signed int64 intmax_t;
....................    typedef unsigned int64 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (9223372036854775807)
....................    #define INTMAXN_MIN  (-9223372036854775808)
....................    #define UINTMAXN_MAX (18446744073709551615)
....................    
....................    #define INTMAX_C(value) ((signed int64)val)
....................    #define UINTMAX_C(value) ((unsigned int64)val)
.................... #else
....................    typedef signed int32 intmax_t;
....................    typedef unsigned int32 uintmax_t;
....................    
....................    #define INTMAXN_MAX  (2147483647)
....................    #define INTMAXN_MIN  (-2147483648)
....................    #define UINTMAXN_MAX (4294967295)
....................    
....................    #define INTMAX_C(value) ((signed int32)val)
....................    #define UINTMAX_C(value) ((unsigned int32)val)
.................... #endif
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... #include <adafruit_rfm69_registers.h>
.................... 
.................... //Internal constants:
.................... #define _REG_FIFO 0x00
.................... #define _REG_OP_MODE 0x01
.................... #define _REG_DATA_MOD 0x02
.................... #define _REG_BITRATE_MSB 0x03
.................... #define _REG_BITRATE_LSB 0x04
.................... #define _REG_FDEV_MSB 0x05
.................... #define _REG_FDEV_LSB 0x06
.................... #define _REG_FRF_MSB 0x07
.................... #define _REG_FRF_MID 0x08
.................... #define _REG_FRF_LSB 0x09
.................... #define _REG_VERSION 0x10
.................... #define _REG_PA_LEVEL 0x11
.................... #define _REG_RX_BW 0x19
.................... #define _REG_AFC_BW 0x1A
.................... #define _REG_RSSI_VALUE 0x24
.................... #define _REG_DIO_MAPPING1 0x25
.................... #define _REG_IRQ_FLAGS1 0x27
.................... #define _REG_IRQ_FLAGS2 0x28
.................... #define _REG_PREAMBLE_MSB 0x2C
.................... #define _REG_PREAMBLE_LSB 0x2D
.................... #define _REG_SYNC_CONFIG 0x2E
.................... #define _REG_SYNC_VALUE1 0x2F
.................... #define _REG_PACKET_CONFIG1 0x37
.................... #define _REG_FIFO_THRESH 0x3C
.................... #define _REG_PACKET_CONFIG2 0x3D
.................... #define _REG_AES_KEY1 0x3E
.................... #define _REG_TEMP1 0x4E
.................... #define _REG_TEMP2 0x4F
.................... #define _REG_TEST_PA1 0x5A
.................... #define _REG_TEST_PA2 0x5C
.................... #define _REG_TEST_DAGC 0x6F
.................... 
.................... #define _TEST_PA1_NORMAL 0x55
.................... #define _TEST_PA1_BOOST 0x5D
.................... #define _TEST_PA2_NORMAL 0x70
.................... #define _TEST_PA2_BOOST 0x7C
.................... 
.................... //The crystal oscillator frequency and frequency synthesizer step size.
.................... //See the datasheet for details of this calculation.
.................... 
.................... //        #define _FXOSC = 32000000.0
.................... //        #define _FSTEP = _FXOSC / 524288
.................... 
.................... //RadioHead specific compatibility constants.
.................... #define _RH_BROADCAST_ADDRESS 0xFF
.................... //The acknowledgement bit in the FLAGS
.................... //The top 4 bits of the flags are reserved for RadioHead. The lower 4 bits are reserved
.................... //for application layer use.
.................... #define _RH_FLAGS_ACK 0x80
.................... #define _RH_FLAGS_RETRY 0x40
.................... 
.................... //User facing constants:
.................... #define SLEEP_MODE 0b000
.................... #define STANDBY_MODE 0b001
.................... #define FS_MODE 0b010
.................... #define TX_MODE 0b011
.................... #define RX_MODE 0b100
.................... //supervisor.ticks_ms() contants
.................... //          #define _TICKS_PERIOD = const(1 << 29)
.................... //          #define _TICKS_MAX = const(_TICKS_PERIOD - 1)
.................... //          #define _TICKS_HALFPERIOD = const(_TICKS_PERIOD // 2)
.................... 
.................... #include <utils.h>
.................... //Global buffer for SPI commands
.................... uint8_t _BUFFER[4];
.................... 
.................... void setOutput(int pin, int value){
....................     output_bit(pin,value);
*
1502:  MOVLB  2
1504:  MOVF   x2B,F
1506:  BNZ   150C
1508:  MOVLW  00
150A:  BRA    150E
150C:  MOVLW  01
150E:  MOVFF  22A,22C
1512:  MOVWF  x2D
1514:  MOVLW  0F
1516:  MOVWF  x2F
1518:  MOVLW  89
151A:  MOVWF  x2E
151C:  MOVLB  0
151E:  RCALL  14C0
1520:  MOVFF  22A,22C
1524:  MOVLB  2
1526:  CLRF   x2D
1528:  MOVLW  0F
152A:  MOVWF  x2F
152C:  MOVLW  92
152E:  MOVWF  x2E
1530:  MOVLB  0
1532:  RCALL  14C0
1534:  RETURN 0
.................... }
.................... void usbPrint(char* str, int debug = 0){
....................       usb_task();  //Verifica la comunicacin USB
*
19A8:  RCALL  159A
....................       if(usb_enumerated() && debug <= debugLevel) {
19AA:  RCALL  1566
19AC:  MOVF   01,F
19AE:  BZ    19C4
19B0:  MOVLB  2
19B2:  MOVF   x3D,W
19B4:  MOVLB  0
19B6:  SUBWF  xBF,W
19B8:  BNC   19C4
....................       
....................          printf(usb_cdc_putc,str); 
19BA:  MOVFF  23C,FEA
19BE:  MOVFF  23B,FE9
19C2:  BRA    1982
....................       }
19C4:  RETURN 0
.................... }
.................... void usbPrint(char str, int debug = 0){
....................       usb_task();  //Verifica la comunicacin USB
*
395E:  CALL   159A
....................       if(usb_enumerated() && debug <= debugLevel) {
3962:  CALL   1566
3966:  MOVF   01,F
3968:  BZ    397C
396A:  MOVLB  1
396C:  MOVF   x98,W
396E:  MOVLB  0
3970:  SUBWF  xBF,W
3972:  BNC   397C
....................          printf(usb_cdc_putc,"%c",str); 
3974:  MOVFF  197,240
3978:  CALL   1946
....................       }
397C:  GOTO   398A (RETURN)
.................... }
.................... 
.................... 
.................... void spiBegin(){
.................... //SPI.beginTransaction(SPISettings(SPIBAUD, MSBFIRST, SPI_MODE0));
.................... setOutput(SSPin, 0);
*
1610:  MOVLW  05
1612:  MOVLB  2
1614:  MOVWF  x2A
1616:  CLRF   x2B
1618:  MOVLB  0
161A:  RCALL  1502
161C:  RETURN 0
.................... 
.................... }
.................... void spiEnd(){
.................... setOutput(SSPin, 1);    
*
1646:  MOVLW  05
1648:  MOVLB  2
164A:  MOVWF  x2A
164C:  MOVLW  01
164E:  MOVWF  x2B
1650:  MOVLB  0
1652:  RCALL  1502
1654:  RETURN 0
.................... //SPI.endTransaction();
.................... }
.................... 
.................... void print(char* str, int debug = 0){
....................     //Serial.print(str);
....................     usbPrint(str, debug);
*
1B3C:  MOVFF  225,23C
1B40:  MOVFF  224,23B
1B44:  MOVFF  226,23D
1B48:  RCALL  19A8
1B4A:  RETURN 0
.................... }
.................... 
.................... void printch(char str, int debug = 0){
....................    usbPrint(str, debug);
*
3980:  MOVFF  194,197
3984:  MOVFF  195,198
3988:  BRA    395E
398A:  GOTO   3F68 (RETURN)
.................... 
.................... }
.................... void print(int16 str, int format, int debug = 0){
....................     char converted[11];
....................     int i;
....................     if (format == HEX) sprintf(converted,"0x%02X",str);
*
19C6:  MOVLB  2
19C8:  MOVF   x2B,W
19CA:  SUBLW  10
19CC:  BNZ   1A00
19CE:  MOVLW  02
19D0:  MOVLB  0
19D2:  MOVWF  xC7
19D4:  MOVLW  2D
19D6:  MOVWF  xC6
19D8:  MOVLW  30
19DA:  MOVLB  2
19DC:  MOVWF  x42
19DE:  MOVLB  0
19E0:  RCALL  16C2
19E2:  MOVLW  78
19E4:  MOVLB  2
19E6:  MOVWF  x42
19E8:  MOVLB  0
19EA:  RCALL  16C2
19EC:  MOVFF  229,239
19F0:  MOVLW  37
19F2:  MOVLB  2
19F4:  MOVWF  x3A
19F6:  MOVLB  0
19F8:  BRA    16E0
19FA:  MOVLB  0
19FC:  BRA    1A98
19FE:  MOVLB  2
....................     else if (format == BIN){
1A00:  MOVF   x2B,W
1A02:  SUBLW  02
1A04:  BNZ   1A58
....................     //Conversion manual
....................     converted[0] = '0';
1A06:  MOVLW  30
1A08:  MOVWF  x2D
....................     converted[1] = 'b';
1A0A:  MOVLW  62
1A0C:  MOVWF  x2E
....................     for (i=0;i<8;i++){
1A0E:  CLRF   x38
1A10:  MOVF   x38,W
1A12:  SUBLW  07
1A14:  BNC   1A54
....................     converted[i+2] = ((str >> (7-i)) & 0x01) + '0';
1A16:  MOVLW  02
1A18:  ADDWF  x38,W
1A1A:  CLRF   03
1A1C:  ADDLW  2D
1A1E:  MOVWF  FE9
1A20:  MOVLW  02
1A22:  ADDWFC 03,W
1A24:  MOVWF  FEA
1A26:  MOVLW  07
1A28:  BSF    FD8.0
1A2A:  SUBFWB x38,W
1A2C:  MOVWF  00
1A2E:  MOVFF  22A,23C
1A32:  MOVFF  229,23B
1A36:  MOVF   00,F
1A38:  BZ    1A44
1A3A:  BCF    FD8.0
1A3C:  RRCF   x3C,F
1A3E:  RRCF   x3B,F
1A40:  DECFSZ 00,F
1A42:  BRA    1A3A
1A44:  MOVLW  01
1A46:  ANDWF  x3B,F
1A48:  CLRF   x3C
1A4A:  MOVLW  30
1A4C:  ADDWF  x3B,W
1A4E:  MOVWF  FEF
1A50:  INCF   x38,F
1A52:  BRA    1A10
....................     }
....................     converted[10] = '\0';
1A54:  CLRF   x37
....................     }
1A56:  BRA    1A9A
....................     else if (format == DEC){
1A58:  MOVF   x2B,W
1A5A:  SUBLW  0A
1A5C:  BNZ   1A7A
....................       sprintf(converted,"%Ld",str);
1A5E:  MOVLW  02
1A60:  MOVLB  0
1A62:  MOVWF  xC7
1A64:  MOVLW  2D
1A66:  MOVWF  xC6
1A68:  MOVLW  10
1A6A:  MOVWF  FE9
1A6C:  MOVFF  22A,23A
1A70:  MOVFF  229,239
1A74:  BRA    1728
....................     }
1A76:  BRA    1A98
1A78:  MOVLB  2
....................     else if (format == UDEC){
1A7A:  MOVF   x2B,W
1A7C:  SUBLW  0B
1A7E:  BNZ   1A9A
....................       sprintf(converted,"%Lu",str);
1A80:  MOVLW  02
1A82:  MOVLB  0
1A84:  MOVWF  xC7
1A86:  MOVLW  2D
1A88:  MOVWF  xC6
1A8A:  MOVLW  10
1A8C:  MOVWF  FE9
1A8E:  MOVFF  22A,23A
1A92:  MOVFF  229,239
1A96:  BRA    1828
1A98:  MOVLB  2
....................     }
....................     usbPrint(converted, debug);
1A9A:  MOVLW  02
1A9C:  MOVWF  x3C
1A9E:  MOVLW  2D
1AA0:  MOVWF  x3B
1AA2:  MOVFF  22C,23D
1AA6:  MOVLB  0
1AA8:  RCALL  19A8
1AAA:  RETURN 0
....................     //Serial.print(str,format);
.................... }
.................... void println(char* str, int debug = 0){
....................     usbPrint(str, debug);
*
1AE2:  MOVFF  225,23C
1AE6:  MOVFF  224,23B
1AEA:  MOVFF  226,23D
1AEE:  RCALL  19A8
....................     usbPrint((char*)"\n", debug);
1AF0:  MOVLW  0A
1AF2:  MOVLB  2
1AF4:  MOVWF  x27
1AF6:  CLRF   x28
1AF8:  MOVLW  02
1AFA:  MOVWF  x3C
1AFC:  MOVLW  27
1AFE:  MOVWF  x3B
1B00:  MOVFF  226,23D
1B04:  MOVLB  0
1B06:  RCALL  19A8
1B08:  RETURN 0
....................     //Serial.println(str);
.................... }
.................... void println(int str, int format, int debug = 0){
....................     print(str,format, debug);
*
1C06:  MOVLB  2
1C08:  CLRF   x2A
1C0A:  MOVFF  222,229
1C0E:  MOVFF  223,22B
1C12:  MOVFF  224,22C
1C16:  MOVLB  0
1C18:  RCALL  19C6
....................     usbPrint((char*)"\n", debug);
1C1A:  MOVLW  0A
1C1C:  MOVLB  2
1C1E:  MOVWF  x25
1C20:  CLRF   x26
1C22:  MOVLW  02
1C24:  MOVWF  x3C
1C26:  MOVLW  25
1C28:  MOVWF  x3B
1C2A:  MOVFF  224,23D
1C2E:  MOVLB  0
1C30:  RCALL  19A8
1C32:  RETURN 0
....................     //Serial.println(str,format);
.................... }
.................... void print(float str, int debug = 0){
....................  char converted[11];
....................  sprintf(converted,"%03f",str);
....................  usbPrint(converted, debug);
.................... }
.................... void println(float str, int debug = 0){
....................     print(str, debug);
....................     usbPrint((char*)"\n", debug);
.................... }
.................... 
.................... float timeSec(){
*
2B5C:  CLRF   19
2B5E:  BTFSC  FF2.7
2B60:  BSF    19.7
2B62:  BCF    FF2.7
....................    float t;
....................    t = (float)(60*globalMin);
2B64:  MOVLB  2
2B66:  CLRF   x6C
2B68:  MOVLW  3C
2B6A:  MOVWF  x6B
2B6C:  MOVFF  BE,26E
2B70:  MOVFF  BD,26D
2B74:  MOVLB  0
2B76:  CALL   04AE
2B7A:  BTFSC  19.7
2B7C:  BSF    FF2.7
2B7E:  MOVFF  02,1E4
2B82:  MOVFF  01,1E3
2B86:  MOVLB  0
2B88:  RCALL  2A30
2B8A:  MOVFF  03,1E2
2B8E:  MOVFF  02,1E1
2B92:  MOVFF  01,1E0
2B96:  MOVFF  00,1DF
....................    t += (float)globalSec;
2B9A:  MOVLB  1
2B9C:  CLRF   xE4
2B9E:  MOVFF  BC,1E3
2BA2:  MOVLB  0
2BA4:  RCALL  2A30
2BA6:  BCF    FD8.1
2BA8:  MOVFF  1E2,1E8
2BAC:  MOVFF  1E1,1E7
2BB0:  MOVFF  1E0,1E6
2BB4:  MOVFF  1DF,1E5
2BB8:  MOVFF  03,1EC
2BBC:  MOVFF  02,1EB
2BC0:  MOVFF  01,1EA
2BC4:  MOVFF  00,1E9
2BC8:  CALL   20D2
2BCC:  MOVFF  03,1E2
2BD0:  MOVFF  02,1E1
2BD4:  MOVFF  01,1E0
2BD8:  MOVFF  00,1DF
....................    t += (float)((float)globalMs*0.001);
2BDC:  MOVFF  BB,1E4
2BE0:  MOVFF  BA,1E3
2BE4:  RCALL  2A30
2BE6:  MOVFF  03,1E6
2BEA:  MOVFF  02,1E5
2BEE:  MOVFF  01,1E4
2BF2:  MOVFF  00,1E3
2BF6:  MOVFF  03,1EA
2BFA:  MOVFF  02,1E9
2BFE:  MOVFF  01,1E8
2C02:  MOVFF  00,1E7
2C06:  MOVLW  6F
2C08:  MOVLB  1
2C0A:  MOVWF  xEE
2C0C:  MOVLW  12
2C0E:  MOVWF  xED
2C10:  MOVLW  03
2C12:  MOVWF  xEC
2C14:  MOVLW  75
2C16:  MOVWF  xEB
2C18:  MOVLB  0
2C1A:  RCALL  2A66
2C1C:  BCF    FD8.1
2C1E:  MOVFF  1E2,1E8
2C22:  MOVFF  1E1,1E7
2C26:  MOVFF  1E0,1E6
2C2A:  MOVFF  1DF,1E5
2C2E:  MOVFF  03,1EC
2C32:  MOVFF  02,1EB
2C36:  MOVFF  01,1EA
2C3A:  MOVFF  00,1E9
2C3E:  CALL   20D2
2C42:  MOVFF  03,1E2
2C46:  MOVFF  02,1E1
2C4A:  MOVFF  01,1E0
2C4E:  MOVFF  00,1DF
....................    //println(t);
....................    return t;
2C52:  MOVFF  1DF,00
2C56:  MOVFF  1E0,01
2C5A:  MOVFF  1E1,02
2C5E:  MOVFF  1E2,03
2C62:  RETURN 0
.................... }
.................... void spi_read_into(uint8_t address,uint8_t* array, uint8_t length){
*
1656:  MOVLB  2
1658:  CLRF   x29
....................     int i=0;
....................     //Select
....................     spiBegin();
165A:  MOVLB  0
165C:  RCALL  1610
....................     _BUFFER[0] = address & 0x7F; //Strip MSB byte to read
165E:  MOVLB  2
1660:  MOVF   x25,W
1662:  ANDLW  7F
1664:  MOVLB  0
1666:  MOVWF  xC2
....................     //Write address
....................     spi_write(_BUFFER[0]);
1668:  MOVF   FC9,W
166A:  MOVFF  C2,FC9
166E:  RRCF   FC7,W
1670:  BNC   166E
....................     delay_us(100);  // Tiempo para que el esclavo responda
1672:  MOVLW  64
1674:  MOVLB  2
1676:  MOVWF  x2A
1678:  MOVLB  0
167A:  BRA    161E
....................     for (i=0;i<length;i++)
167C:  MOVLB  2
167E:  CLRF   x29
1680:  MOVF   x28,W
1682:  SUBWF  x29,W
1684:  BC    16A2
....................         array[i] = spi_read(0xFF);
1686:  MOVF   x29,W
1688:  ADDWF  x26,W
168A:  MOVWF  FE9
168C:  MOVLW  00
168E:  ADDWFC x27,W
1690:  MOVWF  FEA
1692:  MOVF   FC9,W
1694:  SETF   FC9
1696:  RRCF   FC7,W
1698:  BNC   1696
169A:  MOVFF  FC9,FEF
169E:  INCF   x29,F
16A0:  BRA    1680
....................     spiEnd();
16A2:  MOVLB  0
16A4:  RCALL  1646
16A6:  RETURN 0
.................... 
.................... }
.................... void spi_write_from(uint8_t address,uint8_t* array, uint8_t length){
*
1B4C:  MOVLB  2
1B4E:  CLRF   x26
....................     int i=0;
....................     spiBegin();
1B50:  MOVLB  0
1B52:  RCALL  1610
....................     spi_write(address | 0b10000000);
1B54:  MOVLB  2
1B56:  MOVF   x22,W
1B58:  IORLW  80
1B5A:  MOVWF  x27
1B5C:  MOVF   FC9,W
1B5E:  MOVFF  227,FC9
1B62:  RRCF   FC7,W
1B64:  BNC   1B62
....................     //El address se aumenta en 1 automaticamente
....................    //Serial.println("Writing SPI");
....................     for (i=0;i<length;i++){
1B66:  CLRF   x26
1B68:  MOVF   x25,W
1B6A:  SUBWF  x26,W
1B6C:  BC    1B8C
....................       // Serial.println((char)array[i]);
....................       spi_write(array[i]);}
1B6E:  MOVF   x26,W
1B70:  ADDWF  x23,W
1B72:  MOVWF  FE9
1B74:  MOVLW  00
1B76:  ADDWFC x24,W
1B78:  MOVWF  FEA
1B7A:  MOVFF  FEF,227
1B7E:  MOVF   FC9,W
1B80:  MOVFF  227,FC9
1B84:  RRCF   FC7,W
1B86:  BNC   1B84
1B88:  INCF   x26,F
1B8A:  BRA    1B68
....................     spiEnd();    
1B8C:  MOVLB  0
1B8E:  RCALL  1646
1B90:  RETURN 0
.................... }
.................... uint8_t spi_read_u8(uint8_t address){
....................     spi_read_into(address,_BUFFER,1);
*
16A8:  MOVFF  224,225
16AC:  MOVLB  2
16AE:  CLRF   x27
16B0:  MOVLW  C2
16B2:  MOVWF  x26
16B4:  MOVLW  01
16B6:  MOVWF  x28
16B8:  MOVLB  0
16BA:  RCALL  1656
....................     return _BUFFER[0];
16BC:  MOVFF  C2,01
16C0:  RETURN 0
.................... }
.................... uint8_t spi_write_u8(uint8_t address,uint8_t val){
....................     _BUFFER[0] = val;
*
1B92:  MOVFF  221,C2
....................     spi_write_from(address,_BUFFER,1);
1B96:  MOVFF  220,222
1B9A:  MOVLB  2
1B9C:  CLRF   x24
1B9E:  MOVLW  C2
1BA0:  MOVWF  x23
1BA2:  MOVLW  01
1BA4:  MOVWF  x25
1BA6:  MOVLB  0
1BA8:  RCALL  1B4C
....................     return _BUFFER[0];
1BAA:  MOVFF  C2,01
1BAE:  RETURN 0
.................... }
.................... void sleep_ms(int ms){
....................     delay_ms(ms);
*
1608:  MOVFF  1BA,220
160C:  RCALL  15DE
160E:  RETURN 0
.................... }
.................... 
.................... #include <afadruit_rfm69.h>
.................... 
.................... // # The crystal oscillator frequency and frequency synthesizer step size.
.................... // # See the datasheet for details of this calculation.
.................... const float _FXOSC = 32000000.0;
.................... const float _FSTEP = _FXOSC / 524288;
.................... 
.................... void readAllRegs();
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL);
.................... void reset();
.................... void set_boost(uint8_t setting);
.................... void idle();
.................... void rfm_sleep();
.................... void listen();
.................... void transmit();
.................... float temperature_get();
.................... uint8_t operation_mode_get();
.................... void operation_mode_set(uint8_t val);
.................... uint8_t* sync_word_get();
.................... void sync_word_set(uint8_t* wrd);
.................... uint16_t preamble_length_get();
.................... void preamble_length_set(uint16_t val);
.................... float frequency_mhz_get();
.................... void frequency_mhz_set();
.................... uint8_t* encryption_key_get();
.................... void encryption_key_set(uint8_t* val);
.................... int8_t tx_power_get();
.................... void tx_power_set(int8_t val);
.................... float rssi_get();
.................... float bitrate_get();
.................... void bitrate_set(float val);
.................... float frequency_deviation_get();
.................... void frequency_deviation_set(float val);
.................... bool packet_sent();
.................... bool payload_ready();
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256);
.................... bool send_with_ack(uint8_t* data,uint8_t len);
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false);
.................... 
.................... struct _RegisterBits{
.................... uint8_t address;
.................... uint8_t mask;
.................... uint8_t offset;
.................... };
.................... 
.................... void set(uint8_t val,struct _RegisterBits obj){
*
1E54:  MOVFF  1E0,224
1E58:  RCALL  16A8
1E5A:  MOVFF  01,1E3
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         regVal &= ~obj.mask;
1E5E:  MOVLB  1
1E60:  MOVF   xE1,W
1E62:  XORLW  FF
1E64:  ANDWF  xE3,F
....................         regVal |= (val & 0xFF) << obj.offset;
1E66:  MOVFF  1DF,00
1E6A:  MOVF   xE2,W
1E6C:  MOVWF  01
1E6E:  BZ    1E78
1E70:  BCF    FD8.0
1E72:  RLCF   00,F
1E74:  DECFSZ 01,F
1E76:  BRA    1E70
1E78:  MOVF   00,W
1E7A:  IORWF  xE3,F
....................         spi_write_u8(obj.address,regVal);
1E7C:  MOVFF  1E0,220
1E80:  MOVFF  1E3,221
1E84:  MOVLB  0
1E86:  RCALL  1B92
1E88:  RETURN 0
.................... }
.................... uint8_t get(struct _RegisterBits obj){
*
1BDE:  MOVFF  220,224
1BE2:  RCALL  16A8
1BE4:  MOVFF  01,223
....................         uint8_t regVal = spi_read_u8(obj.address);
....................         return ((regVal & obj.mask) >> obj.offset);
1BE8:  MOVLB  2
1BEA:  MOVF   x23,W
1BEC:  ANDWF  x21,W
1BEE:  MOVWF  00
1BF0:  MOVF   x22,W
1BF2:  MOVWF  01
1BF4:  BZ    1BFE
1BF6:  BCF    FD8.0
1BF8:  RRCF   00,F
1BFA:  DECFSZ 01,F
1BFC:  BRA    1BF6
1BFE:  MOVF   00,W
1C00:  MOVWF  01
1C02:  MOVLB  0
1C04:  RETURN 0
....................     }
.................... uint8_t _debug_(struct _RegisterBits obj){
....................       print ((char*)"Mask: ",3);
....................       println(obj.mask,BIN,3);
....................       return obj.mask; 
.................... }
.................... 
.................... struct _RegisterBits _RegisterBits_(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
*
1482:  MOVLB  1
1484:  CLRF   x94
.................... 
....................         uint8_t i=0;
....................         struct _RegisterBits ret;
....................         ret.mask=0;
1486:  CLRF   x96
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         ret.address = _address;
1488:  MOVFF  191,195
....................         for (i=0;i<bits;i++){
148C:  CLRF   x94
148E:  MOVF   x93,W
1490:  SUBWF  x94,W
1492:  BC    149E
....................             ret.mask<<=1;
1494:  BCF    FD8.0
1496:  RLCF   x96,F
....................             ret.mask|=1;
1498:  BSF    x96.0
149A:  INCF   x94,F
149C:  BRA    148E
....................         }
....................         ret.mask <<= _offset;
149E:  MOVF   x92,W
14A0:  MOVWF  01
14A2:  BZ    14AC
14A4:  BCF    FD8.0
14A6:  RLCF   x96,F
14A8:  DECFSZ 01,F
14AA:  BRA    14A4
....................         ret.offset = _offset;
14AC:  MOVFF  192,197
....................         return ret;
14B0:  MOVFF  195,01
14B4:  MOVFF  196,02
14B8:  MOVFF  197,03
14BC:  MOVLB  0
14BE:  RETURN 0
....................  }
....................  
.................... /*
.................... class _RegisterBits{
....................     public:
....................     uint8_t address;
....................     uint8_t mask;
....................     uint8_t offset;
....................     _RegisterBits(uint8_t _address, uint8_t _offset,uint8_t bits = 1){
....................         uint8_t i=0;
....................         mask=0;
....................         //TODO: check offset to be [0,7] and bits [1,8]
....................         address = _address;
....................         for (i=0;i<bits;i++){
....................             mask<<=1;
....................             mask|=1;
....................         }
....................         mask <<= _offset;
....................         offset = _offset;
....................         }
....................     void set(uint8_t val){
....................         uint8_t regVal = spi_read_u8(address);
....................         regVal &= ~mask;
....................         regVal |= (val & 0xFF) << offset;
....................         spi_write_u8(address,regVal);
....................     }
....................     uint8_t get(){
....................         uint8_t regVal = spi_read_u8(address);
....................         return ((regVal & mask) >> offset);
....................     }
....................    
....................   
....................     }
.................... };
.................... */
.................... 
....................     
.................... //Configuraciones que solo utilizan ciertos bits   
.................... struct _RegisterBits data_mode = _RegisterBits_(_REG_DATA_MOD, 5, 2);
.................... struct _RegisterBits modulation_type = _RegisterBits_(_REG_DATA_MOD, 3, 2);
.................... struct _RegisterBits modulation_shaping = _RegisterBits_(_REG_DATA_MOD, 0, 2);
.................... struct _RegisterBits temp_start = _RegisterBits_(_REG_TEMP1, 3);
.................... struct _RegisterBits temp_running = _RegisterBits_(_REG_TEMP1, 2);
.................... struct _RegisterBits sync_on = _RegisterBits_(_REG_SYNC_CONFIG, 7);
.................... struct _RegisterBits sync_size = _RegisterBits_(_REG_SYNC_CONFIG, 3, 3);
.................... struct _RegisterBits aes_on = _RegisterBits_(_REG_PACKET_CONFIG2, 0);
.................... struct _RegisterBits pa_0_on = _RegisterBits_(_REG_PA_LEVEL, 7);
.................... struct _RegisterBits pa_1_on = _RegisterBits_(_REG_PA_LEVEL, 6);
.................... struct _RegisterBits pa_2_on = _RegisterBits_(_REG_PA_LEVEL, 5);
.................... struct _RegisterBits output_power = _RegisterBits_(_REG_PA_LEVEL, 0, 5);
.................... struct _RegisterBits rx_bw_dcc_freq = _RegisterBits_(_REG_RX_BW, 5, 3);
.................... struct _RegisterBits rx_bw_mantissa = _RegisterBits_(_REG_RX_BW, 3, 2);
.................... struct _RegisterBits rx_bw_exponent = _RegisterBits_(_REG_RX_BW, 0, 3);
.................... struct _RegisterBits afc_bw_dcc_freq = _RegisterBits_(_REG_AFC_BW, 5, 3);
.................... struct _RegisterBits afc_bw_mantissa = _RegisterBits_(_REG_AFC_BW, 3, 2);
.................... struct _RegisterBits afc_bw_exponent = _RegisterBits_(_REG_AFC_BW, 0, 3);
.................... struct _RegisterBits packet_format = _RegisterBits_(_REG_PACKET_CONFIG1, 7, 1);
.................... struct _RegisterBits dc_free = _RegisterBits_(_REG_PACKET_CONFIG1, 5, 2);
.................... struct _RegisterBits crc_on = _RegisterBits_(_REG_PACKET_CONFIG1, 4, 1);
.................... struct _RegisterBits crc_auto_clear_off = _RegisterBits_(_REG_PACKET_CONFIG1, 3, 1);
.................... struct _RegisterBits address_filter = _RegisterBits_(_REG_PACKET_CONFIG1, 1, 2);
.................... struct _RegisterBits mode_ready = _RegisterBits_(_REG_IRQ_FLAGS1, 7);
.................... struct _RegisterBits dio_0_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 6, 2);
.................... struct _RegisterBits dio_1_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 4, 2);
.................... struct _RegisterBits dio_2_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 2, 2);
.................... struct _RegisterBits dio_3_mapping = _RegisterBits_(_REG_DIO_MAPPING1, 0, 2);
.................... struct _RegisterBits dio_4_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 6, 2);
.................... struct _RegisterBits dio_5_mapping = _RegisterBits_(_REG_DIO_MAPPING1+1, 4, 2);
.................... 
.................... //Extras
.................... int8_t _tx_power;
.................... int8_t tx_power;
.................... bool high_power;
.................... uint8_t* sync_word;
.................... uint16_t preamble_length;
.................... uint32_t frequency_mhz;
.................... float bitrate;
.................... float rssi;
.................... float last_rssi;
.................... float ack_wait;
.................... float receive_timeout;
.................... float xmit_timeout;
.................... uint8_t ack_retries;
.................... float ack_delay;
.................... uint8_t sequence_number;
.................... uint8_t seen_ids[8];
.................... uint8_t node;
.................... uint8_t destination;
.................... uint8_t identifier;
.................... uint8_t flags;
.................... uint8_t operation_mode;
.................... float temperature;
.................... uint8_t encryption_key[16];
.................... float frequency_deviation;
.................... int _reset_pin;
.................... 
.................... 
.................... void readAllRegs()
.................... {
....................   uint8_t regVal;
....................   
....................   println((char*)"Address - HEX - BIN",2);
....................   for (uint8_t regAddr = 1; regAddr <= 0x4F; regAddr++)
....................   {
....................     /*
....................     spiBegin();
....................     SPI.transfer(regAddr & 0x7F); // send address + r/w bit
....................     regVal = SPI.transfer(0);
....................     spiEnd();*/
....................     regVal = spi_read_u8(regAddr);
....................     print(regAddr, HEX,2);
....................     print((char*)" - ",2);
....................     print(regVal,HEX,2);
....................     print((char*)" - ",2);
....................     println(regVal,BIN,2);
....................   }
....................   spiEnd();
.................... }    
.................... 
.................... bool checkId(){
.................... uint8_t version;
.................... version = spi_read_u8(_REG_VERSION);
*
1AAC:  MOVLW  10
1AAE:  MOVLB  2
1AB0:  MOVWF  x24
1AB2:  MOVLB  0
1AB4:  RCALL  16A8
1AB6:  MOVFF  01,191
.................... print(version,3);
1ABA:  MOVLB  2
1ABC:  CLRF   x2A
1ABE:  MOVFF  191,229
1AC2:  MOVLW  03
1AC4:  MOVWF  x2B
1AC6:  CLRF   x2C
1AC8:  MOVLB  0
1ACA:  RCALL  19C6
.................... return version==0x24;
1ACC:  MOVLB  1
1ACE:  MOVF   x91,W
1AD0:  SUBLW  24
1AD2:  BZ    1AD8
1AD4:  MOVLW  00
1AD6:  BRA    1ADA
1AD8:  MOVLW  01
1ADA:  MOVWF  01
1ADC:  MOVLB  0
1ADE:  GOTO   3E0E (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void init(uint8_t* _sync_word, int resetPin,uint8_t _preamble_length=4,bool _high_power=true,uint32_t baudrate = 2000000,uint8_t* encrypt = NULL){
*
257E:  MOVLB  1
2580:  CLRF   x9C
....................     uint8_t version=0;
....................     println((char*)"Initial conf starts",3);
2582:  MOVLW  01
2584:  MOVWF  FEA
2586:  MOVLW  9D
2588:  MOVWF  FE9
258A:  MOVLW  14
258C:  MOVWF  01
258E:  CLRF   FF7
2590:  MOVLW  00
2592:  MOVLB  0
2594:  CALL   022A
2598:  TBLRD*-
259A:  TBLRD*+
259C:  MOVFF  FF5,FEE
25A0:  DECFSZ 01,F
25A2:  BRA    259A
25A4:  MOVLW  01
25A6:  MOVLB  2
25A8:  MOVWF  x25
25AA:  MOVLW  9D
25AC:  MOVWF  x24
25AE:  MOVLW  03
25B0:  MOVWF  x26
25B2:  MOVLB  0
25B4:  CALL   1AE2
....................     //Serial.println("HOLA 2");
....................     _tx_power = 13;
25B8:  MOVLW  0D
25BA:  MOVLB  1
25BC:  MOVWF  x22
....................     _reset_pin = resetPin;
25BE:  MOVFF  193,16F
....................     high_power = _high_power;
25C2:  MOVLB  0
25C4:  BCF    xB5.1
25C6:  MOVLB  1
25C8:  BTFSS  x95.0
25CA:  BRA    25D2
25CC:  MOVLB  0
25CE:  BSF    xB5.1
25D0:  MOVLB  1
....................     reset();
25D2:  MOVLB  0
25D4:  GOTO   1B0A
....................     //readAllRegs();
....................     
....................     version = spi_read_u8(_REG_VERSION);
25D8:  MOVLW  10
25DA:  MOVLB  2
25DC:  MOVWF  x24
25DE:  MOVLB  0
25E0:  CALL   16A8
25E4:  MOVFF  01,19C
....................     if (version != 0x24){
25E8:  MOVLB  1
25EA:  MOVF   x9C,W
25EC:  SUBLW  24
25EE:  BZ    2662
....................         println((char*)"Error: ID del RFM incorrecta",1);
25F0:  MOVLW  01
25F2:  MOVWF  FEA
25F4:  MOVLW  9D
25F6:  MOVWF  FE9
25F8:  MOVLW  1D
25FA:  MOVWF  01
25FC:  CLRF   FF7
25FE:  MOVLW  00
2600:  MOVLB  0
2602:  CALL   024E
2606:  TBLRD*-
2608:  TBLRD*+
260A:  MOVFF  FF5,FEE
260E:  DECFSZ 01,F
2610:  BRA    2608
2612:  MOVLW  01
2614:  MOVLB  2
2616:  MOVWF  x25
2618:  MOVLW  9D
261A:  MOVWF  x24
261C:  MOVLW  01
261E:  MOVWF  x26
2620:  MOVLB  0
2622:  CALL   1AE2
....................         while(1){
....................         println((char*)"ID Loop",2);
2626:  MOVLW  01
2628:  MOVWF  FEA
262A:  MOVLW  9D
262C:  MOVWF  FE9
262E:  MOVLW  08
2630:  MOVWF  01
2632:  CLRF   FF7
2634:  MOVLW  00
2636:  CALL   027C
263A:  TBLRD*-
263C:  TBLRD*+
263E:  MOVFF  FF5,FEE
2642:  DECFSZ 01,F
2644:  BRA    263C
2646:  MOVLW  01
2648:  MOVLB  2
264A:  MOVWF  x25
264C:  MOVLW  9D
264E:  MOVWF  x24
2650:  MOVLW  02
2652:  MOVWF  x26
2654:  MOVLB  0
2656:  CALL   1AE2
....................         usb_task();
265A:  CALL   159A
265E:  BRA    2626
2660:  MOVLB  1
....................         }
....................         //exit(-1);
....................     }
....................     print((char*)"Idle",3);
2662:  MOVLW  49
2664:  MOVWF  x9D
2666:  MOVLW  64
2668:  MOVWF  x9E
266A:  MOVLW  6C
266C:  MOVWF  x9F
266E:  MOVLW  65
2670:  MOVWF  xA0
2672:  CLRF   xA1
2674:  MOVLW  01
2676:  MOVLB  2
2678:  MOVWF  x25
267A:  MOVLW  9D
267C:  MOVWF  x24
267E:  MOVLW  03
2680:  MOVWF  x26
2682:  MOVLB  0
2684:  CALL   1B3C
....................     idle();
2688:  CALL   1E3E
....................     println((char*)"Ready",2);
268C:  MOVLW  52
268E:  MOVLB  1
2690:  MOVWF  x9D
2692:  MOVLW  65
2694:  MOVWF  x9E
2696:  MOVLW  61
2698:  MOVWF  x9F
269A:  MOVLW  64
269C:  MOVWF  xA0
269E:  MOVLW  79
26A0:  MOVWF  xA1
26A2:  CLRF   xA2
26A4:  MOVLW  01
26A6:  MOVLB  2
26A8:  MOVWF  x25
26AA:  MOVLW  9D
26AC:  MOVWF  x24
26AE:  MOVLW  02
26B0:  MOVWF  x26
26B2:  MOVLB  0
26B4:  CALL   1AE2
....................     //Chip setup
....................     //Set FIFO TX condition to not empty and the default FIFO threshold to 15.
....................     spi_write_u8(_REG_FIFO_THRESH, 0b10001111);
26B8:  MOVLW  3C
26BA:  MOVLB  2
26BC:  MOVWF  x20
26BE:  MOVLW  8F
26C0:  MOVWF  x21
26C2:  MOVLB  0
26C4:  CALL   1B92
....................     //Configure low beta off.
....................     spi_write_u8(_REG_TEST_DAGC, 0x30);
26C8:  MOVLW  6F
26CA:  MOVLB  2
26CC:  MOVWF  x20
26CE:  MOVLW  30
26D0:  MOVWF  x21
26D2:  MOVLB  0
26D4:  CALL   1B92
....................     //Disable boost.
....................     spi_write_u8(_REG_TEST_PA1, _TEST_PA1_NORMAL);
26D8:  MOVLW  5A
26DA:  MOVLB  2
26DC:  MOVWF  x20
26DE:  MOVLW  55
26E0:  MOVWF  x21
26E2:  MOVLB  0
26E4:  CALL   1B92
....................     spi_write_u8(_REG_TEST_PA2, _TEST_PA2_NORMAL);
26E8:  MOVLW  5C
26EA:  MOVLB  2
26EC:  MOVWF  x20
26EE:  MOVLW  70
26F0:  MOVWF  x21
26F2:  MOVLB  0
26F4:  CALL   1B92
....................     //set sync word
....................     //IMPORTANTE: Recuerda alocar el espacio para que no se sobreescriba
....................     print((char*)"Freq",3);
26F8:  MOVLW  46
26FA:  MOVLB  1
26FC:  MOVWF  x9D
26FE:  MOVLW  72
2700:  MOVWF  x9E
2702:  MOVLW  65
2704:  MOVWF  x9F
2706:  MOVLW  71
2708:  MOVWF  xA0
270A:  CLRF   xA1
270C:  MOVLW  01
270E:  MOVLB  2
2710:  MOVWF  x25
2712:  MOVLW  9D
2714:  MOVWF  x24
2716:  MOVLW  03
2718:  MOVWF  x26
271A:  MOVLB  0
271C:  CALL   1B3C
....................     sync_word_set( _sync_word); 
2720:  MOVFF  192,1BB
2724:  MOVFF  191,1BA
2728:  GOTO   1E8A
....................     preamble_length_set(_preamble_length);
272C:  MOVLB  1
272E:  CLRF   xBB
2730:  MOVFF  194,1BA
2734:  MOVLB  0
2736:  GOTO   1F10
....................     frequency_mhz_set(); 
273A:  GOTO   1F3A
....................     println((char*)"Ready",3);
273E:  MOVLW  52
2740:  MOVLB  1
2742:  MOVWF  x9D
2744:  MOVLW  65
2746:  MOVWF  x9E
2748:  MOVLW  61
274A:  MOVWF  x9F
274C:  MOVLW  64
274E:  MOVWF  xA0
2750:  MOVLW  79
2752:  MOVWF  xA1
2754:  CLRF   xA2
2756:  MOVLW  01
2758:  MOVLB  2
275A:  MOVWF  x25
275C:  MOVLW  9D
275E:  MOVWF  x24
2760:  MOVLW  03
2762:  MOVWF  x26
2764:  MOVLB  0
2766:  CALL   1AE2
....................     //TODO: set encryption key
....................     //encryption_key = encrypt;
....................     //encryption_key_set(encrypt);
....................     
....................     //PARA USUARIOS AVANZADOS ----------------------------------------------------------------------------------------------
....................     // Configure modulation for RadioHead library GFSK_Rb250Fd250 mode
....................     // by default.  Users with advanced knowledge can manually reconfigure
....................     // for any other mode (consulting the datasheet is absolutely
....................     // necessary!).
....................     bitrate_set(250000);  // 250kbs
276A:  MOVLB  1
276C:  CLRF   xBD
276E:  MOVLW  24
2770:  MOVWF  xBC
2772:  MOVLW  74
2774:  MOVWF  xBB
2776:  MOVLW  90
2778:  MOVWF  xBA
277A:  MOVLB  0
277C:  BRA    2386
....................     frequency_deviation_set(250000);  // 250khz
277E:  MOVLB  1
2780:  CLRF   xBD
2782:  MOVLW  24
2784:  MOVWF  xBC
2786:  MOVLW  74
2788:  MOVWF  xBB
278A:  MOVLW  90
278C:  MOVWF  xBA
278E:  MOVLB  0
2790:  BRA    2428
....................     set(0b01,modulation_shaping);  // Gaussian filter, BT=1.0
2792:  MOVLW  01
2794:  MOVLB  1
2796:  MOVWF  xDF
2798:  MOVFF  D0,1E2
279C:  MOVFF  CF,1E1
27A0:  MOVFF  CE,1E0
27A4:  MOVLB  0
27A6:  CALL   1E54
....................     set(0b111,rx_bw_dcc_freq);  // RxBw register = 0xE0
27AA:  MOVLW  07
27AC:  MOVLB  1
27AE:  MOVWF  xDF
27B0:  MOVFF  EE,1E2
27B4:  MOVFF  ED,1E1
27B8:  MOVFF  EC,1E0
27BC:  MOVLB  0
27BE:  CALL   1E54
....................     set(0b00,rx_bw_mantissa);
27C2:  MOVLB  1
27C4:  CLRF   xDF
27C6:  MOVFF  F1,1E2
27CA:  MOVFF  F0,1E1
27CE:  MOVFF  EF,1E0
27D2:  MOVLB  0
27D4:  CALL   1E54
....................     set(0b000,rx_bw_exponent);
27D8:  MOVLB  1
27DA:  CLRF   xDF
27DC:  MOVFF  F4,1E2
27E0:  MOVFF  F3,1E1
27E4:  MOVFF  F2,1E0
27E8:  MOVLB  0
27EA:  CALL   1E54
....................     set(0b111,afc_bw_dcc_freq); // AfcBw register = 0xE0
27EE:  MOVLW  07
27F0:  MOVLB  1
27F2:  MOVWF  xDF
27F4:  MOVFF  F7,1E2
27F8:  MOVFF  F6,1E1
27FC:  MOVFF  F5,1E0
2800:  MOVLB  0
2802:  CALL   1E54
....................     set(0b00,afc_bw_mantissa);
2806:  MOVLB  1
2808:  CLRF   xDF
280A:  MOVFF  FA,1E2
280E:  MOVFF  F9,1E1
2812:  MOVFF  F8,1E0
2816:  MOVLB  0
2818:  CALL   1E54
....................     set(0b000,afc_bw_exponent);
281C:  MOVLB  1
281E:  CLRF   xDF
2820:  MOVFF  FD,1E2
2824:  MOVFF  FC,1E1
2828:  MOVFF  FB,1E0
282C:  MOVLB  0
282E:  CALL   1E54
....................     set(1,packet_format);  // Variable length.
2832:  MOVLW  01
2834:  MOVLB  1
2836:  MOVWF  xDF
2838:  MOVFF  100,1E2
283C:  MOVFF  FF,1E1
2840:  MOVFF  FE,1E0
2844:  MOVLB  0
2846:  CALL   1E54
....................     set(0b10,dc_free);  // Whitening
284A:  MOVLW  02
284C:  MOVLB  1
284E:  MOVWF  xDF
2850:  MOVFF  103,1E2
2854:  MOVFF  102,1E1
2858:  MOVFF  101,1E0
285C:  MOVLB  0
285E:  CALL   1E54
....................     //-----------------------------------------------------------------------------------------------------------------------
....................     // Set transmit power to 13 dBm, a safe value any module supports.
....................     tx_power_set(13);
2862:  MOVLW  0D
2864:  MOVLB  1
2866:  MOVWF  xBA
2868:  MOVLB  0
286A:  BRA    24CA
....................     //
....................     // initialize last RSSI reading
....................     last_rssi = 0.0;
286C:  MOVLB  1
286E:  CLRF   x37
2870:  CLRF   x36
2872:  CLRF   x35
2874:  CLRF   x34
....................     // """The RSSI of the last received packet. Stored when the packet was received.
....................     //    This instantaneous RSSI value may not be accurate once the
....................     //    operating mode has been changed.
....................     // """
....................     // initialize timeouts and delays delays
....................     ack_wait = 0.5;
2876:  CLRF   x3B
2878:  CLRF   x3A
287A:  CLRF   x39
287C:  MOVLW  7E
287E:  MOVWF  x38
....................     // """The delay time before attempting a retry after not receiving an ACK"""
....................     receive_timeout = 0.5;
2880:  CLRF   x3F
2882:  CLRF   x3E
2884:  CLRF   x3D
2886:  MOVWF  x3C
....................     // """The amount of time to poll for a received packet.
....................     //    If no packet is received, the returned packet will be None
....................     // """
....................     xmit_timeout = 2.0;
2888:  CLRF   x43
288A:  CLRF   x42
288C:  CLRF   x41
288E:  MOVLW  80
2890:  MOVWF  x40
....................     // """The amount of time to wait for the HW to transmit the packet.
....................     //    This is mainly used to prevent a hang due to a HW issue
....................     // """
....................     ack_retries = 5;
2892:  MOVLW  05
2894:  MOVWF  x44
....................     // """The number of ACK retries before reporting a failure."""
....................     ack_delay = 0;
2896:  CLRF   x48
2898:  CLRF   x47
289A:  CLRF   x46
289C:  CLRF   x45
....................     // """The delay time before attemting to send an ACK.
....................     //    If ACKs are being missed try setting this to .1 or .2.
....................     // """
....................     //print("<------------------------------------------------------------------------------------------------------------------------------------------>")
....................     // initialize sequence number counter for reliabe datagram mode
....................     sequence_number = 0;
289E:  CLRF   x49
....................     // create seen Ids list
....................     //seen_ids = {0};
....................     // initialize packet header
....................     // node address - default is broadcast
....................     node = _RH_BROADCAST_ADDRESS;
28A0:  SETF   x52
....................     // """The default address of this Node. (0-255).
....................     //    If not 255 (0xff) then only packets address to this node will be accepted.
....................     //    First byte of the RadioHead header.
....................     // """
....................     // destination address - default is broadcast
....................     destination = _RH_BROADCAST_ADDRESS;
28A2:  SETF   x53
....................     // """The default destination address for packet transmissions. (0-255).
....................     //    If 255 (0xff) then any receiving node should accept the packet.
....................     //    Second byte of the RadioHead header.
....................     // """
....................     // ID - contains seq count for reliable datagram mode
....................     identifier = 0;
28A4:  CLRF   x54
....................     // """Automatically set to the sequence number when send_with_ack() used.
....................     //    Third byte of the RadioHead header.
....................     // """
....................     // flags - identifies ack/reetry packet for reliable datagram mode
....................     flags = 0;
28A6:  CLRF   x55
....................     // """Upper 4 bits reserved for use by Reliable Datagram Mode.
....................     //    Lower 4 bits may be used to pass information.
....................     //    Fourth byte of the RadioHead header.
....................     // """
....................     //Extras: paara algunos registros que no coinciden con la libreria del micropython
....................     // RSSI_CONFIG: 0x2
....................     spi_write_u8(0x23,0x02);
28A8:  MOVLW  23
28AA:  MOVLB  2
28AC:  MOVWF  x20
28AE:  MOVLW  02
28B0:  MOVWF  x21
28B2:  MOVLB  0
28B4:  CALL   1B92
....................     //_REG_DIO_MAPPING1
....................     spi_write_u8(_REG_DIO_MAPPING1,0x00);
28B8:  MOVLW  25
28BA:  MOVLB  2
28BC:  MOVWF  x20
28BE:  CLRF   x21
28C0:  MOVLB  0
28C2:  CALL   1B92
....................     //101  FXOSC / 32
....................     spi_write_u8(_REG_DIO_MAPPING1+1,0b101);
28C6:  MOVLW  26
28C8:  MOVLB  2
28CA:  MOVWF  x20
28CC:  MOVLW  05
28CE:  MOVWF  x21
28D0:  MOVLB  0
28D2:  CALL   1B92
....................     //RSSI_THRESH
....................     spi_write_u8(0x29,0xFF);
28D6:  MOVLW  29
28D8:  MOVLB  2
28DA:  MOVWF  x20
28DC:  SETF   x21
28DE:  MOVLB  0
28E0:  CALL   1B92
....................     //INIT payload length to 0
....................     spi_write_u8(0x38,0x40);
28E4:  MOVLW  38
28E6:  MOVLB  2
28E8:  MOVWF  x20
28EA:  MOVLW  40
28EC:  MOVWF  x21
28EE:  MOVLB  0
28F0:  CALL   1B92
....................     //AutoRxRestartOn
....................     spi_write_u8(_REG_PACKET_CONFIG2,0x02);
28F4:  MOVLW  3D
28F6:  MOVLB  2
28F8:  MOVWF  x20
28FA:  MOVLW  02
28FC:  MOVWF  x21
28FE:  MOVLB  0
2900:  CALL   1B92
....................     //Con esto se puede colocar un LED en DIO2 y ver los datos que se reciben y se envian
....................     set(0b01,dio_2_mapping);
2904:  MOVLW  01
2906:  MOVLB  1
2908:  MOVWF  xDF
290A:  MOVFF  118,1E2
290E:  MOVFF  117,1E1
2912:  MOVFF  116,1E0
2916:  MOVLB  0
2918:  CALL   1E54
....................     //Asi se puede saber si el buffer FIFO tiene algun dato
....................     set(0b10,dio_1_mapping);
291C:  MOVLW  02
291E:  MOVLB  1
2920:  MOVWF  xDF
2922:  MOVFF  115,1E2
2926:  MOVFF  114,1E1
292A:  MOVFF  113,1E0
292E:  MOVLB  0
2930:  CALL   1E54
....................     //En modo rx, da informacion acerca del RSSI (Recieved Signal Strength Indicator)
....................     set(0b01,dio_3_mapping);
2934:  MOVLW  01
2936:  MOVLB  1
2938:  MOVWF  xDF
293A:  MOVFF  11B,1E2
293E:  MOVFF  11A,1E1
2942:  MOVFF  119,1E0
2946:  MOVLB  0
2948:  CALL   1E54
....................     print((char*)"Initial configuration end\n",2);
294C:  MOVLW  01
294E:  MOVWF  FEA
2950:  MOVLW  9D
2952:  MOVWF  FE9
2954:  MOVLW  1B
2956:  MOVWF  01
2958:  CLRF   FF7
295A:  MOVLW  00
295C:  CALL   0294
2960:  TBLRD*-
2962:  TBLRD*+
2964:  MOVFF  FF5,FEE
2968:  DECFSZ 01,F
296A:  BRA    2962
296C:  MOVLW  01
296E:  MOVLB  2
2970:  MOVWF  x25
2972:  MOVLW  9D
2974:  MOVWF  x24
2976:  MOVLW  02
2978:  MOVWF  x26
297A:  MOVLB  0
297C:  CALL   1B3C
2980:  GOTO   3E8A (RETURN)
.................... }
.................... void reset(){
....................     setOutput(_reset_pin,1);
*
1B0A:  MOVFF  16F,22A
1B0E:  MOVLW  01
1B10:  MOVLB  2
1B12:  MOVWF  x2B
1B14:  MOVLB  0
1B16:  RCALL  1502
....................     sleep_ms(1);
1B18:  MOVLW  01
1B1A:  MOVLB  1
1B1C:  MOVWF  xBA
1B1E:  MOVLB  0
1B20:  RCALL  1608
....................     setOutput(_reset_pin,0);
1B22:  MOVFF  16F,22A
1B26:  MOVLB  2
1B28:  CLRF   x2B
1B2A:  MOVLB  0
1B2C:  RCALL  1502
....................     sleep_ms(5);
1B2E:  MOVLW  05
1B30:  MOVLB  1
1B32:  MOVWF  xBA
1B34:  MOVLB  0
1B36:  RCALL  1608
1B38:  GOTO   25D8 (RETURN)
.................... }
.................... void set_boost(uint8_t setting){
....................     //Set preamp boost if needed.
....................     if (_tx_power >= 18){
*
1BB0:  MOVLB  1
1BB2:  BTFSC  x22.7
1BB4:  BRA    1BDA
1BB6:  MOVF   x22,W
1BB8:  SUBLW  11
1BBA:  BC    1BDA
....................         spi_write_u8(_REG_TEST_PA1, setting);
1BBC:  MOVLW  5A
1BBE:  MOVLB  2
1BC0:  MOVWF  x20
1BC2:  MOVFF  1DF,221
1BC6:  MOVLB  0
1BC8:  RCALL  1B92
....................         spi_write_u8(_REG_TEST_PA2, setting);
1BCA:  MOVLW  5C
1BCC:  MOVLB  2
1BCE:  MOVWF  x20
1BD0:  MOVFF  1DF,221
1BD4:  MOVLB  0
1BD6:  RCALL  1B92
1BD8:  MOVLB  1
....................     }
1BDA:  MOVLB  0
1BDC:  RETURN 0
.................... }
.................... void idle(){
....................     //Enter idle standby mode (switching off high power amplifiers if necessary).
....................     //Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
*
1E3E:  MOVLW  55
1E40:  MOVLB  1
1E42:  MOVWF  xDF
1E44:  MOVLB  0
1E46:  RCALL  1BB0
....................     operation_mode_set(STANDBY_MODE);
1E48:  MOVLW  01
1E4A:  MOVLB  1
1E4C:  MOVWF  xDF
1E4E:  MOVLB  0
1E50:  RCALL  1C34
1E52:  RETURN 0
....................            
.................... }
.................... void rfm_sleep(){
....................     operation_mode_set(SLEEP_MODE); 
.................... }
.................... void listen(){
....................     //Listen for packets to be received by the chip.  Use :py:func:`receive` to listen, wait
....................     //and retrieve packets as they're available.
....................     
....................     // Like RadioHead library, turn off high power boost if enabled.
....................     
....................     set_boost(_TEST_PA1_NORMAL);
*
29FE:  MOVLW  55
2A00:  MOVLB  1
2A02:  MOVWF  xDF
2A04:  MOVLB  0
2A06:  CALL   1BB0
....................     // Enable payload ready interrupt for D0 line.
....................     set(0b01,dio_0_mapping);
2A0A:  MOVLW  01
2A0C:  MOVLB  1
2A0E:  MOVWF  xDF
2A10:  MOVFF  112,1E2
2A14:  MOVFF  111,1E1
2A18:  MOVFF  110,1E0
2A1C:  MOVLB  0
2A1E:  CALL   1E54
....................     // Enter RX mode (will clear FIFO!).
....................           
....................     operation_mode_set(RX_MODE); 
2A22:  MOVLW  04
2A24:  MOVLB  1
2A26:  MOVWF  xDF
2A28:  MOVLB  0
2A2A:  CALL   1C34
2A2E:  RETURN 0
.................... }
.................... void transmit(){
....................     // Transmit a packet which is queued in the FIFO.  This is a low level function for
....................     // entering transmit mode and more.  For generating and transmitting a packet of data use
....................     // :py:func:`send` instead.
....................     
....................     // # Like RadioHead library, turn on high power boost if enabled.
....................     set_boost(_TEST_PA1_BOOST);
*
3212:  MOVLW  5D
3214:  MOVLB  1
3216:  MOVWF  xDF
3218:  MOVLB  0
321A:  CALL   1BB0
....................     // # Enable packet sent interrupt for D0 line.
....................     set(0b00,dio_0_mapping);
321E:  MOVLB  1
3220:  CLRF   xDF
3222:  MOVFF  112,1E2
3226:  MOVFF  111,1E1
322A:  MOVFF  110,1E0
322E:  MOVLB  0
3230:  CALL   1E54
....................     //readAllRegs(); 
....................     // # Enter TX mode (will clear FIFO!).
....................     operation_mode_set(TX_MODE);  
3234:  MOVLW  03
3236:  MOVLB  1
3238:  MOVWF  xDF
323A:  MOVLB  0
323C:  CALL   1C34
3240:  GOTO   33FC (RETURN)
.................... }
.................... // .. warning:: Reading this will STOP any receiving/sending that might be happening!
.................... //WARNING:LOOP infinito
.................... float temperature_get(){
....................     // The internal temperature of the chip in degrees Celsius. Be warned this is not
....................     // calibrated or very accurate.
....................     // .. warning:: Reading this will STOP any receiving/sending that might be happening!
....................     // # Start a measurement then poll the measurement finished bit.
....................     set(1,temp_start);
....................     //WARNING:LOOP infinito
....................     while (get(temp_running) > 0){
....................     usb_task();
....................     
....................     }
....................     temperature = 166.0 - (float)spi_read_u8(_REG_TEMP2);
....................     return temperature;
.................... }
.................... uint8_t operation_mode_get(){
....................     // """The operation mode value.  Unless you're manually controlling the chip you shouldn't
....................     // change the operation_mode with this property as other side-effects are required for
....................     // changing logical modes--use :py:func:`idle`, :py:func:`sleep`, :py:func:`transmit`,
....................     // :py:func:`listen` instead to signal intent for explicit logical modes.
....................     // """
....................     operation_mode = (spi_read_u8(_REG_OP_MODE) >> 2) &0b111;
....................     return operation_mode;
.................... }
.................... void operation_mode_set(uint8_t val){
....................     //float start;
....................     uint16_t n;
....................     //TODO: assert 0 <= val <= 4
....................     n=0;
*
1C34:  MOVLB  1
1C36:  CLRF   xE1
1C38:  CLRF   xE0
....................     
....................     while (!get(mode_ready)){
1C3A:  MOVFF  10F,222
1C3E:  MOVFF  10E,221
1C42:  MOVFF  10D,220
1C46:  MOVLB  0
1C48:  RCALL  1BDE
1C4A:  MOVF   01,F
1C4C:  BNZ   1D06
....................       delay_ms(100);
1C4E:  MOVLW  64
1C50:  MOVLB  2
1C52:  MOVWF  x20
1C54:  MOVLB  0
1C56:  RCALL  15DE
....................       n+=100;
1C58:  MOVLW  64
1C5A:  MOVLB  1
1C5C:  ADDWF  xE0,F
1C5E:  MOVLW  00
1C60:  ADDWFC xE1,F
....................       usb_task();
1C62:  MOVLB  0
1C64:  RCALL  159A
....................       println((char*)"OP Loop 1",3);
1C66:  MOVLW  01
1C68:  MOVWF  FEA
1C6A:  MOVLW  E2
1C6C:  MOVWF  FE9
1C6E:  MOVLW  0A
1C70:  MOVWF  01
1C72:  CLRF   FF7
1C74:  MOVLW  00
1C76:  CALL   02C0
1C7A:  TBLRD*-
1C7C:  TBLRD*+
1C7E:  MOVFF  FF5,FEE
1C82:  DECFSZ 01,F
1C84:  BRA    1C7C
1C86:  MOVLW  01
1C88:  MOVLB  2
1C8A:  MOVWF  x25
1C8C:  MOVLW  E2
1C8E:  MOVWF  x24
1C90:  MOVLW  03
1C92:  MOVWF  x26
1C94:  MOVLB  0
1C96:  RCALL  1AE2
....................         if (n >= 3000){
1C98:  MOVLB  1
1C9A:  MOVF   xE1,W
1C9C:  SUBLW  0A
1C9E:  BC    1D02
1CA0:  XORLW  FF
1CA2:  BNZ   1CAA
1CA4:  MOVF   xE0,W
1CA6:  SUBLW  B7
1CA8:  BC    1D02
....................                  
....................             print ((char*)"Operation Mode couldnt be set\n",2);
1CAA:  MOVLW  01
1CAC:  MOVWF  FEA
1CAE:  MOVLW  E2
1CB0:  MOVWF  FE9
1CB2:  MOVLW  1F
1CB4:  MOVWF  01
1CB6:  CLRF   FF7
1CB8:  MOVLW  00
1CBA:  MOVLB  0
1CBC:  CALL   02DA
1CC0:  TBLRD*-
1CC2:  TBLRD*+
1CC4:  MOVFF  FF5,FEE
1CC8:  DECFSZ 01,F
1CCA:  BRA    1CC2
1CCC:  MOVLW  01
1CCE:  MOVLB  2
1CD0:  MOVWF  x25
1CD2:  MOVLW  E2
1CD4:  MOVWF  x24
1CD6:  MOVLW  02
1CD8:  MOVWF  x26
1CDA:  MOVLB  0
1CDC:  RCALL  1B3C
....................             println(spi_read_u8(0x27),BIN,2);
1CDE:  MOVLW  27
1CE0:  MOVLB  2
1CE2:  MOVWF  x24
1CE4:  MOVLB  0
1CE6:  RCALL  16A8
1CE8:  MOVFF  01,220
1CEC:  MOVFF  01,222
1CF0:  MOVLW  02
1CF2:  MOVLB  2
1CF4:  MOVWF  x23
1CF6:  MOVWF  x24
1CF8:  MOVLB  0
1CFA:  RCALL  1C06
....................             while (1){ 
....................             usb_task();
1CFC:  RCALL  159A
1CFE:  BRA    1CFC
1D00:  MOVLB  1
....................             }
....................             
....................             //exit(-2);
....................         }
1D02:  BRA    1C3A
1D04:  MOVLB  0
....................     }      
....................     // Set the mode bits inside the operation mode register.
....................     operation_mode = spi_read_u8(_REG_OP_MODE);
1D06:  MOVLW  01
1D08:  MOVLB  2
1D0A:  MOVWF  x24
1D0C:  MOVLB  0
1D0E:  RCALL  16A8
1D10:  MOVFF  01,156
....................     operation_mode &= 0b11100011;
1D14:  MOVLW  E3
1D16:  MOVLB  1
1D18:  ANDWF  x56,F
....................     operation_mode |= val << 2;
1D1A:  RLCF   xDF,W
1D1C:  MOVWF  00
1D1E:  RLCF   00,F
1D20:  MOVLW  FC
1D22:  ANDWF  00,F
1D24:  MOVF   00,W
1D26:  IORWF  x56,F
....................     //Serial.println(operation_mode,BIN);
....................     spi_write_u8(_REG_OP_MODE,operation_mode);
1D28:  MOVLW  01
1D2A:  MOVLB  2
1D2C:  MOVWF  x20
1D2E:  MOVFF  156,221
1D32:  MOVLB  0
1D34:  RCALL  1B92
....................    
....................     // Wait for mode to change by polling interrupt bit.
....................     // start = timeSec();
....................     n=0;
1D36:  MOVLB  1
1D38:  CLRF   xE1
1D3A:  CLRF   xE0
....................     while (!get(mode_ready)){
1D3C:  MOVFF  10F,222
1D40:  MOVFF  10E,221
1D44:  MOVFF  10D,220
1D48:  MOVLB  0
1D4A:  RCALL  1BDE
1D4C:  MOVF   01,F
1D4E:  BTFSS  FD8.2
1D50:  BRA    1E3C
....................     usb_task();
1D52:  RCALL  159A
....................     delay_ms(100);
1D54:  MOVLW  64
1D56:  MOVLB  2
1D58:  MOVWF  x20
1D5A:  MOVLB  0
1D5C:  RCALL  15DE
....................     n+=100;
1D5E:  MOVLW  64
1D60:  MOVLB  1
1D62:  ADDWF  xE0,F
1D64:  MOVLW  00
1D66:  ADDWFC xE1,F
....................     println((char*)"OP Loop 2",2);
1D68:  MOVLW  02
1D6A:  MOVWF  FEA
1D6C:  MOVLW  01
1D6E:  MOVWF  FE9
1D70:  MOVLW  0A
1D72:  MOVWF  01
1D74:  CLRF   FF7
1D76:  MOVLW  00
1D78:  MOVLB  0
1D7A:  CALL   030A
1D7E:  TBLRD*-
1D80:  TBLRD*+
1D82:  MOVFF  FF5,FEE
1D86:  DECFSZ 01,F
1D88:  BRA    1D80
1D8A:  MOVLW  02
1D8C:  MOVLB  2
1D8E:  MOVWF  x25
1D90:  MOVLW  01
1D92:  MOVWF  x24
1D94:  MOVLW  02
1D96:  MOVWF  x26
1D98:  MOVLB  0
1D9A:  RCALL  1AE2
....................     println(spi_read_u8(_REG_OP_MODE),BIN,2)  ;  
1D9C:  MOVLW  01
1D9E:  MOVLB  2
1DA0:  MOVWF  x24
1DA2:  MOVLB  0
1DA4:  RCALL  16A8
1DA6:  MOVFF  01,220
1DAA:  MOVFF  01,222
1DAE:  MOVLW  02
1DB0:  MOVLB  2
1DB2:  MOVWF  x23
1DB4:  MOVWF  x24
1DB6:  MOVLB  0
1DB8:  RCALL  1C06
....................     println(n,DEC,2);
1DBA:  MOVFF  1E0,222
1DBE:  MOVLW  0A
1DC0:  MOVLB  2
1DC2:  MOVWF  x23
1DC4:  MOVLW  02
1DC6:  MOVWF  x24
1DC8:  MOVLB  0
1DCA:  RCALL  1C06
....................         if (n >= 3000){
1DCC:  MOVLB  1
1DCE:  MOVF   xE1,W
1DD0:  SUBLW  0A
1DD2:  BC    1E38
1DD4:  XORLW  FF
1DD6:  BNZ   1DDE
1DD8:  MOVF   xE0,W
1DDA:  SUBLW  B7
1DDC:  BC    1E38
....................             print ((char*)"Timeout on Operation Mode Set\n",2);
1DDE:  MOVLW  02
1DE0:  MOVWF  FEA
1DE2:  MOVLW  01
1DE4:  MOVWF  FE9
1DE6:  MOVLW  1F
1DE8:  MOVWF  01
1DEA:  CLRF   FF7
1DEC:  MOVLW  00
1DEE:  MOVLB  0
1DF0:  CALL   0324
1DF4:  TBLRD*-
1DF6:  TBLRD*+
1DF8:  MOVFF  FF5,FEE
1DFC:  DECFSZ 01,F
1DFE:  BRA    1DF6
1E00:  MOVLW  02
1E02:  MOVLB  2
1E04:  MOVWF  x25
1E06:  MOVLW  01
1E08:  MOVWF  x24
1E0A:  MOVLW  02
1E0C:  MOVWF  x26
1E0E:  MOVLB  0
1E10:  RCALL  1B3C
....................             println(spi_read_u8(_REG_OP_MODE),BIN,2)  ;     
1E12:  MOVLW  01
1E14:  MOVLB  2
1E16:  MOVWF  x24
1E18:  MOVLB  0
1E1A:  RCALL  16A8
1E1C:  MOVFF  01,220
1E20:  MOVFF  01,222
1E24:  MOVLW  02
1E26:  MOVLB  2
1E28:  MOVWF  x23
1E2A:  MOVWF  x24
1E2C:  MOVLB  0
1E2E:  RCALL  1C06
....................             while (1){
....................             usb_task();
1E30:  CALL   159A
1E34:  BRA    1E30
1E36:  MOVLB  1
....................             
....................             }
....................             //exit(-2);
....................         }
1E38:  BRA    1D3C
1E3A:  MOVLB  0
....................     }
1E3C:  RETURN 0
.................... }
.................... //WARNING must free allocated memory after using
.................... uint8_t* sync_word_get(){
....................     
....................     // """The synchronization word value.  This is a byte string up to 8 bytes long (64 bits)
....................     // which indicates the synchronization word for transmitted and received packets. Any
....................     // received packet which does not include this sync word will be ignored. The default value
....................     // is 0x2D, 0xD4 which matches the RadioHead RFM69 library. Setting a value of None will
....................     // disable synchronization word matching entirely.
....................     // """
....................     // # Handle when sync word is disabled..
....................     if (!get(sync_on))return NULL;
....................     //WARNING must free allocated memory after using
....................     sync_word = (uint8_t*)malloc(get(sync_size)+2);
....................     sync_word[0] = get(sync_size)+1;
....................     spi_read_into(_REG_SYNC_VALUE1,sync_word+1,get(sync_size)+1);
....................     return sync_word;
.................... }
.................... void sync_word_set(uint8_t* wrd){
*
1E8A:  MOVLB  1
1E8C:  MOVFF  1BA,FE9
1E90:  MOVFF  1BB,FEA
1E94:  MOVFF  FEF,1BC
....................   uint8_t len = wrd[0];
....................     if (len == 0 || wrd == NULL)set(0,sync_on);
1E98:  MOVF   xBC,F
1E9A:  BZ    1EA4
1E9C:  MOVF   xBA,F
1E9E:  BNZ   1EBA
1EA0:  MOVF   xBB,F
1EA2:  BNZ   1EBA
1EA4:  CLRF   xDF
1EA6:  MOVFF  D9,1E2
1EAA:  MOVFF  D8,1E1
1EAE:  MOVFF  D7,1E0
1EB2:  MOVLB  0
1EB4:  RCALL  1E54
1EB6:  BRA    1F0C
1EB8:  MOVLB  1
....................     
....................     else{
....................         //TODO: assert 1 <= len(val) <= 8
....................         spi_write_from(_REG_SYNC_VALUE1,wrd+1,len);
1EBA:  MOVLW  01
1EBC:  ADDWF  xBA,W
1EBE:  MOVWF  xBD
1EC0:  MOVLW  00
1EC2:  ADDWFC xBB,W
1EC4:  MOVWF  xBE
1EC6:  MOVLW  2F
1EC8:  MOVLB  2
1ECA:  MOVWF  x22
1ECC:  MOVFF  1BE,224
1ED0:  MOVFF  1BD,223
1ED4:  MOVFF  1BC,225
1ED8:  MOVLB  0
1EDA:  RCALL  1B4C
....................         //Sync_size: len(SYNC_WORD) - 1
....................         set(len-1,sync_size);
1EDC:  MOVLW  01
1EDE:  MOVLB  1
1EE0:  SUBWF  xBC,W
1EE2:  MOVWF  xBD
1EE4:  MOVWF  xDF
1EE6:  MOVFF  DC,1E2
1EEA:  MOVFF  DB,1E1
1EEE:  MOVFF  DA,1E0
1EF2:  MOVLB  0
1EF4:  RCALL  1E54
....................         set(1,sync_on);
1EF6:  MOVLW  01
1EF8:  MOVLB  1
1EFA:  MOVWF  xDF
1EFC:  MOVFF  D9,1E2
1F00:  MOVFF  D8,1E1
1F04:  MOVFF  D7,1E0
1F08:  MOVLB  0
1F0A:  RCALL  1E54
....................     }
1F0C:  GOTO   272C (RETURN)
.................... }
.................... uint16_t preamble_length_get(){
....................     // The length of the preamble for sent and received packets, an unsigned 16-bit value.
....................     // Received packets must match this length or they are ignored! Set to 4 to match the
....................     // RadioHead RFM69 library.
....................     uint8_t msb = spi_read_u8(_REG_PREAMBLE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_PREAMBLE_LSB);
....................     return ((msb << 8) | lsb) & 0xFFFF;
.................... }
.................... void preamble_length_set(uint16_t val){
....................     spi_write_u8(_REG_PREAMBLE_MSB, (val >> 8) & 0xFF);
1F10:  MOVLB  1
1F12:  CLRF   xBD
1F14:  CLRF   xBD
1F16:  MOVLW  2C
1F18:  MOVLB  2
1F1A:  MOVWF  x20
1F1C:  MOVFF  1BB,221
1F20:  MOVLB  0
1F22:  RCALL  1B92
....................     spi_write_u8(_REG_PREAMBLE_LSB, val & 0xFF);
1F24:  MOVLB  1
1F26:  CLRF   xBD
1F28:  MOVLW  2D
1F2A:  MOVLB  2
1F2C:  MOVWF  x20
1F2E:  MOVFF  1BA,221
1F32:  MOVLB  0
1F34:  RCALL  1B92
1F36:  GOTO   273A (RETURN)
.................... }
.................... float frequency_mhz_get(){
....................     // """The frequency of the radio in Megahertz. Only the allowed values for your radio must be
....................     // specified (i.e. 433 vs. 915 mhz)!
....................     // """
....................     // # FRF register is computed from the frequency following the datasheet.
....................     // # See section 6.2 and FRF register description.
....................     // # Read bytes of FRF register and assemble into a 24-bit unsigned value.
....................     uint8_t msb = spi_read_u8(_REG_FRF_MSB);
....................     uint8_t mid = spi_read_u8(_REG_FRF_MID);
....................     uint8_t lsb = spi_read_u8(_REG_FRF_LSB);
....................     uint32_t frf = ((msb << 16) | (mid << 8) | lsb) & 0xFFFFFF;
....................     float frequency = (frf * _FSTEP) / 1000000.0;
....................     return frequency;
.................... }
.................... //WARNING: No funciona en micros porque requiere de enteros de 32 bits    
.................... void frequency_mhz_set(){
....................     //FRF = int((freq/_FSTEP)*1,000,000) & 0xFFFFFF
....................     uint8_t msb,lsb,mid;
....................     #ifdef FREQ_433
....................     msb = 0x6C;
1F3A:  MOVLW  6C
1F3C:  MOVLB  1
1F3E:  MOVWF  xBA
....................     mid = 0x40;
1F40:  MOVLW  40
1F42:  MOVWF  xBC
....................     lsb = 0x00;
1F44:  CLRF   xBB
....................     #endif
....................     //TODO: aadir soporte para otras frecuencias
....................     
....................     //TODO: assert 290 <= val <= 1020
....................     // Calculate FRF register 24-bit value using section 6.2 of the datasheet.
....................     // unsigned long frf = int((val/_FSTEP)* 1000000.0) ;
....................     // Serial.print("FRF: ");
....................     // Serial.println(frf);
....................     
....................     // frf &=  0xFFFFFF;
....................     // // Extract byte values and update registers.
....................     // uint8_t msb = frf >> 16;
....................     // uint8_t mid = (frf >> 8) & 0xFF;
....................     // uint8_t lsb = frf & 0xFF;
....................     spi_write_u8(_REG_FRF_MSB, msb);
1F46:  MOVLW  07
1F48:  MOVLB  2
1F4A:  MOVWF  x20
1F4C:  MOVFF  1BA,221
1F50:  MOVLB  0
1F52:  RCALL  1B92
....................     spi_write_u8(_REG_FRF_MID, mid);
1F54:  MOVLW  08
1F56:  MOVLB  2
1F58:  MOVWF  x20
1F5A:  MOVFF  1BC,221
1F5E:  MOVLB  0
1F60:  RCALL  1B92
....................     spi_write_u8(_REG_FRF_LSB, lsb);
1F62:  MOVLW  09
1F64:  MOVLB  2
1F66:  MOVWF  x20
1F68:  MOVFF  1BB,221
1F6C:  MOVLB  0
1F6E:  RCALL  1B92
1F70:  GOTO   273E (RETURN)
.................... }
.................... uint8_t* encryption_key_get(){
....................     // """The AES encryption key used to encrypt and decrypt packets by the chip. This can be set
....................     // to None to disable encryption (the default), otherwise it must be a 16 byte long byte
....................     // string which defines the key (both the transmitter and receiver must use the same key
....................     // value).
....................     // """
....................     // # Handle if encryption is disabled.
....................     if(get(aes_on)==0)return NULL;
....................     spi_read_into(_REG_AES_KEY1,encryption_key,16);
....................     return encryption_key;
.................... }
.................... void encryption_key_set(uint8_t* val){
....................     if (val==0)set(0,aes_on);
....................     else{
....................         // Set the encryption key and enable encryption.
....................         //TODO: assert len(val) == 16
....................         spi_write_from(_REG_AES_KEY1,val,16);
....................         set(1,aes_on);
....................     }
.................... }
.................... int8_t tx_power_get(){
....................     // The transmit power in dBm. Can be set to a value from -2 to 20 for high power devices
....................     // (RFM69HCW, high_power=True) or -18 to 13 for low power devices. Only integer power
....................     // levels are actually set (i.e. 12.5 will result in a value of 12 dBm).
....................     // """
....................     // # Follow table 10 truth table from the datasheet for determining power
....................     // # level from the individual PA level bits and output power register.
....................     uint8_t pa0 = get(pa_0_on);
....................     uint8_t pa1 = get(pa_1_on);
....................     uint8_t pa2 = get(pa_2_on);
....................     uint8_t current_output_power = get(output_power);
....................     if (pa0 &&  !pa1 &&  !pa2)
....................         //# -18 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && !pa2)
....................         //# -2 to 13 dBm range
....................         return -18 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && !high_power)
....................         //# 2 to 17 dBm range
....................         return -14 + current_output_power;
....................     if (!pa0 && pa1 && pa2 && high_power)
....................         //# 5 to 20 dBm range
....................         return -11 + current_output_power;
....................     print((char*)"Tx power power amps state unknown!",2);
....................     while (1){
....................     usb_task();
....................     }
....................     //exit(-3);
.................... }
.................... void tx_power_set(int8_t val){
*
24CA:  MOVLB  1
24CC:  CLRF   xBB
24CE:  CLRF   xBC
24D0:  CLRF   xBD
24D2:  CLRF   xBE
....................     // Determine power amplifier and output power values depending on
....................     // high power state and requested power.
....................     uint8_t _pa_0_on = 0;
....................     uint8_t _pa_1_on = 0;
....................     uint8_t _pa_2_on = 0;
....................     uint8_t _output_power = 0;
....................     if (high_power){
24D4:  MOVLB  0
24D6:  BTFSS  xB5.1
24D8:  BRA    2520
....................         // Handle high power mode.
....................         //TODO: assert -2 <= val <= 20
....................         _pa_1_on = 1;
24DA:  MOVLW  01
24DC:  MOVLB  1
24DE:  MOVWF  xBC
....................         if (val <= 13)
24E0:  BTFSC  xBA.7
24E2:  BRA    24EA
24E4:  MOVF   xBA,W
24E6:  SUBLW  0D
24E8:  BNC   24F2
....................             _output_power = val + 18;
24EA:  MOVLW  12
24EC:  ADDWF  xBA,W
24EE:  MOVWF  xBE
24F0:  BRA    251C
....................         else if (13 < val && val <= 17){
24F2:  BTFSC  xBA.7
24F4:  BRA    2512
24F6:  MOVF   xBA,W
24F8:  SUBLW  0D
24FA:  BC    2512
24FC:  BTFSC  xBA.7
24FE:  BRA    2506
2500:  MOVF   xBA,W
2502:  SUBLW  11
2504:  BNC   2512
....................             _pa_2_on = 1;
2506:  MOVLW  01
2508:  MOVWF  xBD
....................             _output_power = val + 14;
250A:  MOVLW  0E
250C:  ADDWF  xBA,W
250E:  MOVWF  xBE
....................             }
2510:  BRA    251C
....................         else{
....................             //  # power >= 18 dBm
....................             //# Note this also needs PA boost enabled separately!
....................             _pa_2_on = 1;
2512:  MOVLW  01
2514:  MOVWF  xBD
....................             _output_power = val + 11;
2516:  MOVLW  0B
2518:  ADDWF  xBA,W
251A:  MOVWF  xBE
....................             }
....................     }
251C:  BRA    252C
251E:  MOVLB  0
....................     else{
....................         //Handle non-high power mode.
....................         //TODO: assert -18 <= val <= 13
....................         // Enable only power amplifier 0 and set output power.
....................         _pa_0_on = 1;
2520:  MOVLW  01
2522:  MOVLB  1
2524:  MOVWF  xBB
....................         _output_power = (val+ 18);
2526:  MOVLW  12
2528:  ADDWF  xBA,W
252A:  MOVWF  xBE
....................     }
....................     //# Set power amplifiers and output power as computed above.
....................     set(_pa_0_on,pa_0_on);
252C:  MOVFF  1BB,1DF
2530:  MOVFF  E2,1E2
2534:  MOVFF  E1,1E1
2538:  MOVFF  E0,1E0
253C:  MOVLB  0
253E:  RCALL  1E54
....................     set(_pa_1_on,pa_1_on);
2540:  MOVFF  1BC,1DF
2544:  MOVFF  E5,1E2
2548:  MOVFF  E4,1E1
254C:  MOVFF  E3,1E0
2550:  RCALL  1E54
....................     set(_pa_2_on,pa_2_on);
2552:  MOVFF  1BD,1DF
2556:  MOVFF  E8,1E2
255A:  MOVFF  E7,1E1
255E:  MOVFF  E6,1E0
2562:  RCALL  1E54
....................     set(_output_power,output_power);
2564:  MOVFF  1BE,1DF
2568:  MOVFF  EB,1E2
256C:  MOVFF  EA,1E1
2570:  MOVFF  E9,1E0
2574:  RCALL  1E54
....................     _tx_power = val;
2576:  MOVFF  1BA,122
257A:  GOTO   286C (RETURN)
.................... }
.................... float rssi_get(){
....................     // ""The received strength indicator (in dBm).
....................     // May be inaccuate if not read immediatey. last_rssi contains the value read immediately
....................     // receipt of the last packet.
....................     // """
....................     // # Read RSSI register and convert to value using formula in datasheet.
....................     rssi = -spi_read_u8(_REG_RSSI_VALUE) / 2.0;
*
2C8E:  MOVLW  24
2C90:  MOVLB  2
2C92:  MOVWF  x24
2C94:  MOVLB  0
2C96:  CALL   16A8
2C9A:  MOVLW  00
2C9C:  BSF    FD8.0
2C9E:  SUBFWB 01,W
2CA0:  MOVLB  1
2CA2:  CLRF   xE4
2CA4:  MOVWF  xE3
2CA6:  MOVLB  0
2CA8:  RCALL  2A30
2CAA:  MOVFF  03,1C5
2CAE:  MOVFF  02,1C4
2CB2:  MOVFF  01,1C3
2CB6:  MOVFF  00,1C2
2CBA:  MOVLB  1
2CBC:  CLRF   xC9
2CBE:  CLRF   xC8
2CC0:  CLRF   xC7
2CC2:  MOVLW  80
2CC4:  MOVWF  xC6
2CC6:  MOVLB  0
2CC8:  CALL   1F74
2CCC:  MOVFF  03,133
2CD0:  MOVFF  02,132
2CD4:  MOVFF  01,131
2CD8:  MOVFF  00,130
....................     return rssi;
2CDC:  MOVFF  130,00
2CE0:  MOVFF  131,01
2CE4:  MOVFF  132,02
2CE8:  MOVFF  133,03
2CEC:  GOTO   3636 (RETURN)
.................... }
.................... float bitrate_get(){
....................     //         """The modulation bitrate in bits/second (or chip rate if Manchester encoding is enabled).
....................     // Can be a value from ~489 to 32mbit/s, but see the datasheet for the exact supported
....................     // values.
....................     // """
....................     uint8_t msb = spi_read_u8(_REG_BITRATE_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_BITRATE_LSB);
....................     bitrate = _FXOSC / ((msb << 8) | lsb);
....................     return bitrate;
.................... }
.................... void bitrate_set(float val){
*
2386:  MOVLB  1
2388:  CLRF   xC5
238A:  MOVLW  24
238C:  MOVWF  xC4
238E:  MOVLW  74
2390:  MOVWF  xC3
2392:  MOVLW  97
2394:  MOVWF  xC2
2396:  MOVFF  1BD,1C9
239A:  MOVFF  1BC,1C8
239E:  MOVFF  1BB,1C7
23A2:  MOVFF  1BA,1C6
23A6:  MOVLB  0
23A8:  RCALL  1F74
23AA:  MOVFF  03,1C5
23AE:  MOVFF  02,1C4
23B2:  MOVFF  01,1C3
23B6:  MOVFF  00,1C2
23BA:  BCF    FD8.1
23BC:  MOVFF  03,1E8
23C0:  MOVFF  02,1E7
23C4:  MOVFF  01,1E6
23C8:  MOVFF  00,1E5
23CC:  MOVLB  1
23CE:  CLRF   xEC
23D0:  CLRF   xEB
23D2:  CLRF   xEA
23D4:  MOVLW  7E
23D6:  MOVWF  xE9
23D8:  MOVLB  0
23DA:  RCALL  20D2
23DC:  MOVFF  03,1C5
23E0:  MOVFF  02,1C4
23E4:  MOVFF  01,1C3
23E8:  MOVFF  00,1C2
23EC:  RCALL  234A
23EE:  MOVFF  01,1BE
23F2:  MOVLB  1
23F4:  CLRF   xBF
23F6:  CLRF   xC0
23F8:  CLRF   xC1
....................     //TODO: assert (_FXOSC / 65535) <= val <= 32000000.0
....................     //# Round up to the next closest bit-rate value with addition of 0.5.
....................     uint32_t _bitrate = (int)((_FXOSC/val)+0.5) & 0xFFF;
....................     spi_write_u8(_REG_BITRATE_MSB, _bitrate >> 8);
23FA:  CLRF   xC6
23FC:  MOVLW  03
23FE:  MOVLB  2
2400:  MOVWF  x20
2402:  MOVFF  1BF,221
2406:  MOVLB  0
2408:  CALL   1B92
....................     spi_write_u8(_REG_BITRATE_LSB, _bitrate & 0xFF);
240C:  MOVLB  1
240E:  CLRF   xC3
2410:  CLRF   xC4
2412:  CLRF   xC5
2414:  MOVLW  04
2416:  MOVLB  2
2418:  MOVWF  x20
241A:  MOVFF  1BE,221
241E:  MOVLB  0
2420:  CALL   1B92
2424:  GOTO   277E (RETURN)
.................... }
.................... float frequency_deviation_get(){
....................     //"""The frequency deviation in Hertz."""
....................     uint8_t msb = spi_read_u8(_REG_FDEV_MSB);
....................     uint8_t lsb = spi_read_u8(_REG_FDEV_LSB);
....................     frequency_deviation = _FSTEP * ((msb << 8) | lsb);
....................     return frequency_deviation;
.................... }
.................... void frequency_deviation_set(float val){
2428:  MOVFF  1BD,1C5
242C:  MOVFF  1BC,1C4
2430:  MOVFF  1BB,1C3
2434:  MOVFF  1BA,1C2
2438:  MOVLB  1
243A:  CLRF   xC9
243C:  MOVLW  24
243E:  MOVWF  xC8
2440:  MOVLW  74
2442:  MOVWF  xC7
2444:  MOVLW  84
2446:  MOVWF  xC6
2448:  MOVLB  0
244A:  RCALL  1F74
244C:  MOVFF  03,1C5
2450:  MOVFF  02,1C4
2454:  MOVFF  01,1C3
2458:  MOVFF  00,1C2
245C:  BCF    FD8.1
245E:  MOVFF  03,1E8
2462:  MOVFF  02,1E7
2466:  MOVFF  01,1E6
246A:  MOVFF  00,1E5
246E:  MOVLB  1
2470:  CLRF   xEC
2472:  CLRF   xEB
2474:  CLRF   xEA
2476:  MOVLW  7E
2478:  MOVWF  xE9
247A:  MOVLB  0
247C:  RCALL  20D2
247E:  MOVFF  03,1C5
2482:  MOVFF  02,1C4
2486:  MOVFF  01,1C3
248A:  MOVFF  00,1C2
248E:  RCALL  234A
2490:  MOVFF  01,1BE
2494:  MOVLB  1
2496:  CLRF   xBF
2498:  CLRF   xC0
249A:  CLRF   xC1
....................     //TODO: assert 0 <= val <= (_FSTEP * 16383)  # fdev is a 14-bit unsigned value
....................     // # Round up to the next closest integer value with addition of 0.5.
....................     uint32_t fdev = (int)((val / _FSTEP) + 0.5) & 0x3FFF;
....................     spi_write_u8(_REG_FDEV_MSB, fdev >> 8);
249C:  CLRF   xC6
249E:  MOVLW  05
24A0:  MOVLB  2
24A2:  MOVWF  x20
24A4:  MOVFF  1BF,221
24A8:  MOVLB  0
24AA:  CALL   1B92
....................     spi_write_u8(_REG_FDEV_LSB, fdev & 0xFF);
24AE:  MOVLB  1
24B0:  CLRF   xC3
24B2:  CLRF   xC4
24B4:  CLRF   xC5
24B6:  MOVLW  06
24B8:  MOVLB  2
24BA:  MOVWF  x20
24BC:  MOVFF  1BE,221
24C0:  MOVLB  0
24C2:  CALL   1B92
24C6:  GOTO   2792 (RETURN)
.................... }
.................... bool packet_sent(){
....................     //Transmit status
....................     return (spi_read_u8(_REG_IRQ_FLAGS2) & 0x8) >> 3;
*
3244:  MOVLW  28
3246:  MOVLB  2
3248:  MOVWF  x24
324A:  MOVLB  0
324C:  CALL   16A8
3250:  MOVF   01,W
3252:  ANDLW  08
3254:  MOVWF  00
3256:  RRCF   00,F
3258:  RRCF   00,F
325A:  RRCF   00,F
325C:  MOVLW  1F
325E:  ANDWF  00,F
3260:  MOVFF  00,01
3264:  GOTO   341C (RETURN)
.................... }
.................... bool payload_ready(){
*
2C64:  MOVLW  28
2C66:  MOVLB  2
2C68:  MOVWF  x24
2C6A:  MOVLB  0
2C6C:  CALL   16A8
2C70:  MOVFF  01,1B9
....................             // """Receive status"""
....................     uint8_t p = spi_read_u8(_REG_IRQ_FLAGS2);
....................     //Serial.println(p,BIN);
....................     return (p & 0x4) >> 2;
2C74:  MOVLB  1
2C76:  MOVF   xB9,W
2C78:  ANDLW  04
2C7A:  MOVWF  00
2C7C:  RRCF   00,F
2C7E:  RRCF   00,F
2C80:  MOVLW  3F
2C82:  ANDWF  00,F
2C84:  MOVFF  00,01
2C88:  MOVLB  0
2C8A:  GOTO   3568 (RETURN)
.................... }
.................... bool send(uint8_t* data,uint8_t len, bool keep_listening = false, uint16_t _destination=256, uint16_t _node=256,uint16_t _identifier= 256, uint16_t _flags = 256){
....................     // """Send a string of data using the transmitter.
....................     // You can only send 60 bytes at a time
....................     // (limited by chip's FIFO size and appended headers).
....................     // This appends a 4 byte header to be compatible with the RadioHead library.
....................     // The header defaults to using the initialized attributes:
....................     // (destination,node,identifier,flags)
....................     // It may be temporarily overidden via the kwargs - destination,node,identifier,flags.
....................     // Values passed via kwargs do not alter the attribute settings.
....................     // The keep_listening argument should be set to True if you want to start listening
....................     // automatically after the packet is sent. The default setting is False.
....................     // Returns: True if success or False if the send timed out.
....................     // """
....................     // # Disable pylint warning to not use length as a check for zero.
....................     // # This is a puzzling warning as the below code is clearly the most
....................     // # efficient and proper way to ensure a precondition that the provided
....................     // # buffer be within an expected range of bounds.  Disable this check.
....................     // # pylint: disable=len-as-condition
....................     // TODO: assert 0 < len(data) <= 60
....................     // # pylint: enable=len-as-condition
....................     idle(); //# Stop receiving to clear FIFO and keep it clear.
*
3268:  CALL   1E3E
....................     // # Fill the FIFO with a packet to send.
....................     // # Combine header and data to form payload
....................     uint32_t i=0;
....................     char* payload = (char*)malloc(5 + len + 1);
326C:  MOVLB  1
326E:  CLRF   xCD
3270:  CLRF   xCC
3272:  CLRF   xCB
3274:  CLRF   xCA
3276:  MOVLW  05
3278:  ADDWF  xC0,W
327A:  ADDLW  01
327C:  MOVWF  xDF
327E:  CLRF   xE1
3280:  MOVWF  xE0
3282:  MOVLB  0
3284:  RCALL  2EBC
3286:  MOVFF  02,1CF
328A:  MOVFF  01,1CE
....................     
....................     payload[0] = 4 + len;
328E:  MOVLB  1
3290:  MOVFF  1CE,FE9
3294:  MOVFF  1CF,FEA
3298:  MOVLW  04
329A:  ADDWF  xC0,W
329C:  MOVWF  FEF
....................     if (_destination >=256 )  // use attribute
329E:  MOVF   xC3,W
32A0:  SUBLW  00
32A2:  BC    32B6
....................         payload[1] = destination;
32A4:  MOVLW  01
32A6:  ADDWF  xCE,W
32A8:  MOVWF  FE9
32AA:  MOVLW  00
32AC:  ADDWFC xCF,W
32AE:  MOVWF  FEA
32B0:  MOVFF  153,FEF
32B4:  BRA    32C6
....................     else//  # use kwarg
....................         payload[1] = _destination;
32B6:  MOVLW  01
32B8:  ADDWF  xCE,W
32BA:  MOVWF  FE9
32BC:  MOVLW  00
32BE:  ADDWFC xCF,W
32C0:  MOVWF  FEA
32C2:  MOVFF  1C2,FEF
....................     if (_node >= 256) // use attribute
32C6:  MOVF   xC5,W
32C8:  SUBLW  00
32CA:  BC    32DE
....................         payload[2] = node;
32CC:  MOVLW  02
32CE:  ADDWF  xCE,W
32D0:  MOVWF  FE9
32D2:  MOVLW  00
32D4:  ADDWFC xCF,W
32D6:  MOVWF  FEA
32D8:  MOVFF  152,FEF
32DC:  BRA    32EE
....................     else  //# use kwarg
....................         payload[2] = _node;
32DE:  MOVLW  02
32E0:  ADDWF  xCE,W
32E2:  MOVWF  FE9
32E4:  MOVLW  00
32E6:  ADDWFC xCF,W
32E8:  MOVWF  FEA
32EA:  MOVFF  1C4,FEF
....................     if (identifier >=256)  // use attribute
....................         payload[3] = identifier;
....................     else  //# use kwarg
....................         payload[3] = _identifier;
32EE:  MOVLW  03
32F0:  ADDWF  xCE,W
32F2:  MOVWF  FE9
32F4:  MOVLW  00
32F6:  ADDWFC xCF,W
32F8:  MOVWF  FEA
32FA:  MOVFF  1C6,FEF
....................     if (flags >=256)  // use attribute
....................         payload[4] = flags;
....................     else  // use kwarg
....................         payload[4] = _flags;
32FE:  MOVLW  04
3300:  ADDWF  xCE,W
3302:  MOVWF  FE9
3304:  MOVLW  00
3306:  ADDWFC xCF,W
3308:  MOVWF  FEA
330A:  MOVFF  1C8,FEF
....................     for (i=0;i<= len;i++)
330E:  CLRF   xCD
3310:  CLRF   xCC
3312:  CLRF   xCB
3314:  CLRF   xCA
3316:  MOVF   xCD,F
3318:  BNZ   3380
331A:  MOVF   xCC,F
331C:  BNZ   3380
331E:  MOVF   xCB,F
3320:  BNZ   3380
3322:  MOVF   xCA,W
3324:  SUBWF  xC0,W
3326:  BNC   3380
....................         payload[5+i] = data[i];
3328:  MOVLW  05
332A:  ADDWF  xCA,W
332C:  MOVWF  xDF
332E:  MOVLW  00
3330:  ADDWFC xCB,W
3332:  MOVWF  xE0
3334:  MOVLW  00
3336:  ADDWFC xCC,W
3338:  MOVWF  xE1
333A:  MOVLW  00
333C:  ADDWFC xCD,W
333E:  MOVWF  xE2
3340:  MOVF   xCE,W
3342:  ADDWF  xDF,W
3344:  MOVWF  01
3346:  MOVF   xCF,W
3348:  ADDWFC xE0,W
334A:  MOVWF  03
334C:  MOVFF  01,1E3
3350:  MOVWF  xE4
3352:  MOVF   xBE,W
3354:  ADDWF  xCA,W
3356:  MOVWF  FE9
3358:  MOVF   xBF,W
335A:  ADDWFC xCB,W
335C:  MOVWF  FEA
335E:  MOVFF  FEF,1E5
3362:  MOVFF  03,FEA
3366:  MOVFF  01,FE9
336A:  MOVFF  1E5,FEF
336E:  MOVLW  01
3370:  ADDWF  xCA,F
3372:  BTFSC  FD8.0
3374:  INCF   xCB,F
3376:  BTFSC  FD8.2
3378:  INCF   xCC,F
337A:  BTFSC  FD8.2
337C:  INCF   xCD,F
337E:  BRA    3316
....................        
....................     // # Write payload to transmit fifo
....................     spi_write_from(_REG_FIFO, payload,5+len);
3380:  MOVLW  05
3382:  ADDWF  xC0,W
3384:  MOVWF  xDF
3386:  MOVLB  2
3388:  CLRF   x22
338A:  MOVFF  1CF,224
338E:  MOVFF  1CE,223
3392:  MOVWF  x25
3394:  MOVLB  0
3396:  CALL   1B4C
....................     print((char*)"Payload: ",2);
339A:  MOVLW  01
339C:  MOVWF  FEA
339E:  MOVLW  D0
33A0:  MOVWF  FE9
33A2:  MOVLW  0A
33A4:  MOVWF  01
33A6:  CLRF   FF7
33A8:  MOVLW  00
33AA:  CALL   0354
33AE:  TBLRD*-
33B0:  TBLRD*+
33B2:  MOVFF  FF5,FEE
33B6:  DECFSZ 01,F
33B8:  BRA    33B0
33BA:  MOVLW  01
33BC:  MOVLB  2
33BE:  MOVWF  x25
33C0:  MOVLW  D0
33C2:  MOVWF  x24
33C4:  MOVLW  02
33C6:  MOVWF  x26
33C8:  MOVLB  0
33CA:  CALL   1B3C
....................     println(payload+5,2);
33CE:  MOVLW  05
33D0:  MOVLB  1
33D2:  ADDWF  xCE,W
33D4:  MOVWF  xDF
33D6:  MOVLW  00
33D8:  ADDWFC xCF,W
33DA:  MOVWF  xE0
33DC:  MOVFF  FE8,225
33E0:  MOVFF  1DF,224
33E4:  MOVLW  02
33E6:  MOVLB  2
33E8:  MOVWF  x26
33EA:  MOVLB  0
33EC:  CALL   1AE2
....................     // Serial.println((char)spi_read_u8(_REG_FIFO));              
.................... 
....................     free(payload);
33F0:  MOVFF  1CF,1E0
33F4:  MOVFF  1CE,1DF
33F8:  RCALL  3198
....................     // # Turn on transmit mode to send out the packet.       
....................     transmit();
33FA:  BRA    3212
....................    
....................     // # Wait for packet sent interrupt with explicit polling (not ideal but
....................     // # best that can be done right now without interrupts).
....................     
....................     float start = timeSec();
....................     bool timed_out = false;
33FC:  CALL   2B5C
3400:  MOVFF  03,1DD
3404:  MOVFF  02,1DC
3408:  MOVFF  01,1DB
340C:  MOVFF  00,1DA
3410:  MOVLB  1
3412:  BCF    xDE.0
....................     while (!timed_out && !packet_sent()){
3414:  BTFSC  xDE.0
3416:  BRA    34B4
3418:  MOVLB  0
341A:  BRA    3244
341C:  MOVF   01,F
341E:  BTFSC  FD8.2
3420:  BRA    3426
3422:  MOVLB  1
3424:  BRA    34B4
....................     usb_task();
3426:  CALL   159A
....................         if ((timeSec() - start) >= xmit_timeout)
342A:  CALL   2B5C
342E:  MOVFF  03,1E2
3432:  MOVFF  02,1E1
3436:  MOVFF  01,1E0
343A:  MOVFF  00,1DF
343E:  MOVFF  FEA,1E4
3442:  MOVFF  FE9,1E3
3446:  BSF    FD8.1
3448:  MOVFF  03,1E8
344C:  MOVFF  02,1E7
3450:  MOVFF  01,1E6
3454:  MOVFF  00,1E5
3458:  MOVFF  1DD,1EC
345C:  MOVFF  1DC,1EB
3460:  MOVFF  1DB,1EA
3464:  MOVFF  1DA,1E9
3468:  CALL   20D2
346C:  MOVFF  1E4,FEA
3470:  MOVFF  1E3,FE9
3474:  MOVFF  03,1E2
3478:  MOVFF  02,1E1
347C:  MOVFF  01,1E0
3480:  MOVFF  00,1DF
3484:  MOVFF  143,1E8
3488:  MOVFF  142,1E7
348C:  MOVFF  141,1E6
3490:  MOVFF  140,1E5
3494:  MOVFF  03,1EC
3498:  MOVFF  02,1EB
349C:  MOVFF  01,1EA
34A0:  MOVFF  00,1E9
34A4:  CALL   2984
34A8:  BC    34AC
34AA:  BNZ   34B0
....................             timed_out = true;
34AC:  MOVLB  1
34AE:  BSF    xDE.0
34B0:  MOVLB  1
34B2:  BRA    3414
....................     }
....................     // # Listen again if requested.
....................     if (keep_listening)
34B4:  MOVF   xC1,F
34B6:  BZ    34C2
....................         listen();
34B8:  MOVLB  0
34BA:  CALL   29FE
34BE:  BRA    34C8
34C0:  MOVLB  1
....................     else  //# Enter idle mode to stop receiving other packets.
....................   
....................         idle();
34C2:  MOVLB  0
34C4:  CALL   1E3E
....................     return !timed_out;
34C8:  MOVLW  00
34CA:  MOVLB  1
34CC:  BTFSS  xDE.0
34CE:  MOVLW  01
34D0:  MOVWF  01
34D2:  MOVLB  0
34D4:  GOTO   385E (RETURN)
.................... }
.................... bool send_with_ack(uint8_t* data,uint8_t len){
....................     // Reliable Datagram mode:
....................     // Send a packet with data and wait for an ACK response.
....................     // The packet header is automatically generated.
....................     // If enabled, the packet transmission will be retried on failure
....................     int retries_remaining = 0;
....................     bool got_ack = false;
....................     uint8_t* ack_packet;
....................     if (ack_retries)retries_remaining = ack_retries;
....................     else retries_remaining=1;
....................     sequence_number = (sequence_number+1) & 0xFF;
....................     while (!got_ack && retries_remaining){
....................         identifier = sequence_number;
....................         send(data,len,true);
....................         // Don't look for ACK from Broadcast message
....................         if (destination == _RH_BROADCAST_ADDRESS)got_ack = true;
....................         else{
....................             ack_packet = receive(true,false,ack_wait,true);
....................             if(ack_packet != NULL){
....................                 if (ack_packet[4] & _RH_FLAGS_ACK){
....................                     //Check id:
....................                     if (ack_packet[3] == identifier){
....................                         got_ack = true;
....................                         break;
....................                     }
....................                 }
....................             }
....................             
....................         }
....................         //# pause before next retry -- random delay
....................         if (!got_ack){
....................             sleep_ms(ack_wait * (1.5));
....................         }
....................         retries_remaining -= 1;
....................         //# set retry flag in packet header
....................         flags |= _RH_FLAGS_RETRY;
....................     }
....................     flags = 0;  //# clear flags
....................     return got_ack;
.................... }
.................... //IMPORTANTE: La funcion es igual a la de adafruit, excepto porque retorna un array donde el primer valor es la longitud del array
.................... char* receive(bool keep_listening=true,bool with_ack = false, float timeout = 0,bool with_header = false){
34D8:  MOVLB  1
34DA:  BCF    x98.0
34DC:  CLRF   x99
34DE:  CLRF   x9A
34E0:  CLRF   x9C
34E2:  CLRF   x9B
34E4:  CLRF   x9F
34E6:  CLRF   x9E
....................     // Wait to receive a packet from the receiver. If a packet is found the payload bytes
....................     // are returned, otherwise None is returned (which indicates the timeout elapsed with no
....................     // reception).
....................     // If keep_listening is True (the default) the chip will immediately enter listening mode
....................     // after reception of a packet, otherwise it will fall back to idle mode and ignore any
....................     // future reception.
....................     // All packets must have a 4 byte header for compatibilty with the
....................     // RadioHead library.
....................     // The header consists of 4 bytes (To,From,ID,Flags). The default setting will  strip
....................     // the header before returning the packet to the caller.
....................     // If with_header is True then the 4 byte header will be returned with the packet.
....................     // The payload then begins at packet[4].
....................     // If with_ack is True, send an ACK after receipt (Reliable Datagram mode)
....................     // """
....................     bool timed_out = false;
....................     int start = 0;
....................     int i=0;
....................     uint16_t n=0;
....................     uint8_t fifo_length;
....................     char* packet= NULL;
....................     char fifo_len_str [4];
....................     if (timeout == 0)timeout = receive_timeout;
34E8:  MOVFF  196,1E8
34EC:  MOVFF  195,1E7
34F0:  MOVFF  194,1E6
34F4:  MOVFF  193,1E5
34F8:  CLRF   xEC
34FA:  CLRF   xEB
34FC:  CLRF   xEA
34FE:  CLRF   xE9
3500:  MOVLB  0
3502:  CALL   2984
3506:  BNZ   3518
3508:  MOVFF  13F,196
350C:  MOVFF  13E,195
3510:  MOVFF  13D,194
3514:  MOVFF  13C,193
....................     if (timeout!=0){
3518:  MOVFF  196,1E8
351C:  MOVFF  195,1E7
3520:  MOVFF  194,1E6
3524:  MOVFF  193,1E5
3528:  MOVLB  1
352A:  CLRF   xEC
352C:  CLRF   xEB
352E:  CLRF   xEA
3530:  CLRF   xE9
3532:  MOVLB  0
3534:  CALL   2984
3538:  BTFSC  FD8.2
353A:  BRA    362E
....................         //readAllRegs();
....................         //while(1){}
....................         listen();
353C:  CALL   29FE
....................         start = timeSec();
3540:  CALL   2B5C
3544:  MOVFF  03,1C5
3548:  MOVFF  02,1C4
354C:  MOVFF  01,1C3
3550:  MOVFF  00,1C2
3554:  CALL   234A
3558:  MOVFF  01,199
....................         while (!timed_out && !payload_ready()){
355C:  MOVLB  1
355E:  BTFSC  x98.0
3560:  BRA    3630
3562:  MOVLB  0
3564:  GOTO   2C64
3568:  MOVF   01,F
356A:  BTFSC  FD8.2
356C:  BRA    3572
356E:  MOVLB  1
3570:  BRA    3630
....................         usb_task();
3572:  CALL   159A
....................         delay_ms(100);
3576:  MOVLW  64
3578:  MOVLB  2
357A:  MOVWF  x20
357C:  MOVLB  0
357E:  CALL   15DE
....................         n+=100;
3582:  MOVLW  64
3584:  MOVLB  1
3586:  ADDWF  x9B,F
3588:  MOVLW  00
358A:  ADDWFC x9C,F
....................             //delay(20);
....................             if (n >= (1000*xmit_timeout)){
358C:  CLRF   xEA
358E:  CLRF   xE9
3590:  MOVLW  7A
3592:  MOVWF  xE8
3594:  MOVLW  88
3596:  MOVWF  xE7
3598:  MOVFF  143,1EE
359C:  MOVFF  142,1ED
35A0:  MOVFF  141,1EC
35A4:  MOVFF  140,1EB
35A8:  MOVLB  0
35AA:  CALL   2A66
35AE:  MOVFF  03,1BC
35B2:  MOVFF  02,1BB
35B6:  MOVFF  01,1BA
35BA:  MOVFF  00,1B9
35BE:  MOVFF  19C,1E4
35C2:  MOVFF  19B,1E3
35C6:  CALL   2A30
35CA:  MOVFF  1BC,1E8
35CE:  MOVFF  1BB,1E7
35D2:  MOVFF  1BA,1E6
35D6:  MOVFF  1B9,1E5
35DA:  MOVFF  03,1EC
35DE:  MOVFF  02,1EB
35E2:  MOVFF  01,1EA
35E6:  MOVFF  00,1E9
35EA:  CALL   2984
35EE:  BC    35F2
35F0:  BNZ   362C
....................                 println((char*)"Timed out",2);
35F2:  MOVLW  01
35F4:  MOVWF  FEA
35F6:  MOVLW  A4
35F8:  MOVWF  FE9
35FA:  MOVLW  0A
35FC:  MOVWF  01
35FE:  CLRF   FF7
3600:  MOVLW  00
3602:  CALL   036E
3606:  TBLRD*-
3608:  TBLRD*+
360A:  MOVFF  FF5,FEE
360E:  DECFSZ 01,F
3610:  BRA    3608
3612:  MOVLW  01
3614:  MOVLB  2
3616:  MOVWF  x25
3618:  MOVLW  A4
361A:  MOVWF  x24
361C:  MOVLW  02
361E:  MOVWF  x26
3620:  MOVLB  0
3622:  CALL   1AE2
....................                 timed_out = true;
3626:  MOVLB  1
3628:  BSF    x98.0
362A:  MOVLB  0
....................                 }
362C:  BRA    355C
362E:  MOVLB  1
....................         }
....................     }
....................    
....................     last_rssi = rssi_get();
3630:  MOVLB  0
3632:  GOTO   2C8E
3636:  MOVFF  03,137
363A:  MOVFF  02,136
363E:  MOVFF  01,135
3642:  MOVFF  00,134
....................     // Enter idle mode to stop receiving other packets.
....................     idle();
3646:  CALL   1E3E
....................      
....................     if (!timed_out){
364A:  MOVLB  1
364C:  BTFSC  x98.0
364E:  BRA    393C
....................         fifo_length = spi_read_u8(_REG_FIFO);
3650:  MOVLB  2
3652:  CLRF   x24
3654:  MOVLB  0
3656:  CALL   16A8
365A:  MOVFF  01,19D
....................         print((char*)"FIFO LEN: ",2);
365E:  MOVLW  01
3660:  MOVWF  FEA
3662:  MOVLW  AE
3664:  MOVWF  FE9
3666:  MOVLW  0B
3668:  MOVWF  01
366A:  CLRF   FF7
366C:  MOVLW  00
366E:  CALL   0388
3672:  TBLRD*-
3674:  TBLRD*+
3676:  MOVFF  FF5,FEE
367A:  DECFSZ 01,F
367C:  BRA    3674
367E:  MOVLW  01
3680:  MOVLB  2
3682:  MOVWF  x25
3684:  MOVLW  AE
3686:  MOVWF  x24
3688:  MOVLW  02
368A:  MOVWF  x26
368C:  MOVLB  0
368E:  CALL   1B3C
....................         sprintf(fifo_len_str,"%d",fifo_length);
3692:  MOVLW  01
3694:  MOVWF  xC7
3696:  MOVLW  A0
3698:  MOVWF  xC6
369A:  MOVFF  19D,1B9
369E:  MOVLW  18
36A0:  MOVLB  1
36A2:  MOVWF  xBA
36A4:  MOVLB  0
36A6:  GOTO   2D1C
....................         println(fifo_len_str,2);
36AA:  MOVLW  01
36AC:  MOVLB  2
36AE:  MOVWF  x25
36B0:  MOVLW  A0
36B2:  MOVWF  x24
36B4:  MOVLW  02
36B6:  MOVWF  x26
36B8:  MOVLB  0
36BA:  CALL   1AE2
....................         //  # Handle if the received packet is too small to include the 4 byte
....................         // # RadioHead header and at least one byte of data --reject this packet and ignore it.
....................         if (fifo_length > 0){
36BE:  MOVLB  1
36C0:  MOVF   x9D,F
36C2:  BZ    371C
....................             packet = (uint8_t*)malloc(fifo_length+2);
36C4:  MOVLW  02
36C6:  ADDWF  x9D,W
36C8:  MOVWF  xB9
36CA:  CLRF   xE1
36CC:  MOVWF  xE0
36CE:  MOVLB  0
36D0:  CALL   2EBC
36D4:  MOVFF  02,19F
36D8:  MOVFF  01,19E
....................             packet[0] = fifo_length;
36DC:  MOVLB  1
36DE:  MOVFF  19E,FE9
36E2:  MOVFF  19F,FEA
36E6:  MOVFF  19D,FEF
....................             packet[fifo_length+1] = '\0';
36EA:  MOVLW  01
36EC:  ADDWF  x9D,W
36EE:  ADDWF  x9E,W
36F0:  MOVWF  FE9
36F2:  MOVLW  00
36F4:  ADDWFC x9F,W
36F6:  MOVWF  FEA
36F8:  CLRF   FEF
....................             spi_read_into(_REG_FIFO,packet+1,fifo_length);
36FA:  MOVLW  01
36FC:  ADDWF  x9E,W
36FE:  MOVWF  xB9
3700:  MOVLW  00
3702:  ADDWFC x9F,W
3704:  MOVWF  xBA
3706:  MOVLB  2
3708:  CLRF   x25
370A:  MOVWF  x27
370C:  MOVFF  1B9,226
3710:  MOVFF  19D,228
3714:  MOVLB  0
3716:  CALL   1656
371A:  MOVLB  1
....................             //print(packet);
....................         }
....................         if (fifo_length < 5){
371C:  MOVF   x9D,W
371E:  SUBLW  04
3720:  BNC   3728
....................             packet = NULL;
3722:  CLRF   x9F
3724:  CLRF   x9E
....................         }
3726:  BRA    393C
....................         else{
....................             if (node != _RH_BROADCAST_ADDRESS && packet[1] != _RH_BROADCAST_ADDRESS && packet[1] != node){
3728:  INCFSZ x52,W
372A:  BRA    372E
372C:  BRA    3766
372E:  MOVLW  01
3730:  ADDWF  x9E,W
3732:  MOVWF  FE9
3734:  MOVLW  00
3736:  ADDWFC x9F,W
3738:  MOVWF  FEA
373A:  INCFSZ FEF,W
373C:  BRA    3740
373E:  BRA    3766
3740:  MOVLW  01
3742:  ADDWF  x9E,W
3744:  MOVWF  FE9
3746:  MOVLW  00
3748:  ADDWFC x9F,W
374A:  MOVWF  FEA
374C:  MOVF   x52,W
374E:  SUBWF  FEF,W
3750:  BZ    3766
....................                 free(packet);
3752:  MOVFF  19F,1E0
3756:  MOVFF  19E,1DF
375A:  MOVLB  0
375C:  RCALL  3198
....................                 packet = NULL;
375E:  MOVLB  1
3760:  CLRF   x9F
3762:  CLRF   x9E
....................             }
3764:  BRA    38E8
....................             //# send ACK unless this was an ACK or a broadcast
....................             else if (with_ack && (packet[4]&_RH_FLAGS_ACK)==0 && packet[1] != _RH_BROADCAST_ADDRESS){
3766:  MOVF   x92,F
3768:  BTFSC  FD8.2
376A:  BRA    38E8
376C:  MOVLW  04
376E:  ADDWF  x9E,W
3770:  MOVWF  FE9
3772:  MOVLW  00
3774:  ADDWFC x9F,W
3776:  MOVWF  FEA
3778:  MOVF   FEF,W
377A:  ANDLW  80
377C:  BTFSS  FD8.2
377E:  BRA    38E8
3780:  MOVLW  01
3782:  ADDWF  x9E,W
3784:  MOVWF  FE9
3786:  MOVLW  00
3788:  ADDWFC x9F,W
378A:  MOVWF  FEA
378C:  INCFSZ FEF,W
378E:  BRA    3792
3790:  BRA    38E8
....................                 if (ack_delay != 0)sleep_ms((int)(ack_delay/1000));
3792:  MOVFF  148,1E8
3796:  MOVFF  147,1E7
379A:  MOVFF  146,1E6
379E:  MOVFF  145,1E5
37A2:  CLRF   xEC
37A4:  CLRF   xEB
37A6:  CLRF   xEA
37A8:  CLRF   xE9
37AA:  MOVLB  0
37AC:  CALL   2984
37B0:  BZ    37F6
37B2:  MOVFF  148,1C5
37B6:  MOVFF  147,1C4
37BA:  MOVFF  146,1C3
37BE:  MOVFF  145,1C2
37C2:  MOVLB  1
37C4:  CLRF   xC9
37C6:  CLRF   xC8
37C8:  MOVLW  7A
37CA:  MOVWF  xC7
37CC:  MOVLW  88
37CE:  MOVWF  xC6
37D0:  MOVLB  0
37D2:  CALL   1F74
37D6:  MOVFF  03,1C5
37DA:  MOVFF  02,1C4
37DE:  MOVFF  01,1C3
37E2:  MOVFF  00,1C2
37E6:  CALL   234A
37EA:  MOVFF  01,1B9
37EE:  MOVFF  01,1BA
37F2:  CALL   1608
....................                 //# send ACK packet to sender (data is b'!')
....................                 send((char*)"!",false,packet[2],packet[1],packet[3],packet[4]|_RH_FLAGS_ACK);
37F6:  MOVLW  21
37F8:  MOVLB  1
37FA:  MOVWF  xAE
37FC:  CLRF   xAF
37FE:  MOVLW  02
3800:  ADDWF  x9E,W
3802:  MOVWF  FE9
3804:  MOVLW  00
3806:  ADDWFC x9F,W
3808:  MOVWF  FEA
380A:  MOVFF  FEF,1C1
380E:  MOVLW  01
3810:  ADDWF  x9E,W
3812:  MOVWF  FE9
3814:  MOVLW  00
3816:  ADDWFC x9F,W
3818:  MOVWF  FEA
381A:  MOVFF  FEF,1C2
381E:  MOVLW  03
3820:  ADDWF  x9E,W
3822:  MOVWF  FE9
3824:  MOVLW  00
3826:  ADDWFC x9F,W
3828:  MOVWF  FEA
382A:  MOVFF  FEF,1C4
382E:  MOVLW  04
3830:  ADDWF  x9E,W
3832:  MOVWF  FE9
3834:  MOVLW  00
3836:  ADDWFC x9F,W
3838:  MOVWF  FEA
383A:  MOVF   FEF,W
383C:  IORLW  80
383E:  MOVWF  xBD
3840:  MOVLW  01
3842:  MOVWF  xBF
3844:  MOVLW  AE
3846:  MOVWF  xBE
3848:  CLRF   xC0
384A:  CLRF   xC3
384C:  CLRF   xC5
384E:  CLRF   xC7
3850:  MOVFF  1BD,1C6
3854:  MOVLW  01
3856:  MOVWF  xC9
3858:  CLRF   xC8
385A:  MOVLB  0
385C:  BRA    3268
....................                 // # reject Retries if we have seen this idetifier from this source before
....................                 if (seen_ids[packet[2]] == packet[3] && packet[4]&_RH_FLAGS_RETRY){
385E:  MOVLW  02
3860:  MOVLB  1
3862:  ADDWF  x9E,W
3864:  MOVWF  FE9
3866:  MOVLW  00
3868:  ADDWFC x9F,W
386A:  MOVWF  FEA
386C:  CLRF   03
386E:  MOVF   FEF,W
3870:  ADDLW  4A
3872:  MOVWF  FE9
3874:  MOVLW  01
3876:  ADDWFC 03,W
3878:  MOVWF  FEA
387A:  MOVFF  FEF,1B9
387E:  MOVLW  03
3880:  ADDWF  x9E,W
3882:  MOVWF  FE9
3884:  MOVLW  00
3886:  ADDWFC x9F,W
3888:  MOVWF  FEA
388A:  MOVF   FEF,W
388C:  SUBWF  xB9,W
388E:  BNZ   38B4
3890:  MOVLW  04
3892:  ADDWF  x9E,W
3894:  MOVWF  FE9
3896:  MOVLW  00
3898:  ADDWFC x9F,W
389A:  MOVWF  FEA
389C:  BTFSS  FEF.6
389E:  BRA    38B4
....................                     free(packet);
38A0:  MOVFF  19F,1E0
38A4:  MOVFF  19E,1DF
38A8:  MOVLB  0
38AA:  RCALL  3198
....................                     packet= NULL;
38AC:  MOVLB  1
38AE:  CLRF   x9F
38B0:  CLRF   x9E
....................                 }
38B2:  BRA    38E8
....................                 else{ //Save identifier from source
....................                     seen_ids[packet[2]] = packet[3];
38B4:  MOVLW  02
38B6:  ADDWF  x9E,W
38B8:  MOVWF  FE9
38BA:  MOVLW  00
38BC:  ADDWFC x9F,W
38BE:  MOVWF  FEA
38C0:  CLRF   03
38C2:  MOVF   FEF,W
38C4:  ADDLW  4A
38C6:  MOVWF  01
38C8:  MOVLW  01
38CA:  ADDWFC 03,F
38CC:  MOVLW  03
38CE:  ADDWF  x9E,W
38D0:  MOVWF  FE9
38D2:  MOVLW  00
38D4:  ADDWFC x9F,W
38D6:  MOVWF  FEA
38D8:  MOVFF  FEF,1BB
38DC:  MOVFF  03,FEA
38E0:  MOVFF  01,FE9
38E4:  MOVFF  1BB,FEF
....................                 }
....................             }
....................             if (!with_header && packet != NULL){
38E8:  MOVF   x97,F
38EA:  BNZ   393C
38EC:  MOVF   x9E,F
38EE:  BNZ   38F4
38F0:  MOVF   x9F,F
38F2:  BZ    393C
....................                  //skip the header if not wanted
....................                  for (i=1; i< fifo_length-4;i++){
38F4:  MOVLW  01
38F6:  MOVWF  x9A
38F8:  MOVLW  04
38FA:  SUBWF  x9D,W
38FC:  SUBWF  x9A,W
38FE:  BC    392E
....................                     packet[i] = packet[i+4];
3900:  MOVF   x9A,W
3902:  ADDWF  x9E,W
3904:  MOVWF  01
3906:  MOVLW  00
3908:  ADDWFC x9F,W
390A:  MOVWF  03
390C:  MOVLW  04
390E:  ADDWF  x9A,W
3910:  ADDWF  x9E,W
3912:  MOVWF  FE9
3914:  MOVLW  00
3916:  ADDWFC x9F,W
3918:  MOVWF  FEA
391A:  MOVFF  FEF,1BB
391E:  MOVFF  03,FEA
3922:  MOVFF  01,FE9
3926:  MOVFF  1BB,FEF
392A:  INCF   x9A,F
392C:  BRA    38F8
....................                  }
....................                  //reduce indicated length
....................                  packet[0] -= 4;
392E:  MOVFF  19E,FE9
3932:  MOVFF  19F,FEA
3936:  MOVLW  04
3938:  SUBWF  FEF,W
393A:  MOVWF  FEF
....................             }
....................         }
....................     }
....................     
....................     if (keep_listening)listen();        
393C:  MOVF   x91,F
393E:  BZ    3948
3940:  MOVLB  0
3942:  CALL   29FE
3946:  BRA    394E
....................     else idle();
3948:  MOVLB  0
394A:  CALL   1E3E
....................     return (char*)packet;
394E:  MOVLB  1
3950:  MOVFF  19E,01
3954:  MOVFF  19F,02
3958:  MOVLB  0
395A:  GOTO   3ED6 (RETURN)
.................... }
.................... 
.................... 
.................... #ZERO_RAM
.................... 
.................... 
.................... //Define la interrupcin por recepcin Serial
.................... static void RDA_isr(void)
.................... {  
*
13F6:  GOTO   147A (RETURN)
....................  
.................... }
.................... 
.................... 
.................... /* TODO: Use usb_cdc_putc() to transmit data to the USB
.................... virtual COM port. Use usb_cdc_kbhit() and usb_cdc_getc() to
.................... receive data from the USB virtual COM port. usb_enumerated()
.................... can be used to see if connected to a host and ready to
.................... communicate. */
.................... 
.................... /*
.................... Conexiones
.................... MOSI: RX (23)
.................... MISO: B0 (00) (SDI)
.................... CLK: B1 (01) (SCK)
.................... CS: A5 (13)
.................... Reset: E0
.................... */
.................... 
.................... void main()
*
398E:  CLRF   FF8
3990:  BCF    FD0.7
3992:  BSF    07.7
3994:  MOVLW  FE
3996:  MOVWF  00
3998:  MOVLW  04
399A:  MOVWF  01
399C:  MOVLW  02
399E:  MOVWF  FE9
39A0:  MOVLW  00
39A2:  MOVWF  FEA
39A4:  CLRF   FEE
39A6:  DECFSZ 00,F
39A8:  BRA    39A4
39AA:  DECFSZ 01,F
39AC:  BRA    39A4
39AE:  MOVLW  DD
39B0:  MOVWF  00
39B2:  MOVLW  03
39B4:  MOVWF  01
39B6:  MOVLW  23
39B8:  MOVWF  FE9
39BA:  MOVLW  05
39BC:  MOVWF  FEA
39BE:  CLRF   FEE
39C0:  DECFSZ 00,F
39C2:  BRA    39BE
39C4:  DECFSZ 01,F
39C6:  BRA    39BE
39C8:  MOVLW  01
39CA:  MOVWF  xBF
39CC:  BCF    FC6.5
39CE:  MOVLW  40
39D0:  MOVWF  FC7
39D2:  MOVLW  22
39D4:  MOVWF  FC6
39D6:  BCF    F94.7
39D8:  BSF    F93.0
39DA:  BSF    F89.5
39DC:  MOVLW  EF
39DE:  MOVWF  F92
39E0:  BCF    F93.1
39E2:  CLRF   xC7
39E4:  CLRF   xC6
39E6:  MOVLW  02
39E8:  MOVLB  1
39EA:  MOVWF  x91
39EC:  MOVLW  05
39EE:  MOVWF  x92
39F0:  MOVLW  02
39F2:  MOVWF  x93
39F4:  MOVLB  0
39F6:  CALL   1482
39FA:  MOVFF  03,CA
39FE:  MOVFF  02,C9
3A02:  MOVFF  01,C8
3A06:  MOVLW  02
3A08:  MOVLB  1
3A0A:  MOVWF  x91
3A0C:  MOVLW  03
3A0E:  MOVWF  x92
3A10:  MOVLW  02
3A12:  MOVWF  x93
3A14:  MOVLB  0
3A16:  CALL   1482
3A1A:  MOVFF  03,CD
3A1E:  MOVFF  02,CC
3A22:  MOVFF  01,CB
3A26:  MOVLW  02
3A28:  MOVLB  1
3A2A:  MOVWF  x91
3A2C:  CLRF   x92
3A2E:  MOVWF  x93
3A30:  MOVLB  0
3A32:  CALL   1482
3A36:  MOVFF  03,D0
3A3A:  MOVFF  02,CF
3A3E:  MOVFF  01,CE
3A42:  MOVLW  4E
3A44:  MOVLB  1
3A46:  MOVWF  x91
3A48:  MOVLW  03
3A4A:  MOVWF  x92
3A4C:  MOVLW  01
3A4E:  MOVWF  x93
3A50:  MOVLB  0
3A52:  CALL   1482
3A56:  MOVFF  03,D3
3A5A:  MOVFF  02,D2
3A5E:  MOVFF  01,D1
3A62:  MOVLW  4E
3A64:  MOVLB  1
3A66:  MOVWF  x91
3A68:  MOVLW  02
3A6A:  MOVWF  x92
3A6C:  MOVLW  01
3A6E:  MOVWF  x93
3A70:  MOVLB  0
3A72:  CALL   1482
3A76:  MOVFF  03,D6
3A7A:  MOVFF  02,D5
3A7E:  MOVFF  01,D4
3A82:  MOVLW  2E
3A84:  MOVLB  1
3A86:  MOVWF  x91
3A88:  MOVLW  07
3A8A:  MOVWF  x92
3A8C:  MOVLW  01
3A8E:  MOVWF  x93
3A90:  MOVLB  0
3A92:  CALL   1482
3A96:  MOVFF  03,D9
3A9A:  MOVFF  02,D8
3A9E:  MOVFF  01,D7
3AA2:  MOVLW  2E
3AA4:  MOVLB  1
3AA6:  MOVWF  x91
3AA8:  MOVLW  03
3AAA:  MOVWF  x92
3AAC:  MOVWF  x93
3AAE:  MOVLB  0
3AB0:  CALL   1482
3AB4:  MOVFF  03,DC
3AB8:  MOVFF  02,DB
3ABC:  MOVFF  01,DA
3AC0:  MOVLW  3D
3AC2:  MOVLB  1
3AC4:  MOVWF  x91
3AC6:  CLRF   x92
3AC8:  MOVLW  01
3ACA:  MOVWF  x93
3ACC:  MOVLB  0
3ACE:  CALL   1482
3AD2:  MOVFF  03,DF
3AD6:  MOVFF  02,DE
3ADA:  MOVFF  01,DD
3ADE:  MOVLW  11
3AE0:  MOVLB  1
3AE2:  MOVWF  x91
3AE4:  MOVLW  07
3AE6:  MOVWF  x92
3AE8:  MOVLW  01
3AEA:  MOVWF  x93
3AEC:  MOVLB  0
3AEE:  CALL   1482
3AF2:  MOVFF  03,E2
3AF6:  MOVFF  02,E1
3AFA:  MOVFF  01,E0
3AFE:  MOVLW  11
3B00:  MOVLB  1
3B02:  MOVWF  x91
3B04:  MOVLW  06
3B06:  MOVWF  x92
3B08:  MOVLW  01
3B0A:  MOVWF  x93
3B0C:  MOVLB  0
3B0E:  CALL   1482
3B12:  MOVFF  03,E5
3B16:  MOVFF  02,E4
3B1A:  MOVFF  01,E3
3B1E:  MOVLW  11
3B20:  MOVLB  1
3B22:  MOVWF  x91
3B24:  MOVLW  05
3B26:  MOVWF  x92
3B28:  MOVLW  01
3B2A:  MOVWF  x93
3B2C:  MOVLB  0
3B2E:  CALL   1482
3B32:  MOVFF  03,E8
3B36:  MOVFF  02,E7
3B3A:  MOVFF  01,E6
3B3E:  MOVLW  11
3B40:  MOVLB  1
3B42:  MOVWF  x91
3B44:  CLRF   x92
3B46:  MOVLW  05
3B48:  MOVWF  x93
3B4A:  MOVLB  0
3B4C:  CALL   1482
3B50:  MOVFF  03,EB
3B54:  MOVFF  02,EA
3B58:  MOVFF  01,E9
3B5C:  MOVLW  19
3B5E:  MOVLB  1
3B60:  MOVWF  x91
3B62:  MOVLW  05
3B64:  MOVWF  x92
3B66:  MOVLW  03
3B68:  MOVWF  x93
3B6A:  MOVLB  0
3B6C:  CALL   1482
3B70:  MOVFF  03,EE
3B74:  MOVFF  02,ED
3B78:  MOVFF  01,EC
3B7C:  MOVLW  19
3B7E:  MOVLB  1
3B80:  MOVWF  x91
3B82:  MOVLW  03
3B84:  MOVWF  x92
3B86:  MOVLW  02
3B88:  MOVWF  x93
3B8A:  MOVLB  0
3B8C:  CALL   1482
3B90:  MOVFF  03,F1
3B94:  MOVFF  02,F0
3B98:  MOVFF  01,EF
3B9C:  MOVLW  19
3B9E:  MOVLB  1
3BA0:  MOVWF  x91
3BA2:  CLRF   x92
3BA4:  MOVLW  03
3BA6:  MOVWF  x93
3BA8:  MOVLB  0
3BAA:  CALL   1482
3BAE:  MOVFF  03,F4
3BB2:  MOVFF  02,F3
3BB6:  MOVFF  01,F2
3BBA:  MOVLW  1A
3BBC:  MOVLB  1
3BBE:  MOVWF  x91
3BC0:  MOVLW  05
3BC2:  MOVWF  x92
3BC4:  MOVLW  03
3BC6:  MOVWF  x93
3BC8:  MOVLB  0
3BCA:  CALL   1482
3BCE:  MOVFF  03,F7
3BD2:  MOVFF  02,F6
3BD6:  MOVFF  01,F5
3BDA:  MOVLW  1A
3BDC:  MOVLB  1
3BDE:  MOVWF  x91
3BE0:  MOVLW  03
3BE2:  MOVWF  x92
3BE4:  MOVLW  02
3BE6:  MOVWF  x93
3BE8:  MOVLB  0
3BEA:  CALL   1482
3BEE:  MOVFF  03,FA
3BF2:  MOVFF  02,F9
3BF6:  MOVFF  01,F8
3BFA:  MOVLW  1A
3BFC:  MOVLB  1
3BFE:  MOVWF  x91
3C00:  CLRF   x92
3C02:  MOVLW  03
3C04:  MOVWF  x93
3C06:  MOVLB  0
3C08:  CALL   1482
3C0C:  MOVFF  03,FD
3C10:  MOVFF  02,FC
3C14:  MOVFF  01,FB
3C18:  MOVLW  37
3C1A:  MOVLB  1
3C1C:  MOVWF  x91
3C1E:  MOVLW  07
3C20:  MOVWF  x92
3C22:  MOVLW  01
3C24:  MOVWF  x93
3C26:  MOVLB  0
3C28:  CALL   1482
3C2C:  MOVFF  03,100
3C30:  MOVFF  02,FF
3C34:  MOVFF  01,FE
3C38:  MOVLW  37
3C3A:  MOVLB  1
3C3C:  MOVWF  x91
3C3E:  MOVLW  05
3C40:  MOVWF  x92
3C42:  MOVLW  02
3C44:  MOVWF  x93
3C46:  MOVLB  0
3C48:  CALL   1482
3C4C:  MOVFF  03,103
3C50:  MOVFF  02,102
3C54:  MOVFF  01,101
3C58:  MOVLW  37
3C5A:  MOVLB  1
3C5C:  MOVWF  x91
3C5E:  MOVLW  04
3C60:  MOVWF  x92
3C62:  MOVLW  01
3C64:  MOVWF  x93
3C66:  MOVLB  0
3C68:  CALL   1482
3C6C:  MOVFF  03,106
3C70:  MOVFF  02,105
3C74:  MOVFF  01,104
3C78:  MOVLW  37
3C7A:  MOVLB  1
3C7C:  MOVWF  x91
3C7E:  MOVLW  03
3C80:  MOVWF  x92
3C82:  MOVLW  01
3C84:  MOVWF  x93
3C86:  MOVLB  0
3C88:  CALL   1482
3C8C:  MOVFF  03,109
3C90:  MOVFF  02,108
3C94:  MOVFF  01,107
3C98:  MOVLW  37
3C9A:  MOVLB  1
3C9C:  MOVWF  x91
3C9E:  MOVLW  01
3CA0:  MOVWF  x92
3CA2:  MOVLW  02
3CA4:  MOVWF  x93
3CA6:  MOVLB  0
3CA8:  CALL   1482
3CAC:  MOVFF  03,10C
3CB0:  MOVFF  02,10B
3CB4:  MOVFF  01,10A
3CB8:  MOVLW  27
3CBA:  MOVLB  1
3CBC:  MOVWF  x91
3CBE:  MOVLW  07
3CC0:  MOVWF  x92
3CC2:  MOVLW  01
3CC4:  MOVWF  x93
3CC6:  MOVLB  0
3CC8:  CALL   1482
3CCC:  MOVFF  03,10F
3CD0:  MOVFF  02,10E
3CD4:  MOVFF  01,10D
3CD8:  MOVLW  25
3CDA:  MOVLB  1
3CDC:  MOVWF  x91
3CDE:  MOVLW  06
3CE0:  MOVWF  x92
3CE2:  MOVLW  02
3CE4:  MOVWF  x93
3CE6:  MOVLB  0
3CE8:  CALL   1482
3CEC:  MOVFF  03,112
3CF0:  MOVFF  02,111
3CF4:  MOVFF  01,110
3CF8:  MOVLW  25
3CFA:  MOVLB  1
3CFC:  MOVWF  x91
3CFE:  MOVLW  04
3D00:  MOVWF  x92
3D02:  MOVLW  02
3D04:  MOVWF  x93
3D06:  MOVLB  0
3D08:  CALL   1482
3D0C:  MOVFF  03,115
3D10:  MOVFF  02,114
3D14:  MOVFF  01,113
3D18:  MOVLW  25
3D1A:  MOVLB  1
3D1C:  MOVWF  x91
3D1E:  MOVLW  02
3D20:  MOVWF  x92
3D22:  MOVWF  x93
3D24:  MOVLB  0
3D26:  CALL   1482
3D2A:  MOVFF  03,118
3D2E:  MOVFF  02,117
3D32:  MOVFF  01,116
3D36:  MOVLW  25
3D38:  MOVLB  1
3D3A:  MOVWF  x91
3D3C:  CLRF   x92
3D3E:  MOVLW  02
3D40:  MOVWF  x93
3D42:  MOVLB  0
3D44:  CALL   1482
3D48:  MOVFF  03,11B
3D4C:  MOVFF  02,11A
3D50:  MOVFF  01,119
3D54:  MOVLW  26
3D56:  MOVLB  1
3D58:  MOVWF  x91
3D5A:  MOVLW  06
3D5C:  MOVWF  x92
3D5E:  MOVLW  02
3D60:  MOVWF  x93
3D62:  MOVLB  0
3D64:  CALL   1482
3D68:  MOVFF  03,11E
3D6C:  MOVFF  02,11D
3D70:  MOVFF  01,11C
3D74:  MOVLW  26
3D76:  MOVLB  1
3D78:  MOVWF  x91
3D7A:  MOVLW  04
3D7C:  MOVWF  x92
3D7E:  MOVLW  02
3D80:  MOVWF  x93
3D82:  MOVLB  0
3D84:  CALL   1482
3D88:  MOVFF  03,121
3D8C:  MOVFF  02,120
3D90:  MOVFF  01,11F
3D94:  MOVF   FC1,W
3D96:  ANDLW  C0
3D98:  IORLW  0F
3D9A:  MOVWF  FC1
3D9C:  MOVLW  07
3D9E:  MOVWF  FB4
3DA0:  MOVLW  02
3DA2:  MOVWF  xC1
3DA4:  MOVLW  70
3DA6:  MOVWF  xC0
3DA8:  MOVLW  01
3DAA:  MOVLB  2
3DAC:  MOVWF  x71
3DAE:  MOVLW  8C
3DB0:  MOVWF  x70
3DB2:  MOVLW  05
3DB4:  MOVWF  x73
3DB6:  MOVLW  23
3DB8:  MOVWF  x72
3DBA:  MOVLW  02
3DBC:  MOVLB  5
3DBE:  MOVWF  x24
3DC0:  MOVLW  D9
3DC2:  MOVWF  x23
3DC4:  CLRF   x26
3DC6:  CLRF   x25
3DC8:  MOVLB  0
3DCA:  CLRF   xB8
3DCC:  CLRF   xB9
*
3DE0:  MOVLW  20
3DE2:  MOVWF  x74
.................... {
.................... 
.................... /*
....................    //Timer de 8 bits
.................... //timer0 (RTCC_INTERNAL), Preescaler de 256, timer de 8 bits
.................... setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256 | RTCC_8_bit); 
.................... //el timer se va a desbordar dependiendo de la formula:
.................... //tiempo_desbordamiento =  (Valor_maximo_del_timer * (4*Preescaler))/Freq
.................... 
.................... //EJEMPLO, 
.................... //para un divisor de 64, reloj de 48 MHZ y tiempo de 1ms
.................... //Dado que el oscilador funciona a 48 Mhz, la formula es:
.................... //t = 256*4*64 / 48000000 = 1.365 ms (aprox. 1ms),
.................... //Para hacerlo mas preciso, es posible inicializar el timer a un valor mayor a 0, por lo que el desbordamiento ocurriria antes:
.................... //con un valor de inicio de 67 (contando el 0, esto es 68 pasos) (256-68 = 180), el valor da 1.0026ms
.................... 
.................... 
.................... set_rtcc(TIMER_START);
.................... //Interrupciones del timer
.................... enable_interrupts(INT_RTCC);
.................... enable_interrupts(GLOBAL);
.................... 
.................... */
....................    //RFM69 radio;
....................    //PRIMER BYTE es el tamao del array 
....................    uint8_t synch[] = {3,0xAA,0x2D,0xD4};
*
3DCE:  MOVLW  03
3DD0:  MOVLB  1
3DD2:  MOVWF  x70
3DD4:  MOVLW  AA
3DD6:  MOVWF  x71
3DD8:  MOVLW  2D
3DDA:  MOVWF  x72
3DDC:  MOVLW  D4
3DDE:  MOVWF  x73
....................    int ResetPin = RF_Reset;
....................    setOutput(INDICATOR_LED,0);
*
3DE4:  MOVLW  04
3DE6:  MOVLB  2
3DE8:  MOVWF  x2A
3DEA:  CLRF   x2B
3DEC:  MOVLB  0
3DEE:  CALL   1502
....................    //radio.init(synch,ResetPin);
....................    
....................    setup_adc_ports(NO_ANALOGS, VSS_VDD);
3DF2:  MOVF   FC1,W
3DF4:  ANDLW  C0
3DF6:  IORLW  0F
3DF8:  MOVWF  FC1
....................    usb_init();
3DFA:  GOTO   15D0
....................    
....................    //Esperar un segundo antes de iniciar
....................    sleep_ms(1000);
3DFE:  MOVLW  E8
3E00:  MOVLB  1
3E02:  MOVWF  xBA
3E04:  MOVLB  0
3E06:  CALL   1608
....................    while (!checkId()){
3E0A:  GOTO   1AAC
3E0E:  MOVF   01,F
3E10:  BNZ   3E4C
....................    usb_task();
3E12:  CALL   159A
....................    println((char*)"Id incorrecto", 2);
3E16:  MOVLW  01
3E18:  MOVWF  FEA
3E1A:  MOVLW  75
3E1C:  MOVWF  FE9
3E1E:  MOVLW  0E
3E20:  MOVWF  01
3E22:  CLRF   FF7
3E24:  MOVLW  00
3E26:  CALL   03A4
3E2A:  TBLRD*-
3E2C:  TBLRD*+
3E2E:  MOVFF  FF5,FEE
3E32:  DECFSZ 01,F
3E34:  BRA    3E2C
3E36:  MOVLW  01
3E38:  MOVLB  2
3E3A:  MOVWF  x25
3E3C:  MOVLW  75
3E3E:  MOVWF  x24
3E40:  MOVLW  02
3E42:  MOVWF  x26
3E44:  MOVLB  0
3E46:  CALL   1AE2
3E4A:  BRA    3E0A
....................    }
....................    setOutput(INDICATOR_LED,1);
3E4C:  MOVLW  04
3E4E:  MOVLB  2
3E50:  MOVWF  x2A
3E52:  MOVLW  01
3E54:  MOVWF  x2B
3E56:  MOVLB  0
3E58:  CALL   1502
....................    
....................    init(synch,ResetPin);
3E5C:  MOVLW  01
3E5E:  MOVLB  1
3E60:  MOVWF  x92
3E62:  MOVLW  70
3E64:  MOVWF  x91
3E66:  MOVFF  174,193
3E6A:  MOVLW  04
3E6C:  MOVWF  x94
3E6E:  MOVLW  01
3E70:  MOVWF  x95
3E72:  CLRF   x99
3E74:  MOVLW  1E
3E76:  MOVWF  x98
3E78:  MOVLW  84
3E7A:  MOVWF  x97
3E7C:  MOVLW  80
3E7E:  MOVWF  x96
3E80:  CLRF   x9B
3E82:  CLRF   x9A
3E84:  MOVLB  0
3E86:  GOTO   257E
....................    println((char*)"INIT DONE", 3);
3E8A:  MOVLW  01
3E8C:  MOVWF  FEA
3E8E:  MOVLW  83
3E90:  MOVWF  FE9
3E92:  MOVLW  0A
3E94:  MOVWF  01
3E96:  CLRF   FF7
3E98:  MOVLW  00
3E9A:  CALL   03C2
3E9E:  TBLRD*-
3EA0:  TBLRD*+
3EA2:  MOVFF  FF5,FEE
3EA6:  DECFSZ 01,F
3EA8:  BRA    3EA0
3EAA:  MOVLW  01
3EAC:  MOVLB  2
3EAE:  MOVWF  x25
3EB0:  MOVLW  83
3EB2:  MOVWF  x24
3EB4:  MOVLW  03
3EB6:  MOVWF  x26
3EB8:  MOVLB  0
3EBA:  CALL   1AE2
.................... //!   readAllRegs();
.................... //!   while(1){}
....................    while(TRUE)
....................    {
....................    char* packet = receive(1,0,0,0);
3EBE:  MOVLW  01
3EC0:  MOVLB  1
3EC2:  MOVWF  x91
3EC4:  CLRF   x92
3EC6:  CLRF   x96
3EC8:  CLRF   x95
3ECA:  CLRF   x94
3ECC:  CLRF   x93
3ECE:  CLRF   x97
3ED0:  MOVLB  0
3ED2:  GOTO   34D8
3ED6:  MOVFF  02,18E
3EDA:  MOVFF  01,18D
....................    if (!(packet == NULL || packet[0] == 0)){
3EDE:  MOVLB  1
3EE0:  MOVF   x8D,F
3EE2:  BNZ   3EE8
3EE4:  MOVF   x8E,F
3EE6:  BZ    3F74
3EE8:  MOVFF  18D,FE9
3EEC:  MOVFF  18E,FEA
3EF0:  MOVF   FEF,F
3EF2:  BZ    3F74
....................     println ((char*)"Packet",2);
3EF4:  MOVLW  01
3EF6:  MOVWF  FEA
3EF8:  MOVLW  83
3EFA:  MOVWF  FE9
3EFC:  MOVLW  07
3EFE:  MOVWF  01
3F00:  CLRF   FF7
3F02:  MOVLW  00
3F04:  MOVLB  0
3F06:  CALL   03DC
3F0A:  TBLRD*-
3F0C:  TBLRD*+
3F0E:  MOVFF  FF5,FEE
3F12:  DECFSZ 01,F
3F14:  BRA    3F0C
3F16:  MOVLW  01
3F18:  MOVLB  2
3F1A:  MOVWF  x25
3F1C:  MOVLW  83
3F1E:  MOVWF  x24
3F20:  MOVLW  02
3F22:  MOVWF  x26
3F24:  MOVLB  0
3F26:  CALL   1AE2
....................     for (uint16_t i=0;i<packet[0]-1;i++){
3F2A:  MOVLB  1
3F2C:  CLRF   x90
3F2E:  CLRF   x8F
3F30:  MOVFF  18D,FE9
3F34:  MOVFF  18E,FEA
3F38:  MOVLW  01
3F3A:  SUBWF  FEF,W
3F3C:  MOVF   x90,F
3F3E:  BNZ   3F72
3F40:  SUBWF  x8F,W
3F42:  BC    3F72
....................       printch(packet[i+1],1);
3F44:  MOVLW  01
3F46:  ADDWF  x8F,W
3F48:  MOVWF  x91
3F4A:  MOVLW  00
3F4C:  ADDWFC x90,W
3F4E:  MOVWF  x92
3F50:  MOVF   x8D,W
3F52:  ADDWF  x91,W
3F54:  MOVWF  FE9
3F56:  MOVF   x8E,W
3F58:  ADDWFC x92,W
3F5A:  MOVWF  FEA
3F5C:  MOVFF  FEF,194
3F60:  MOVLW  01
3F62:  MOVWF  x95
3F64:  MOVLB  0
3F66:  BRA    3980
3F68:  MOVLB  1
3F6A:  INCF   x8F,F
3F6C:  BTFSC  FD8.2
3F6E:  INCF   x90,F
3F70:  BRA    3F30
....................       }
....................   //println((char*)"",0);
....................    }
3F72:  BRA    3FAC
....................    else println((char*) "Esperando",2);
3F74:  MOVLW  01
3F76:  MOVWF  FEA
3F78:  MOVLW  83
3F7A:  MOVWF  FE9
3F7C:  MOVLW  0A
3F7E:  MOVWF  01
3F80:  CLRF   FF7
3F82:  MOVLW  00
3F84:  MOVLB  0
3F86:  CALL   03F4
3F8A:  TBLRD*-
3F8C:  TBLRD*+
3F8E:  MOVFF  FF5,FEE
3F92:  DECFSZ 01,F
3F94:  BRA    3F8C
3F96:  MOVLW  01
3F98:  MOVLB  2
3F9A:  MOVWF  x25
3F9C:  MOVLW  83
3F9E:  MOVWF  x24
3FA0:  MOVLW  02
3FA2:  MOVWF  x26
3FA4:  MOVLB  0
3FA6:  CALL   1AE2
3FAA:  MOVLB  1
....................   //radio.readAllRegs();
....................   free(packet);
3FAC:  MOVFF  18E,1E0
3FB0:  MOVFF  18D,1DF
3FB4:  MOVLB  0
3FB6:  CALL   3198
....................    //println(globalSec,DEC);
....................    
....................    //readAllRegs();
....................    //print((char*)"RFM ");
....................    
....................    //if (!checkId())println((char*)"incorrecto");
....................    //else println((char*)"Correcto");
....................    //radio.readAllRegs();
.................... //!   println((char*)"HOLA USB");
.................... //!   println(134,HEX);
.................... //!   println(47,BIN);
....................    delay_ms(10);
3FBA:  MOVLW  0A
3FBC:  MOVLB  2
3FBE:  MOVWF  x20
3FC0:  MOVLB  0
3FC2:  CALL   15DE
3FC6:  BRA    3EBE
....................       //TODO: User Code
....................    }
.................... 
.................... }
.................... 
3FC8:  SLEEP 
.................... /*
.................... 
.................... //Interrupcion del timer
.................... #INT_RTCC  //TIMER0
.................... void timer0(void){
....................    set_rtcc(TIMER_START); //Timer0
....................    //println((char*)"Timer INT");
....................    globalMs += TIMER_STEP_MS ;       
....................    if (globalMs >= 1000){
....................    globalSec ++;
....................    globalMs -= 1000;
....................    }
....................    if (globalSec >= 60){
....................    globalMin ++;
....................    globalSec -= 60;
....................    }
....................    //Inicializar todo al llegar a 60 minutos
....................    //Puede introducir un bug rarisimo en el que una diferencia entre tiempos de negativa, pero es muy poco probable
....................    //Y aun asi el bug ocurrira cuando gloabalMin desborde
....................    if (globalMin >= 60){
....................    globalMs = 0;
....................    globalSec= 0;
....................    globalMin = 0;
....................    }
.................... }
.................... 
.................... */

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
